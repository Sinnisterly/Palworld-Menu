#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Pal

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "Pal_structs.hpp"
#include "AkAudio_structs.hpp"
#include "AkAudio_classes.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "UMG_structs.hpp"
#include "UMG_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "NiagaraAnimNotifies_classes.hpp"
#include "CommonUI_classes.hpp"
#include "PhysicsCore_structs.hpp"
#include "GameplayCameras_structs.hpp"
#include "SlateCore_structs.hpp"
#include "LevelSequence_classes.hpp"
#include "Foliage_classes.hpp"
#include "PocketpairUser_structs.hpp"
#include "DLSSBlueprint_structs.hpp"
#include "ModularGameplay_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "CommonGame_classes.hpp"
#include "NavigationSystem_classes.hpp"
#include "Niagara_classes.hpp"
#include "InputCore_structs.hpp"
#include "ReplicationGraph_structs.hpp"
#include "ReplicationGraph_classes.hpp"
#include "CommonInput_structs.hpp"


namespace SDK
{

// Class Pal.PalMapObjectConcreteModelBase
// 0x01F0 (0x0218 - 0x0028)
class UPalMapObjectConcreteModelBase : public UObject
{
public:
	uint8                                         Pad_271B[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnAvailableDelegate;                               // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNotAvailableDelegate;                            // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<class UClass*, FMulticastInlineDelegateProperty_> OnSpawnedReadyModuleDelegateMap;                   // 0x0050(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FGuid                                  InstanceId;                                        // 0x00A0(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  ModelInstanceId;                                   // 0x00B0(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDisposed;                                         // 0x00C0(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_271C[0x7];                                     // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPalFastMapObjectModuleRepInfoArray    ModuleRepInfoArray;                                // 0x00C8(0x0148)(Edit, Net, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	class UPalMapObjectWorkeeModule*              WorkeeModuleCache;                                 // 0x0210(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void CallOrRegisterOnReadyModule(const EPalMapObjectConcreteModelModuleType ModuleType, TDelegate<void(class UPalMapObjectConcreteModelBase* Model, class UPalMapObjectConcreteModelModuleBase* Module)> Delegate);
	void GetMapObjectLocation(struct FVector* OutVector);
	void OnEndTriggerInteract(class AActor* Other, EPalInteractiveObjectIndicatorType IndicatorType);
	void OnRep_ModuleArray();
	void OnStartTriggerInteract(class AActor* Other, EPalInteractiveObjectIndicatorType IndicatorType);
	void OnTriggeringInteract(class AActor* Other, EPalInteractiveObjectIndicatorType IndicatorType, const float DeltaTime);
	void OnTriggerInteract(class AActor* Other, EPalInteractiveObjectIndicatorType IndicatorType);
	void SimpleDelegate__DelegateSignature(class UPalMapObjectConcreteModelBase* Model);
	class FName TryGetMapObjectId();

	const struct FGuid GetBaseCampIdBelongTo() const;
	class UPalBaseCampModel* GetBaseCampModelBelongTo() const;
	class UPalMapObjectCharacterContainerModule* GetCharacterContainerModule() const;
	class UPalMapObjectEnergyModule* GetEnergyModule() const;
	const struct FGuid GetInstanceId() const;
	class UPalMapObjectItemContainerModule* GetItemContainerModule() const;
	class UPalMapObjectPasswordLockModule* GetPasswordLockModule() const;
	class UPalMapObjectSwitchModule* GetSwitchModule() const;
	const struct FTransform GetTransform() const;
	class UPalMapObjectWorkeeModule* GetWorkeeModule() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectConcreteModelBase">();
	}
	static class UPalMapObjectConcreteModelBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectConcreteModelBase>();
	}
};
static_assert(alignof(UPalMapObjectConcreteModelBase) == 0x000008, "Wrong alignment on UPalMapObjectConcreteModelBase");
static_assert(sizeof(UPalMapObjectConcreteModelBase) == 0x000218, "Wrong size on UPalMapObjectConcreteModelBase");
static_assert(offsetof(UPalMapObjectConcreteModelBase, OnAvailableDelegate) == 0x000030, "Member 'UPalMapObjectConcreteModelBase::OnAvailableDelegate' has a wrong offset!");
static_assert(offsetof(UPalMapObjectConcreteModelBase, OnNotAvailableDelegate) == 0x000040, "Member 'UPalMapObjectConcreteModelBase::OnNotAvailableDelegate' has a wrong offset!");
static_assert(offsetof(UPalMapObjectConcreteModelBase, OnSpawnedReadyModuleDelegateMap) == 0x000050, "Member 'UPalMapObjectConcreteModelBase::OnSpawnedReadyModuleDelegateMap' has a wrong offset!");
static_assert(offsetof(UPalMapObjectConcreteModelBase, InstanceId) == 0x0000A0, "Member 'UPalMapObjectConcreteModelBase::InstanceId' has a wrong offset!");
static_assert(offsetof(UPalMapObjectConcreteModelBase, ModelInstanceId) == 0x0000B0, "Member 'UPalMapObjectConcreteModelBase::ModelInstanceId' has a wrong offset!");
static_assert(offsetof(UPalMapObjectConcreteModelBase, bDisposed) == 0x0000C0, "Member 'UPalMapObjectConcreteModelBase::bDisposed' has a wrong offset!");
static_assert(offsetof(UPalMapObjectConcreteModelBase, ModuleRepInfoArray) == 0x0000C8, "Member 'UPalMapObjectConcreteModelBase::ModuleRepInfoArray' has a wrong offset!");
static_assert(offsetof(UPalMapObjectConcreteModelBase, WorkeeModuleCache) == 0x000210, "Member 'UPalMapObjectConcreteModelBase::WorkeeModuleCache' has a wrong offset!");

// Class Pal.PalMapObjectBreedFarmModel
// 0x0050 (0x0268 - 0x0218)
class UPalMapObjectBreedFarmModel final : public UPalMapObjectConcreteModelBase
{
public:
	FMulticastInlineDelegateProperty_             OnUpdateBreedProgress;                             // 0x0218(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FGuid>                          SpawnedEggInstanceIds;                             // 0x0228(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	int32                                         ExistPalEggMaxNum;                                 // 0x0238(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BreedRequiredRealTime;                             // 0x023C(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BreedProgressTime;                                 // 0x0240(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2722[0x4];                                     // 0x0244(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPalInstanceID>                 LastProceedWorkerIndividualIds;                    // 0x0248(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	TArray<class FName>                           TargetBreedItemIds;                                // 0x0258(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)

public:
	void GetBreedProgress(float* NowProgress, float* MaxProgress);
	void OnBreedProgressChangedDelegate__DelegateSignature(float CurrentProgress, float MaxProgress);
	void OnRep_UpdateBreedProgress();
	void OnUpdateAssignedCharacter(class UPalWorkBase* Work);

	EPalItemOperationResult CanConsumeBreedItem(struct FPalItemSlotIdAndNum* ConsumableItem) const;
	bool CanProceedBreeding() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectBreedFarmModel">();
	}
	static class UPalMapObjectBreedFarmModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectBreedFarmModel>();
	}
};
static_assert(alignof(UPalMapObjectBreedFarmModel) == 0x000008, "Wrong alignment on UPalMapObjectBreedFarmModel");
static_assert(sizeof(UPalMapObjectBreedFarmModel) == 0x000268, "Wrong size on UPalMapObjectBreedFarmModel");
static_assert(offsetof(UPalMapObjectBreedFarmModel, OnUpdateBreedProgress) == 0x000218, "Member 'UPalMapObjectBreedFarmModel::OnUpdateBreedProgress' has a wrong offset!");
static_assert(offsetof(UPalMapObjectBreedFarmModel, SpawnedEggInstanceIds) == 0x000228, "Member 'UPalMapObjectBreedFarmModel::SpawnedEggInstanceIds' has a wrong offset!");
static_assert(offsetof(UPalMapObjectBreedFarmModel, ExistPalEggMaxNum) == 0x000238, "Member 'UPalMapObjectBreedFarmModel::ExistPalEggMaxNum' has a wrong offset!");
static_assert(offsetof(UPalMapObjectBreedFarmModel, BreedRequiredRealTime) == 0x00023C, "Member 'UPalMapObjectBreedFarmModel::BreedRequiredRealTime' has a wrong offset!");
static_assert(offsetof(UPalMapObjectBreedFarmModel, BreedProgressTime) == 0x000240, "Member 'UPalMapObjectBreedFarmModel::BreedProgressTime' has a wrong offset!");
static_assert(offsetof(UPalMapObjectBreedFarmModel, LastProceedWorkerIndividualIds) == 0x000248, "Member 'UPalMapObjectBreedFarmModel::LastProceedWorkerIndividualIds' has a wrong offset!");
static_assert(offsetof(UPalMapObjectBreedFarmModel, TargetBreedItemIds) == 0x000258, "Member 'UPalMapObjectBreedFarmModel::TargetBreedItemIds' has a wrong offset!");

// Class Pal.PalAIActionCompositeOrderCommandInterface
// 0x0000 (0x0028 - 0x0028)
class IPalAIActionCompositeOrderCommandInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionCompositeOrderCommandInterface">();
	}
	static class IPalAIActionCompositeOrderCommandInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPalAIActionCompositeOrderCommandInterface>();
	}
};
static_assert(alignof(IPalAIActionCompositeOrderCommandInterface) == 0x000008, "Wrong alignment on IPalAIActionCompositeOrderCommandInterface");
static_assert(sizeof(IPalAIActionCompositeOrderCommandInterface) == 0x000028, "Wrong size on IPalAIActionCompositeOrderCommandInterface");

// Class Pal.PalCoopSkillSearchBase
// 0x0070 (0x0098 - 0x0028)
class UPalCoopSkillSearchBase : public UObject
{
public:
	TArray<float>                                 SearchRangeMaxByRank;                              // 0x0028(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 ExtendRangePerSecByRank;                           // 0x0038(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                SearchOrigin;                                      // 0x0048(0x0018)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SearchRangeMax;                                    // 0x0060(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ExtendRangePerSec;                                 // 0x0064(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ElapsedTime;                                       // 0x0068(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SkillRank;                                         // 0x006C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  CalledPlayerUId;                                   // 0x0070(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsRunning;                                        // 0x0080(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2724[0x7];                                     // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPalCoopSkillSearchResultParameter> SearchResultParameters;                            // 0x0088(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)

public:
	void AddSearchResultParameter(const struct FPalCoopSkillSearchResultParameter& ResultParameter);
	void ClearSearchResultParameters();
	void End();
	void OnAddedLocationForCompass(const struct FGuid& LocationId, class UPalLocationBase* Location);
	void OnAddedLocationForCompass_BP(const struct FGuid& LocationId, class UPalLocationBase* Location);
	void OnRemoveLocationForCompass(const struct FGuid& LocationId, class UPalLocationBase* Location);
	void OnRemoveLocationForCompass_BP(const struct FGuid& LocationId, class UPalLocationBase* Location);
	void Start(const struct FVector& Origin, int32 Rank, const struct FGuid& RequestPlayerUId);
	void Terminate();
	void Tick(float DeltaTime, class UPalCoopSkillSearchLocationRegister* LocationRegister);

	float GetCurrentSearchRadius() const;
	float GetExtendRangePerSecByRank(int32 Rank) const;
	float GetExtendSearchRangePerSec() const;
	const struct FVector GetOrigin() const;
	int32 GetRank() const;
	float GetSearchRangeByRank(int32 Rank) const;
	float GetSearchRangeMax() const;
	bool IsFinished() const;
	bool IsRunning() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalCoopSkillSearchBase">();
	}
	static class UPalCoopSkillSearchBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalCoopSkillSearchBase>();
	}
};
static_assert(alignof(UPalCoopSkillSearchBase) == 0x000008, "Wrong alignment on UPalCoopSkillSearchBase");
static_assert(sizeof(UPalCoopSkillSearchBase) == 0x000098, "Wrong size on UPalCoopSkillSearchBase");
static_assert(offsetof(UPalCoopSkillSearchBase, SearchRangeMaxByRank) == 0x000028, "Member 'UPalCoopSkillSearchBase::SearchRangeMaxByRank' has a wrong offset!");
static_assert(offsetof(UPalCoopSkillSearchBase, ExtendRangePerSecByRank) == 0x000038, "Member 'UPalCoopSkillSearchBase::ExtendRangePerSecByRank' has a wrong offset!");
static_assert(offsetof(UPalCoopSkillSearchBase, SearchOrigin) == 0x000048, "Member 'UPalCoopSkillSearchBase::SearchOrigin' has a wrong offset!");
static_assert(offsetof(UPalCoopSkillSearchBase, SearchRangeMax) == 0x000060, "Member 'UPalCoopSkillSearchBase::SearchRangeMax' has a wrong offset!");
static_assert(offsetof(UPalCoopSkillSearchBase, ExtendRangePerSec) == 0x000064, "Member 'UPalCoopSkillSearchBase::ExtendRangePerSec' has a wrong offset!");
static_assert(offsetof(UPalCoopSkillSearchBase, ElapsedTime) == 0x000068, "Member 'UPalCoopSkillSearchBase::ElapsedTime' has a wrong offset!");
static_assert(offsetof(UPalCoopSkillSearchBase, SkillRank) == 0x00006C, "Member 'UPalCoopSkillSearchBase::SkillRank' has a wrong offset!");
static_assert(offsetof(UPalCoopSkillSearchBase, CalledPlayerUId) == 0x000070, "Member 'UPalCoopSkillSearchBase::CalledPlayerUId' has a wrong offset!");
static_assert(offsetof(UPalCoopSkillSearchBase, bIsRunning) == 0x000080, "Member 'UPalCoopSkillSearchBase::bIsRunning' has a wrong offset!");
static_assert(offsetof(UPalCoopSkillSearchBase, SearchResultParameters) == 0x000088, "Member 'UPalCoopSkillSearchBase::SearchResultParameters' has a wrong offset!");

// Class Pal.FixedPoint64MathLibrary
// 0x0000 (0x0028 - 0x0028)
class UFixedPoint64MathLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FFixedPoint64 Add_FixedPoint64FixedPoint64(const struct FFixedPoint64& A, const struct FFixedPoint64& B);
	static struct FFixedPoint64 Add_FixedPoint64Float(const struct FFixedPoint64& A, float B);
	static struct FFixedPoint64 Add_FixedPoint64Integer(const struct FFixedPoint64& A, int64 B);
	static float Convert_FixedPoint64ToFloat(const struct FFixedPoint64& Value);
	static int32 Convert_FixedPoint64ToInt(const struct FFixedPoint64& Value);
	static int64 Convert_FixedPoint64ToInt64(const struct FFixedPoint64& Value);
	static struct FFixedPoint64 Convert_FloatToFixedPoint64(float Value);
	static struct FFixedPoint64 Convert_Int64ToFixedPoint64(int64 Value);
	static struct FFixedPoint64 Convert_IntToFixedPoint64(int32 Value);
	static struct FFixedPoint64 Divide_FixedPoint64FixedPoint64(const struct FFixedPoint64& A, const struct FFixedPoint64& B);
	static struct FFixedPoint64 Divide_FixedPoint64Float(const struct FFixedPoint64& A, float B);
	static struct FFixedPoint64 Divide_FixedPoint64Integer(const struct FFixedPoint64& A, int64 B);
	static bool EqualEqual_FixedPoint64FixedPoint64(const struct FFixedPoint64& A, const struct FFixedPoint64& B);
	static bool EqualEqual_FixedPoint64Float(const struct FFixedPoint64& A, float B);
	static bool EqualEqual_FixedPoint64Integer(const struct FFixedPoint64& A, int64 B);
	static bool Greater_FixedPoint64FixedPoint64(const struct FFixedPoint64& A, const struct FFixedPoint64& B);
	static bool Greater_FixedPoint64Float(const struct FFixedPoint64& A, float B);
	static bool Greater_FixedPoint64Integer(const struct FFixedPoint64& A, int64 B);
	static bool GreaterEqual_FixedPoint64FixedPoint64(const struct FFixedPoint64& A, const struct FFixedPoint64& B);
	static bool GreaterEqual_FixedPoint64Float(const struct FFixedPoint64& A, float B);
	static bool GreaterEqual_FixedPoint64Integer(const struct FFixedPoint64& A, int64 B);
	static bool Less_FixedPoint64FixedPoint64(const struct FFixedPoint64& A, const struct FFixedPoint64& B);
	static bool Less_FixedPoint64Float(const struct FFixedPoint64& A, float B);
	static bool Less_FixedPoint64Integer(const struct FFixedPoint64& A, int64 B);
	static bool LessEqual_FixedPoint64FixedPoint64(const struct FFixedPoint64& A, const struct FFixedPoint64& B);
	static bool LessEqual_FixedPoint64Float(const struct FFixedPoint64& A, float B);
	static bool LessEqual_FixedPoint64Integer(const struct FFixedPoint64& A, int64 B);
	static struct FFixedPoint64 Multiply_FixedPoint64FixedPoint64(const struct FFixedPoint64& A, const struct FFixedPoint64& B);
	static struct FFixedPoint64 Multiply_FixedPoint64Float(const struct FFixedPoint64& A, float B);
	static struct FFixedPoint64 Multiply_FixedPoint64Integer(const struct FFixedPoint64& A, int64 B);
	static bool NotEqual_FixedPoint64FixedPoint64(const struct FFixedPoint64& A, const struct FFixedPoint64& B);
	static bool NotEqual_FixedPoint64Float(const struct FFixedPoint64& A, float B);
	static bool NotEqual_FixedPoint64Integer(const struct FFixedPoint64& A, int64 B);
	static struct FFixedPoint64 Subtract_FixedPoint64FixedPoint64(const struct FFixedPoint64& A, const struct FFixedPoint64& B);
	static struct FFixedPoint64 Subtract_FixedPoint64Float(const struct FFixedPoint64& A, float B);
	static struct FFixedPoint64 Subtract_FixedPoint64Integer(const struct FFixedPoint64& A, int64 B);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FixedPoint64MathLibrary">();
	}
	static class UFixedPoint64MathLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFixedPoint64MathLibrary>();
	}
};
static_assert(alignof(UFixedPoint64MathLibrary) == 0x000008, "Wrong alignment on UFixedPoint64MathLibrary");
static_assert(sizeof(UFixedPoint64MathLibrary) == 0x000028, "Wrong size on UFixedPoint64MathLibrary");

// Class Pal.PalBodyPartsCapsuleComponent
// 0x0020 (0x0580 - 0x0560)
class UPalBodyPartsCapsuleComponent final : public UCapsuleComponent
{
public:
	EPalBodyPartsType                             BodyPartsType;                                     // 0x0560(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2741[0x3];                                     // 0x0561(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DefaultCollisionProfileName;                       // 0x0564(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   BroadcastCollisionProfileName;                     // 0x056C(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2742[0xC];                                     // 0x0574(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_BroadcastCollisionProfileName();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBodyPartsCapsuleComponent">();
	}
	static class UPalBodyPartsCapsuleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBodyPartsCapsuleComponent>();
	}
};
static_assert(alignof(UPalBodyPartsCapsuleComponent) == 0x000010, "Wrong alignment on UPalBodyPartsCapsuleComponent");
static_assert(sizeof(UPalBodyPartsCapsuleComponent) == 0x000580, "Wrong size on UPalBodyPartsCapsuleComponent");
static_assert(offsetof(UPalBodyPartsCapsuleComponent, BodyPartsType) == 0x000560, "Member 'UPalBodyPartsCapsuleComponent::BodyPartsType' has a wrong offset!");
static_assert(offsetof(UPalBodyPartsCapsuleComponent, DefaultCollisionProfileName) == 0x000564, "Member 'UPalBodyPartsCapsuleComponent::DefaultCollisionProfileName' has a wrong offset!");
static_assert(offsetof(UPalBodyPartsCapsuleComponent, BroadcastCollisionProfileName) == 0x00056C, "Member 'UPalBodyPartsCapsuleComponent::BroadcastCollisionProfileName' has a wrong offset!");

// Class Pal.PalStaticItemDataBase
// 0x0148 (0x0170 - 0x0028)
class UPalStaticItemDataBase : public UObject
{
public:
	class FName                                   ID;                                                // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              IconTexture;                                       // 0x0030(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPalItemTypeA                                 TypeA;                                             // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPalItemTypeB                                 TypeB;                                             // 0x0061(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2743[0x2];                                     // 0x0062(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Rank;                                              // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rarity;                                            // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Price;                                             // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxStackCount;                                     // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SortID;                                            // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalDynamicItemDataBase>    DynamicItemDataClass;                              // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNotConsumed;                                      // 0x0080(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2744[0x7];                                     // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   ActorClass;                                        // 0x0088(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStaticMesh>             StaticMeshPath;                                    // 0x00B8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   VisualBlueprintClassSoft;                          // 0x00E8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPalDropItemType                              DropItemType;                                      // 0x0118(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2745[0x3];                                     // 0x0119(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Weight;                                            // 0x011C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Durability;                                        // 0x0120(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PassiveSkill;                                      // 0x0124(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PassiveSkill2;                                     // 0x012C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PassiveSkill3;                                     // 0x0134(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PassiveSkill4;                                     // 0x013C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CorruptionFactor;                                  // 0x0144(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatValue1;                                       // 0x0148(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OverrideNameMsgID;                                 // 0x014C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   OverrideDescMsgID;                                 // 0x0154(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2746[0x14];                                    // 0x015C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const bool UseItem(class UPalDynamicItemDataBase* DynamicItemData, const class UObject* WorldContextObject);

	const TSoftClassPtr<class UClass> GetActorClass() const;
	void GetAllPassiveSkill(TArray<class FName>* OutArray) const;
	void GetDescriptionMsgId(class FName* OutMsgID) const;
	TSubclassOf<class UPalDynamicItemDataBase> GetDynamicItemDataClass() const;
	const class FName GetId() const;
	const int32 GetMaxStackCount() const;
	void GetNameMsgId(class FName* OutMsgID) const;
	class FName GetPassiveSkill() const;
	class FName GetPassiveSkill2() const;
	class FName GetPassiveSkill3() const;
	class FName GetPassiveSkill4() const;
	TSoftClassPtr<class UClass> GetVisualBlueprintClass(const class UObject* WorldContextObject) const;
	const bool HasActorClass() const;
	const bool HasDynamicItemClass() const;
	bool IsCorruptible() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalStaticItemDataBase">();
	}
	static class UPalStaticItemDataBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalStaticItemDataBase>();
	}
};
static_assert(alignof(UPalStaticItemDataBase) == 0x000008, "Wrong alignment on UPalStaticItemDataBase");
static_assert(sizeof(UPalStaticItemDataBase) == 0x000170, "Wrong size on UPalStaticItemDataBase");
static_assert(offsetof(UPalStaticItemDataBase, ID) == 0x000028, "Member 'UPalStaticItemDataBase::ID' has a wrong offset!");
static_assert(offsetof(UPalStaticItemDataBase, IconTexture) == 0x000030, "Member 'UPalStaticItemDataBase::IconTexture' has a wrong offset!");
static_assert(offsetof(UPalStaticItemDataBase, TypeA) == 0x000060, "Member 'UPalStaticItemDataBase::TypeA' has a wrong offset!");
static_assert(offsetof(UPalStaticItemDataBase, TypeB) == 0x000061, "Member 'UPalStaticItemDataBase::TypeB' has a wrong offset!");
static_assert(offsetof(UPalStaticItemDataBase, Rank) == 0x000064, "Member 'UPalStaticItemDataBase::Rank' has a wrong offset!");
static_assert(offsetof(UPalStaticItemDataBase, Rarity) == 0x000068, "Member 'UPalStaticItemDataBase::Rarity' has a wrong offset!");
static_assert(offsetof(UPalStaticItemDataBase, Price) == 0x00006C, "Member 'UPalStaticItemDataBase::Price' has a wrong offset!");
static_assert(offsetof(UPalStaticItemDataBase, MaxStackCount) == 0x000070, "Member 'UPalStaticItemDataBase::MaxStackCount' has a wrong offset!");
static_assert(offsetof(UPalStaticItemDataBase, SortID) == 0x000074, "Member 'UPalStaticItemDataBase::SortID' has a wrong offset!");
static_assert(offsetof(UPalStaticItemDataBase, DynamicItemDataClass) == 0x000078, "Member 'UPalStaticItemDataBase::DynamicItemDataClass' has a wrong offset!");
static_assert(offsetof(UPalStaticItemDataBase, bNotConsumed) == 0x000080, "Member 'UPalStaticItemDataBase::bNotConsumed' has a wrong offset!");
static_assert(offsetof(UPalStaticItemDataBase, ActorClass) == 0x000088, "Member 'UPalStaticItemDataBase::ActorClass' has a wrong offset!");
static_assert(offsetof(UPalStaticItemDataBase, StaticMeshPath) == 0x0000B8, "Member 'UPalStaticItemDataBase::StaticMeshPath' has a wrong offset!");
static_assert(offsetof(UPalStaticItemDataBase, VisualBlueprintClassSoft) == 0x0000E8, "Member 'UPalStaticItemDataBase::VisualBlueprintClassSoft' has a wrong offset!");
static_assert(offsetof(UPalStaticItemDataBase, DropItemType) == 0x000118, "Member 'UPalStaticItemDataBase::DropItemType' has a wrong offset!");
static_assert(offsetof(UPalStaticItemDataBase, Weight) == 0x00011C, "Member 'UPalStaticItemDataBase::Weight' has a wrong offset!");
static_assert(offsetof(UPalStaticItemDataBase, Durability) == 0x000120, "Member 'UPalStaticItemDataBase::Durability' has a wrong offset!");
static_assert(offsetof(UPalStaticItemDataBase, PassiveSkill) == 0x000124, "Member 'UPalStaticItemDataBase::PassiveSkill' has a wrong offset!");
static_assert(offsetof(UPalStaticItemDataBase, PassiveSkill2) == 0x00012C, "Member 'UPalStaticItemDataBase::PassiveSkill2' has a wrong offset!");
static_assert(offsetof(UPalStaticItemDataBase, PassiveSkill3) == 0x000134, "Member 'UPalStaticItemDataBase::PassiveSkill3' has a wrong offset!");
static_assert(offsetof(UPalStaticItemDataBase, PassiveSkill4) == 0x00013C, "Member 'UPalStaticItemDataBase::PassiveSkill4' has a wrong offset!");
static_assert(offsetof(UPalStaticItemDataBase, CorruptionFactor) == 0x000144, "Member 'UPalStaticItemDataBase::CorruptionFactor' has a wrong offset!");
static_assert(offsetof(UPalStaticItemDataBase, FloatValue1) == 0x000148, "Member 'UPalStaticItemDataBase::FloatValue1' has a wrong offset!");
static_assert(offsetof(UPalStaticItemDataBase, OverrideNameMsgID) == 0x00014C, "Member 'UPalStaticItemDataBase::OverrideNameMsgID' has a wrong offset!");
static_assert(offsetof(UPalStaticItemDataBase, OverrideDescMsgID) == 0x000154, "Member 'UPalStaticItemDataBase::OverrideDescMsgID' has a wrong offset!");

// Class Pal.PalStaticWeaponItemData
// 0x0010 (0x0180 - 0x0170)
class UPalStaticWeaponItemData final : public UPalStaticItemDataBase
{
public:
	int32                                         MagazineSize;                                      // 0x0170(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SneakAttackRate;                                   // 0x0174(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AttackValue;                                       // 0x0178(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DefenseValue;                                      // 0x017C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	const int32 GetMaxMagazineSize() const;
	const float GetSneakAttackRate() const;
	const int32 GetWeaponBaseDamage() const;
	const int32 GetWeaponDefense() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalStaticWeaponItemData">();
	}
	static class UPalStaticWeaponItemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalStaticWeaponItemData>();
	}
};
static_assert(alignof(UPalStaticWeaponItemData) == 0x000008, "Wrong alignment on UPalStaticWeaponItemData");
static_assert(sizeof(UPalStaticWeaponItemData) == 0x000180, "Wrong size on UPalStaticWeaponItemData");
static_assert(offsetof(UPalStaticWeaponItemData, MagazineSize) == 0x000170, "Member 'UPalStaticWeaponItemData::MagazineSize' has a wrong offset!");
static_assert(offsetof(UPalStaticWeaponItemData, SneakAttackRate) == 0x000174, "Member 'UPalStaticWeaponItemData::SneakAttackRate' has a wrong offset!");
static_assert(offsetof(UPalStaticWeaponItemData, AttackValue) == 0x000178, "Member 'UPalStaticWeaponItemData::AttackValue' has a wrong offset!");
static_assert(offsetof(UPalStaticWeaponItemData, DefenseValue) == 0x00017C, "Member 'UPalStaticWeaponItemData::DefenseValue' has a wrong offset!");

// Class Pal.PalAIActionCompositeBase
// 0x0020 (0x0048 - 0x0028)
class UPalAIActionCompositeBase : public UObject
{
public:
	uint8                                         Pad_2748[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalAIActionCompositeBase*              Child;                                             // 0x0030(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2749[0x8];                                     // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalAIActionComponent*                  OwnerComponent;                                    // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetChildAction(class UPalAIActionBase* Action, class UObject* Instigator);
	void SetChildActionComposite(class UPalAIActionCompositeBase* Composite);

	class UPalActionComponent* GetActionComponent() const;
	class UPalCharacterParameterComponent* GetCharacterParameter() const;
	class UPalAIActionCompositeBase* GetChild() const;
	class AController* GetController() const;
	class UPalAIActionComponent* GetOwnerComponent() const;
	class APawn* GetPawn() const;
	bool IsPaused() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionCompositeBase">();
	}
	static class UPalAIActionCompositeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIActionCompositeBase>();
	}
};
static_assert(alignof(UPalAIActionCompositeBase) == 0x000008, "Wrong alignment on UPalAIActionCompositeBase");
static_assert(sizeof(UPalAIActionCompositeBase) == 0x000048, "Wrong size on UPalAIActionCompositeBase");
static_assert(offsetof(UPalAIActionCompositeBase, Child) == 0x000030, "Member 'UPalAIActionCompositeBase::Child' has a wrong offset!");
static_assert(offsetof(UPalAIActionCompositeBase, OwnerComponent) == 0x000040, "Member 'UPalAIActionCompositeBase::OwnerComponent' has a wrong offset!");

// Class Pal.PalAIActionCompositeActionDummy
// 0x0008 (0x0050 - 0x0048)
class UPalAIActionCompositeActionDummy final : public UPalAIActionCompositeBase
{
public:
	uint8                                         Pad_274A[0x8];                                     // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFinishAction(class UPalAIActionBase* Action);
	void OnPauseAction(class UPalAIActionBase* Action, const class UPawnAction* PausedBy);
	void OnResumeAction(class UPalAIActionBase* Action);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionCompositeActionDummy">();
	}
	static class UPalAIActionCompositeActionDummy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIActionCompositeActionDummy>();
	}
};
static_assert(alignof(UPalAIActionCompositeActionDummy) == 0x000008, "Wrong alignment on UPalAIActionCompositeActionDummy");
static_assert(sizeof(UPalAIActionCompositeActionDummy) == 0x000050, "Wrong size on UPalAIActionCompositeActionDummy");

// Class Pal.PalArenaPartyAsset
// 0x0018 (0x0048 - 0x0030)
class UPalArenaPartyAsset final : public UDataAsset
{
public:
	TArray<struct FPalDebugOtomoPalInfo>          PalInfo;                                           // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         RidePalIndex;                                      // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_274B[0x4];                                     // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalArenaPartyAsset">();
	}
	static class UPalArenaPartyAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalArenaPartyAsset>();
	}
};
static_assert(alignof(UPalArenaPartyAsset) == 0x000008, "Wrong alignment on UPalArenaPartyAsset");
static_assert(sizeof(UPalArenaPartyAsset) == 0x000048, "Wrong size on UPalArenaPartyAsset");
static_assert(offsetof(UPalArenaPartyAsset, PalInfo) == 0x000030, "Member 'UPalArenaPartyAsset::PalInfo' has a wrong offset!");
static_assert(offsetof(UPalArenaPartyAsset, RidePalIndex) == 0x000040, "Member 'UPalArenaPartyAsset::RidePalIndex' has a wrong offset!");

// Class Pal.PalRideMarkerComponent
// 0x0050 (0x0640 - 0x05F0)
class UPalRideMarkerComponent final : public UStaticMeshComponent
{
public:
	EPalRidePositionType                          RidePositionType;                                  // 0x05F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAdjustRotation;                                 // 0x05F1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFixScale;                                       // 0x05F2(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHiddenCharacterWhenAim;                           // 0x05F3(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableLookAtByRide;                              // 0x05F4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableFullBodyIK_UniqueRide;                     // 0x05F5(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_274C[0x2];                                     // 0x05F6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class APalUniqueRideWeaponBase>   UniqueRidePalWeaponClass;                          // 0x05F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPalDataTableRowName_PalMonsterData    UniqueRidePalID;                                   // 0x0600(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeRiding;                                    // 0x0608(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_274D[0x4];                                     // 0x0618(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UPalRiderComponent>      Rider;                                             // 0x061C(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_274E[0x4];                                     // 0x0624(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalActiveSkillSlot*                    SkillSlot;                                         // 0x0628(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APalUniqueRideWeaponBase*               WeaponActor;                                       // 0x0630(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_274F[0x8];                                     // 0x0638(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CameraChangeActorActive(bool Active);
	void ChangeRiding__DelegateSignature(bool IsEnable);
	class UPalActiveSkillSlot* GetActiveSkillSlot();
	void SetRidingFlag(bool bIsEnable);
	void SetVisibleWeapon();
	void SyncActiveSkill(class UPalIndividualCharacterParameter* IndividualParameter);

	class FName GetAttackSocketName() const;
	class APalCharacter* GetRiderCharacter() const;
	struct FTransform GetRideSocketTransform(ERelativeTransformSpace Space) const;
	bool IsAdjustRotation() const;
	bool IsRiding() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalRideMarkerComponent">();
	}
	static class UPalRideMarkerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalRideMarkerComponent>();
	}
};
static_assert(alignof(UPalRideMarkerComponent) == 0x000010, "Wrong alignment on UPalRideMarkerComponent");
static_assert(sizeof(UPalRideMarkerComponent) == 0x000640, "Wrong size on UPalRideMarkerComponent");
static_assert(offsetof(UPalRideMarkerComponent, RidePositionType) == 0x0005F0, "Member 'UPalRideMarkerComponent::RidePositionType' has a wrong offset!");
static_assert(offsetof(UPalRideMarkerComponent, bIsAdjustRotation) == 0x0005F1, "Member 'UPalRideMarkerComponent::bIsAdjustRotation' has a wrong offset!");
static_assert(offsetof(UPalRideMarkerComponent, bIsFixScale) == 0x0005F2, "Member 'UPalRideMarkerComponent::bIsFixScale' has a wrong offset!");
static_assert(offsetof(UPalRideMarkerComponent, bHiddenCharacterWhenAim) == 0x0005F3, "Member 'UPalRideMarkerComponent::bHiddenCharacterWhenAim' has a wrong offset!");
static_assert(offsetof(UPalRideMarkerComponent, bDisableLookAtByRide) == 0x0005F4, "Member 'UPalRideMarkerComponent::bDisableLookAtByRide' has a wrong offset!");
static_assert(offsetof(UPalRideMarkerComponent, bDisableFullBodyIK_UniqueRide) == 0x0005F5, "Member 'UPalRideMarkerComponent::bDisableFullBodyIK_UniqueRide' has a wrong offset!");
static_assert(offsetof(UPalRideMarkerComponent, UniqueRidePalWeaponClass) == 0x0005F8, "Member 'UPalRideMarkerComponent::UniqueRidePalWeaponClass' has a wrong offset!");
static_assert(offsetof(UPalRideMarkerComponent, UniqueRidePalID) == 0x000600, "Member 'UPalRideMarkerComponent::UniqueRidePalID' has a wrong offset!");
static_assert(offsetof(UPalRideMarkerComponent, OnChangeRiding) == 0x000608, "Member 'UPalRideMarkerComponent::OnChangeRiding' has a wrong offset!");
static_assert(offsetof(UPalRideMarkerComponent, Rider) == 0x00061C, "Member 'UPalRideMarkerComponent::Rider' has a wrong offset!");
static_assert(offsetof(UPalRideMarkerComponent, SkillSlot) == 0x000628, "Member 'UPalRideMarkerComponent::SkillSlot' has a wrong offset!");
static_assert(offsetof(UPalRideMarkerComponent, WeaponActor) == 0x000630, "Member 'UPalRideMarkerComponent::WeaponActor' has a wrong offset!");

// Class Pal.FixedPointMathLibrary
// 0x0000 (0x0028 - 0x0028)
class UFixedPointMathLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FFixedPoint Add_FixedPointFixedPoint(const struct FFixedPoint& A, const struct FFixedPoint& B);
	static struct FFixedPoint Add_FixedPointFloat(const struct FFixedPoint& A, float B);
	static struct FFixedPoint Add_FixedPointInteger(const struct FFixedPoint& A, int32 B);
	static float Convert_FixedPointToFloat(const struct FFixedPoint& Value);
	static int32 Convert_FixedPointToInt(const struct FFixedPoint& Value);
	static struct FFixedPoint Convert_FloatToFixedPoint(float Value);
	static struct FFixedPoint Convert_IntToFixedPoint(int32 Value);
	static struct FFixedPoint Divide_FixedPointFixedPoint(const struct FFixedPoint& A, const struct FFixedPoint& B);
	static struct FFixedPoint Divide_FixedPointFloat(const struct FFixedPoint& A, float B);
	static struct FFixedPoint Divide_FixedPointInteger(const struct FFixedPoint& A, int32 B);
	static bool EqualEqual_FixedPointFixedPoint(const struct FFixedPoint& A, const struct FFixedPoint& B);
	static bool EqualEqual_FixedPointFloat(const struct FFixedPoint& A, float B);
	static bool EqualEqual_FixedPointInteger(const struct FFixedPoint& A, int32 B);
	static bool Greater_FixedPointFixedPoint(const struct FFixedPoint& A, const struct FFixedPoint& B);
	static bool Greater_FixedPointFloat(const struct FFixedPoint& A, float B);
	static bool Greater_FixedPointInteger(const struct FFixedPoint& A, int32 B);
	static bool GreaterEqual_FixedPointFixedPoint(const struct FFixedPoint& A, const struct FFixedPoint& B);
	static bool GreaterEqual_FixedPointFloat(const struct FFixedPoint& A, float B);
	static bool GreaterEqual_FixedPointInteger(const struct FFixedPoint& A, int32 B);
	static bool Less_FixedPointFixedPoint(const struct FFixedPoint& A, const struct FFixedPoint& B);
	static bool Less_FixedPointFloat(const struct FFixedPoint& A, float B);
	static bool Less_FixedPointInteger(const struct FFixedPoint& A, int32 B);
	static bool LessEqual_FixedPointFixedPoint(const struct FFixedPoint& A, const struct FFixedPoint& B);
	static bool LessEqual_FixedPointFloat(const struct FFixedPoint& A, float B);
	static bool LessEqual_FixedPointInteger(const struct FFixedPoint& A, int32 B);
	static struct FFixedPoint Multiply_FixedPointFixedPoint(const struct FFixedPoint& A, const struct FFixedPoint& B);
	static struct FFixedPoint Multiply_FixedPointFloat(const struct FFixedPoint& A, float B);
	static struct FFixedPoint Multiply_FixedPointInteger(const struct FFixedPoint& A, int32 B);
	static bool NotEqual_FixedPointFixedPoint(const struct FFixedPoint& A, const struct FFixedPoint& B);
	static bool NotEqual_FixedPointFloat(const struct FFixedPoint& A, float B);
	static bool NotEqual_FixedPointInteger(const struct FFixedPoint& A, int32 B);
	static struct FFixedPoint Subtract_FixedPointFixedPoint(const struct FFixedPoint& A, const struct FFixedPoint& B);
	static struct FFixedPoint Subtract_FixedPointFloat(const struct FFixedPoint& A, float B);
	static struct FFixedPoint Subtract_FixedPointInteger(const struct FFixedPoint& A, int32 B);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FixedPointMathLibrary">();
	}
	static class UFixedPointMathLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFixedPointMathLibrary>();
	}
};
static_assert(alignof(UFixedPointMathLibrary) == 0x000008, "Wrong alignment on UFixedPointMathLibrary");
static_assert(sizeof(UFixedPointMathLibrary) == 0x000028, "Wrong size on UFixedPointMathLibrary");

// Class Pal.PalNiagaraDataInterfaceSoundPlayer
// 0x0010 (0x0048 - 0x0038)
class UPalNiagaraDataInterfaceSoundPlayer final : public UNiagaraDataInterface
{
public:
	class UAkAudioEvent*                          AkEvent;                                           // 0x0038(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutDuration;                                   // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2763[0x4];                                     // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalNiagaraDataInterfaceSoundPlayer">();
	}
	static class UPalNiagaraDataInterfaceSoundPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalNiagaraDataInterfaceSoundPlayer>();
	}
};
static_assert(alignof(UPalNiagaraDataInterfaceSoundPlayer) == 0x000008, "Wrong alignment on UPalNiagaraDataInterfaceSoundPlayer");
static_assert(sizeof(UPalNiagaraDataInterfaceSoundPlayer) == 0x000048, "Wrong size on UPalNiagaraDataInterfaceSoundPlayer");
static_assert(offsetof(UPalNiagaraDataInterfaceSoundPlayer, AkEvent) == 0x000038, "Member 'UPalNiagaraDataInterfaceSoundPlayer::AkEvent' has a wrong offset!");
static_assert(offsetof(UPalNiagaraDataInterfaceSoundPlayer, FadeOutDuration) == 0x000040, "Member 'UPalNiagaraDataInterfaceSoundPlayer::FadeOutDuration' has a wrong offset!");

// Class Pal.PalMapObjectDamageReactionComponent
// 0x0010 (0x00B0 - 0x00A0)
class UPalMapObjectDamageReactionComponent final : public UActorComponent
{
public:
	uint8                                         Pad_2764[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalHitEffectSlot*                      EffectSlot;                                        // 0x00A8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectDamageReactionComponent">();
	}
	static class UPalMapObjectDamageReactionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectDamageReactionComponent>();
	}
};
static_assert(alignof(UPalMapObjectDamageReactionComponent) == 0x000008, "Wrong alignment on UPalMapObjectDamageReactionComponent");
static_assert(sizeof(UPalMapObjectDamageReactionComponent) == 0x0000B0, "Wrong size on UPalMapObjectDamageReactionComponent");
static_assert(offsetof(UPalMapObjectDamageReactionComponent, EffectSlot) == 0x0000A8, "Member 'UPalMapObjectDamageReactionComponent::EffectSlot' has a wrong offset!");

// Class Pal.PalAIActionCompositeWorker
// 0x0040 (0x0088 - 0x0048)
class UPalAIActionCompositeWorker : public UPalAIActionCompositeBase
{
public:
	TSubclassOf<class UPalAIActionBase>           WaitActionClass;                                   // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UPalAIActionBase>           ApproachActionClass;                               // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UPalAIActionBase>           WaitForWorkableActionClass;                        // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UPalAIActionBase>           WorkingActionClass;                                // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UPalAIActionBase>           CurrentActionClass;                                // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SpeedFlagName;                                     // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DefaultWalkSpeed;                                  // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2765[0xC];                                     // 0x007C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeActionApproachToWorkArea();
	void ChangeActionWait();
	void ChangeActionWaitForWorkable();
	void OnStartAction(class UPalAIActionBase* Action);
	void OnTickInWaitAction(float DeltaTime);
	void RegisterFixedAssignWork(const struct FGuid& WorkId);
	void RegisterFixedAssignWorkAttack(const struct FGuid& MapObjectModelInstanceId);
	bool TryFindNextWork();
	void UnregisterFixAssignWork();

	bool IsAssignedToTarget() const;
	bool IsTargetAssignable() const;
	bool IsTargetWorkable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionCompositeWorker">();
	}
	static class UPalAIActionCompositeWorker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIActionCompositeWorker>();
	}
};
static_assert(alignof(UPalAIActionCompositeWorker) == 0x000008, "Wrong alignment on UPalAIActionCompositeWorker");
static_assert(sizeof(UPalAIActionCompositeWorker) == 0x000088, "Wrong size on UPalAIActionCompositeWorker");
static_assert(offsetof(UPalAIActionCompositeWorker, WaitActionClass) == 0x000048, "Member 'UPalAIActionCompositeWorker::WaitActionClass' has a wrong offset!");
static_assert(offsetof(UPalAIActionCompositeWorker, ApproachActionClass) == 0x000050, "Member 'UPalAIActionCompositeWorker::ApproachActionClass' has a wrong offset!");
static_assert(offsetof(UPalAIActionCompositeWorker, WaitForWorkableActionClass) == 0x000058, "Member 'UPalAIActionCompositeWorker::WaitForWorkableActionClass' has a wrong offset!");
static_assert(offsetof(UPalAIActionCompositeWorker, WorkingActionClass) == 0x000060, "Member 'UPalAIActionCompositeWorker::WorkingActionClass' has a wrong offset!");
static_assert(offsetof(UPalAIActionCompositeWorker, CurrentActionClass) == 0x000068, "Member 'UPalAIActionCompositeWorker::CurrentActionClass' has a wrong offset!");
static_assert(offsetof(UPalAIActionCompositeWorker, SpeedFlagName) == 0x000070, "Member 'UPalAIActionCompositeWorker::SpeedFlagName' has a wrong offset!");
static_assert(offsetof(UPalAIActionCompositeWorker, DefaultWalkSpeed) == 0x000078, "Member 'UPalAIActionCompositeWorker::DefaultWalkSpeed' has a wrong offset!");

// Class Pal.PalCombiMonsterParameter
// 0x0000 (0x0028 - 0x0028)
class UPalCombiMonsterParameter final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalCombiMonsterParameter">();
	}
	static class UPalCombiMonsterParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalCombiMonsterParameter>();
	}
};
static_assert(alignof(UPalCombiMonsterParameter) == 0x000008, "Wrong alignment on UPalCombiMonsterParameter");
static_assert(sizeof(UPalCombiMonsterParameter) == 0x000028, "Wrong size on UPalCombiMonsterParameter");

// Class Pal.PalRiderComponent
// 0x02F8 (0x0398 - 0x00A0)
class UPalRiderComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnRide;                                            // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGetOff;                                          // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UPalRideMarkerComponent> RidingMarker;                                      // 0x00C0(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EPalRidePositionType, struct FRiderActionInfo> RideActionMap;                                     // 0x00C8(0x0050)(Edit, NativeAccessSpecifierPublic)
	class AController*                            FullRidePalController;                             // 0x0118(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           RideShakingMontage;                                // 0x0120(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFlagContainer                         DisableRide;                                       // 0x0128(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	struct FFlagContainer                         DisableGetOff;                                     // 0x0178(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	struct FFlagContainer                         DisableAdjustRotation;                             // 0x01C8(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	struct FVector                                DefaultMeshLocation;                               // 0x0218(0x0018)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFlagContainer                         DisableUniqueRideIK;                               // 0x0230(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2766[0xC];                                     // 0x0280(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultJumpZVelocity;                              // 0x028C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                InitialMeshLocation;                               // 0x0290(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<EPalWeaponType, struct FVector2D>        BackRideLimit;                                     // 0x02A8(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<struct FPalDataTableRowName_PalMonsterData, TSubclassOf<class UPalUniqueRideAnimeAssetBase>> UniqueRideAnimBPClassMap;                          // 0x02F8(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<class FName, class UPalUniqueRideAnimeAssetBase*> UniqueRideAnimeAssetMap;                           // 0x0348(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	bool AttachRider();
	void AttachRiderNoAnimation();
	void AttachRiderNoAnimation_ToALL(int32 ID);
	void AttachRiderNoAnimation_ToServer(int32 ID);
	bool CanUniqueRideIK();
	void DettachRider();
	void DettachRider_ToALL(int32 ID);
	void DettachRider_ToServer(int32 ID);
	void DettachRiderNoAnimation();
	void DettachRiderNoAnimation_ToALL(int32 ID);
	void DettachRiderNoAnimation_ToServer(int32 ID);
	bool GetOff(bool bIsSkipAnimation, bool bNoAnimCancel);
	bool GetRiderModelIsBackward();
	class UPalUniqueRideAnimeAssetBase* GetUniqueRideAnimeAsset();
	bool IsDisableAdjustRotation();
	bool IsDisableGetOff();
	bool IsDisableRide();
	void OnCaptureStart();
	void OnChangeActive(bool Param_IsActive);
	void OnDead(const struct FPalDeadInfo& DeadInfo);
	void OnDeadPlayer(const struct FPalDeadInfo& DeadInfo);
	void OnEndAim();
	void OnEndInteractForServer();
	void OnEndInteractInClient();
	void OnGetOff__DelegateSignature(class AActor* RideActor);
	void OnInactive();
	void OnRide__DelegateSignature(class AActor* RideActor);
	void OnSleep(int32 LastDamage);
	void OnSleepPlayer(int32 LastDamage);
	void OnStartAim();
	void OnStartInteractForServer();
	void OnStartInteractInClient(TScriptInterface<class IPalInteractiveObjectComponentInterface> Object);
	void PlayShakingMontage(class UAnimMontage* OverrideMontage, float PlayRate);
	bool Ride(class UPalRideMarkerComponent* Marker, bool bIsSkipAnimation);
	void RideClientRep(class UPalRideMarkerComponent* Marker);
	void SetDisableAdjustRotation(class FName FlagName, bool bIsDisable);
	void SetDisableGetOff(class FName FlagName, bool bIsDisable);
	void SetDisableRide(class FName FlagName, bool bIsDisable);
	void SetDisableUniqueRideIK(class FName FlagName, bool IsDisable);
	void SetRideMarker(class UPalRideMarkerComponent* Marker);
	void SetRideMarker_Internal(class UPalRideMarkerComponent* Marker);
	void SetRideMarker_ToALL(int32 ID, class UPalRideMarkerComponent* Marker);
	void SetRideMarker_ToServer(int32 ID, class UPalRideMarkerComponent* Marker);
	void StopShakingMontage();

	EPalRidePositionType GetCurrentRidePositionType() const;
	class UPalRideMarkerComponent* GetRideMarker() const;
	class AActor* GetRindingActor() const;
	bool IsRiding() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalRiderComponent">();
	}
	static class UPalRiderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalRiderComponent>();
	}
};
static_assert(alignof(UPalRiderComponent) == 0x000008, "Wrong alignment on UPalRiderComponent");
static_assert(sizeof(UPalRiderComponent) == 0x000398, "Wrong size on UPalRiderComponent");
static_assert(offsetof(UPalRiderComponent, OnRide) == 0x0000A0, "Member 'UPalRiderComponent::OnRide' has a wrong offset!");
static_assert(offsetof(UPalRiderComponent, OnGetOff) == 0x0000B0, "Member 'UPalRiderComponent::OnGetOff' has a wrong offset!");
static_assert(offsetof(UPalRiderComponent, RidingMarker) == 0x0000C0, "Member 'UPalRiderComponent::RidingMarker' has a wrong offset!");
static_assert(offsetof(UPalRiderComponent, RideActionMap) == 0x0000C8, "Member 'UPalRiderComponent::RideActionMap' has a wrong offset!");
static_assert(offsetof(UPalRiderComponent, FullRidePalController) == 0x000118, "Member 'UPalRiderComponent::FullRidePalController' has a wrong offset!");
static_assert(offsetof(UPalRiderComponent, RideShakingMontage) == 0x000120, "Member 'UPalRiderComponent::RideShakingMontage' has a wrong offset!");
static_assert(offsetof(UPalRiderComponent, DisableRide) == 0x000128, "Member 'UPalRiderComponent::DisableRide' has a wrong offset!");
static_assert(offsetof(UPalRiderComponent, DisableGetOff) == 0x000178, "Member 'UPalRiderComponent::DisableGetOff' has a wrong offset!");
static_assert(offsetof(UPalRiderComponent, DisableAdjustRotation) == 0x0001C8, "Member 'UPalRiderComponent::DisableAdjustRotation' has a wrong offset!");
static_assert(offsetof(UPalRiderComponent, DefaultMeshLocation) == 0x000218, "Member 'UPalRiderComponent::DefaultMeshLocation' has a wrong offset!");
static_assert(offsetof(UPalRiderComponent, DisableUniqueRideIK) == 0x000230, "Member 'UPalRiderComponent::DisableUniqueRideIK' has a wrong offset!");
static_assert(offsetof(UPalRiderComponent, DefaultJumpZVelocity) == 0x00028C, "Member 'UPalRiderComponent::DefaultJumpZVelocity' has a wrong offset!");
static_assert(offsetof(UPalRiderComponent, InitialMeshLocation) == 0x000290, "Member 'UPalRiderComponent::InitialMeshLocation' has a wrong offset!");
static_assert(offsetof(UPalRiderComponent, BackRideLimit) == 0x0002A8, "Member 'UPalRiderComponent::BackRideLimit' has a wrong offset!");
static_assert(offsetof(UPalRiderComponent, UniqueRideAnimBPClassMap) == 0x0002F8, "Member 'UPalRiderComponent::UniqueRideAnimBPClassMap' has a wrong offset!");
static_assert(offsetof(UPalRiderComponent, UniqueRideAnimeAssetMap) == 0x000348, "Member 'UPalRiderComponent::UniqueRideAnimeAssetMap' has a wrong offset!");

// Class Pal.PalAbilityPassiveSkill
// 0x00D0 (0x00F8 - 0x0028)
class UPalAbilityPassiveSkill final : public UObject
{
public:
	TDelegate<void(class AActor* Trainer)>        IsRestrictedDelegate;                              // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsReserving;                                       // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRestricted;                                     // 0x0039(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRequireWorkerWorkingPassiveSkill;                 // 0x003A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsWorking;                                        // 0x003B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_276F[0x4];                                     // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPalPassiveAbilitySkills>       PassiveSkills;                                     // 0x0040(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	TMap<struct FPalDataTableRowName_PassiveSkillData, struct FPalPassiveAbilitySkillStatus> SkillStatus;                                       // 0x0050(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	int32                                         CurrentRank;                                       // 0x00A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2770[0x54];                                    // 0x00A4(0x0054)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InactivateWorkingSkill();
	void Initialize(const TArray<struct FPalPassiveAbilitySkills>& _PassiveSkills);
	bool IsRestricted__DelegateSignature(class AActor* Trainer);
	void ObserveWorking();
	void OnActivatedAsOtomo();
	void OnActivatedAsOtomoHolder();
	void OnActivatedAsWorker();
	void OnInactivatedAsOtomo();
	void OnInactivatedAsOtomoHolder();
	void OnInactivatedAsWorker();
	void OnReserveActivated();
	void OnReserveInactivated();
	void OnRideActivated();
	void OnRideInactivated();
	void OnUpdateInventoryContainer(class UPalItemContainer* Container);
	void OnUpdateOtomoHolder(class APalCharacter* Character);
	void OnWorkerAssignChanged(class UPalCharacterParameterComponent* Parameter);

	int32 GetOtomoRank() const;
	class APalCharacter* GetOwner() const;
	TArray<class FName> GetPassiveSkillList() const;
	class ACharacter* GetTrainer() const;
	class APalPlayerCharacter* GetTrainerActor() const;
	class APalPlayerController* GetTrainerController() const;
	bool IsRestricted() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAbilityPassiveSkill">();
	}
	static class UPalAbilityPassiveSkill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAbilityPassiveSkill>();
	}
};
static_assert(alignof(UPalAbilityPassiveSkill) == 0x000008, "Wrong alignment on UPalAbilityPassiveSkill");
static_assert(sizeof(UPalAbilityPassiveSkill) == 0x0000F8, "Wrong size on UPalAbilityPassiveSkill");
static_assert(offsetof(UPalAbilityPassiveSkill, IsRestrictedDelegate) == 0x000028, "Member 'UPalAbilityPassiveSkill::IsRestrictedDelegate' has a wrong offset!");
static_assert(offsetof(UPalAbilityPassiveSkill, IsReserving) == 0x000038, "Member 'UPalAbilityPassiveSkill::IsReserving' has a wrong offset!");
static_assert(offsetof(UPalAbilityPassiveSkill, bIsRestricted) == 0x000039, "Member 'UPalAbilityPassiveSkill::bIsRestricted' has a wrong offset!");
static_assert(offsetof(UPalAbilityPassiveSkill, bRequireWorkerWorkingPassiveSkill) == 0x00003A, "Member 'UPalAbilityPassiveSkill::bRequireWorkerWorkingPassiveSkill' has a wrong offset!");
static_assert(offsetof(UPalAbilityPassiveSkill, bIsWorking) == 0x00003B, "Member 'UPalAbilityPassiveSkill::bIsWorking' has a wrong offset!");
static_assert(offsetof(UPalAbilityPassiveSkill, PassiveSkills) == 0x000040, "Member 'UPalAbilityPassiveSkill::PassiveSkills' has a wrong offset!");
static_assert(offsetof(UPalAbilityPassiveSkill, SkillStatus) == 0x000050, "Member 'UPalAbilityPassiveSkill::SkillStatus' has a wrong offset!");
static_assert(offsetof(UPalAbilityPassiveSkill, CurrentRank) == 0x0000A0, "Member 'UPalAbilityPassiveSkill::CurrentRank' has a wrong offset!");

// Class Pal.PalWorkBase
// 0x02F8 (0x0320 - 0x0028)
#pragma pack(push, 0x1)
class alignas(0x10) UPalWorkBase : public UObject
{
public:
	uint8                                         Pad_2772[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnDisposeDelegate;                                 // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFinishWorkInServerDelegate;                      // 0x0040(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnReflectFinishWorkDelegate;                       // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateAssignedCharacterDelegate;                 // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateCurrentStateDelegate;                      // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRequiredAssignWorkDelegate;                      // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAssignWorkDelegate;                              // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUnassignWorkDelegate;                            // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStartWorkDelegate;                               // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEndWorkDelegate;                                 // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FPalBoundsTransform                    WorkableBounds;                                    // 0x00D0(0x0080)(Edit, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   AssignDefineDataId;                                // 0x0150(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPalWorkType                                  OverrideWorkType;                                  // 0x0158(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2773[0x7];                                     // 0x0159(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPalWorkAssignLocalLocation>    AssignLocations;                                   // 0x0160(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2774[0x4];                                     // 0x0170(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  BaseCampIdBelongTo;                                // 0x0174(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  OwnerMapObjectModelId;                             // 0x0184(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  OwnerMapObjectConcreteModelId;                     // 0x0194(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPalWorkBehaviourType                         BehaviourType;                                     // 0x01A4(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPalWorkAssignableFixedType                   AssignableFixedType;                               // 0x01A5(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAssignableOtomo;                                  // 0x01A6(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanTriggerWorkerEvent;                            // 0x01A7(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanStealAssign;                                   // 0x01A8(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2775[0x3];                                     // 0x01A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  ID;                                                // 0x01AC(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPalWorkProgressState                         CurrentState;                                      // 0x01BC(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2776[0x3];                                     // 0x01BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalWorkProgressTransformBase*          Transform;                                         // 0x01C0(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPalFastWorkAssignRepInfoArray         AssignRepInfoArray;                                // 0x01C8(0x0148)(Edit, Net, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	bool                                          bGroupRaycastStartOffsetOrigin;                    // 0x0310(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2777[0x7];                                     // 0x0311(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void IssueNotifierLog_WorkStart(const class UPalCharacterParameterComponent* CharacterParameter);
	void NotifyWorkDelegate__DelegateSignature(class UPalWorkBase* Work);
	void OnRep_CurrentState();
	void WorkAssignRequirementDelegate__DelegateSignature(class UPalWorkBase* Work, const struct FPalWorkAssignRequirementParameter& RequirementParameter);
	void WorkAssignUpdateDelegate__DelegateSignature(class UPalWorkBase* Work, const struct FPalInstanceID& IndividualId);

	EPalWorkAssignableFixedType GetAssignableFixedType() const;
	void GetAssignedCharacters(TArray<class UPalIndividualCharacterSlot*>* IndividualSlots) const;
	void GetGenusCategorieNames(TArray<class FText>* OutGenusCategorieNames) const;
	const struct FGuid GetId() const;
	void GetWorkableElementTypeNames(TArray<class FText>* OutElementNames) const;
	void GetWorkAssignInfo(TArray<struct FPalWorkAssignInfo>* OutWorkAssignInfo) const;
	const struct FGuid GetWorkId() const;
	class FText GetWorkName() const;
	bool IsAssignableFixedOnly() const;
	bool IsAssignedCharacter(const class UPalIndividualCharacterHandle* IndividualHandle) const;
	bool IsExistAssignableSlot(const class UPalIndividualCharacterHandle* AssignIndividualHandle, const bool bByFixedAssign) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorkBase">();
	}
	static class UPalWorkBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWorkBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(UPalWorkBase) == 0x000010, "Wrong alignment on UPalWorkBase");
static_assert(sizeof(UPalWorkBase) == 0x000320, "Wrong size on UPalWorkBase");
static_assert(offsetof(UPalWorkBase, OnDisposeDelegate) == 0x000030, "Member 'UPalWorkBase::OnDisposeDelegate' has a wrong offset!");
static_assert(offsetof(UPalWorkBase, OnFinishWorkInServerDelegate) == 0x000040, "Member 'UPalWorkBase::OnFinishWorkInServerDelegate' has a wrong offset!");
static_assert(offsetof(UPalWorkBase, OnReflectFinishWorkDelegate) == 0x000050, "Member 'UPalWorkBase::OnReflectFinishWorkDelegate' has a wrong offset!");
static_assert(offsetof(UPalWorkBase, OnUpdateAssignedCharacterDelegate) == 0x000060, "Member 'UPalWorkBase::OnUpdateAssignedCharacterDelegate' has a wrong offset!");
static_assert(offsetof(UPalWorkBase, OnUpdateCurrentStateDelegate) == 0x000070, "Member 'UPalWorkBase::OnUpdateCurrentStateDelegate' has a wrong offset!");
static_assert(offsetof(UPalWorkBase, OnRequiredAssignWorkDelegate) == 0x000080, "Member 'UPalWorkBase::OnRequiredAssignWorkDelegate' has a wrong offset!");
static_assert(offsetof(UPalWorkBase, OnAssignWorkDelegate) == 0x000090, "Member 'UPalWorkBase::OnAssignWorkDelegate' has a wrong offset!");
static_assert(offsetof(UPalWorkBase, OnUnassignWorkDelegate) == 0x0000A0, "Member 'UPalWorkBase::OnUnassignWorkDelegate' has a wrong offset!");
static_assert(offsetof(UPalWorkBase, OnStartWorkDelegate) == 0x0000B0, "Member 'UPalWorkBase::OnStartWorkDelegate' has a wrong offset!");
static_assert(offsetof(UPalWorkBase, OnEndWorkDelegate) == 0x0000C0, "Member 'UPalWorkBase::OnEndWorkDelegate' has a wrong offset!");
static_assert(offsetof(UPalWorkBase, WorkableBounds) == 0x0000D0, "Member 'UPalWorkBase::WorkableBounds' has a wrong offset!");
static_assert(offsetof(UPalWorkBase, AssignDefineDataId) == 0x000150, "Member 'UPalWorkBase::AssignDefineDataId' has a wrong offset!");
static_assert(offsetof(UPalWorkBase, OverrideWorkType) == 0x000158, "Member 'UPalWorkBase::OverrideWorkType' has a wrong offset!");
static_assert(offsetof(UPalWorkBase, AssignLocations) == 0x000160, "Member 'UPalWorkBase::AssignLocations' has a wrong offset!");
static_assert(offsetof(UPalWorkBase, BaseCampIdBelongTo) == 0x000174, "Member 'UPalWorkBase::BaseCampIdBelongTo' has a wrong offset!");
static_assert(offsetof(UPalWorkBase, OwnerMapObjectModelId) == 0x000184, "Member 'UPalWorkBase::OwnerMapObjectModelId' has a wrong offset!");
static_assert(offsetof(UPalWorkBase, OwnerMapObjectConcreteModelId) == 0x000194, "Member 'UPalWorkBase::OwnerMapObjectConcreteModelId' has a wrong offset!");
static_assert(offsetof(UPalWorkBase, BehaviourType) == 0x0001A4, "Member 'UPalWorkBase::BehaviourType' has a wrong offset!");
static_assert(offsetof(UPalWorkBase, AssignableFixedType) == 0x0001A5, "Member 'UPalWorkBase::AssignableFixedType' has a wrong offset!");
static_assert(offsetof(UPalWorkBase, bAssignableOtomo) == 0x0001A6, "Member 'UPalWorkBase::bAssignableOtomo' has a wrong offset!");
static_assert(offsetof(UPalWorkBase, bCanTriggerWorkerEvent) == 0x0001A7, "Member 'UPalWorkBase::bCanTriggerWorkerEvent' has a wrong offset!");
static_assert(offsetof(UPalWorkBase, bCanStealAssign) == 0x0001A8, "Member 'UPalWorkBase::bCanStealAssign' has a wrong offset!");
static_assert(offsetof(UPalWorkBase, ID) == 0x0001AC, "Member 'UPalWorkBase::ID' has a wrong offset!");
static_assert(offsetof(UPalWorkBase, CurrentState) == 0x0001BC, "Member 'UPalWorkBase::CurrentState' has a wrong offset!");
static_assert(offsetof(UPalWorkBase, Transform) == 0x0001C0, "Member 'UPalWorkBase::Transform' has a wrong offset!");
static_assert(offsetof(UPalWorkBase, AssignRepInfoArray) == 0x0001C8, "Member 'UPalWorkBase::AssignRepInfoArray' has a wrong offset!");
static_assert(offsetof(UPalWorkBase, bGroupRaycastStartOffsetOrigin) == 0x000310, "Member 'UPalWorkBase::bGroupRaycastStartOffsetOrigin' has a wrong offset!");

// Class Pal.PalWorkOnlyJoinAndWalkAround
// 0x0020 (0x0340 - 0x0320)
class UPalWorkOnlyJoinAndWalkAround final : public UPalWorkBase
{
public:
	uint8                                         Pad_277A[0x28];                                    // 0x0318(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorkOnlyJoinAndWalkAround">();
	}
	static class UPalWorkOnlyJoinAndWalkAround* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWorkOnlyJoinAndWalkAround>();
	}
};
static_assert(alignof(UPalWorkOnlyJoinAndWalkAround) == 0x000010, "Wrong alignment on UPalWorkOnlyJoinAndWalkAround");
static_assert(sizeof(UPalWorkOnlyJoinAndWalkAround) == 0x000340, "Wrong size on UPalWorkOnlyJoinAndWalkAround");

// Class Pal.PalFoliageGridModel
// 0x01B8 (0x01E0 - 0x0028)
class UPalFoliageGridModel final : public UObject
{
public:
	uint8                                         Pad_277B[0x20];                                    // 0x0028(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class UPalMapObjectFoliageModel*> FoliageModelMapInServer;                           // 0x0048(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_277C[0xA8];                                    // 0x0098(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FPalFoliageGridInstanceMap> InstanceMapByComponentId;                          // 0x0140(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	TMap<struct FVector, struct FPalFoliageInstanceId> InstanceIdMapByLocation;                           // 0x0190(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalFoliageGridModel">();
	}
	static class UPalFoliageGridModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalFoliageGridModel>();
	}
};
static_assert(alignof(UPalFoliageGridModel) == 0x000008, "Wrong alignment on UPalFoliageGridModel");
static_assert(sizeof(UPalFoliageGridModel) == 0x0001E0, "Wrong size on UPalFoliageGridModel");
static_assert(offsetof(UPalFoliageGridModel, FoliageModelMapInServer) == 0x000048, "Member 'UPalFoliageGridModel::FoliageModelMapInServer' has a wrong offset!");
static_assert(offsetof(UPalFoliageGridModel, InstanceMapByComponentId) == 0x000140, "Member 'UPalFoliageGridModel::InstanceMapByComponentId' has a wrong offset!");
static_assert(offsetof(UPalFoliageGridModel, InstanceIdMapByLocation) == 0x000190, "Member 'UPalFoliageGridModel::InstanceIdMapByLocation' has a wrong offset!");

// Class Pal.PalAIActionBase
// 0x00A0 (0x0130 - 0x0090)
class UPalAIActionBase : public UPawnAction_BlueprintBase
{
public:
	bool                                          bIsAutoStopBehaviorTree;                           // 0x0090(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPalAIActionCategory                          AiActionCategory;                                  // 0x0091(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_277D[0x6];                                     // 0x0092(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPalAIActionDynamicParameter           DynamicParameter;                                  // 0x0098(0x0050)(BlueprintVisible, Transient, NoDestructor, NativeAccessSpecifierPublic)
	EAIRequestPriority                            DefaultPriority;                                   // 0x00E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_277E[0x7];                                     // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnStartActionDelegate;                             // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPauseActionDelegate;                             // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnResumeActionDelegate;                            // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFinishActionDelegate;                            // 0x0120(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UPawnAction* CreateActionInstanceFixName(class UObject* WorldContextObject, TSubclassOf<class UPawnAction> ActionClass, class FName ActionName);

	void ActionAbort(class APawn* ControlledPawn);
	class UPawnActionsComponent* GetOwnerComponent();
	void OnActionByDelegate__DelegateSignature(class UPalAIActionBase* Action, const class UPawnAction* byAction);
	void OnActionDelegate__DelegateSignature(class UPalAIActionBase* Action);
	void OnChildActionFinished(class UPawnAction* Action, EPawnActionResult WithResult);
	bool PushChildAction(class UPawnAction* Action);
	class UPalAIActionBase* SetAIActionClassParameter(TSubclassOf<class UPalAIActionBase> NewActionClass, const struct FPalAIActionDynamicParameter& Parameter);
	void SetWalkSpeed_ForAIAction(EPalMovementSpeedType MoveSpeedType);

	class UPalActionComponent* GetActionComponent() const;
	class UPalAIActionComponent* GetAIActionComponent() const;
	class APalCharacter* GetCharacter() const;
	class UPalCharacterParameterComponent* GetCharacterParameter() const;
	class AController* GetController() const;
	class APalAIController* GetPalAIController() const;
	EAIRequestPriority GetRequestPriority() const;
	class FString GetSimpleName() const;
	bool IsActive() const;
	bool IsPaused() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionBase">();
	}
	static class UPalAIActionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIActionBase>();
	}
};
static_assert(alignof(UPalAIActionBase) == 0x000008, "Wrong alignment on UPalAIActionBase");
static_assert(sizeof(UPalAIActionBase) == 0x000130, "Wrong size on UPalAIActionBase");
static_assert(offsetof(UPalAIActionBase, bIsAutoStopBehaviorTree) == 0x000090, "Member 'UPalAIActionBase::bIsAutoStopBehaviorTree' has a wrong offset!");
static_assert(offsetof(UPalAIActionBase, AiActionCategory) == 0x000091, "Member 'UPalAIActionBase::AiActionCategory' has a wrong offset!");
static_assert(offsetof(UPalAIActionBase, DynamicParameter) == 0x000098, "Member 'UPalAIActionBase::DynamicParameter' has a wrong offset!");
static_assert(offsetof(UPalAIActionBase, DefaultPriority) == 0x0000E8, "Member 'UPalAIActionBase::DefaultPriority' has a wrong offset!");
static_assert(offsetof(UPalAIActionBase, OnStartActionDelegate) == 0x0000F0, "Member 'UPalAIActionBase::OnStartActionDelegate' has a wrong offset!");
static_assert(offsetof(UPalAIActionBase, OnPauseActionDelegate) == 0x000100, "Member 'UPalAIActionBase::OnPauseActionDelegate' has a wrong offset!");
static_assert(offsetof(UPalAIActionBase, OnResumeActionDelegate) == 0x000110, "Member 'UPalAIActionBase::OnResumeActionDelegate' has a wrong offset!");
static_assert(offsetof(UPalAIActionBase, OnFinishActionDelegate) == 0x000120, "Member 'UPalAIActionBase::OnFinishActionDelegate' has a wrong offset!");

// Class Pal.PalAIActionWorkerChildBase
// 0x0008 (0x0138 - 0x0130)
class UPalAIActionWorkerChildBase : public UPalAIActionBase
{
public:
	uint8                                         Pad_2781[0x8];                                     // 0x0130(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void LookToTarget(const float TurnSpeed, const float DeltaTime);

	class UPalAIActionCompositeWorker* GetParent() const;
	struct FVector GetWorkLookAtLocation() const;
	bool IsAssignedToTarget() const;
	bool IsTargetAssignable() const;
	bool IsTargetWorkable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionWorkerChildBase">();
	}
	static class UPalAIActionWorkerChildBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIActionWorkerChildBase>();
	}
};
static_assert(alignof(UPalAIActionWorkerChildBase) == 0x000008, "Wrong alignment on UPalAIActionWorkerChildBase");
static_assert(sizeof(UPalAIActionWorkerChildBase) == 0x000138, "Wrong size on UPalAIActionWorkerChildBase");

// Class Pal.PalMapObject
// 0x0120 (0x03B0 - 0x0290)
class APalMapObject : public AActor
{
public:
	uint8                                         Pad_2782[0x10];                                    // 0x0290(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnNotifiedShowStatusHUDDelegate;                   // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNotifiedShowBuildProgressHUDDelegate;            // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSetConcreteModelDelegate;                        // 0x02C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FVector                                SpawnLocationOffset;                               // 0x02D0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalMapObjectConcreteModelBase> ConcreteModelClass;                                // 0x02E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TScriptInterface<class IPalInteractiveObjectComponentInterface>> InteractComps;                                     // 0x02F0(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UPalMapObjectDamageReactionComponent*   DamageReaction;                                    // 0x0300(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalMapObjectVisualEffectComponent*     VisualEffect;                                      // 0x0308(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSpawnableIfOverlapped;                            // 0x0310(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLevelSpawnObject;                                 // 0x0311(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2783[0x6];                                     // 0x0312(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           AllowOverlapCollisionPresetNames;                  // 0x0318(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           AllowOverlapActorTags;                             // 0x0328(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bSpawnSlipAboveIfAnyOverlap;                       // 0x0338(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShakeOnDamaged;                                   // 0x0339(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPalMapObjectDestroyFXType                    DestroyFXType;                                     // 0x033A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowOutlineInTargettingReticle;                   // 0x033B(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowOutlineNearPlayer;                            // 0x033C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAutoDestroyByOverlapSpawning;                     // 0x033D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInDoorObject;                                     // 0x033E(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBaseObject;                                       // 0x033F(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  HPHUDId;                                           // 0x0340(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPalMapObjectDamagableType                    DamagableType;                                     // 0x0350(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2784[0x3];                                     // 0x0351(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  ModelInstanceId;                                   // 0x0354(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2785[0x4];                                     // 0x0364(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalMapObjectModel*                     MapObjectModel;                                    // 0x0368(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUnmanagedInLocal;                                 // 0x0370(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2786[0x7];                                     // 0x0371(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UPalUserWidgetWorldHUD>     IndicatorWidgetClass;                              // 0x0378(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FPalMapObjectMeshVisibleData>   MeshVisibleDataSet;                                // 0x0380(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	EPalMapObjectChangeMeshFXType                 ChangeMeshFXType;                                  // 0x0390(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2787[0x3];                                     // 0x0391(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  OpenWidgetId;                                      // 0x0394(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bWorkLocationGroupRaycastStartOffsetOrigin;        // 0x03A4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShouldPlayDestroyFX;                              // 0x03A5(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2788[0xA];                                     // 0x03A6(0x000A)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnSetConcreteModel(class UPalMapObjectConcreteModelBase* ConcreteModel);
	void BroadcastShouldPlayDestroyFX();
	void CallOrRegisterOnSetConcreteModel(TDelegate<void(class UPalMapObjectConcreteModelBase* Model)> Delegate);
	void DisposeSelf_ServerInternal();
	void OnCloseParameter(class UPalHUDDispatchParameterBase* Parameter);
	void OnDamaged(class UPalMapObjectModel* TargetModel, const struct FPalDamageInfo& DamageInfo);
	void OnDisposeModel_ServerInternal(class UPalMapObjectModel* DisposeModel, const struct FPalMapObjectDisposeOptions& Options);
	void OnInteractBegin(class AActor* Other, TScriptInterface<class IPalInteractiveObjectComponentInterface> Component);
	void OnInteractEnd(class AActor* Other, TScriptInterface<class IPalInteractiveObjectComponentInterface> Component);
	void OnRep_MapObjectModel();
	void OnUpdatedEnableTickByModel(class UPalMapObjectModel* Model);
	void ReturnSelf__DelegateSignature(class APalMapObject* Self, EPalHUDDisplayType DisplayType);
	void SetIgnoreSave_ServerInternal(const bool bIgnore);
	void ToggleBuildProgressHUD__DelegateSignature(EPalHUDDisplayType DisplayType);
	void TryGetConcreteModel(EPalMapObjectGetModelOutPinType* OutputPin, class UPalMapObjectConcreteModelBase** ConcreteModel);

	const struct FGuid GetGroupIdBelongTo() const;
	class UPalMapObjectModel* GetModel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObject">();
	}
	static class APalMapObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalMapObject>();
	}
};
static_assert(alignof(APalMapObject) == 0x000008, "Wrong alignment on APalMapObject");
static_assert(sizeof(APalMapObject) == 0x0003B0, "Wrong size on APalMapObject");
static_assert(offsetof(APalMapObject, OnNotifiedShowStatusHUDDelegate) == 0x0002A0, "Member 'APalMapObject::OnNotifiedShowStatusHUDDelegate' has a wrong offset!");
static_assert(offsetof(APalMapObject, OnNotifiedShowBuildProgressHUDDelegate) == 0x0002B0, "Member 'APalMapObject::OnNotifiedShowBuildProgressHUDDelegate' has a wrong offset!");
static_assert(offsetof(APalMapObject, OnSetConcreteModelDelegate) == 0x0002C0, "Member 'APalMapObject::OnSetConcreteModelDelegate' has a wrong offset!");
static_assert(offsetof(APalMapObject, SpawnLocationOffset) == 0x0002D0, "Member 'APalMapObject::SpawnLocationOffset' has a wrong offset!");
static_assert(offsetof(APalMapObject, ConcreteModelClass) == 0x0002E8, "Member 'APalMapObject::ConcreteModelClass' has a wrong offset!");
static_assert(offsetof(APalMapObject, InteractComps) == 0x0002F0, "Member 'APalMapObject::InteractComps' has a wrong offset!");
static_assert(offsetof(APalMapObject, DamageReaction) == 0x000300, "Member 'APalMapObject::DamageReaction' has a wrong offset!");
static_assert(offsetof(APalMapObject, VisualEffect) == 0x000308, "Member 'APalMapObject::VisualEffect' has a wrong offset!");
static_assert(offsetof(APalMapObject, bSpawnableIfOverlapped) == 0x000310, "Member 'APalMapObject::bSpawnableIfOverlapped' has a wrong offset!");
static_assert(offsetof(APalMapObject, bLevelSpawnObject) == 0x000311, "Member 'APalMapObject::bLevelSpawnObject' has a wrong offset!");
static_assert(offsetof(APalMapObject, AllowOverlapCollisionPresetNames) == 0x000318, "Member 'APalMapObject::AllowOverlapCollisionPresetNames' has a wrong offset!");
static_assert(offsetof(APalMapObject, AllowOverlapActorTags) == 0x000328, "Member 'APalMapObject::AllowOverlapActorTags' has a wrong offset!");
static_assert(offsetof(APalMapObject, bSpawnSlipAboveIfAnyOverlap) == 0x000338, "Member 'APalMapObject::bSpawnSlipAboveIfAnyOverlap' has a wrong offset!");
static_assert(offsetof(APalMapObject, bShakeOnDamaged) == 0x000339, "Member 'APalMapObject::bShakeOnDamaged' has a wrong offset!");
static_assert(offsetof(APalMapObject, DestroyFXType) == 0x00033A, "Member 'APalMapObject::DestroyFXType' has a wrong offset!");
static_assert(offsetof(APalMapObject, bShowOutlineInTargettingReticle) == 0x00033B, "Member 'APalMapObject::bShowOutlineInTargettingReticle' has a wrong offset!");
static_assert(offsetof(APalMapObject, bShowOutlineNearPlayer) == 0x00033C, "Member 'APalMapObject::bShowOutlineNearPlayer' has a wrong offset!");
static_assert(offsetof(APalMapObject, bAutoDestroyByOverlapSpawning) == 0x00033D, "Member 'APalMapObject::bAutoDestroyByOverlapSpawning' has a wrong offset!");
static_assert(offsetof(APalMapObject, bInDoorObject) == 0x00033E, "Member 'APalMapObject::bInDoorObject' has a wrong offset!");
static_assert(offsetof(APalMapObject, bBaseObject) == 0x00033F, "Member 'APalMapObject::bBaseObject' has a wrong offset!");
static_assert(offsetof(APalMapObject, HPHUDId) == 0x000340, "Member 'APalMapObject::HPHUDId' has a wrong offset!");
static_assert(offsetof(APalMapObject, DamagableType) == 0x000350, "Member 'APalMapObject::DamagableType' has a wrong offset!");
static_assert(offsetof(APalMapObject, ModelInstanceId) == 0x000354, "Member 'APalMapObject::ModelInstanceId' has a wrong offset!");
static_assert(offsetof(APalMapObject, MapObjectModel) == 0x000368, "Member 'APalMapObject::MapObjectModel' has a wrong offset!");
static_assert(offsetof(APalMapObject, bUnmanagedInLocal) == 0x000370, "Member 'APalMapObject::bUnmanagedInLocal' has a wrong offset!");
static_assert(offsetof(APalMapObject, IndicatorWidgetClass) == 0x000378, "Member 'APalMapObject::IndicatorWidgetClass' has a wrong offset!");
static_assert(offsetof(APalMapObject, MeshVisibleDataSet) == 0x000380, "Member 'APalMapObject::MeshVisibleDataSet' has a wrong offset!");
static_assert(offsetof(APalMapObject, ChangeMeshFXType) == 0x000390, "Member 'APalMapObject::ChangeMeshFXType' has a wrong offset!");
static_assert(offsetof(APalMapObject, OpenWidgetId) == 0x000394, "Member 'APalMapObject::OpenWidgetId' has a wrong offset!");
static_assert(offsetof(APalMapObject, bWorkLocationGroupRaycastStartOffsetOrigin) == 0x0003A4, "Member 'APalMapObject::bWorkLocationGroupRaycastStartOffsetOrigin' has a wrong offset!");
static_assert(offsetof(APalMapObject, bShouldPlayDestroyFX) == 0x0003A5, "Member 'APalMapObject::bShouldPlayDestroyFX' has a wrong offset!");

// Class Pal.PalBuildObject
// 0x01D0 (0x0580 - 0x03B0)
class APalBuildObject : public APalMapObject
{
public:
	uint8                                         Pad_278B[0x20];                                    // 0x03B0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnChangeState;                                     // 0x03D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_278C[0x18];                                    // 0x03E0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	EPalBuildObjectInstallStrategy                InstallStrategy;                                   // 0x03F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_278D[0x3];                                     // 0x03F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InstallCapacitySlopeAngle;                         // 0x03FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InstallCapacitySinkRateByHeight;                   // 0x0400(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_278E[0x4];                                     // 0x0404(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalBuildObjectVisualControlComponent*  VisualCtrl;                                        // 0x0408(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BuildObjectId;                                     // 0x0410(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UShapeComponent*                        OverlapCheckCollision;                             // 0x0418(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FComponentReference                    OverlapCheckCollisionRef;                          // 0x0420(0x0028)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FBox                                   LocalBounds;                                       // 0x0448(0x0038)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UPalBuildObjectOverlapChecker*          OverlapChecker;                                    // 0x0480(0x0008)(Edit, ZeroConstructor, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMeshComponent*>                 AllMeshes;                                         // 0x0488(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UPrimitiveComponent*>            VirtualMeshCollisions;                             // 0x0498(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	EPalBuildObjectState                          CurrentState;                                      // 0x04A8(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_278F[0x3];                                     // 0x04A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  WorldHUDId;                                        // 0x04AC(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  buildProgressWorldHUDId;                           // 0x04BC(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2790[0x4];                                     // 0x04CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                WorldHUDDisplayOffset;                             // 0x04D0(0x0018)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WorldHUDDisplayRange;                              // 0x04E8(0x0004)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2791[0x4];                                     // 0x04EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                buildProgressHUDDisplayOffset;                     // 0x04F0(0x0018)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              buildProgressHUDDisplayOffsetScreen;               // 0x0508(0x0010)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         buildProgressHUDDisplayRange;                      // 0x0518(0x0004)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2792[0x4];                                     // 0x051C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          BuildCompleteSEOverride;                           // 0x0520(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BuildProgressVisualRate;                           // 0x0528(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDismantleTargetInLocal;                           // 0x052C(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2793[0x3];                                     // 0x052D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UPrimitiveComponent*, struct FPalBuildObjectMeshDefaultSetting> DefaultMeshSettingMap;                             // 0x0530(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void OnAvailable_BlueprintImpl();
	void OnBeginInteractBuilding(class AActor* OtherActor, TScriptInterface<class IPalInteractiveObjectComponentInterface> InteractiveObject);
	void OnChangeStateDelegate__DelegateSignature(EPalBuildObjectState State);
	void OnDamage(class UPalMapObjectModel* DamagedModel, const struct FPalDamageInfo& DamageInfo);
	void OnEndTriggerInteractBuilding(class AActor* OtherActor, EPalInteractiveObjectIndicatorType IndicatorType);
	void OnFinishBuildWork_ServerInternal(class UPalBuildProcess* BuildProcess);
	void OnNotAvailable_BlueprintImpl();
	void OnRep_BuildProgressVisualRate();
	void OnRep_CurrentState();
	void OnStartTriggerInteractBuilding(class AActor* OtherActor, EPalInteractiveObjectIndicatorType IndicatorType);
	void OnTickBuildCompleteAnimation();
	void OnTickRepairCompleteAnimation();
	void OnTriggerInteractBuilding(class AActor* OtherActor, EPalInteractiveObjectIndicatorType IndicatorType);
	void OnUpdateBuildWorkAmount(class UPalWorkProgress* WorkProgress);
	void OnUpdateHp(class UPalMapObjectModel* DamagedModel);
	void PlayBuildCompleteFX_ToALL();

	class UShapeComponent* GetBuildWorkableBoundsShape() const;
	bool IsAvailable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBuildObject">();
	}
	static class APalBuildObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalBuildObject>();
	}
};
static_assert(alignof(APalBuildObject) == 0x000008, "Wrong alignment on APalBuildObject");
static_assert(sizeof(APalBuildObject) == 0x000580, "Wrong size on APalBuildObject");
static_assert(offsetof(APalBuildObject, OnChangeState) == 0x0003D0, "Member 'APalBuildObject::OnChangeState' has a wrong offset!");
static_assert(offsetof(APalBuildObject, InstallStrategy) == 0x0003F8, "Member 'APalBuildObject::InstallStrategy' has a wrong offset!");
static_assert(offsetof(APalBuildObject, InstallCapacitySlopeAngle) == 0x0003FC, "Member 'APalBuildObject::InstallCapacitySlopeAngle' has a wrong offset!");
static_assert(offsetof(APalBuildObject, InstallCapacitySinkRateByHeight) == 0x000400, "Member 'APalBuildObject::InstallCapacitySinkRateByHeight' has a wrong offset!");
static_assert(offsetof(APalBuildObject, VisualCtrl) == 0x000408, "Member 'APalBuildObject::VisualCtrl' has a wrong offset!");
static_assert(offsetof(APalBuildObject, BuildObjectId) == 0x000410, "Member 'APalBuildObject::BuildObjectId' has a wrong offset!");
static_assert(offsetof(APalBuildObject, OverlapCheckCollision) == 0x000418, "Member 'APalBuildObject::OverlapCheckCollision' has a wrong offset!");
static_assert(offsetof(APalBuildObject, OverlapCheckCollisionRef) == 0x000420, "Member 'APalBuildObject::OverlapCheckCollisionRef' has a wrong offset!");
static_assert(offsetof(APalBuildObject, LocalBounds) == 0x000448, "Member 'APalBuildObject::LocalBounds' has a wrong offset!");
static_assert(offsetof(APalBuildObject, OverlapChecker) == 0x000480, "Member 'APalBuildObject::OverlapChecker' has a wrong offset!");
static_assert(offsetof(APalBuildObject, AllMeshes) == 0x000488, "Member 'APalBuildObject::AllMeshes' has a wrong offset!");
static_assert(offsetof(APalBuildObject, VirtualMeshCollisions) == 0x000498, "Member 'APalBuildObject::VirtualMeshCollisions' has a wrong offset!");
static_assert(offsetof(APalBuildObject, CurrentState) == 0x0004A8, "Member 'APalBuildObject::CurrentState' has a wrong offset!");
static_assert(offsetof(APalBuildObject, WorldHUDId) == 0x0004AC, "Member 'APalBuildObject::WorldHUDId' has a wrong offset!");
static_assert(offsetof(APalBuildObject, buildProgressWorldHUDId) == 0x0004BC, "Member 'APalBuildObject::buildProgressWorldHUDId' has a wrong offset!");
static_assert(offsetof(APalBuildObject, WorldHUDDisplayOffset) == 0x0004D0, "Member 'APalBuildObject::WorldHUDDisplayOffset' has a wrong offset!");
static_assert(offsetof(APalBuildObject, WorldHUDDisplayRange) == 0x0004E8, "Member 'APalBuildObject::WorldHUDDisplayRange' has a wrong offset!");
static_assert(offsetof(APalBuildObject, buildProgressHUDDisplayOffset) == 0x0004F0, "Member 'APalBuildObject::buildProgressHUDDisplayOffset' has a wrong offset!");
static_assert(offsetof(APalBuildObject, buildProgressHUDDisplayOffsetScreen) == 0x000508, "Member 'APalBuildObject::buildProgressHUDDisplayOffsetScreen' has a wrong offset!");
static_assert(offsetof(APalBuildObject, buildProgressHUDDisplayRange) == 0x000518, "Member 'APalBuildObject::buildProgressHUDDisplayRange' has a wrong offset!");
static_assert(offsetof(APalBuildObject, BuildCompleteSEOverride) == 0x000520, "Member 'APalBuildObject::BuildCompleteSEOverride' has a wrong offset!");
static_assert(offsetof(APalBuildObject, BuildProgressVisualRate) == 0x000528, "Member 'APalBuildObject::BuildProgressVisualRate' has a wrong offset!");
static_assert(offsetof(APalBuildObject, bDismantleTargetInLocal) == 0x00052C, "Member 'APalBuildObject::bDismantleTargetInLocal' has a wrong offset!");
static_assert(offsetof(APalBuildObject, DefaultMeshSettingMap) == 0x000530, "Member 'APalBuildObject::DefaultMeshSettingMap' has a wrong offset!");

// Class Pal.PalBuildObjectMonsterFarm
// 0x0028 (0x05A8 - 0x0580)
class APalBuildObjectMonsterFarm final : public APalBuildObject
{
public:
	struct FComponentReference                    WalkAroundVolumeRef;                               // 0x0580(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBuildObjectMonsterFarm">();
	}
	static class APalBuildObjectMonsterFarm* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalBuildObjectMonsterFarm>();
	}
};
static_assert(alignof(APalBuildObjectMonsterFarm) == 0x000008, "Wrong alignment on APalBuildObjectMonsterFarm");
static_assert(sizeof(APalBuildObjectMonsterFarm) == 0x0005A8, "Wrong size on APalBuildObjectMonsterFarm");
static_assert(offsetof(APalBuildObjectMonsterFarm, WalkAroundVolumeRef) == 0x000580, "Member 'APalBuildObjectMonsterFarm::WalkAroundVolumeRef' has a wrong offset!");

// Class Pal.PalAbilitySkillParameterComponent
// 0x0018 (0x00B8 - 0x00A0)
class UPalAbilitySkillParameterComponent final : public UActorComponent
{
public:
	TArray<struct FPalPassiveAbilitySkills>       AbilitySkills;                                     // 0x00A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UPalAbilityPassiveSkill*                PassiveSkill;                                      // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void InitializedCharacterByFunnel();
	void OnActivatedAsOtomoHolder();
	void OnActivatedAsPartner();
	void OnActivatedAsWorker();
	void OnInactivatedAsOtomoHolder();
	void OnInactivatedAsPartner();
	void OnInactivatedAsWorker();
	void OnInitializedCharacter(class APalCharacter* OwnerCharacter);
	void OnOwnerCharacterSpawned(const struct FPalInstanceID& ID);
	void OnRideActivated();
	void OnRideInactivated();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAbilitySkillParameterComponent">();
	}
	static class UPalAbilitySkillParameterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAbilitySkillParameterComponent>();
	}
};
static_assert(alignof(UPalAbilitySkillParameterComponent) == 0x000008, "Wrong alignment on UPalAbilitySkillParameterComponent");
static_assert(sizeof(UPalAbilitySkillParameterComponent) == 0x0000B8, "Wrong size on UPalAbilitySkillParameterComponent");
static_assert(offsetof(UPalAbilitySkillParameterComponent, AbilitySkills) == 0x0000A0, "Member 'UPalAbilitySkillParameterComponent::AbilitySkills' has a wrong offset!");
static_assert(offsetof(UPalAbilitySkillParameterComponent, PassiveSkill) == 0x0000B0, "Member 'UPalAbilitySkillParameterComponent::PassiveSkill' has a wrong offset!");

// Class Pal.PalBaseCampWorkerEventBase
// 0x0068 (0x0090 - 0x0028)
class UPalBaseCampWorkerEventBase : public UObject
{
public:
	struct FPalDataTableRowName_BaseCampWorkerEventData MasterDataId;                                      // 0x0028(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPalLogType                                   LogType;                                           // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2797[0x7];                                     // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPalBaseCampWorkerEventMasterData      MasterData;                                        // 0x0038(0x0028)(Edit, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UNiagaraSystem>          OverrideSleepFX;                                   // 0x0060(0x0030)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class FText CreateNotifyMessageText(const class FText& LocalizedFormatText, class APalCharacter* Character);
	class FString Debug_CreateTextTriggerEventSanity();

	bool IsTriggerEventByCharacter(const class APalCharacter* Character) const;
	bool IsTriggerEventBySanity(const float SanityValue) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBaseCampWorkerEventBase">();
	}
	static class UPalBaseCampWorkerEventBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBaseCampWorkerEventBase>();
	}
};
static_assert(alignof(UPalBaseCampWorkerEventBase) == 0x000008, "Wrong alignment on UPalBaseCampWorkerEventBase");
static_assert(sizeof(UPalBaseCampWorkerEventBase) == 0x000090, "Wrong size on UPalBaseCampWorkerEventBase");
static_assert(offsetof(UPalBaseCampWorkerEventBase, MasterDataId) == 0x000028, "Member 'UPalBaseCampWorkerEventBase::MasterDataId' has a wrong offset!");
static_assert(offsetof(UPalBaseCampWorkerEventBase, LogType) == 0x000030, "Member 'UPalBaseCampWorkerEventBase::LogType' has a wrong offset!");
static_assert(offsetof(UPalBaseCampWorkerEventBase, MasterData) == 0x000038, "Member 'UPalBaseCampWorkerEventBase::MasterData' has a wrong offset!");
static_assert(offsetof(UPalBaseCampWorkerEventBase, OverrideSleepFX) == 0x000060, "Member 'UPalBaseCampWorkerEventBase::OverrideSleepFX' has a wrong offset!");

// Class Pal.PalBaseCampWorkerEvent_Tantrum
// 0x0008 (0x0098 - 0x0090)
class UPalBaseCampWorkerEvent_Tantrum final : public UPalBaseCampWorkerEventBase
{
public:
	TSubclassOf<class UPalAIActionBaseCampTrantrum> ActionClass;                                       // 0x0090(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBaseCampWorkerEvent_Tantrum">();
	}
	static class UPalBaseCampWorkerEvent_Tantrum* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBaseCampWorkerEvent_Tantrum>();
	}
};
static_assert(alignof(UPalBaseCampWorkerEvent_Tantrum) == 0x000008, "Wrong alignment on UPalBaseCampWorkerEvent_Tantrum");
static_assert(sizeof(UPalBaseCampWorkerEvent_Tantrum) == 0x000098, "Wrong size on UPalBaseCampWorkerEvent_Tantrum");
static_assert(offsetof(UPalBaseCampWorkerEvent_Tantrum, ActionClass) == 0x000090, "Member 'UPalBaseCampWorkerEvent_Tantrum::ActionClass' has a wrong offset!");

// Class Pal.PalAIActionCompositeWorkerBaseCamp
// 0x0018 (0x00A0 - 0x0088)
class UPalAIActionCompositeWorkerBaseCamp : public UPalAIActionCompositeWorker
{
public:
	uint8                                         Pad_279A[0x8];                                     // 0x0088(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UPalAIActionCombatBase>     CombatActionClass;                                 // 0x0090(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UPalAIActionBaseCampDefenseBase> DefenseActionClass;                                // 0x0098(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionCompositeWorkerBaseCamp">();
	}
	static class UPalAIActionCompositeWorkerBaseCamp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIActionCompositeWorkerBaseCamp>();
	}
};
static_assert(alignof(UPalAIActionCompositeWorkerBaseCamp) == 0x000008, "Wrong alignment on UPalAIActionCompositeWorkerBaseCamp");
static_assert(sizeof(UPalAIActionCompositeWorkerBaseCamp) == 0x0000A0, "Wrong size on UPalAIActionCompositeWorkerBaseCamp");
static_assert(offsetof(UPalAIActionCompositeWorkerBaseCamp, CombatActionClass) == 0x000090, "Member 'UPalAIActionCompositeWorkerBaseCamp::CombatActionClass' has a wrong offset!");
static_assert(offsetof(UPalAIActionCompositeWorkerBaseCamp, DefenseActionClass) == 0x000098, "Member 'UPalAIActionCompositeWorkerBaseCamp::DefenseActionClass' has a wrong offset!");

// Class Pal.PalMapObjectRankUpCharacterModel
// 0x0028 (0x0240 - 0x0218)
class UPalMapObjectRankUpCharacterModel final : public UPalMapObjectConcreteModelBase
{
public:
	FMulticastInlineDelegateProperty_             OnReceiveRequestResultDelegate;                    // 0x0218(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGuid                                  BaseCampIdBelongTo;                                // 0x0228(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UPalUserWidgetOverlayUI>    MenuUIWidgetClass;                                 // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ReceiveOperationResult(const int32 ResultInt);
	void RequestRankup_ServerInternal(const int32 RequestPlayerId, const struct FPalNetArchive& Archive);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectRankUpCharacterModel">();
	}
	static class UPalMapObjectRankUpCharacterModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectRankUpCharacterModel>();
	}
};
static_assert(alignof(UPalMapObjectRankUpCharacterModel) == 0x000008, "Wrong alignment on UPalMapObjectRankUpCharacterModel");
static_assert(sizeof(UPalMapObjectRankUpCharacterModel) == 0x000240, "Wrong size on UPalMapObjectRankUpCharacterModel");
static_assert(offsetof(UPalMapObjectRankUpCharacterModel, OnReceiveRequestResultDelegate) == 0x000218, "Member 'UPalMapObjectRankUpCharacterModel::OnReceiveRequestResultDelegate' has a wrong offset!");
static_assert(offsetof(UPalMapObjectRankUpCharacterModel, BaseCampIdBelongTo) == 0x000228, "Member 'UPalMapObjectRankUpCharacterModel::BaseCampIdBelongTo' has a wrong offset!");
static_assert(offsetof(UPalMapObjectRankUpCharacterModel, MenuUIWidgetClass) == 0x000238, "Member 'UPalMapObjectRankUpCharacterModel::MenuUIWidgetClass' has a wrong offset!");

// Class Pal.ActionDynamicParameterUtility
// 0x0000 (0x0028 - 0x0028)
class UActionDynamicParameterUtility final : public UBlueprintFunctionLibrary
{
public:
	static void SetBlackboard(struct FActionDynamicParameter& DynamicParameterRef, struct FPalNetArchive& Blackboard);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionDynamicParameterUtility">();
	}
	static class UActionDynamicParameterUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionDynamicParameterUtility>();
	}
};
static_assert(alignof(UActionDynamicParameterUtility) == 0x000008, "Wrong alignment on UActionDynamicParameterUtility");
static_assert(sizeof(UActionDynamicParameterUtility) == 0x000028, "Wrong size on UActionDynamicParameterUtility");

// Class Pal.PalMapObjectFoliageModel
// 0x0118 (0x0140 - 0x0028)
class UPalMapObjectFoliageModel final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnRespawn;                                         // 0x0028(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDamage;                                          // 0x0038(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDestroy;                                         // 0x0048(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdatedRequiredTickInServer;                     // 0x0058(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDisposeModelDelegate;                            // 0x0068(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	class FName                                   ModelId;                                           // 0x0078(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<struct FPalFoliageInstanceId, class UPalFoliageInstance*> InstanceMap;                                       // 0x0080(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_279C[0x50];                                    // 0x00D0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPalCellCoord                          CellCoord;                                         // 0x0120(0x0018)(Edit, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPalFoliagePresetType                         FoliagePresetType;                                 // 0x0138(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_279D[0x7];                                     // 0x0139(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InstanceDamageDelegate__DelegateSignature(class UPalFoliageInstance* Instance, const int32 DamageValue);
	void InstanceDelegate__DelegateSignature(class UPalFoliageInstance* Instance);
	void OnDestroyInstance(class UPalFoliageInstance* Instance);
	void RespawnInstance(class UPalFoliageInstance* Instance);
	void ReturnSelfDelegate__DelegateSignature(class UPalMapObjectFoliageModel* Self);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectFoliageModel">();
	}
	static class UPalMapObjectFoliageModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectFoliageModel>();
	}
};
static_assert(alignof(UPalMapObjectFoliageModel) == 0x000008, "Wrong alignment on UPalMapObjectFoliageModel");
static_assert(sizeof(UPalMapObjectFoliageModel) == 0x000140, "Wrong size on UPalMapObjectFoliageModel");
static_assert(offsetof(UPalMapObjectFoliageModel, OnRespawn) == 0x000028, "Member 'UPalMapObjectFoliageModel::OnRespawn' has a wrong offset!");
static_assert(offsetof(UPalMapObjectFoliageModel, OnDamage) == 0x000038, "Member 'UPalMapObjectFoliageModel::OnDamage' has a wrong offset!");
static_assert(offsetof(UPalMapObjectFoliageModel, OnDestroy) == 0x000048, "Member 'UPalMapObjectFoliageModel::OnDestroy' has a wrong offset!");
static_assert(offsetof(UPalMapObjectFoliageModel, OnUpdatedRequiredTickInServer) == 0x000058, "Member 'UPalMapObjectFoliageModel::OnUpdatedRequiredTickInServer' has a wrong offset!");
static_assert(offsetof(UPalMapObjectFoliageModel, OnDisposeModelDelegate) == 0x000068, "Member 'UPalMapObjectFoliageModel::OnDisposeModelDelegate' has a wrong offset!");
static_assert(offsetof(UPalMapObjectFoliageModel, ModelId) == 0x000078, "Member 'UPalMapObjectFoliageModel::ModelId' has a wrong offset!");
static_assert(offsetof(UPalMapObjectFoliageModel, InstanceMap) == 0x000080, "Member 'UPalMapObjectFoliageModel::InstanceMap' has a wrong offset!");
static_assert(offsetof(UPalMapObjectFoliageModel, CellCoord) == 0x000120, "Member 'UPalMapObjectFoliageModel::CellCoord' has a wrong offset!");
static_assert(offsetof(UPalMapObjectFoliageModel, FoliagePresetType) == 0x000138, "Member 'UPalMapObjectFoliageModel::FoliagePresetType' has a wrong offset!");

// Class Pal.PalAIDamageReactionComponent
// 0x0000 (0x00A0 - 0x00A0)
class UPalAIDamageReactionComponent : public UActorComponent
{
public:
	void FunctionTest();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIDamageReactionComponent">();
	}
	static class UPalAIDamageReactionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIDamageReactionComponent>();
	}
};
static_assert(alignof(UPalAIDamageReactionComponent) == 0x000008, "Wrong alignment on UPalAIDamageReactionComponent");
static_assert(sizeof(UPalAIDamageReactionComponent) == 0x0000A0, "Wrong size on UPalAIDamageReactionComponent");

// Class Pal.PalTriggerAreaBase
// 0x0030 (0x02C0 - 0x0290)
class APalTriggerAreaBase final : public AActor
{
public:
	FMulticastInlineDelegateProperty_             OnTriggerHitBeginDelegate;                         // 0x0290(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerHitEndDelegate;                           // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	struct FGuid                                  InstanceId;                                        // 0x02B0(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	const struct FGuid GetInstanceId();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalTriggerAreaBase">();
	}
	static class APalTriggerAreaBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalTriggerAreaBase>();
	}
};
static_assert(alignof(APalTriggerAreaBase) == 0x000008, "Wrong alignment on APalTriggerAreaBase");
static_assert(sizeof(APalTriggerAreaBase) == 0x0002C0, "Wrong size on APalTriggerAreaBase");
static_assert(offsetof(APalTriggerAreaBase, OnTriggerHitBeginDelegate) == 0x000290, "Member 'APalTriggerAreaBase::OnTriggerHitBeginDelegate' has a wrong offset!");
static_assert(offsetof(APalTriggerAreaBase, OnTriggerHitEndDelegate) == 0x0002A0, "Member 'APalTriggerAreaBase::OnTriggerHitEndDelegate' has a wrong offset!");
static_assert(offsetof(APalTriggerAreaBase, InstanceId) == 0x0002B0, "Member 'APalTriggerAreaBase::InstanceId' has a wrong offset!");

// Class Pal.PalActionBase
// 0x0118 (0x0140 - 0x0028)
#pragma pack(push, 0x1)
class alignas(0x10) UPalActionBase : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnActionEndDelegate;                               // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsEndAction;                                      // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanDeleteInstance;                                // 0x0039(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanInterruptWaza;                                 // 0x003A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsChangeWorkAnimPlayRate;                         // 0x003B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsChangeWalkableFloorAngle;                       // 0x003C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_279F[0x3];                                     // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ActionWalkableFloorAngle;                          // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDisableNavWalk;                                 // 0x0044(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsReflectForClient;                               // 0x0045(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27A0[0xA];                                     // 0x0046(0x000A)(Fixing Size After Last Property [ Dumper-7 ])
	struct FActionDynamicParameter                DynamicParameter;                                  // 0x0050(0x00E0)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_27A1[0x8];                                     // 0x0130(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActionEndDelegate__DelegateSignature();
	void AnimEventAttack();
	void AnimEventOther();
	void AnimEventSpawn();
	bool CanDeleteInstance();
	bool CanGainSP();
	bool CanNextActionCancel();
	bool CanStepCancel();
	bool IsEndAction();
	void OnBeginAction();
	void OnBreakAction();
	void OnChangeCurrentWorkSuitability();
	void OnEndAction();
	void OnEndPassiveSkill(EPalPassiveSkillEffectType EffectType);
	void OnUpdatePassiveSkill(EPalPassiveSkillEffectType EffectType, float Value);
	void SendNotify(class FName NotifyName);
	void SetAnimRateScale(class FName FlagName, float AnimRateScale);
	void TickAction(float DeltaTime);

	class APalCharacter* GetActionCharacter() const;
	class UPalIndividualCharacterParameter* GetActionIndividualCharacterParameter() const;
	class AActor* GetActionTarget() const;
	struct FVector GetActionVelocity() const;
	const struct FPalNetArchive GetBlackboard() const;
	int32 GetGeneralPurposeIndex() const;
	struct FRandomStream GetRandomStream() const;
	class FString GetSimpleName() const;
	struct FVector GetTargetLocation() const;
	bool IsInLocalControlled() const;
	bool IsInServer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalActionBase">();
	}
	static class UPalActionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalActionBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(UPalActionBase) == 0x000010, "Wrong alignment on UPalActionBase");
static_assert(sizeof(UPalActionBase) == 0x000140, "Wrong size on UPalActionBase");
static_assert(offsetof(UPalActionBase, OnActionEndDelegate) == 0x000028, "Member 'UPalActionBase::OnActionEndDelegate' has a wrong offset!");
static_assert(offsetof(UPalActionBase, bIsEndAction) == 0x000038, "Member 'UPalActionBase::bIsEndAction' has a wrong offset!");
static_assert(offsetof(UPalActionBase, bCanDeleteInstance) == 0x000039, "Member 'UPalActionBase::bCanDeleteInstance' has a wrong offset!");
static_assert(offsetof(UPalActionBase, bCanInterruptWaza) == 0x00003A, "Member 'UPalActionBase::bCanInterruptWaza' has a wrong offset!");
static_assert(offsetof(UPalActionBase, bIsChangeWorkAnimPlayRate) == 0x00003B, "Member 'UPalActionBase::bIsChangeWorkAnimPlayRate' has a wrong offset!");
static_assert(offsetof(UPalActionBase, bIsChangeWalkableFloorAngle) == 0x00003C, "Member 'UPalActionBase::bIsChangeWalkableFloorAngle' has a wrong offset!");
static_assert(offsetof(UPalActionBase, ActionWalkableFloorAngle) == 0x000040, "Member 'UPalActionBase::ActionWalkableFloorAngle' has a wrong offset!");
static_assert(offsetof(UPalActionBase, bIsDisableNavWalk) == 0x000044, "Member 'UPalActionBase::bIsDisableNavWalk' has a wrong offset!");
static_assert(offsetof(UPalActionBase, bIsReflectForClient) == 0x000045, "Member 'UPalActionBase::bIsReflectForClient' has a wrong offset!");
static_assert(offsetof(UPalActionBase, DynamicParameter) == 0x000050, "Member 'UPalActionBase::DynamicParameter' has a wrong offset!");

// Class Pal.PalActionComponent
// 0x00B0 (0x0150 - 0x00A0)
class UPalActionComponent final : public UActorComponent
{
public:
	TMap<EPalActionType, TSubclassOf<class UPalActionBase>> ActionMap;                                         // 0x00A0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAllActionFinishDelegate;                         // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnActionBeginDelegate;                             // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnActionNotifyDelegate;                            // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UPalActionBase*                         CurrentAction;                                     // 0x0120(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UPalActionBase*>                 ActionQueue;                                       // 0x0128(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	TArray<class UPalActionBase*>                 TerminateWaitActionList;                           // 0x0138(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_27A3[0x8];                                     // 0x0148(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ActionIsEmpty();
	void ActionNotify__DelegateSignature(const class UPalActionBase* Action, class FName NotifyName);
	void ActionStartDelegate__DelegateSignature(const class UPalActionBase* Action);
	void AllActionFinishDelegate__DelegateSignature(const class UPalActionComponent* ActionComponent);
	void BeginPlay();
	void CancelAction(class UPalActionBase* Action);
	void CancelAction_Internal(const struct FGuid& ActionID);
	void CancelAction_ToALL(int32 ID, const struct FGuid& ActionID);
	void CancelAction_ToServer(int32 ID, const struct FGuid& ActionID);
	void CancelActionByType(EPalActionType Type);
	void CancelAllAction();
	void CancelAllAction_Internal();
	void CancelAllAction_ToALL(int32 ID);
	void CancelAllAction_ToServer(int32 ID);
	void OnCompleteCharacter(class APalCharacter* InCharacter);
	void OnOwnerEndPlay(class AActor* Actor, EEndPlayReason ReasonType);
	class UPalActionBase* PlayAction(class AActor* ActionTarget, TSubclassOf<class UPalActionBase> ActionClass);
	class UPalActionBase* PlayAction_Internal(const struct FActionDynamicParameter& Param, TSubclassOf<class UPalActionBase> ActionClass);
	class UPalActionBase* PlayAction_LocalOnly(const struct FActionDynamicParameter& Param, TSubclassOf<class UPalActionBase> ActionClass);
	void PlayAction_ToALL(const struct FActionDynamicParameter& Param, TSubclassOf<class UPalActionBase> ActionClass, int32 IssuerID);
	void PlayAction_ToServer(const struct FActionDynamicParameter& Param, TSubclassOf<class UPalActionBase> ActionClass, int32 IssuerID);
	class UPalActionBase* PlayActionByType(class AActor* ActionTarget, EPalActionType Type);
	class UPalActionBase* PlayActionByTypeParameter(const struct FActionDynamicParameter& Param, EPalActionType Type);
	class UPalActionBase* PlayActionLocation(const struct FVector& Location, TSubclassOf<class UPalActionBase> ActionClass);
	class UPalActionBase* PlayActionLocationByType(const struct FVector& Location, EPalActionType Type);
	class UPalActionBase* PlayActionParameter(const struct FActionDynamicParameter& Param, TSubclassOf<class UPalActionBase> ActionClass);

	class UPalActionBase* GetCurrentAction() const;
	EPalActionType GetCurrentActionType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalActionComponent">();
	}
	static class UPalActionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalActionComponent>();
	}
};
static_assert(alignof(UPalActionComponent) == 0x000008, "Wrong alignment on UPalActionComponent");
static_assert(sizeof(UPalActionComponent) == 0x000150, "Wrong size on UPalActionComponent");
static_assert(offsetof(UPalActionComponent, ActionMap) == 0x0000A0, "Member 'UPalActionComponent::ActionMap' has a wrong offset!");
static_assert(offsetof(UPalActionComponent, OnAllActionFinishDelegate) == 0x0000F0, "Member 'UPalActionComponent::OnAllActionFinishDelegate' has a wrong offset!");
static_assert(offsetof(UPalActionComponent, OnActionBeginDelegate) == 0x000100, "Member 'UPalActionComponent::OnActionBeginDelegate' has a wrong offset!");
static_assert(offsetof(UPalActionComponent, OnActionNotifyDelegate) == 0x000110, "Member 'UPalActionComponent::OnActionNotifyDelegate' has a wrong offset!");
static_assert(offsetof(UPalActionComponent, CurrentAction) == 0x000120, "Member 'UPalActionComponent::CurrentAction' has a wrong offset!");
static_assert(offsetof(UPalActionComponent, ActionQueue) == 0x000128, "Member 'UPalActionComponent::ActionQueue' has a wrong offset!");
static_assert(offsetof(UPalActionComponent, TerminateWaitActionList) == 0x000138, "Member 'UPalActionComponent::TerminateWaitActionList' has a wrong offset!");

// Class Pal.PalStateMachineStateBase
// 0x0008 (0x0030 - 0x0028)
class UPalStateMachineStateBase : public UObject
{
public:
	uint8                                         Pad_27AA[0x8];                                     // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalStateMachineStateBase">();
	}
	static class UPalStateMachineStateBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalStateMachineStateBase>();
	}
};
static_assert(alignof(UPalStateMachineStateBase) == 0x000008, "Wrong alignment on UPalStateMachineStateBase");
static_assert(sizeof(UPalStateMachineStateBase) == 0x000030, "Wrong size on UPalStateMachineStateBase");

// Class Pal.PalMapObjectFarmBlockV2ModelStateBehaviourBase
// 0x0000 (0x0030 - 0x0030)
class UPalMapObjectFarmBlockV2ModelStateBehaviourBase : public UPalStateMachineStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectFarmBlockV2ModelStateBehaviourBase">();
	}
	static class UPalMapObjectFarmBlockV2ModelStateBehaviourBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectFarmBlockV2ModelStateBehaviourBase>();
	}
};
static_assert(alignof(UPalMapObjectFarmBlockV2ModelStateBehaviourBase) == 0x000008, "Wrong alignment on UPalMapObjectFarmBlockV2ModelStateBehaviourBase");
static_assert(sizeof(UPalMapObjectFarmBlockV2ModelStateBehaviourBase) == 0x000030, "Wrong size on UPalMapObjectFarmBlockV2ModelStateBehaviourBase");

// Class Pal.PalMapObjectFarmBlockV2ModelStateBehaviourGrowup
// 0x0018 (0x0048 - 0x0030)
class UPalMapObjectFarmBlockV2ModelStateBehaviourGrowup final : public UPalMapObjectFarmBlockV2ModelStateBehaviourBase
{
public:
	uint8                                         Pad_27AB[0x18];                                    // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectFarmBlockV2ModelStateBehaviourGrowup">();
	}
	static class UPalMapObjectFarmBlockV2ModelStateBehaviourGrowup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectFarmBlockV2ModelStateBehaviourGrowup>();
	}
};
static_assert(alignof(UPalMapObjectFarmBlockV2ModelStateBehaviourGrowup) == 0x000008, "Wrong alignment on UPalMapObjectFarmBlockV2ModelStateBehaviourGrowup");
static_assert(sizeof(UPalMapObjectFarmBlockV2ModelStateBehaviourGrowup) == 0x000048, "Wrong size on UPalMapObjectFarmBlockV2ModelStateBehaviourGrowup");

// Class Pal.PalOptimizeParameterSetting
// 0x0490 (0x04B8 - 0x0028)
class UPalOptimizeParameterSetting : public UObject
{
public:
	struct FPalOptimizeParameter                  Parameter;                                         // 0x0028(0x0490)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalOptimizeParameterSetting">();
	}
	static class UPalOptimizeParameterSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalOptimizeParameterSetting>();
	}
};
static_assert(alignof(UPalOptimizeParameterSetting) == 0x000008, "Wrong alignment on UPalOptimizeParameterSetting");
static_assert(sizeof(UPalOptimizeParameterSetting) == 0x0004B8, "Wrong size on UPalOptimizeParameterSetting");
static_assert(offsetof(UPalOptimizeParameterSetting, Parameter) == 0x000028, "Member 'UPalOptimizeParameterSetting::Parameter' has a wrong offset!");

// Class Pal.PalActionDummyTargetActor
// 0x0000 (0x0290 - 0x0290)
class APalActionDummyTargetActor final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalActionDummyTargetActor">();
	}
	static class APalActionDummyTargetActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalActionDummyTargetActor>();
	}
};
static_assert(alignof(APalActionDummyTargetActor) == 0x000008, "Wrong alignment on APalActionDummyTargetActor");
static_assert(sizeof(APalActionDummyTargetActor) == 0x000290, "Wrong size on APalActionDummyTargetActor");

// Class Pal.PalMapObjectModelInitializeExtraParameterBase
// 0x0000 (0x0028 - 0x0028)
class UPalMapObjectModelInitializeExtraParameterBase : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectModelInitializeExtraParameterBase">();
	}
	static class UPalMapObjectModelInitializeExtraParameterBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectModelInitializeExtraParameterBase>();
	}
};
static_assert(alignof(UPalMapObjectModelInitializeExtraParameterBase) == 0x000008, "Wrong alignment on UPalMapObjectModelInitializeExtraParameterBase");
static_assert(sizeof(UPalMapObjectModelInitializeExtraParameterBase) == 0x000028, "Wrong size on UPalMapObjectModelInitializeExtraParameterBase");

// Class Pal.PalMapObjectModelInitializeExtraParameterItemContainerAttribute
// 0x0010 (0x0038 - 0x0028)
class UPalMapObjectModelInitializeExtraParameterItemContainerAttribute final : public UPalMapObjectModelInitializeExtraParameterBase
{
public:
	TArray<EPalMapObjectItemContainerSlotAttribute> AllSlotAttribute;                                  // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectModelInitializeExtraParameterItemContainerAttribute">();
	}
	static class UPalMapObjectModelInitializeExtraParameterItemContainerAttribute* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectModelInitializeExtraParameterItemContainerAttribute>();
	}
};
static_assert(alignof(UPalMapObjectModelInitializeExtraParameterItemContainerAttribute) == 0x000008, "Wrong alignment on UPalMapObjectModelInitializeExtraParameterItemContainerAttribute");
static_assert(sizeof(UPalMapObjectModelInitializeExtraParameterItemContainerAttribute) == 0x000038, "Wrong size on UPalMapObjectModelInitializeExtraParameterItemContainerAttribute");
static_assert(offsetof(UPalMapObjectModelInitializeExtraParameterItemContainerAttribute, AllSlotAttribute) == 0x000028, "Member 'UPalMapObjectModelInitializeExtraParameterItemContainerAttribute::AllSlotAttribute' has a wrong offset!");

// Class Pal.PalWorldSubsystem
// 0x0040 (0x0070 - 0x0030)
class UPalWorldSubsystem : public UWorldSubsystem
{
public:
	uint8                                         Pad_27AC[0x8];                                     // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShouldCreate;                                     // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27AD[0x7];                                     // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UWorldSubsystem>>    PrerequisiteWorldSubsystemList;                    // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_27AE[0x20];                                    // 0x0050(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorldSubsystem">();
	}
	static class UPalWorldSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWorldSubsystem>();
	}
};
static_assert(alignof(UPalWorldSubsystem) == 0x000008, "Wrong alignment on UPalWorldSubsystem");
static_assert(sizeof(UPalWorldSubsystem) == 0x000070, "Wrong size on UPalWorldSubsystem");
static_assert(offsetof(UPalWorldSubsystem, bShouldCreate) == 0x000038, "Member 'UPalWorldSubsystem::bShouldCreate' has a wrong offset!");
static_assert(offsetof(UPalWorldSubsystem, PrerequisiteWorldSubsystemList) == 0x000040, "Member 'UPalWorldSubsystem::PrerequisiteWorldSubsystemList' has a wrong offset!");

// Class Pal.PalActivatableWidget
// 0x0008 (0x03D0 - 0x03C8)
class UPalActivatableWidget : public UCommonActivatableWidget
{
public:
	EPalWidgetInputMode                           InputConfig;                                       // 0x03C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMouseCaptureMode                             GameMouseCaptureMode;                              // 0x03C9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27AF[0x6];                                     // 0x03CA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalActivatableWidget">();
	}
	static class UPalActivatableWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalActivatableWidget>();
	}
};
static_assert(alignof(UPalActivatableWidget) == 0x000008, "Wrong alignment on UPalActivatableWidget");
static_assert(sizeof(UPalActivatableWidget) == 0x0003D0, "Wrong size on UPalActivatableWidget");
static_assert(offsetof(UPalActivatableWidget, InputConfig) == 0x0003C8, "Member 'UPalActivatableWidget::InputConfig' has a wrong offset!");
static_assert(offsetof(UPalActivatableWidget, GameMouseCaptureMode) == 0x0003C9, "Member 'UPalActivatableWidget::GameMouseCaptureMode' has a wrong offset!");

// Class Pal.PalUserWidget
// 0x0038 (0x0408 - 0x03D0)
class UPalUserWidget : public UPalActivatableWidget
{
public:
	bool                                          bSyncPlayerInventory;                              // 0x03D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27B0[0x17];                                    // 0x03D1(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalHUDDispatchParameterBase*           Param;                                             // 0x03E8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27B1[0x8];                                     // 0x03F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPalUIActionBindData>           BindedActionHandles;                               // 0x03F8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	class UUserWidget* FindParentWidget(TSubclassOf<class UUserWidget> Param_Class);
	bool IsSameWidget(const struct FGuid& CheckID);
	void OnClosed();
	void OnSetup();
	void OnSetup_AfterCreatedPlayer();
	void PlayAkSound(class UAkAudioEvent* AkEvent);
	const struct FGuid Push(TSubclassOf<class UPalUserWidgetOverlayUI> WidgetClass, class UPalHUDDispatchParameterBase* Parameter);
	struct FPalUIActionBindData RegisterActionBinding(const class FName& ActionName, bool IsDisplayActionBar, EInputEvent InputType, TDelegate<void()> Callback);
	struct FPalUIActionBindData RegisterActionBinding_NotConcume(const class FName& ActionName, bool IsDisplayActionBar, EInputEvent InputType, TDelegate<void()> Callback);
	void UnregisterActionBinding(struct FPalUIActionBindData& BindingData);
	void VisibilityOverride(ESlateVisibility ChangedVisibility);

	class UPalHUDDispatchParameterBase* GetParam() const;
	void RequestInventorySync(bool bOpen) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUserWidget">();
	}
	static class UPalUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUserWidget>();
	}
};
static_assert(alignof(UPalUserWidget) == 0x000008, "Wrong alignment on UPalUserWidget");
static_assert(sizeof(UPalUserWidget) == 0x000408, "Wrong size on UPalUserWidget");
static_assert(offsetof(UPalUserWidget, bSyncPlayerInventory) == 0x0003D0, "Member 'UPalUserWidget::bSyncPlayerInventory' has a wrong offset!");
static_assert(offsetof(UPalUserWidget, Param) == 0x0003E8, "Member 'UPalUserWidget::Param' has a wrong offset!");
static_assert(offsetof(UPalUserWidget, BindedActionHandles) == 0x0003F8, "Member 'UPalUserWidget::BindedActionHandles' has a wrong offset!");

// Class Pal.PalUIInventoryEquipment
// 0x0050 (0x0458 - 0x0408)
class UPalUIInventoryEquipment final : public UPalUserWidget
{
public:
	uint8                                         Pad_27B5[0x50];                                    // 0x0408(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeLocalPlayerNickname(const class FString& NewName);
	void QuickSortInventory();
	void RequestUpdatePlayerStatusPoint(const TMap<class FName, int32>& AddPointMap);
	void SwapEquipmentByLiftItem(EPalPlayerEquipItemSlotType SlotType);
	void SwapItemSlot(class UPalItemSlot* SlotA, class UPalItemSlot* SlotB);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIInventoryEquipment">();
	}
	static class UPalUIInventoryEquipment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIInventoryEquipment>();
	}
};
static_assert(alignof(UPalUIInventoryEquipment) == 0x000008, "Wrong alignment on UPalUIInventoryEquipment");
static_assert(sizeof(UPalUIInventoryEquipment) == 0x000458, "Wrong size on UPalUIInventoryEquipment");

// Class Pal.PalBaseCampFunctionModuleBase
// 0x0000 (0x0028 - 0x0028)
class UPalBaseCampFunctionModuleBase : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBaseCampFunctionModuleBase">();
	}
	static class UPalBaseCampFunctionModuleBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBaseCampFunctionModuleBase>();
	}
};
static_assert(alignof(UPalBaseCampFunctionModuleBase) == 0x000008, "Wrong alignment on UPalBaseCampFunctionModuleBase");
static_assert(sizeof(UPalBaseCampFunctionModuleBase) == 0x000028, "Wrong size on UPalBaseCampFunctionModuleBase");

// Class Pal.PalBaseCampModuleItemStorage
// 0x0070 (0x0098 - 0x0028)
class UPalBaseCampModuleItemStorage final : public UPalBaseCampFunctionModuleBase
{
public:
	FMulticastInlineDelegateProperty_             OnUpdateAnyItemContainerDelegate;                  // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FPalBaseCampItemContainerInfo>  ContainerInfos;                                    // 0x0038(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	TMap<struct FGuid, struct FPalBaseCampItemExistsInfo> RepairKitItemExistsInfos;                          // 0x0048(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)

public:
	void MulticastReturnSelfAndUpdatedContainerDelegate__DelegateSignature(class UPalBaseCampModuleItemStorage* Self, class UPalItemContainer* UpdatedContainer);
	void OnAvailableConcreteModel(class UPalMapObjectConcreteModelBase* ConcreteModel);
	void OnNotAvailableConcreteModel(class UPalMapObjectConcreteModelBase* ConcreteModel);
	void OnUpdateItemContainer(class UPalMapObjectItemContainerModule* ItemContainerModule);

	void GetContainerIds(TArray<struct FPalContainerId>* OutContainerIds) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBaseCampModuleItemStorage">();
	}
	static class UPalBaseCampModuleItemStorage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBaseCampModuleItemStorage>();
	}
};
static_assert(alignof(UPalBaseCampModuleItemStorage) == 0x000008, "Wrong alignment on UPalBaseCampModuleItemStorage");
static_assert(sizeof(UPalBaseCampModuleItemStorage) == 0x000098, "Wrong size on UPalBaseCampModuleItemStorage");
static_assert(offsetof(UPalBaseCampModuleItemStorage, OnUpdateAnyItemContainerDelegate) == 0x000028, "Member 'UPalBaseCampModuleItemStorage::OnUpdateAnyItemContainerDelegate' has a wrong offset!");
static_assert(offsetof(UPalBaseCampModuleItemStorage, ContainerInfos) == 0x000038, "Member 'UPalBaseCampModuleItemStorage::ContainerInfos' has a wrong offset!");
static_assert(offsetof(UPalBaseCampModuleItemStorage, RepairKitItemExistsInfos) == 0x000048, "Member 'UPalBaseCampModuleItemStorage::RepairKitItemExistsInfos' has a wrong offset!");

// Class Pal.PalActionDummyTargetManager
// 0x0010 (0x0080 - 0x0070)
class UPalActionDummyTargetManager final : public UPalWorldSubsystem
{
public:
	TArray<class APalActionDummyTargetActor*>     ActionDummyTargetCache;                            // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalActionDummyTargetManager">();
	}
	static class UPalActionDummyTargetManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalActionDummyTargetManager>();
	}
};
static_assert(alignof(UPalActionDummyTargetManager) == 0x000008, "Wrong alignment on UPalActionDummyTargetManager");
static_assert(sizeof(UPalActionDummyTargetManager) == 0x000080, "Wrong size on UPalActionDummyTargetManager");
static_assert(offsetof(UPalActionDummyTargetManager, ActionDummyTargetCache) == 0x000070, "Member 'UPalActionDummyTargetManager::ActionDummyTargetCache' has a wrong offset!");

// Class Pal.PalHUDDispatchParameterBase
// 0x0010 (0x0038 - 0x0028)
class UPalHUDDispatchParameterBase : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnClose;                                           // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalHUDDispatchParameterBase">();
	}
	static class UPalHUDDispatchParameterBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalHUDDispatchParameterBase>();
	}
};
static_assert(alignof(UPalHUDDispatchParameterBase) == 0x000008, "Wrong alignment on UPalHUDDispatchParameterBase");
static_assert(sizeof(UPalHUDDispatchParameterBase) == 0x000038, "Wrong size on UPalHUDDispatchParameterBase");
static_assert(offsetof(UPalHUDDispatchParameterBase, OnClose) == 0x000028, "Member 'UPalHUDDispatchParameterBase::OnClose' has a wrong offset!");

// Class Pal.PalHUDDispatchParameter_MapObject
// 0x0008 (0x0040 - 0x0038)
class UPalHUDDispatchParameter_MapObject : public UPalHUDDispatchParameterBase
{
public:
	class UPalMapObjectConcreteModelBase*         MapObjectConcreteModel;                            // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalHUDDispatchParameter_MapObject">();
	}
	static class UPalHUDDispatchParameter_MapObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalHUDDispatchParameter_MapObject>();
	}
};
static_assert(alignof(UPalHUDDispatchParameter_MapObject) == 0x000008, "Wrong alignment on UPalHUDDispatchParameter_MapObject");
static_assert(sizeof(UPalHUDDispatchParameter_MapObject) == 0x000040, "Wrong size on UPalHUDDispatchParameter_MapObject");
static_assert(offsetof(UPalHUDDispatchParameter_MapObject, MapObjectConcreteModel) == 0x000038, "Member 'UPalHUDDispatchParameter_MapObject::MapObjectConcreteModel' has a wrong offset!");

// Class Pal.PalHUDDispatchParameter_Authentication
// 0x0008 (0x0048 - 0x0040)
class UPalHUDDispatchParameter_Authentication final : public UPalHUDDispatchParameter_MapObject
{
public:
	bool                                          IsAuthentication;                                  // 0x0040(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27B6[0x7];                                     // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalHUDDispatchParameter_Authentication">();
	}
	static class UPalHUDDispatchParameter_Authentication* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalHUDDispatchParameter_Authentication>();
	}
};
static_assert(alignof(UPalHUDDispatchParameter_Authentication) == 0x000008, "Wrong alignment on UPalHUDDispatchParameter_Authentication");
static_assert(sizeof(UPalHUDDispatchParameter_Authentication) == 0x000048, "Wrong size on UPalHUDDispatchParameter_Authentication");
static_assert(offsetof(UPalHUDDispatchParameter_Authentication, IsAuthentication) == 0x000040, "Member 'UPalHUDDispatchParameter_Authentication::IsAuthentication' has a wrong offset!");

// Class Pal.PalActionOneShotAnimation
// 0x0010 (0x0150 - 0x0140)
class UPalActionOneShotAnimation final : public UPalActionBase
{
public:
	uint8                                         Pad_27B7[0x18];                                    // 0x0138(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEndMontage(class UAnimMontage* Montage, bool bInterrupted);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalActionOneShotAnimation">();
	}
	static class UPalActionOneShotAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalActionOneShotAnimation>();
	}
};
static_assert(alignof(UPalActionOneShotAnimation) == 0x000010, "Wrong alignment on UPalActionOneShotAnimation");
static_assert(sizeof(UPalActionOneShotAnimation) == 0x000150, "Wrong size on UPalActionOneShotAnimation");

// Class Pal.PalActionSpawnItem
// 0x0030 (0x0170 - 0x0140)
class UPalActionSpawnItem final : public UPalActionBase
{
public:
	class FName                                   SpawnSocketName;                                   // 0x0138(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                SpawnLocationOffset;                               // 0x0140(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               SpawnItemRotator;                                  // 0x0158(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static void WriteBlackboard(struct FPalNetArchive& BlackboardRef, const struct FPalStaticItemIdAndNum& ItemInfo);

	void SpawnItemInServer();

	void ReadBlackboard(struct FPalStaticItemIdAndNum* ItemInfo) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalActionSpawnItem">();
	}
	static class UPalActionSpawnItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalActionSpawnItem>();
	}
};
static_assert(alignof(UPalActionSpawnItem) == 0x000010, "Wrong alignment on UPalActionSpawnItem");
static_assert(sizeof(UPalActionSpawnItem) == 0x000170, "Wrong size on UPalActionSpawnItem");
static_assert(offsetof(UPalActionSpawnItem, SpawnSocketName) == 0x000138, "Member 'UPalActionSpawnItem::SpawnSocketName' has a wrong offset!");
static_assert(offsetof(UPalActionSpawnItem, SpawnLocationOffset) == 0x000140, "Member 'UPalActionSpawnItem::SpawnLocationOffset' has a wrong offset!");
static_assert(offsetof(UPalActionSpawnItem, SpawnItemRotator) == 0x000158, "Member 'UPalActionSpawnItem::SpawnItemRotator' has a wrong offset!");

// Class Pal.PalActionTransportItem
// 0x0020 (0x0160 - 0x0140)
class UPalActionTransportItem : public UPalActionBase
{
public:
	class FName                                   ItemAttachSocketName;                              // 0x0138(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 ItemActor;                                         // 0x0140(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27BA[0x18];                                    // 0x0148(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void WriteBlackboard(struct FPalNetArchive& BlackboardRef, const class FName StaticItemId);

	void StartSetupItemActor(const class FName StaticItemId);

	void ReadBlackboard(class FName* StaticItemId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalActionTransportItem">();
	}
	static class UPalActionTransportItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalActionTransportItem>();
	}
};
static_assert(alignof(UPalActionTransportItem) == 0x000010, "Wrong alignment on UPalActionTransportItem");
static_assert(sizeof(UPalActionTransportItem) == 0x000160, "Wrong size on UPalActionTransportItem");
static_assert(offsetof(UPalActionTransportItem, ItemAttachSocketName) == 0x000138, "Member 'UPalActionTransportItem::ItemAttachSocketName' has a wrong offset!");
static_assert(offsetof(UPalActionTransportItem, ItemActor) == 0x000140, "Member 'UPalActionTransportItem::ItemActor' has a wrong offset!");

// Class Pal.PalDungeonEntrance
// 0x0010 (0x02A0 - 0x0290)
class APalDungeonEntrance : public AActor
{
public:
	uint8                                         Pad_27BB[0x8];                                     // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalStageModelDungeon*                  StageModel;                                        // 0x0298(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnResponseDialogEnterDungeon(const bool bResponse);
	void OnTriggerInteract(class AActor* Other, EPalInteractiveObjectIndicatorType IndicatorType);

	struct FTransform GetDeadItemDropPoint() const;
	const struct FGuid GetDungeonInstanceId() const;
	const struct FPalStageInstanceId GetStageInstanceId() const;
	class UPalStageModelDungeon* GetStageModel() const;
	struct FTransform GetWarpPoint() const;
	bool TryGetDungeonInstanceModel(class UPalDungeonInstanceModel** OutModel) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalDungeonEntrance">();
	}
	static class APalDungeonEntrance* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalDungeonEntrance>();
	}
};
static_assert(alignof(APalDungeonEntrance) == 0x000008, "Wrong alignment on APalDungeonEntrance");
static_assert(sizeof(APalDungeonEntrance) == 0x0002A0, "Wrong size on APalDungeonEntrance");
static_assert(offsetof(APalDungeonEntrance, StageModel) == 0x000298, "Member 'APalDungeonEntrance::StageModel' has a wrong offset!");

// Class Pal.PalPassiveSkillManager
// 0x01E8 (0x0210 - 0x0028)
class UPalPassiveSkillManager : public UObject
{
public:
	class UDataTable*                             PassiveSkillDataTable;                             // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FPalPassiveSkillDatabaseRow> PalAssignableSkillMap;                             // 0x0030(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class FName, struct FPalPassiveSkillDatabaseRow> RarePalAssignableSkillMap;                         // 0x0080(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class FName, struct FPalPassiveSkillDatabaseRow> RangedWeaponAssignableSkillMap;                    // 0x00D0(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class FName, struct FPalPassiveSkillDatabaseRow> MeleeWeaponAssignableSkillMap;                     // 0x0120(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class FName, struct FPalPassiveSkillDatabaseRow> ArmorAssignableSkillMap;                           // 0x0170(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class FName, struct FPalPassiveSkillDatabaseRow> AccessoryAssignableSkillMap;                       // 0x01C0(0x0050)(NativeAccessSpecifierPrivate)

public:
	static float GetParameterWithSkillEffect(float OriginalValue, EPalPassiveSkillEffectType EffectType, const TArray<struct FPalPassiveSkillEffect>& SkillEffectList);

	class FName GetNameTextId(class FName SkillName);
	TArray<struct FPalPassiveSkillEffect> GetPassiveSkillEffect(const class FName& SkillName, bool bTargetToSelf);
	TArray<class FName> GetPassiveSkillNamesRowName(const TArray<class FName>& PassiveList);
	bool GetSkillData(const class FName& SkillName, struct FPalPassiveSkillDatabaseRow* OutSkillData);
	TArray<EPalPassiveSkillEffectType> GetSkillEffectTypes(class FName SkillName);
	void OnCreatedDynamicItemDataInServer(class UPalDynamicItemDataBase* CreatedItemData, const struct FPalItemCreateParameter& CreateParameter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalPassiveSkillManager">();
	}
	static class UPalPassiveSkillManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalPassiveSkillManager>();
	}
};
static_assert(alignof(UPalPassiveSkillManager) == 0x000008, "Wrong alignment on UPalPassiveSkillManager");
static_assert(sizeof(UPalPassiveSkillManager) == 0x000210, "Wrong size on UPalPassiveSkillManager");
static_assert(offsetof(UPalPassiveSkillManager, PassiveSkillDataTable) == 0x000028, "Member 'UPalPassiveSkillManager::PassiveSkillDataTable' has a wrong offset!");
static_assert(offsetof(UPalPassiveSkillManager, PalAssignableSkillMap) == 0x000030, "Member 'UPalPassiveSkillManager::PalAssignableSkillMap' has a wrong offset!");
static_assert(offsetof(UPalPassiveSkillManager, RarePalAssignableSkillMap) == 0x000080, "Member 'UPalPassiveSkillManager::RarePalAssignableSkillMap' has a wrong offset!");
static_assert(offsetof(UPalPassiveSkillManager, RangedWeaponAssignableSkillMap) == 0x0000D0, "Member 'UPalPassiveSkillManager::RangedWeaponAssignableSkillMap' has a wrong offset!");
static_assert(offsetof(UPalPassiveSkillManager, MeleeWeaponAssignableSkillMap) == 0x000120, "Member 'UPalPassiveSkillManager::MeleeWeaponAssignableSkillMap' has a wrong offset!");
static_assert(offsetof(UPalPassiveSkillManager, ArmorAssignableSkillMap) == 0x000170, "Member 'UPalPassiveSkillManager::ArmorAssignableSkillMap' has a wrong offset!");
static_assert(offsetof(UPalPassiveSkillManager, AccessoryAssignableSkillMap) == 0x0001C0, "Member 'UPalPassiveSkillManager::AccessoryAssignableSkillMap' has a wrong offset!");

// Class Pal.PalActionWazaBase
// 0x0010 (0x0150 - 0x0140)
class UPalActionWazaBase : public UPalActionBase
{
public:
	EPalWazaID                                    WazaID;                                            // 0x0138(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27C2[0x7];                                     // 0x0139(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalSoundPlayer*                        SoundPlayer;                                       // 0x0140(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bApplyFullStomachCost;                             // 0x0148(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_27C3[0x7];                                     // 0x0149(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class APalPlayerCharacter* GetRiderPlayer();
	void PlayAkSound(class UAkAudioEvent* AudioEvent);
	void StopAkSound();

	EPalWazaID GetWazaID() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalActionWazaBase">();
	}
	static class UPalActionWazaBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalActionWazaBase>();
	}
};
static_assert(alignof(UPalActionWazaBase) == 0x000010, "Wrong alignment on UPalActionWazaBase");
static_assert(sizeof(UPalActionWazaBase) == 0x000150, "Wrong size on UPalActionWazaBase");
static_assert(offsetof(UPalActionWazaBase, WazaID) == 0x000138, "Member 'UPalActionWazaBase::WazaID' has a wrong offset!");
static_assert(offsetof(UPalActionWazaBase, SoundPlayer) == 0x000140, "Member 'UPalActionWazaBase::SoundPlayer' has a wrong offset!");
static_assert(offsetof(UPalActionWazaBase, bApplyFullStomachCost) == 0x000148, "Member 'UPalActionWazaBase::bApplyFullStomachCost' has a wrong offset!");

// Class Pal.PalAction_BeLiftup
// 0x0000 (0x0140 - 0x0140)
class UPalAction_BeLiftup : public UPalActionBase
{
public:
	void OnAttachedForBP();
	void OnDeadOwner_ServerInternal(const struct FPalDeadInfo& DeadInfo);
	void OnEndInterpTransform();
	void OnStartInterpTransform();
	void OnStartLifting();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAction_BeLiftup">();
	}
	static class UPalAction_BeLiftup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAction_BeLiftup>();
	}
};
static_assert(alignof(UPalAction_BeLiftup) == 0x000010, "Wrong alignment on UPalAction_BeLiftup");
static_assert(sizeof(UPalAction_BeLiftup) == 0x000140, "Wrong size on UPalAction_BeLiftup");

// Class Pal.PalAIControllerWorkerModule
// 0x0000 (0x0028 - 0x0028)
class UPalAIControllerWorkerModule : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIControllerWorkerModule">();
	}
	static class UPalAIControllerWorkerModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIControllerWorkerModule>();
	}
};
static_assert(alignof(UPalAIControllerWorkerModule) == 0x000008, "Wrong alignment on UPalAIControllerWorkerModule");
static_assert(sizeof(UPalAIControllerWorkerModule) == 0x000028, "Wrong size on UPalAIControllerWorkerModule");

// Class Pal.PalAIControllerWorkerModuleBaseCamp
// 0x0000 (0x0028 - 0x0028)
class UPalAIControllerWorkerModuleBaseCamp final : public UPalAIControllerWorkerModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIControllerWorkerModuleBaseCamp">();
	}
	static class UPalAIControllerWorkerModuleBaseCamp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIControllerWorkerModuleBaseCamp>();
	}
};
static_assert(alignof(UPalAIControllerWorkerModuleBaseCamp) == 0x000008, "Wrong alignment on UPalAIControllerWorkerModuleBaseCamp");
static_assert(sizeof(UPalAIControllerWorkerModuleBaseCamp) == 0x000028, "Wrong size on UPalAIControllerWorkerModuleBaseCamp");

// Class Pal.PalAction_BeThrown
// 0x0010 (0x0150 - 0x0140)
class UPalAction_BeThrown : public UPalActionBase
{
public:
	class UAnimMontage*                           PlayingMontage;                                    // 0x0138(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      NiagaraComponent;                                  // 0x0140(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27C4[0x8];                                     // 0x0148(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayThrownFX();
	void PlayThrownMontage();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAction_BeThrown">();
	}
	static class UPalAction_BeThrown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAction_BeThrown>();
	}
};
static_assert(alignof(UPalAction_BeThrown) == 0x000010, "Wrong alignment on UPalAction_BeThrown");
static_assert(sizeof(UPalAction_BeThrown) == 0x000150, "Wrong size on UPalAction_BeThrown");
static_assert(offsetof(UPalAction_BeThrown, PlayingMontage) == 0x000138, "Member 'UPalAction_BeThrown::PlayingMontage' has a wrong offset!");
static_assert(offsetof(UPalAction_BeThrown, NiagaraComponent) == 0x000140, "Member 'UPalAction_BeThrown::NiagaraComponent' has a wrong offset!");

// Class Pal.PalStatusBase
// 0x0020 (0x0048 - 0x0028)
class UPalStatusBase : public UObject
{
public:
	bool                                          bIsEndStatus;                                      // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27C5[0x3];                                     // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStatusDynamicParameter                DynamicParameter;                                  // 0x002C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnTemplate, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	EPalStatusID                                  StatusId;                                          // 0x0038(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27C6[0x3];                                     // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsNerverEnd;                                      // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27C7[0x7];                                     // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBeginSomeStatus();
	void OnBeginStatus();
	void OnBreakStatus();
	void OnEndStatus();
	void SetHalfDurationTimer();
	void TickStatus(float DeltaTime);

	class AActor* GetOwner() const;
	bool IsEndStatus() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalStatusBase">();
	}
	static class UPalStatusBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalStatusBase>();
	}
};
static_assert(alignof(UPalStatusBase) == 0x000008, "Wrong alignment on UPalStatusBase");
static_assert(sizeof(UPalStatusBase) == 0x000048, "Wrong size on UPalStatusBase");
static_assert(offsetof(UPalStatusBase, bIsEndStatus) == 0x000028, "Member 'UPalStatusBase::bIsEndStatus' has a wrong offset!");
static_assert(offsetof(UPalStatusBase, DynamicParameter) == 0x00002C, "Member 'UPalStatusBase::DynamicParameter' has a wrong offset!");
static_assert(offsetof(UPalStatusBase, StatusId) == 0x000038, "Member 'UPalStatusBase::StatusId' has a wrong offset!");
static_assert(offsetof(UPalStatusBase, Duration) == 0x00003C, "Member 'UPalStatusBase::Duration' has a wrong offset!");
static_assert(offsetof(UPalStatusBase, bIsNerverEnd) == 0x000040, "Member 'UPalStatusBase::bIsNerverEnd' has a wrong offset!");

// Class Pal.PalBaseCampManager
// 0x01D0 (0x0240 - 0x0070)
class UPalBaseCampManager : public UPalWorldSubsystem
{
public:
	uint8                                         Pad_27C8[0x30];                                    // 0x0070(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   WorkerEventClassDirectoryPath;                     // 0x00A0(0x0008)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AController>                BaseCampAIControllerClass;                         // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         WorkerCapacityNumDefault;                          // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27C9[0x4];                                     // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 WorkableBoundShapeName;                            // 0x00B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DisplayCapacityNum;                                // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27CA[0x4];                                     // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    WarningSanityValueTextId;                          // 0x00D0(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_27CB[0x50];                                    // 0x00E0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EPalBaseCampWorkerEventType, class UPalBaseCampWorkerEventBase*> WorkerEventMap;                                    // 0x0130(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	class UDataTable*                             WorkerEventMasterDataTable;                        // 0x0180(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             WorkerSickMasterDataTable;                         // 0x0188(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         WorkerEventTriggerTickMaxCount;                    // 0x0190(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_27CC[0x4];                                     // 0x0194(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UPalAIActionBaseCampDefenseBase>> DefenseAIActionArray;                              // 0x0198(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<struct FPalBaseCampSignificanceInfo>   BaseCampSignificanceInfoList;                      // 0x01A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         UpdateIntervalSquaredDistanceFromPlayer;           // 0x01B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_27CD[0x8];                                     // 0x01BC(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RestoreIgnoredWorkDistanceFromPlayer;              // 0x01C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ClearUnreachableDistanceFromPlayer;                // 0x01C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_27CE[0x4];                                     // 0x01CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SpawnPointInBaseCampPointSubLocalTransform;        // 0x01D0(0x0060)(Edit, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         BaseCampTickInvokeMaxNumInOneTick;                 // 0x0230(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_27CF[0xC];                                     // 0x0234(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCreateMapObjectModelInServer(class UPalMapObjectModel* CreatedModel, const struct FVector& Location);
	void OnRegisteredNewWork_ServerInternal(class UPalWorkBase* Work);
	void OnUnregisteredWork_ServerInternal(class UPalWorkBase* Work);
	void OnUpdateLocationWork_ServerInternal(class UPalWorkBase* Work);
	void RequestDismantalDistanceBaseCamp(const struct FGuid& InstanceId);

	void GetBaseCampIds(TArray<struct FGuid>* OutIds) const;
	class UPalBaseCampModel* GetInRangedBaseCamp(const struct FVector& Location, const float Margin) const;
	class UPalBaseCampModel* GetNearestBaseCamp(const struct FVector& Location) const;
	bool TryGetModel(const struct FGuid& BaseCampId, class UPalBaseCampModel** OutModel) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBaseCampManager">();
	}
	static class UPalBaseCampManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBaseCampManager>();
	}
};
static_assert(alignof(UPalBaseCampManager) == 0x000010, "Wrong alignment on UPalBaseCampManager");
static_assert(sizeof(UPalBaseCampManager) == 0x000240, "Wrong size on UPalBaseCampManager");
static_assert(offsetof(UPalBaseCampManager, WorkerEventClassDirectoryPath) == 0x0000A0, "Member 'UPalBaseCampManager::WorkerEventClassDirectoryPath' has a wrong offset!");
static_assert(offsetof(UPalBaseCampManager, BaseCampAIControllerClass) == 0x0000A8, "Member 'UPalBaseCampManager::BaseCampAIControllerClass' has a wrong offset!");
static_assert(offsetof(UPalBaseCampManager, WorkerCapacityNumDefault) == 0x0000B0, "Member 'UPalBaseCampManager::WorkerCapacityNumDefault' has a wrong offset!");
static_assert(offsetof(UPalBaseCampManager, WorkableBoundShapeName) == 0x0000B8, "Member 'UPalBaseCampManager::WorkableBoundShapeName' has a wrong offset!");
static_assert(offsetof(UPalBaseCampManager, DisplayCapacityNum) == 0x0000C8, "Member 'UPalBaseCampManager::DisplayCapacityNum' has a wrong offset!");
static_assert(offsetof(UPalBaseCampManager, WarningSanityValueTextId) == 0x0000D0, "Member 'UPalBaseCampManager::WarningSanityValueTextId' has a wrong offset!");
static_assert(offsetof(UPalBaseCampManager, WorkerEventMap) == 0x000130, "Member 'UPalBaseCampManager::WorkerEventMap' has a wrong offset!");
static_assert(offsetof(UPalBaseCampManager, WorkerEventMasterDataTable) == 0x000180, "Member 'UPalBaseCampManager::WorkerEventMasterDataTable' has a wrong offset!");
static_assert(offsetof(UPalBaseCampManager, WorkerSickMasterDataTable) == 0x000188, "Member 'UPalBaseCampManager::WorkerSickMasterDataTable' has a wrong offset!");
static_assert(offsetof(UPalBaseCampManager, WorkerEventTriggerTickMaxCount) == 0x000190, "Member 'UPalBaseCampManager::WorkerEventTriggerTickMaxCount' has a wrong offset!");
static_assert(offsetof(UPalBaseCampManager, DefenseAIActionArray) == 0x000198, "Member 'UPalBaseCampManager::DefenseAIActionArray' has a wrong offset!");
static_assert(offsetof(UPalBaseCampManager, BaseCampSignificanceInfoList) == 0x0001A8, "Member 'UPalBaseCampManager::BaseCampSignificanceInfoList' has a wrong offset!");
static_assert(offsetof(UPalBaseCampManager, UpdateIntervalSquaredDistanceFromPlayer) == 0x0001B8, "Member 'UPalBaseCampManager::UpdateIntervalSquaredDistanceFromPlayer' has a wrong offset!");
static_assert(offsetof(UPalBaseCampManager, RestoreIgnoredWorkDistanceFromPlayer) == 0x0001C4, "Member 'UPalBaseCampManager::RestoreIgnoredWorkDistanceFromPlayer' has a wrong offset!");
static_assert(offsetof(UPalBaseCampManager, ClearUnreachableDistanceFromPlayer) == 0x0001C8, "Member 'UPalBaseCampManager::ClearUnreachableDistanceFromPlayer' has a wrong offset!");
static_assert(offsetof(UPalBaseCampManager, SpawnPointInBaseCampPointSubLocalTransform) == 0x0001D0, "Member 'UPalBaseCampManager::SpawnPointInBaseCampPointSubLocalTransform' has a wrong offset!");
static_assert(offsetof(UPalBaseCampManager, BaseCampTickInvokeMaxNumInOneTick) == 0x000230, "Member 'UPalBaseCampManager::BaseCampTickInvokeMaxNumInOneTick' has a wrong offset!");

// Class Pal.PalUserWidgetHierarchical
// 0x0000 (0x0408 - 0x0408)
class UPalUserWidgetHierarchical : public UPalUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUserWidgetHierarchical">();
	}
	static class UPalUserWidgetHierarchical* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUserWidgetHierarchical>();
	}
};
static_assert(alignof(UPalUserWidgetHierarchical) == 0x000008, "Wrong alignment on UPalUserWidgetHierarchical");
static_assert(sizeof(UPalUserWidgetHierarchical) == 0x000408, "Wrong size on UPalUserWidgetHierarchical");

// Class Pal.PalUserWidgetStackableUI
// 0x0018 (0x0420 - 0x0408)
class UPalUserWidgetStackableUI : public UPalUserWidgetHierarchical
{
public:
	class UAkAudioEvent*                          OpenAkEvent;                                       // 0x0408(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          CloseAkEvent;                                      // 0x0410(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27D2[0x8];                                     // 0x0418(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Close();
	void OnClose();
	void OnPostClose();
	void OnPreClose();

	class UAkAudioEvent* GetCloseAkEvent() const;
	class UAkAudioEvent* GetOpenAkEvent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUserWidgetStackableUI">();
	}
	static class UPalUserWidgetStackableUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUserWidgetStackableUI>();
	}
};
static_assert(alignof(UPalUserWidgetStackableUI) == 0x000008, "Wrong alignment on UPalUserWidgetStackableUI");
static_assert(sizeof(UPalUserWidgetStackableUI) == 0x000420, "Wrong size on UPalUserWidgetStackableUI");
static_assert(offsetof(UPalUserWidgetStackableUI, OpenAkEvent) == 0x000408, "Member 'UPalUserWidgetStackableUI::OpenAkEvent' has a wrong offset!");
static_assert(offsetof(UPalUserWidgetStackableUI, CloseAkEvent) == 0x000410, "Member 'UPalUserWidgetStackableUI::CloseAkEvent' has a wrong offset!");

// Class Pal.PalAction_DrownCheckBase
// 0x0020 (0x0068 - 0x0048)
class UPalAction_DrownCheckBase : public UPalStatusBase
{
public:
	uint8                                         Pad_27D3[0x20];                                    // 0x0048(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAction_DrownCheckBase">();
	}
	static class UPalAction_DrownCheckBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAction_DrownCheckBase>();
	}
};
static_assert(alignof(UPalAction_DrownCheckBase) == 0x000008, "Wrong alignment on UPalAction_DrownCheckBase");
static_assert(sizeof(UPalAction_DrownCheckBase) == 0x000068, "Wrong size on UPalAction_DrownCheckBase");

// Class Pal.PalCoopSkillSearchSystem
// 0x0030 (0x0058 - 0x0028)
class UPalCoopSkillSearchSystem : public UObject
{
public:
	uint8                                         Pad_27D4[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UPalCoopSkillSearchEffectController> EffectControllerClass;                             // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalCoopSkillSearchLocationRegister*    LocationRegister;                                  // 0x0038(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalCoopSkillSearchEffectController*    EffectController;                                  // 0x0040(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UPalCoopSkillSearchBase*>        SearchObjects;                                     // 0x0048(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)

public:
	class UPalCoopSkillSearchBase* CreateSearchObject(TSubclassOf<class UPalCoopSkillSearchBase> SearchClass);
	void StartSearchEffect(const struct FPalCoopSkillSearchEffectParameter& EffectParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalCoopSkillSearchSystem">();
	}
	static class UPalCoopSkillSearchSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalCoopSkillSearchSystem>();
	}
};
static_assert(alignof(UPalCoopSkillSearchSystem) == 0x000008, "Wrong alignment on UPalCoopSkillSearchSystem");
static_assert(sizeof(UPalCoopSkillSearchSystem) == 0x000058, "Wrong size on UPalCoopSkillSearchSystem");
static_assert(offsetof(UPalCoopSkillSearchSystem, EffectControllerClass) == 0x000030, "Member 'UPalCoopSkillSearchSystem::EffectControllerClass' has a wrong offset!");
static_assert(offsetof(UPalCoopSkillSearchSystem, LocationRegister) == 0x000038, "Member 'UPalCoopSkillSearchSystem::LocationRegister' has a wrong offset!");
static_assert(offsetof(UPalCoopSkillSearchSystem, EffectController) == 0x000040, "Member 'UPalCoopSkillSearchSystem::EffectController' has a wrong offset!");
static_assert(offsetof(UPalCoopSkillSearchSystem, SearchObjects) == 0x000048, "Member 'UPalCoopSkillSearchSystem::SearchObjects' has a wrong offset!");

// Class Pal.PalUserWidgetOverlayUI
// 0x0010 (0x0430 - 0x0420)
class UPalUserWidgetOverlayUI : public UPalUserWidgetStackableUI
{
public:
	bool                                          IsEnableCancelAction;                              // 0x0420(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27D5[0x3];                                     // 0x0421(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPalUIActionBindData                   CancelInputHandle;                                 // 0x0424(0x0004)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	struct FPalUIActionBindData                   EscInputHandle;                                    // 0x0428(0x0004)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_27D6[0x4];                                     // 0x042C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearCancelAction();
	void OverrideCancelAction(bool IsDisplayActionBar, EInputEvent InputType, TDelegate<void()> Callback);
	void ResetCancelAction();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUserWidgetOverlayUI">();
	}
	static class UPalUserWidgetOverlayUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUserWidgetOverlayUI>();
	}
};
static_assert(alignof(UPalUserWidgetOverlayUI) == 0x000008, "Wrong alignment on UPalUserWidgetOverlayUI");
static_assert(sizeof(UPalUserWidgetOverlayUI) == 0x000430, "Wrong size on UPalUserWidgetOverlayUI");
static_assert(offsetof(UPalUserWidgetOverlayUI, IsEnableCancelAction) == 0x000420, "Member 'UPalUserWidgetOverlayUI::IsEnableCancelAction' has a wrong offset!");
static_assert(offsetof(UPalUserWidgetOverlayUI, CancelInputHandle) == 0x000424, "Member 'UPalUserWidgetOverlayUI::CancelInputHandle' has a wrong offset!");
static_assert(offsetof(UPalUserWidgetOverlayUI, EscInputHandle) == 0x000428, "Member 'UPalUserWidgetOverlayUI::EscInputHandle' has a wrong offset!");

// Class Pal.PalMapObjectDropItem
// 0x0000 (0x03B0 - 0x03B0)
class APalMapObjectDropItem final : public APalMapObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectDropItem">();
	}
	static class APalMapObjectDropItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalMapObjectDropItem>();
	}
};
static_assert(alignof(APalMapObjectDropItem) == 0x000008, "Wrong alignment on APalMapObjectDropItem");
static_assert(sizeof(APalMapObjectDropItem) == 0x0003B0, "Wrong size on APalMapObjectDropItem");

// Class Pal.PalAction_FeedItemToCharacter
// 0x0040 (0x0180 - 0x0140)
class UPalAction_FeedItemToCharacter final : public UPalActionBase
{
public:
	uint8                                         Pad_27D8[0x10];                                    // 0x0138(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurnSpeed;                                         // 0x0148(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27D9[0x4];                                     // 0x014C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalAIActionFed*                        TargetCharacterAction;                             // 0x0150(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_27DA[0x28];                                    // 0x0158(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCancelByInputGuard();
	void OnFinishPlayMontageFeeding();
	void OnNotifiedMontage_OnReachFeeding();
	void PlayMontageFeeding();
	void SimpleDelegate__DelegateSignature();
	void TimeoutStartTargetCharacterApproachAction();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAction_FeedItemToCharacter">();
	}
	static class UPalAction_FeedItemToCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAction_FeedItemToCharacter>();
	}
};
static_assert(alignof(UPalAction_FeedItemToCharacter) == 0x000010, "Wrong alignment on UPalAction_FeedItemToCharacter");
static_assert(sizeof(UPalAction_FeedItemToCharacter) == 0x000180, "Wrong size on UPalAction_FeedItemToCharacter");
static_assert(offsetof(UPalAction_FeedItemToCharacter, TurnSpeed) == 0x000148, "Member 'UPalAction_FeedItemToCharacter::TurnSpeed' has a wrong offset!");
static_assert(offsetof(UPalAction_FeedItemToCharacter, TargetCharacterAction) == 0x000150, "Member 'UPalAction_FeedItemToCharacter::TargetCharacterAction' has a wrong offset!");

// Class Pal.PalAction_Liftup
// 0x0000 (0x0140 - 0x0140)
class UPalAction_Liftup : public UPalActionBase
{
public:
	float                                         AttachRelativeLocationOffsetZ;                     // 0x0138(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAttachToLeftHand;                               // 0x013C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27DB[0x3];                                     // 0x013D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AttachLiftedCharacter();
	void OnCompleteStartLiftupMontage();
	void OnTriggerPlayerInteract();
	void PlayStartLiftupMontage();
	void PlayTargetBeLiftupAction(class APalCharacter* TargetCharacter);
	void PlayWeaponChangeAnime();
	void StartInterpTransformForAttachCharacter();
	void StartRagdollForTargetCharacter();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAction_Liftup">();
	}
	static class UPalAction_Liftup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAction_Liftup>();
	}
};
static_assert(alignof(UPalAction_Liftup) == 0x000010, "Wrong alignment on UPalAction_Liftup");
static_assert(sizeof(UPalAction_Liftup) == 0x000140, "Wrong size on UPalAction_Liftup");
static_assert(offsetof(UPalAction_Liftup, AttachRelativeLocationOffsetZ) == 0x000138, "Member 'UPalAction_Liftup::AttachRelativeLocationOffsetZ' has a wrong offset!");
static_assert(offsetof(UPalAction_Liftup, bIsAttachToLeftHand) == 0x00013C, "Member 'UPalAction_Liftup::bIsAttachToLeftHand' has a wrong offset!");

// Class Pal.PalAction_LiftupThrow
// 0x0000 (0x0140 - 0x0140)
class UPalAction_LiftupThrow : public UPalActionBase
{
public:
	float                                         AttachRelativeLocationOffsetZ;                     // 0x0138(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAttachToLeftHand;                               // 0x013C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27DC[0x3];                                     // 0x013D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void LaunchLiftObject();
	void PlayPlayerThrowMontage();
	void PlayWeaponChangeAnime();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAction_LiftupThrow">();
	}
	static class UPalAction_LiftupThrow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAction_LiftupThrow>();
	}
};
static_assert(alignof(UPalAction_LiftupThrow) == 0x000010, "Wrong alignment on UPalAction_LiftupThrow");
static_assert(sizeof(UPalAction_LiftupThrow) == 0x000140, "Wrong size on UPalAction_LiftupThrow");
static_assert(offsetof(UPalAction_LiftupThrow, AttachRelativeLocationOffsetZ) == 0x000138, "Member 'UPalAction_LiftupThrow::AttachRelativeLocationOffsetZ' has a wrong offset!");
static_assert(offsetof(UPalAction_LiftupThrow, bIsAttachToLeftHand) == 0x00013C, "Member 'UPalAction_LiftupThrow::bIsAttachToLeftHand' has a wrong offset!");

// Class Pal.PalHUDDispatchParameter_WorkSuitabilityPreference
// 0x0008 (0x0040 - 0x0038)
class UPalHUDDispatchParameter_WorkSuitabilityPreference final : public UPalHUDDispatchParameterBase
{
public:
	class UPalUIWorkSuitabilitySettingModel*      Model;                                             // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalHUDDispatchParameter_WorkSuitabilityPreference">();
	}
	static class UPalHUDDispatchParameter_WorkSuitabilityPreference* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalHUDDispatchParameter_WorkSuitabilityPreference>();
	}
};
static_assert(alignof(UPalHUDDispatchParameter_WorkSuitabilityPreference) == 0x000008, "Wrong alignment on UPalHUDDispatchParameter_WorkSuitabilityPreference");
static_assert(sizeof(UPalHUDDispatchParameter_WorkSuitabilityPreference) == 0x000040, "Wrong size on UPalHUDDispatchParameter_WorkSuitabilityPreference");
static_assert(offsetof(UPalHUDDispatchParameter_WorkSuitabilityPreference, Model) == 0x000038, "Member 'UPalHUDDispatchParameter_WorkSuitabilityPreference::Model' has a wrong offset!");

// Class Pal.PalAnimNotifyState_AttackCollision
// 0x0030 (0x0060 - 0x0030)
class UPalAnimNotifyState_AttackCollision final : public UAnimNotifyState
{
public:
	class FName                                   AttachBoneName;                                    // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEnableHitStop;                                  // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27DD[0x3];                                     // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverrideHitStopTime;                               // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalHitFilter*                          AttackFilter;                                      // 0x0040(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UShapeComponent*                        ShapeComponent;                                    // 0x0048(0x0008)(ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UShapeComponent*>                ShapeComponents;                                   // 0x0050(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	void OnHit(class UPrimitiveComponent* MyHitComponent, class AActor* HitActor, class UPrimitiveComponent* HitComponent, const TArray<int32>& FoliageIndex, const struct FVector& HitLocation, int32 HitCount) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAnimNotifyState_AttackCollision">();
	}
	static class UPalAnimNotifyState_AttackCollision* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAnimNotifyState_AttackCollision>();
	}
};
static_assert(alignof(UPalAnimNotifyState_AttackCollision) == 0x000008, "Wrong alignment on UPalAnimNotifyState_AttackCollision");
static_assert(sizeof(UPalAnimNotifyState_AttackCollision) == 0x000060, "Wrong size on UPalAnimNotifyState_AttackCollision");
static_assert(offsetof(UPalAnimNotifyState_AttackCollision, AttachBoneName) == 0x000030, "Member 'UPalAnimNotifyState_AttackCollision::AttachBoneName' has a wrong offset!");
static_assert(offsetof(UPalAnimNotifyState_AttackCollision, bIsEnableHitStop) == 0x000038, "Member 'UPalAnimNotifyState_AttackCollision::bIsEnableHitStop' has a wrong offset!");
static_assert(offsetof(UPalAnimNotifyState_AttackCollision, OverrideHitStopTime) == 0x00003C, "Member 'UPalAnimNotifyState_AttackCollision::OverrideHitStopTime' has a wrong offset!");
static_assert(offsetof(UPalAnimNotifyState_AttackCollision, AttackFilter) == 0x000040, "Member 'UPalAnimNotifyState_AttackCollision::AttackFilter' has a wrong offset!");
static_assert(offsetof(UPalAnimNotifyState_AttackCollision, ShapeComponent) == 0x000048, "Member 'UPalAnimNotifyState_AttackCollision::ShapeComponent' has a wrong offset!");
static_assert(offsetof(UPalAnimNotifyState_AttackCollision, ShapeComponents) == 0x000050, "Member 'UPalAnimNotifyState_AttackCollision::ShapeComponents' has a wrong offset!");

// Class Pal.PalStageAreaBounds
// 0x0000 (0x0290 - 0x0290)
class APalStageAreaBounds final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalStageAreaBounds">();
	}
	static class APalStageAreaBounds* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalStageAreaBounds>();
	}
};
static_assert(alignof(APalStageAreaBounds) == 0x000008, "Wrong alignment on APalStageAreaBounds");
static_assert(sizeof(APalStageAreaBounds) == 0x000290, "Wrong size on APalStageAreaBounds");

// Class Pal.PalAction_SleepPlayerBed
// 0x0010 (0x0150 - 0x0140)
class UPalAction_SleepPlayerBed final : public UPalActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnGetupTriggerDelegate;                            // 0x0138(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_27DF[0x8];                                     // 0x0148(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetupBroadcast();
	void OnGetupPlayerBedFromModel();
	void OnGetupTriggerDelegate__DelegateSignature();

	bool IsSleepLooping() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAction_SleepPlayerBed">();
	}
	static class UPalAction_SleepPlayerBed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAction_SleepPlayerBed>();
	}
};
static_assert(alignof(UPalAction_SleepPlayerBed) == 0x000010, "Wrong alignment on UPalAction_SleepPlayerBed");
static_assert(sizeof(UPalAction_SleepPlayerBed) == 0x000150, "Wrong size on UPalAction_SleepPlayerBed");
static_assert(offsetof(UPalAction_SleepPlayerBed, OnGetupTriggerDelegate) == 0x000138, "Member 'UPalAction_SleepPlayerBed::OnGetupTriggerDelegate' has a wrong offset!");

// Class Pal.PalMapObjectAmusementModel
// 0x0068 (0x0280 - 0x0218)
class UPalMapObjectAmusementModel final : public UPalMapObjectConcreteModelBase
{
public:
	uint8                                         Pad_27E0[0x28];                                    // 0x0218(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnUpdateCharacterDelegate;                         // 0x0240(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UPalIndividualCharacterHandle*          HealingCharacterHandle;                            // 0x0250(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                HealingLocationOffset;                             // 0x0258(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AffectSanityRate;                                  // 0x0270(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27E1[0x4];                                     // 0x0274(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UPalAIActionBase>           AIActionClass;                                     // 0x0278(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ClearCharacterHandle();
	void OnFinishHealingAction(class UPalAIActionBase* Action);
	void OnInteractBegin(class AActor* Other, TScriptInterface<class IPalInteractiveObjectComponentInterface> Component);
	void SimpleDelegate__DelegateSignature(class UPalMapObjectAmusementModel* Model);

	class UPalIndividualCharacterHandle* GetHealingHandle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectAmusementModel">();
	}
	static class UPalMapObjectAmusementModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectAmusementModel>();
	}
};
static_assert(alignof(UPalMapObjectAmusementModel) == 0x000008, "Wrong alignment on UPalMapObjectAmusementModel");
static_assert(sizeof(UPalMapObjectAmusementModel) == 0x000280, "Wrong size on UPalMapObjectAmusementModel");
static_assert(offsetof(UPalMapObjectAmusementModel, OnUpdateCharacterDelegate) == 0x000240, "Member 'UPalMapObjectAmusementModel::OnUpdateCharacterDelegate' has a wrong offset!");
static_assert(offsetof(UPalMapObjectAmusementModel, HealingCharacterHandle) == 0x000250, "Member 'UPalMapObjectAmusementModel::HealingCharacterHandle' has a wrong offset!");
static_assert(offsetof(UPalMapObjectAmusementModel, HealingLocationOffset) == 0x000258, "Member 'UPalMapObjectAmusementModel::HealingLocationOffset' has a wrong offset!");
static_assert(offsetof(UPalMapObjectAmusementModel, AffectSanityRate) == 0x000270, "Member 'UPalMapObjectAmusementModel::AffectSanityRate' has a wrong offset!");
static_assert(offsetof(UPalMapObjectAmusementModel, AIActionClass) == 0x000278, "Member 'UPalMapObjectAmusementModel::AIActionClass' has a wrong offset!");

// Class Pal.PalNavArea_HighObstacle
// 0x0000 (0x0048 - 0x0048)
class UPalNavArea_HighObstacle final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalNavArea_HighObstacle">();
	}
	static class UPalNavArea_HighObstacle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalNavArea_HighObstacle>();
	}
};
static_assert(alignof(UPalNavArea_HighObstacle) == 0x000008, "Wrong alignment on UPalNavArea_HighObstacle");
static_assert(sizeof(UPalNavArea_HighObstacle) == 0x000048, "Wrong size on UPalNavArea_HighObstacle");

// Class Pal.PalActivatableWidgetContainer
// 0x0000 (0x0280 - 0x0280)
class UPalActivatableWidgetContainer final : public UCommonActivatableWidgetStack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalActivatableWidgetContainer">();
	}
	static class UPalActivatableWidgetContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalActivatableWidgetContainer>();
	}
};
static_assert(alignof(UPalActivatableWidgetContainer) == 0x000008, "Wrong alignment on UPalActivatableWidgetContainer");
static_assert(sizeof(UPalActivatableWidgetContainer) == 0x000280, "Wrong size on UPalActivatableWidgetContainer");

// Class Pal.PalMapObjectConcreteModelModuleBase
// 0x0008 (0x0030 - 0x0028)
class UPalMapObjectConcreteModelModuleBase : public UObject
{
public:
	bool                                          bTriggeredOnSpawnedReady;                          // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_27E2[0x7];                                     // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectConcreteModelModuleBase">();
	}
	static class UPalMapObjectConcreteModelModuleBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectConcreteModelModuleBase>();
	}
};
static_assert(alignof(UPalMapObjectConcreteModelModuleBase) == 0x000008, "Wrong alignment on UPalMapObjectConcreteModelModuleBase");
static_assert(sizeof(UPalMapObjectConcreteModelModuleBase) == 0x000030, "Wrong size on UPalMapObjectConcreteModelModuleBase");
static_assert(offsetof(UPalMapObjectConcreteModelModuleBase, bTriggeredOnSpawnedReady) == 0x000028, "Member 'UPalMapObjectConcreteModelModuleBase::bTriggeredOnSpawnedReady' has a wrong offset!");

// Class Pal.PalMapObjectPlayerRecordModule
// 0x0048 (0x0078 - 0x0030)
class UPalMapObjectPlayerRecordModule final : public UPalMapObjectConcreteModelModuleBase
{
public:
	FMulticastInlineDelegateProperty_             OnUpdatePlayerRecordBoolValDelegate;               // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdatePlayerRecordIntValDelegate;                // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_27E3[0x20];                                    // 0x0050(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TargetKey;                                         // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void MulticastBoolValDelegate__DelegateSignature(class UPalMapObjectPlayerRecordModule* Module, const class FName Key, const bool Value);
	void MulticastIntValDelegate__DelegateSignature(class UPalMapObjectPlayerRecordModule* Module, const class FName Key, const int32 Value);
	void OnCompleteSyncPlayerFromServer_InClient(class APalPlayerState* LocalPlayerState);
	void OnUpdatePlayerRecordBoolVal(const class FName Key, const bool Value);
	void OnUpdatePlayerRecordIntVal(const class FName Key, const int32 Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectPlayerRecordModule">();
	}
	static class UPalMapObjectPlayerRecordModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectPlayerRecordModule>();
	}
};
static_assert(alignof(UPalMapObjectPlayerRecordModule) == 0x000008, "Wrong alignment on UPalMapObjectPlayerRecordModule");
static_assert(sizeof(UPalMapObjectPlayerRecordModule) == 0x000078, "Wrong size on UPalMapObjectPlayerRecordModule");
static_assert(offsetof(UPalMapObjectPlayerRecordModule, OnUpdatePlayerRecordBoolValDelegate) == 0x000030, "Member 'UPalMapObjectPlayerRecordModule::OnUpdatePlayerRecordBoolValDelegate' has a wrong offset!");
static_assert(offsetof(UPalMapObjectPlayerRecordModule, OnUpdatePlayerRecordIntValDelegate) == 0x000040, "Member 'UPalMapObjectPlayerRecordModule::OnUpdatePlayerRecordIntValDelegate' has a wrong offset!");
static_assert(offsetof(UPalMapObjectPlayerRecordModule, TargetKey) == 0x000070, "Member 'UPalMapObjectPlayerRecordModule::TargetKey' has a wrong offset!");

// Class Pal.PalActiveSkill
// 0x0048 (0x0070 - 0x0028)
class UPalActiveSkill final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnCoolTimeUpdate;                                  // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCoolStart;                                       // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCoolFinish;                                      // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          IsCooling;                                         // 0x0058(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27E7[0x3];                                     // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReuseCoolTimer;                                    // 0x005C(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPalWazaID                                    WazaType;                                          // 0x0060(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsIgnoreRaycast;                                   // 0x0061(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsStopTimer;                                       // 0x0062(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_27E8[0x1];                                     // 0x0063(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DatabaseCoolTime;                                  // 0x0064(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsTransient;                                      // 0x0068(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_27E9[0x7];                                     // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCoolStateChange__DelegateSignature();
	void OnCoolTimeUpdateDelegate__DelegateSignature(float CoolRate);
	void OnRep_ChangeCTState();
	void OnRep_UpdateCoolTime();

	bool IsCoolTimeFinish() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalActiveSkill">();
	}
	static class UPalActiveSkill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalActiveSkill>();
	}
};
static_assert(alignof(UPalActiveSkill) == 0x000008, "Wrong alignment on UPalActiveSkill");
static_assert(sizeof(UPalActiveSkill) == 0x000070, "Wrong size on UPalActiveSkill");
static_assert(offsetof(UPalActiveSkill, OnCoolTimeUpdate) == 0x000028, "Member 'UPalActiveSkill::OnCoolTimeUpdate' has a wrong offset!");
static_assert(offsetof(UPalActiveSkill, OnCoolStart) == 0x000038, "Member 'UPalActiveSkill::OnCoolStart' has a wrong offset!");
static_assert(offsetof(UPalActiveSkill, OnCoolFinish) == 0x000048, "Member 'UPalActiveSkill::OnCoolFinish' has a wrong offset!");
static_assert(offsetof(UPalActiveSkill, IsCooling) == 0x000058, "Member 'UPalActiveSkill::IsCooling' has a wrong offset!");
static_assert(offsetof(UPalActiveSkill, ReuseCoolTimer) == 0x00005C, "Member 'UPalActiveSkill::ReuseCoolTimer' has a wrong offset!");
static_assert(offsetof(UPalActiveSkill, WazaType) == 0x000060, "Member 'UPalActiveSkill::WazaType' has a wrong offset!");
static_assert(offsetof(UPalActiveSkill, IsIgnoreRaycast) == 0x000061, "Member 'UPalActiveSkill::IsIgnoreRaycast' has a wrong offset!");
static_assert(offsetof(UPalActiveSkill, IsStopTimer) == 0x000062, "Member 'UPalActiveSkill::IsStopTimer' has a wrong offset!");
static_assert(offsetof(UPalActiveSkill, DatabaseCoolTime) == 0x000064, "Member 'UPalActiveSkill::DatabaseCoolTime' has a wrong offset!");
static_assert(offsetof(UPalActiveSkill, bIsTransient) == 0x000068, "Member 'UPalActiveSkill::bIsTransient' has a wrong offset!");

// Class Pal.PalActiveSkillSlot
// 0x0070 (0x0098 - 0x0028)
class UPalActiveSkillSlot final : public UObject
{
public:
	class AActor*                                 SelfActor;                                         // 0x0028(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<int32, class UPalActiveSkill*>           SkillMap;                                          // 0x0030(0x0050)(Transient, NativeAccessSpecifierPrivate)
	bool                                          IsEndInit;                                         // 0x0080(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_27EA[0x7];                                     // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatContainer                        CoolDownSpeedRateMap;                              // 0x0088(0x0010)(Transient, NativeAccessSpecifierPrivate)

public:
	int32 FindFarthestSlotID_IgnoreSlotID(int32 IgnoreID);
	int32 FindSlotIndexByWazaID(EPalWazaID WazaID);
	void InitObject(class AActor* ActorSelf);
	void OnChangeEquipWaza(class UPalIndividualCharacterParameter* IndividualParameter);
	void RemoveSkill(int32 SlotID);
	void RestartCoolTime(int32 SlotID);
	void SetCoolTimeRate(class FName Key, float Rate);
	void SetSkill(int32 SlotID, EPalWazaID WazaType);
	void SetTransient(int32 SlotID, bool IsTransient);
	void StopCoolTime(int32 SlotID);
	void UpdateCoolTime(float DeltaTime);

	bool CanUse(int32 SlotID, class AActor* TargetActor) const;
	int32 ChoiceEnableSlotIDByRandom() const;
	int32 FindMostEffectiveSlotID(class AActor* TargetActor) const;
	float GetCoolTime(int32 SlotID) const;
	float GetCoolTimeRate(int32 SlotID) const;
	TArray<int32> GetEnableSlotIDs() const;
	TMap<int32, class UPalActiveSkill*> GetSkillMap() const;
	EPalWazaID GetWazaType(int32 SlotID) const;
	bool IsCoolTimeFinish(int32 SlotID) const;
	bool IsFarMinRange(int32 SlotID, class AActor* TargetActor) const;
	bool IsNearMaxRange(int32 SlotID, class AActor* TargetActor) const;
	bool IsNearMaxRange_AndRayCheck(int32 SlotID, class AActor* TargetActor) const;
	bool IsTransient(int32 SlotID) const;
	bool IsValidSkill(int32 SlotID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalActiveSkillSlot">();
	}
	static class UPalActiveSkillSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalActiveSkillSlot>();
	}
};
static_assert(alignof(UPalActiveSkillSlot) == 0x000008, "Wrong alignment on UPalActiveSkillSlot");
static_assert(sizeof(UPalActiveSkillSlot) == 0x000098, "Wrong size on UPalActiveSkillSlot");
static_assert(offsetof(UPalActiveSkillSlot, SelfActor) == 0x000028, "Member 'UPalActiveSkillSlot::SelfActor' has a wrong offset!");
static_assert(offsetof(UPalActiveSkillSlot, SkillMap) == 0x000030, "Member 'UPalActiveSkillSlot::SkillMap' has a wrong offset!");
static_assert(offsetof(UPalActiveSkillSlot, IsEndInit) == 0x000080, "Member 'UPalActiveSkillSlot::IsEndInit' has a wrong offset!");
static_assert(offsetof(UPalActiveSkillSlot, CoolDownSpeedRateMap) == 0x000088, "Member 'UPalActiveSkillSlot::CoolDownSpeedRateMap' has a wrong offset!");

// Class Pal.PalEditorSetting
// 0x0280 (0x02A8 - 0x0028)
class UPalEditorSetting final : public UObject
{
public:
	struct FSoftObjectPath                        ItemDataTableAssetPath;                            // 0x0028(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        PalMonsterDataTableAssetPath;                      // 0x0048(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        PalHumanDataTableAssetPath;                        // 0x0068(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        MapObjectDataTableAssetPath;                       // 0x0088(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        FarmCropDataTableAssetPath;                        // 0x00A8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        CrimeMasterDataTableAssetPath;                     // 0x00C8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        PassiveSkillDataTableAssetPath;                    // 0x00E8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ItemProductDataTableAssetPath;                     // 0x0108(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        NPCUniqueDataTableAssetPath;                       // 0x0128(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        RecipeTechnologyDataTableAssetPath;                // 0x0148(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BaseCampWorkerEventDataTableAssetPath;             // 0x0168(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        UIInputActionTableAssetPath;                       // 0x0188(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SoundIDTableAssetPath;                             // 0x01A8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ItemShopCreateDataTableAssetPath;                  // 0x01C8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ItemShopLotteryDataTableAssetPath;                 // 0x01E8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        PalShopCreateDataTableAssetPath;                   // 0x0208(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        DungeonSpawnAreaDataTableAssetPath;                // 0x0228(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        FieldLotteryNameDataTableAssetPath;                // 0x0248(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        NoteDataTableAssetPath;                            // 0x0268(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        GameProgressPresetTableAssetPath;                  // 0x0288(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalEditorSetting">();
	}
	static class UPalEditorSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalEditorSetting>();
	}
};
static_assert(alignof(UPalEditorSetting) == 0x000008, "Wrong alignment on UPalEditorSetting");
static_assert(sizeof(UPalEditorSetting) == 0x0002A8, "Wrong size on UPalEditorSetting");
static_assert(offsetof(UPalEditorSetting, ItemDataTableAssetPath) == 0x000028, "Member 'UPalEditorSetting::ItemDataTableAssetPath' has a wrong offset!");
static_assert(offsetof(UPalEditorSetting, PalMonsterDataTableAssetPath) == 0x000048, "Member 'UPalEditorSetting::PalMonsterDataTableAssetPath' has a wrong offset!");
static_assert(offsetof(UPalEditorSetting, PalHumanDataTableAssetPath) == 0x000068, "Member 'UPalEditorSetting::PalHumanDataTableAssetPath' has a wrong offset!");
static_assert(offsetof(UPalEditorSetting, MapObjectDataTableAssetPath) == 0x000088, "Member 'UPalEditorSetting::MapObjectDataTableAssetPath' has a wrong offset!");
static_assert(offsetof(UPalEditorSetting, FarmCropDataTableAssetPath) == 0x0000A8, "Member 'UPalEditorSetting::FarmCropDataTableAssetPath' has a wrong offset!");
static_assert(offsetof(UPalEditorSetting, CrimeMasterDataTableAssetPath) == 0x0000C8, "Member 'UPalEditorSetting::CrimeMasterDataTableAssetPath' has a wrong offset!");
static_assert(offsetof(UPalEditorSetting, PassiveSkillDataTableAssetPath) == 0x0000E8, "Member 'UPalEditorSetting::PassiveSkillDataTableAssetPath' has a wrong offset!");
static_assert(offsetof(UPalEditorSetting, ItemProductDataTableAssetPath) == 0x000108, "Member 'UPalEditorSetting::ItemProductDataTableAssetPath' has a wrong offset!");
static_assert(offsetof(UPalEditorSetting, NPCUniqueDataTableAssetPath) == 0x000128, "Member 'UPalEditorSetting::NPCUniqueDataTableAssetPath' has a wrong offset!");
static_assert(offsetof(UPalEditorSetting, RecipeTechnologyDataTableAssetPath) == 0x000148, "Member 'UPalEditorSetting::RecipeTechnologyDataTableAssetPath' has a wrong offset!");
static_assert(offsetof(UPalEditorSetting, BaseCampWorkerEventDataTableAssetPath) == 0x000168, "Member 'UPalEditorSetting::BaseCampWorkerEventDataTableAssetPath' has a wrong offset!");
static_assert(offsetof(UPalEditorSetting, UIInputActionTableAssetPath) == 0x000188, "Member 'UPalEditorSetting::UIInputActionTableAssetPath' has a wrong offset!");
static_assert(offsetof(UPalEditorSetting, SoundIDTableAssetPath) == 0x0001A8, "Member 'UPalEditorSetting::SoundIDTableAssetPath' has a wrong offset!");
static_assert(offsetof(UPalEditorSetting, ItemShopCreateDataTableAssetPath) == 0x0001C8, "Member 'UPalEditorSetting::ItemShopCreateDataTableAssetPath' has a wrong offset!");
static_assert(offsetof(UPalEditorSetting, ItemShopLotteryDataTableAssetPath) == 0x0001E8, "Member 'UPalEditorSetting::ItemShopLotteryDataTableAssetPath' has a wrong offset!");
static_assert(offsetof(UPalEditorSetting, PalShopCreateDataTableAssetPath) == 0x000208, "Member 'UPalEditorSetting::PalShopCreateDataTableAssetPath' has a wrong offset!");
static_assert(offsetof(UPalEditorSetting, DungeonSpawnAreaDataTableAssetPath) == 0x000228, "Member 'UPalEditorSetting::DungeonSpawnAreaDataTableAssetPath' has a wrong offset!");
static_assert(offsetof(UPalEditorSetting, FieldLotteryNameDataTableAssetPath) == 0x000248, "Member 'UPalEditorSetting::FieldLotteryNameDataTableAssetPath' has a wrong offset!");
static_assert(offsetof(UPalEditorSetting, NoteDataTableAssetPath) == 0x000268, "Member 'UPalEditorSetting::NoteDataTableAssetPath' has a wrong offset!");
static_assert(offsetof(UPalEditorSetting, GameProgressPresetTableAssetPath) == 0x000288, "Member 'UPalEditorSetting::GameProgressPresetTableAssetPath' has a wrong offset!");

// Class Pal.PalBuildObjectInstallStrategyBase
// 0x0010 (0x0038 - 0x0028)
class UPalBuildObjectInstallStrategyBase : public UObject
{
public:
	class APalBuildObject*                        TargetBuildObject;                                 // 0x0028(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27FB[0x8];                                     // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBuildObjectInstallStrategyBase">();
	}
	static class UPalBuildObjectInstallStrategyBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBuildObjectInstallStrategyBase>();
	}
};
static_assert(alignof(UPalBuildObjectInstallStrategyBase) == 0x000008, "Wrong alignment on UPalBuildObjectInstallStrategyBase");
static_assert(sizeof(UPalBuildObjectInstallStrategyBase) == 0x000038, "Wrong size on UPalBuildObjectInstallStrategyBase");
static_assert(offsetof(UPalBuildObjectInstallStrategyBase, TargetBuildObject) == 0x000028, "Member 'UPalBuildObjectInstallStrategyBase::TargetBuildObject' has a wrong offset!");

// Class Pal.PalBuildObjectInstallStrategySinkableNormal
// 0x0000 (0x0038 - 0x0038)
class UPalBuildObjectInstallStrategySinkableNormal : public UPalBuildObjectInstallStrategyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBuildObjectInstallStrategySinkableNormal">();
	}
	static class UPalBuildObjectInstallStrategySinkableNormal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBuildObjectInstallStrategySinkableNormal>();
	}
};
static_assert(alignof(UPalBuildObjectInstallStrategySinkableNormal) == 0x000008, "Wrong alignment on UPalBuildObjectInstallStrategySinkableNormal");
static_assert(sizeof(UPalBuildObjectInstallStrategySinkableNormal) == 0x000038, "Wrong size on UPalBuildObjectInstallStrategySinkableNormal");

// Class Pal.PalBuildObjectInstallStrategyBaseCampPoint
// 0x0040 (0x0078 - 0x0038)
class UPalBuildObjectInstallStrategyBaseCampPoint final : public UPalBuildObjectInstallStrategySinkableNormal
{
public:
	class APalBuildObjectBaseCampPoint*           TargetBuildObjectCache;                            // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBox                                   CannotOverlapAreaBox;                              // 0x0040(0x0038)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBuildObjectInstallStrategyBaseCampPoint">();
	}
	static class UPalBuildObjectInstallStrategyBaseCampPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBuildObjectInstallStrategyBaseCampPoint>();
	}
};
static_assert(alignof(UPalBuildObjectInstallStrategyBaseCampPoint) == 0x000008, "Wrong alignment on UPalBuildObjectInstallStrategyBaseCampPoint");
static_assert(sizeof(UPalBuildObjectInstallStrategyBaseCampPoint) == 0x000078, "Wrong size on UPalBuildObjectInstallStrategyBaseCampPoint");
static_assert(offsetof(UPalBuildObjectInstallStrategyBaseCampPoint, TargetBuildObjectCache) == 0x000038, "Member 'UPalBuildObjectInstallStrategyBaseCampPoint::TargetBuildObjectCache' has a wrong offset!");
static_assert(offsetof(UPalBuildObjectInstallStrategyBaseCampPoint, CannotOverlapAreaBox) == 0x000040, "Member 'UPalBuildObjectInstallStrategyBaseCampPoint::CannotOverlapAreaBox' has a wrong offset!");

// Class Pal.PalActorChannel
// 0x0000 (0x0290 - 0x0290)
class UPalActorChannel final : public UActorChannel
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalActorChannel">();
	}
	static class UPalActorChannel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalActorChannel>();
	}
};
static_assert(alignof(UPalActorChannel) == 0x000008, "Wrong alignment on UPalActorChannel");
static_assert(sizeof(UPalActorChannel) == 0x000290, "Wrong size on UPalActorChannel");

// Class Pal.PalMapLevelObject
// 0x0018 (0x03C8 - 0x03B0)
class APalMapLevelObject final : public APalMapObject
{
public:
	uint8                                         Pad_27FC[0x8];                                     // 0x03B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  LevelObjectInstanceId;                             // 0x03B8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, NonPIEDuplicateTransient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	const struct FGuid GetLevelObjectInstanceId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapLevelObject">();
	}
	static class APalMapLevelObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalMapLevelObject>();
	}
};
static_assert(alignof(APalMapLevelObject) == 0x000008, "Wrong alignment on APalMapLevelObject");
static_assert(sizeof(APalMapLevelObject) == 0x0003C8, "Wrong size on APalMapLevelObject");
static_assert(offsetof(APalMapLevelObject, LevelObjectInstanceId) == 0x0003B8, "Member 'APalMapLevelObject::LevelObjectInstanceId' has a wrong offset!");

// Class Pal.PalBaseCampWorkerDirector
// 0x0108 (0x0130 - 0x0028)
class UPalBaseCampWorkerDirector final : public UObject
{
public:
	uint8                                         Pad_27FD[0x18];                                    // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnAddNewWorkerDelegate;                            // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRemovedWorkerInServerDelegate;                   // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGuid                                  BaseCampId;                                        // 0x0060(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             SpawnTransform;                                    // 0x0070(0x0060)(Edit, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalIndividualCharacterContainer*       CharacterContainer;                                // 0x00D0(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPalMapBaseCampWorkerOrderType                CurrentOrderType;                                  // 0x00D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPalBaseCampWorkerDirectionBattleType         CurrentBattleType;                                 // 0x00D9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27FE[0x6];                                     // 0x00DA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalIndividualCharacterSlotsObserver*   SlotObserverForServer;                             // 0x00E0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FPalBaseCampWorkAssignRequest>  RequiredAssignWorks;                               // 0x00E8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<struct FPalInstanceID>                 WaitingWorkerIndividualIds;                        // 0x00F8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	int32                                         WorkerEventTickCount;                              // 0x0108(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_27FF[0x4];                                     // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UPalBaseCampWorkerTaskBase*>     WorkerTasks;                                       // 0x0110(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2800[0x1];                                     // 0x0120(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	EPalBaseCampWorkerDirectorState               State;                                             // 0x0121(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2801[0xE];                                     // 0x0122(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddNewWorkerDelegate__DelegateSignature(class UPalIndividualCharacterHandle* NewCharacter);
	void OnAddedNewCharacterInServer(const struct FPalInstanceID& IndividualId);
	void OnChangeWorldSettings_ServerInternal(const struct FPalOptionWorldSettings& PrevSettings, const struct FPalOptionWorldSettings& NewSettings);
	void OnDeadWorkerInServer(const struct FPalDeadInfo& Info);
	void OnDeadWorkerInServer_Internal(class APalCharacter* DeadCharacter);
	void OnNotifiedUnassignWork_ServerInternal(class UPalWorkBase* Work, const struct FPalInstanceID& IndividualId);
	void OnRaisedPhantomCharacterInServer(const struct FPalInstanceID& IndividualId, int32 PhantomId);
	void OnReflectSlotCompleteInServer();
	void OnRemovedNewCharacterInServer(const struct FPalInstanceID& IndividualId);
	void OnRep_CharacterContainer();
	void OnRequiredAssignWork_ServerInternal(class UPalWorkBase* Work, const struct FPalWorkAssignRequirementParameter& RequirementParameter);
	void OnSpawnedCharacterInServer(const struct FPalInstanceID& IndividualId);
	void OnUpdateOwnerBaseCampStatus_ServerInternal(class UPalBaseCampModel* OwnerBaseCamp);
	void OrderCommand(const EPalMapBaseCampWorkerOrderType OrderType);
	void RemovedWorkerDelegate__DelegateSignature(class UPalIndividualCharacterHandle* IndividualHandle);

	class UPalIndividualCharacterSlot* FindSlotByHandle(class UPalIndividualCharacterHandle* Handle) const;
	void GetCharacterHandleSlots(TArray<class UPalIndividualCharacterSlot*>* OutSlots) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBaseCampWorkerDirector">();
	}
	static class UPalBaseCampWorkerDirector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBaseCampWorkerDirector>();
	}
};
static_assert(alignof(UPalBaseCampWorkerDirector) == 0x000010, "Wrong alignment on UPalBaseCampWorkerDirector");
static_assert(sizeof(UPalBaseCampWorkerDirector) == 0x000130, "Wrong size on UPalBaseCampWorkerDirector");
static_assert(offsetof(UPalBaseCampWorkerDirector, OnAddNewWorkerDelegate) == 0x000040, "Member 'UPalBaseCampWorkerDirector::OnAddNewWorkerDelegate' has a wrong offset!");
static_assert(offsetof(UPalBaseCampWorkerDirector, OnRemovedWorkerInServerDelegate) == 0x000050, "Member 'UPalBaseCampWorkerDirector::OnRemovedWorkerInServerDelegate' has a wrong offset!");
static_assert(offsetof(UPalBaseCampWorkerDirector, BaseCampId) == 0x000060, "Member 'UPalBaseCampWorkerDirector::BaseCampId' has a wrong offset!");
static_assert(offsetof(UPalBaseCampWorkerDirector, SpawnTransform) == 0x000070, "Member 'UPalBaseCampWorkerDirector::SpawnTransform' has a wrong offset!");
static_assert(offsetof(UPalBaseCampWorkerDirector, CharacterContainer) == 0x0000D0, "Member 'UPalBaseCampWorkerDirector::CharacterContainer' has a wrong offset!");
static_assert(offsetof(UPalBaseCampWorkerDirector, CurrentOrderType) == 0x0000D8, "Member 'UPalBaseCampWorkerDirector::CurrentOrderType' has a wrong offset!");
static_assert(offsetof(UPalBaseCampWorkerDirector, CurrentBattleType) == 0x0000D9, "Member 'UPalBaseCampWorkerDirector::CurrentBattleType' has a wrong offset!");
static_assert(offsetof(UPalBaseCampWorkerDirector, SlotObserverForServer) == 0x0000E0, "Member 'UPalBaseCampWorkerDirector::SlotObserverForServer' has a wrong offset!");
static_assert(offsetof(UPalBaseCampWorkerDirector, RequiredAssignWorks) == 0x0000E8, "Member 'UPalBaseCampWorkerDirector::RequiredAssignWorks' has a wrong offset!");
static_assert(offsetof(UPalBaseCampWorkerDirector, WaitingWorkerIndividualIds) == 0x0000F8, "Member 'UPalBaseCampWorkerDirector::WaitingWorkerIndividualIds' has a wrong offset!");
static_assert(offsetof(UPalBaseCampWorkerDirector, WorkerEventTickCount) == 0x000108, "Member 'UPalBaseCampWorkerDirector::WorkerEventTickCount' has a wrong offset!");
static_assert(offsetof(UPalBaseCampWorkerDirector, WorkerTasks) == 0x000110, "Member 'UPalBaseCampWorkerDirector::WorkerTasks' has a wrong offset!");
static_assert(offsetof(UPalBaseCampWorkerDirector, State) == 0x000121, "Member 'UPalBaseCampWorkerDirector::State' has a wrong offset!");

// Class Pal.PalMapObjectPalFoodBoxModel
// 0x0008 (0x0220 - 0x0218)
class UPalMapObjectPalFoodBoxModel final : public UPalMapObjectConcreteModelBase
{
public:
	uint8                                         Pad_2803[0x8];                                     // 0x0218(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectPalFoodBoxModel">();
	}
	static class UPalMapObjectPalFoodBoxModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectPalFoodBoxModel>();
	}
};
static_assert(alignof(UPalMapObjectPalFoodBoxModel) == 0x000008, "Wrong alignment on UPalMapObjectPalFoodBoxModel");
static_assert(sizeof(UPalMapObjectPalFoodBoxModel) == 0x000220, "Wrong size on UPalMapObjectPalFoodBoxModel");

// Class Pal.PalAIActionBaseCampBase
// 0x0010 (0x0140 - 0x0130)
class UPalAIActionBaseCampBase : public UPalAIActionBase
{
public:
	uint8                                         Pad_2804[0x8];                                     // 0x0130(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WalkSpeedDefault;                                  // 0x0138(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2805[0x4];                                     // 0x013C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeActionToFighter();
	void ChangeActionToWorker();
	void ChangeChildAction(class UPalAIActionBaseCampChildBase* Action);
	void FinishCombatAction();
	void InterruptActionToRecoverHungry(const struct FPalMonsterControllerBaseCampHungryParameter& Parameter);
	void NotifyOrderCommand(const EPalMapBaseCampWorkerOrderType OrderType);
	void OnClosedWorkerRadialMenu(class UPalHUDDispatchParameterBase* Parameter);
	void OnTriggerInteract(class AActor* OtherActor, EPalInteractiveObjectIndicatorType IndicatorType);
	void OnUpdateFullStomach(const float Current, const float Last);
	void StartCombatAction(TSubclassOf<class UPalAIActionCombatBase> CombatActionClass);

	class UPalBaseCampModel* GetBaseCampBelongTo() const;
	const struct FGuid GetBaseCampIdBelongTo() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionBaseCampBase">();
	}
	static class UPalAIActionBaseCampBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIActionBaseCampBase>();
	}
};
static_assert(alignof(UPalAIActionBaseCampBase) == 0x000008, "Wrong alignment on UPalAIActionBaseCampBase");
static_assert(sizeof(UPalAIActionBaseCampBase) == 0x000140, "Wrong size on UPalAIActionBaseCampBase");
static_assert(offsetof(UPalAIActionBaseCampBase, WalkSpeedDefault) == 0x000138, "Member 'UPalAIActionBaseCampBase::WalkSpeedDefault' has a wrong offset!");

// Class Pal.PalUIJoinGameBase
// 0x0060 (0x0490 - 0x0430)
class UPalUIJoinGameBase : public UPalUserWidgetOverlayUI
{
public:
	bool                                          bIsShowIgnoreVersionServer;                        // 0x0430(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2807[0x7];                                     // 0x0431(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         OfficialServerIPRangeList;                         // 0x0438(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         CurrentPage;                                       // 0x0448(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PageSize;                                          // 0x044C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNextPage;                                        // 0x0450(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2808[0x7];                                     // 0x0451(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPalUIServerDisplayData>        CachedServerDisplayInfo;                           // 0x0458(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class FString                                 InputIPAddress;                                    // 0x0468(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsCheckedInputPassword;                            // 0x0478(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2809[0x7];                                     // 0x0479(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SaveConfigCategoryName;                            // 0x0480(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void CollectServerDisplayInfo(const struct FPalUIServerDataCollectInfo& CollectInfo, TArray<struct FPalUIServerDisplayData>* OutServerInfo);
	void ConnectServer(const struct FPalUIServerDisplayData& ServerDisplayData);
	void ConnectServerByAddress(const class FString& Address, int32 Port);
	void OnCompleteFindSessionResult(const class FString& ResponseBody, bool bResponseOK, int32 ResponseCode);
	void OnCompleteFindSessions(bool IsSuccess, const TArray<struct FBlueprintSessionResult>& Results, const class FString& ErrorStr);
	void OnCompleteGetServerListEvent();
	void OnCompleteOfficialServerIPRange(const class FString& ResponseBody, bool bResponseOK, int32 ResponseCode);
	void RequestGetServerList(EPalUIServerListFilterType Type, EPalUIServerListSortType SortType, const class FString& Region, bool IsCleanCache, int32 PageOffset, const class FString& SearchWord);
	void RequestOfficialServerIPRange();
	void SaveConfigValue();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIJoinGameBase">();
	}
	static class UPalUIJoinGameBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIJoinGameBase>();
	}
};
static_assert(alignof(UPalUIJoinGameBase) == 0x000008, "Wrong alignment on UPalUIJoinGameBase");
static_assert(sizeof(UPalUIJoinGameBase) == 0x000490, "Wrong size on UPalUIJoinGameBase");
static_assert(offsetof(UPalUIJoinGameBase, bIsShowIgnoreVersionServer) == 0x000430, "Member 'UPalUIJoinGameBase::bIsShowIgnoreVersionServer' has a wrong offset!");
static_assert(offsetof(UPalUIJoinGameBase, OfficialServerIPRangeList) == 0x000438, "Member 'UPalUIJoinGameBase::OfficialServerIPRangeList' has a wrong offset!");
static_assert(offsetof(UPalUIJoinGameBase, CurrentPage) == 0x000448, "Member 'UPalUIJoinGameBase::CurrentPage' has a wrong offset!");
static_assert(offsetof(UPalUIJoinGameBase, PageSize) == 0x00044C, "Member 'UPalUIJoinGameBase::PageSize' has a wrong offset!");
static_assert(offsetof(UPalUIJoinGameBase, IsNextPage) == 0x000450, "Member 'UPalUIJoinGameBase::IsNextPage' has a wrong offset!");
static_assert(offsetof(UPalUIJoinGameBase, CachedServerDisplayInfo) == 0x000458, "Member 'UPalUIJoinGameBase::CachedServerDisplayInfo' has a wrong offset!");
static_assert(offsetof(UPalUIJoinGameBase, InputIPAddress) == 0x000468, "Member 'UPalUIJoinGameBase::InputIPAddress' has a wrong offset!");
static_assert(offsetof(UPalUIJoinGameBase, IsCheckedInputPassword) == 0x000478, "Member 'UPalUIJoinGameBase::IsCheckedInputPassword' has a wrong offset!");
static_assert(offsetof(UPalUIJoinGameBase, SaveConfigCategoryName) == 0x000480, "Member 'UPalUIJoinGameBase::SaveConfigCategoryName' has a wrong offset!");

// Class Pal.PalBaseCampPassiveEffectBase
// 0x0050 (0x0078 - 0x0028)
class UPalBaseCampPassiveEffectBase : public UObject
{
public:
	TMap<class FName, struct FPalBaseCampPassiveEffectMapObjectInfo> MapObjectInfoMapByMapObjectId;                     // 0x0028(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBaseCampPassiveEffectBase">();
	}
	static class UPalBaseCampPassiveEffectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBaseCampPassiveEffectBase>();
	}
};
static_assert(alignof(UPalBaseCampPassiveEffectBase) == 0x000008, "Wrong alignment on UPalBaseCampPassiveEffectBase");
static_assert(sizeof(UPalBaseCampPassiveEffectBase) == 0x000078, "Wrong size on UPalBaseCampPassiveEffectBase");
static_assert(offsetof(UPalBaseCampPassiveEffectBase, MapObjectInfoMapByMapObjectId) == 0x000028, "Member 'UPalBaseCampPassiveEffectBase::MapObjectInfoMapByMapObjectId' has a wrong offset!");

// Class Pal.PalBaseCampPassiveEffect_WorkSuitability
// 0x0058 (0x00D0 - 0x0078)
class UPalBaseCampPassiveEffect_WorkSuitability final : public UPalBaseCampPassiveEffectBase
{
public:
	uint8                                         Pad_2811[0x8];                                     // 0x0078(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EPalWorkSuitability, float>              WorkSpeedAdditionalRateMap;                        // 0x0080(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBaseCampPassiveEffect_WorkSuitability">();
	}
	static class UPalBaseCampPassiveEffect_WorkSuitability* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBaseCampPassiveEffect_WorkSuitability>();
	}
};
static_assert(alignof(UPalBaseCampPassiveEffect_WorkSuitability) == 0x000008, "Wrong alignment on UPalBaseCampPassiveEffect_WorkSuitability");
static_assert(sizeof(UPalBaseCampPassiveEffect_WorkSuitability) == 0x0000D0, "Wrong size on UPalBaseCampPassiveEffect_WorkSuitability");
static_assert(offsetof(UPalBaseCampPassiveEffect_WorkSuitability, WorkSpeedAdditionalRateMap) == 0x000080, "Member 'UPalBaseCampPassiveEffect_WorkSuitability::WorkSpeedAdditionalRateMap' has a wrong offset!");

// Class Pal.PalAIActionBaseCampChildBase
// 0x0008 (0x0138 - 0x0130)
class UPalAIActionBaseCampChildBase : public UPalAIActionBase
{
public:
	TWeakObjectPtr<class UPalAIActionBaseCampBase> BaseCampParentAction;                              // 0x0130(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionBaseCampChildBase">();
	}
	static class UPalAIActionBaseCampChildBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIActionBaseCampChildBase>();
	}
};
static_assert(alignof(UPalAIActionBaseCampChildBase) == 0x000008, "Wrong alignment on UPalAIActionBaseCampChildBase");
static_assert(sizeof(UPalAIActionBaseCampChildBase) == 0x000138, "Wrong size on UPalAIActionBaseCampChildBase");
static_assert(offsetof(UPalAIActionBaseCampChildBase, BaseCampParentAction) == 0x000130, "Member 'UPalAIActionBaseCampChildBase::BaseCampParentAction' has a wrong offset!");

// Class Pal.PalMapObjectRaidBossSummon
// 0x0020 (0x0238 - 0x0218)
class UPalMapObjectRaidBossSummon final : public UPalMapObjectConcreteModelBase
{
public:
	uint8                                         Pad_2812[0x10];                                    // 0x0218(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  SummonRequestPlayerUId;                            // 0x0228(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnReceiveConfirmSummonRaidBossResult(const bool bResult);
	void RaidBossSummonDelegate__DelegateSignature();
	void RequestSummonRaidBoss_ServerInternal(const int32 RequestPlayerId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectRaidBossSummon">();
	}
	static class UPalMapObjectRaidBossSummon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectRaidBossSummon>();
	}
};
static_assert(alignof(UPalMapObjectRaidBossSummon) == 0x000008, "Wrong alignment on UPalMapObjectRaidBossSummon");
static_assert(sizeof(UPalMapObjectRaidBossSummon) == 0x000238, "Wrong size on UPalMapObjectRaidBossSummon");
static_assert(offsetof(UPalMapObjectRaidBossSummon, SummonRequestPlayerUId) == 0x000228, "Member 'UPalMapObjectRaidBossSummon::SummonRequestPlayerUId' has a wrong offset!");

// Class Pal.PalAIActionBaseCampCage
// 0x0008 (0x0138 - 0x0130)
class UPalAIActionBaseCampCage : public UPalAIActionBase
{
public:
	uint8                                         Pad_2813[0x8];                                     // 0x0130(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionBaseCampCage">();
	}
	static class UPalAIActionBaseCampCage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIActionBaseCampCage>();
	}
};
static_assert(alignof(UPalAIActionBaseCampCage) == 0x000008, "Wrong alignment on UPalAIActionBaseCampCage");
static_assert(sizeof(UPalAIActionBaseCampCage) == 0x000138, "Wrong size on UPalAIActionBaseCampCage");

// Class Pal.PalDungeonStartPointMarker
// 0x0000 (0x0290 - 0x0290)
class APalDungeonStartPointMarker final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalDungeonStartPointMarker">();
	}
	static class APalDungeonStartPointMarker* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalDungeonStartPointMarker>();
	}
};
static_assert(alignof(APalDungeonStartPointMarker) == 0x000008, "Wrong alignment on APalDungeonStartPointMarker");
static_assert(sizeof(APalDungeonStartPointMarker) == 0x000290, "Wrong size on APalDungeonStartPointMarker");

// Class Pal.PalAIActionBaseCampDefenseBase
// 0x0058 (0x0188 - 0x0130)
class UPalAIActionBaseCampDefenseBase : public UPalAIActionBase
{
public:
	uint8                                         Pad_2814[0x8];                                     // 0x0130(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TargetActor;                                       // 0x0138(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APalCharacter*                          SelfActor;                                         // 0x0140(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalAICombatModule*                     CombatModule;                                      // 0x0148(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPalWorkType                                  CurrentWorkType;                                   // 0x0150(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2815[0x3];                                     // 0x0151(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPalWorkAssignHandleId                 CurrentWorkAssignId;                               // 0x0154(0x0018)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPalWorkDefenseCombatType                     DefenseCombatType;                                 // 0x016C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2816[0x3];                                     // 0x016D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UPalActionBase>             DefenseActionClass;                                // 0x0170(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UPalActionBase>             DefenseWaitActionClass;                            // 0x0178(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UPalMapObjectDefenseBulletLauncherModel> WeakDefenseModel;                                  // 0x0180(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class APalAIController* GetControllerRef();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionBaseCampDefenseBase">();
	}
	static class UPalAIActionBaseCampDefenseBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIActionBaseCampDefenseBase>();
	}
};
static_assert(alignof(UPalAIActionBaseCampDefenseBase) == 0x000008, "Wrong alignment on UPalAIActionBaseCampDefenseBase");
static_assert(sizeof(UPalAIActionBaseCampDefenseBase) == 0x000188, "Wrong size on UPalAIActionBaseCampDefenseBase");
static_assert(offsetof(UPalAIActionBaseCampDefenseBase, TargetActor) == 0x000138, "Member 'UPalAIActionBaseCampDefenseBase::TargetActor' has a wrong offset!");
static_assert(offsetof(UPalAIActionBaseCampDefenseBase, SelfActor) == 0x000140, "Member 'UPalAIActionBaseCampDefenseBase::SelfActor' has a wrong offset!");
static_assert(offsetof(UPalAIActionBaseCampDefenseBase, CombatModule) == 0x000148, "Member 'UPalAIActionBaseCampDefenseBase::CombatModule' has a wrong offset!");
static_assert(offsetof(UPalAIActionBaseCampDefenseBase, CurrentWorkType) == 0x000150, "Member 'UPalAIActionBaseCampDefenseBase::CurrentWorkType' has a wrong offset!");
static_assert(offsetof(UPalAIActionBaseCampDefenseBase, CurrentWorkAssignId) == 0x000154, "Member 'UPalAIActionBaseCampDefenseBase::CurrentWorkAssignId' has a wrong offset!");
static_assert(offsetof(UPalAIActionBaseCampDefenseBase, DefenseCombatType) == 0x00016C, "Member 'UPalAIActionBaseCampDefenseBase::DefenseCombatType' has a wrong offset!");
static_assert(offsetof(UPalAIActionBaseCampDefenseBase, DefenseActionClass) == 0x000170, "Member 'UPalAIActionBaseCampDefenseBase::DefenseActionClass' has a wrong offset!");
static_assert(offsetof(UPalAIActionBaseCampDefenseBase, DefenseWaitActionClass) == 0x000178, "Member 'UPalAIActionBaseCampDefenseBase::DefenseWaitActionClass' has a wrong offset!");
static_assert(offsetof(UPalAIActionBaseCampDefenseBase, WeakDefenseModel) == 0x000180, "Member 'UPalAIActionBaseCampDefenseBase::WeakDefenseModel' has a wrong offset!");

// Class Pal.PalAIActionBaseCampDefenseGunner
// 0x0008 (0x0190 - 0x0188)
class UPalAIActionBaseCampDefenseGunner : public UPalAIActionBaseCampDefenseBase
{
public:
	uint8                                         Pad_2817[0x8];                                     // 0x0188(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnShootBullet();
	void StopTrigger();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionBaseCampDefenseGunner">();
	}
	static class UPalAIActionBaseCampDefenseGunner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIActionBaseCampDefenseGunner>();
	}
};
static_assert(alignof(UPalAIActionBaseCampDefenseGunner) == 0x000008, "Wrong alignment on UPalAIActionBaseCampDefenseGunner");
static_assert(sizeof(UPalAIActionBaseCampDefenseGunner) == 0x000190, "Wrong size on UPalAIActionBaseCampDefenseGunner");

// Class Pal.PalMapObjectModelInitializeExtraParameterBuild
// 0x0008 (0x0030 - 0x0028)
class UPalMapObjectModelInitializeExtraParameterBuild final : public UPalMapObjectModelInitializeExtraParameterBase
{
public:
	float                                         BuildWorkAmount;                                   // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2818[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectModelInitializeExtraParameterBuild">();
	}
	static class UPalMapObjectModelInitializeExtraParameterBuild* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectModelInitializeExtraParameterBuild>();
	}
};
static_assert(alignof(UPalMapObjectModelInitializeExtraParameterBuild) == 0x000008, "Wrong alignment on UPalMapObjectModelInitializeExtraParameterBuild");
static_assert(sizeof(UPalMapObjectModelInitializeExtraParameterBuild) == 0x000030, "Wrong size on UPalMapObjectModelInitializeExtraParameterBuild");
static_assert(offsetof(UPalMapObjectModelInitializeExtraParameterBuild, BuildWorkAmount) == 0x000028, "Member 'UPalMapObjectModelInitializeExtraParameterBuild::BuildWorkAmount' has a wrong offset!");

// Class Pal.PalFlyMeshHeightCtrlComponent
// 0x0048 (0x00E8 - 0x00A0)
class UPalFlyMeshHeightCtrlComponent final : public UActorComponent
{
public:
	float                                         FlingAdditionalHeight;                             // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HighFlingAddtionalHeight;                          // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPalFlyHeightType                             State;                                             // 0x00A8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2819[0xB];                                     // 0x00A9(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsHighFling;                                      // 0x00B4(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsHighFlingCache;                                 // 0x00B5(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_281A[0x2];                                     // 0x00B6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 SK;                                                // 0x00B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_281B[0x28];                                    // 0x00C0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Debug_ForceHighFlingEnd();
	float GetDefaultMeshLocationZ();
	void HighFlingEnd();
	void HighFlingEnd_Implementation();
	void HighFlingEnd_Server();
	void OnChangeBattleMode(bool bIsBattleMode);
	void OnDead(const struct FPalDeadInfo& Info);
	void OnInitializedCharacter(class APalCharacter* OwnerCharacter);
	void OnRep_bIsHighFling();
	void OnUpdatePlayerHp(const struct FFixedPoint64& NowHP, const struct FFixedPoint64& NowMaxHP);
	void SetupMesh();
	void ToFly(float Duration);
	void ToFly_All(float Duration);
	void ToLand(float Duration);
	void ToLand_All(float Duration);

	bool IsFlying() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalFlyMeshHeightCtrlComponent">();
	}
	static class UPalFlyMeshHeightCtrlComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalFlyMeshHeightCtrlComponent>();
	}
};
static_assert(alignof(UPalFlyMeshHeightCtrlComponent) == 0x000008, "Wrong alignment on UPalFlyMeshHeightCtrlComponent");
static_assert(sizeof(UPalFlyMeshHeightCtrlComponent) == 0x0000E8, "Wrong size on UPalFlyMeshHeightCtrlComponent");
static_assert(offsetof(UPalFlyMeshHeightCtrlComponent, FlingAdditionalHeight) == 0x0000A0, "Member 'UPalFlyMeshHeightCtrlComponent::FlingAdditionalHeight' has a wrong offset!");
static_assert(offsetof(UPalFlyMeshHeightCtrlComponent, HighFlingAddtionalHeight) == 0x0000A4, "Member 'UPalFlyMeshHeightCtrlComponent::HighFlingAddtionalHeight' has a wrong offset!");
static_assert(offsetof(UPalFlyMeshHeightCtrlComponent, State) == 0x0000A8, "Member 'UPalFlyMeshHeightCtrlComponent::State' has a wrong offset!");
static_assert(offsetof(UPalFlyMeshHeightCtrlComponent, bIsHighFling) == 0x0000B4, "Member 'UPalFlyMeshHeightCtrlComponent::bIsHighFling' has a wrong offset!");
static_assert(offsetof(UPalFlyMeshHeightCtrlComponent, bIsHighFlingCache) == 0x0000B5, "Member 'UPalFlyMeshHeightCtrlComponent::bIsHighFlingCache' has a wrong offset!");
static_assert(offsetof(UPalFlyMeshHeightCtrlComponent, SK) == 0x0000B8, "Member 'UPalFlyMeshHeightCtrlComponent::SK' has a wrong offset!");

// Class Pal.PalAIActionBaseCampDefenseWait
// 0x0000 (0x0188 - 0x0188)
class UPalAIActionBaseCampDefenseWait : public UPalAIActionBaseCampDefenseBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionBaseCampDefenseWait">();
	}
	static class UPalAIActionBaseCampDefenseWait* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIActionBaseCampDefenseWait>();
	}
};
static_assert(alignof(UPalAIActionBaseCampDefenseWait) == 0x000008, "Wrong alignment on UPalAIActionBaseCampDefenseWait");
static_assert(sizeof(UPalAIActionBaseCampDefenseWait) == 0x000188, "Wrong size on UPalAIActionBaseCampDefenseWait");

// Class Pal.PalUICharacterMakeBase
// 0x0000 (0x0430 - 0x0430)
class UPalUICharacterMakeBase : public UPalUserWidgetOverlayUI
{
public:
	void ApplyMakeInfoToPlayerData(const struct FPalPlayerDataCharacterMakeInfo& MakeInfo);
	bool GetPlayerMakeInfo(struct FPalPlayerDataCharacterMakeInfo* OutMakeInfo);
	void RequestChangePlayerName(const class FString& NewPlayerName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUICharacterMakeBase">();
	}
	static class UPalUICharacterMakeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUICharacterMakeBase>();
	}
};
static_assert(alignof(UPalUICharacterMakeBase) == 0x000008, "Wrong alignment on UPalUICharacterMakeBase");
static_assert(sizeof(UPalUICharacterMakeBase) == 0x000430, "Wrong size on UPalUICharacterMakeBase");

// Class Pal.PalBuildProcess
// 0x0040 (0x0068 - 0x0028)
class UPalBuildProcess final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnUpdateStateDelegate;                             // 0x0028(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFinishBuildDelegate;                             // 0x0038(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	EPalBuildProcessState                         State;                                             // 0x0048(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_281D[0x7];                                     // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalWorkProgress*                       BuildWork;                                         // 0x0050(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_281E[0x10];                                    // 0x0058(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFinishWorkInServer(class UPalWorkBase* Work);
	void OnReflectFinishBuildWork(class UPalWorkBase* Work);
	void OnRep_BuildWork();
	void OnRep_StateChanged();
	void UpdateStateDelegate__DelegateSignature(class UPalBuildProcess* BuildProcess);

	class UPalWorkProgress* GetWorkProgress() const;
	bool IsCompleted() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBuildProcess">();
	}
	static class UPalBuildProcess* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBuildProcess>();
	}
};
static_assert(alignof(UPalBuildProcess) == 0x000008, "Wrong alignment on UPalBuildProcess");
static_assert(sizeof(UPalBuildProcess) == 0x000068, "Wrong size on UPalBuildProcess");
static_assert(offsetof(UPalBuildProcess, OnUpdateStateDelegate) == 0x000028, "Member 'UPalBuildProcess::OnUpdateStateDelegate' has a wrong offset!");
static_assert(offsetof(UPalBuildProcess, OnFinishBuildDelegate) == 0x000038, "Member 'UPalBuildProcess::OnFinishBuildDelegate' has a wrong offset!");
static_assert(offsetof(UPalBuildProcess, State) == 0x000048, "Member 'UPalBuildProcess::State' has a wrong offset!");
static_assert(offsetof(UPalBuildProcess, BuildWork) == 0x000050, "Member 'UPalBuildProcess::BuildWork' has a wrong offset!");

// Class Pal.PalAIActionBaseCampDodgeWork
// 0x0030 (0x0160 - 0x0130)
class UPalAIActionBaseCampDodgeWork final : public UPalAIActionBase
{
public:
	float                                         WalkAroundArrivalRange;                            // 0x0130(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WalkAroundNextDistance;                            // 0x0134(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFloatInterval                         WalkAroundRandomTime;                              // 0x0138(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_281F[0x20];                                    // 0x0140(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionBaseCampDodgeWork">();
	}
	static class UPalAIActionBaseCampDodgeWork* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIActionBaseCampDodgeWork>();
	}
};
static_assert(alignof(UPalAIActionBaseCampDodgeWork) == 0x000008, "Wrong alignment on UPalAIActionBaseCampDodgeWork");
static_assert(sizeof(UPalAIActionBaseCampDodgeWork) == 0x000160, "Wrong size on UPalAIActionBaseCampDodgeWork");
static_assert(offsetof(UPalAIActionBaseCampDodgeWork, WalkAroundArrivalRange) == 0x000130, "Member 'UPalAIActionBaseCampDodgeWork::WalkAroundArrivalRange' has a wrong offset!");
static_assert(offsetof(UPalAIActionBaseCampDodgeWork, WalkAroundNextDistance) == 0x000134, "Member 'UPalAIActionBaseCampDodgeWork::WalkAroundNextDistance' has a wrong offset!");
static_assert(offsetof(UPalAIActionBaseCampDodgeWork, WalkAroundRandomTime) == 0x000138, "Member 'UPalAIActionBaseCampDodgeWork::WalkAroundRandomTime' has a wrong offset!");

// Class Pal.PalMapObjectModelEffect
// 0x0170 (0x0198 - 0x0028)
class UPalMapObjectModelEffect final : public UObject
{
public:
	uint8                                         Pad_2820[0x20];                                    // 0x0028(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPalFastMapObjectModelEffectRepInfoArray RepInfoArray;                                      // 0x0048(0x0148)(Edit, Net, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2821[0x8];                                     // 0x0190(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectModelEffect">();
	}
	static class UPalMapObjectModelEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectModelEffect>();
	}
};
static_assert(alignof(UPalMapObjectModelEffect) == 0x000008, "Wrong alignment on UPalMapObjectModelEffect");
static_assert(sizeof(UPalMapObjectModelEffect) == 0x000198, "Wrong size on UPalMapObjectModelEffect");
static_assert(offsetof(UPalMapObjectModelEffect, RepInfoArray) == 0x000048, "Member 'UPalMapObjectModelEffect::RepInfoArray' has a wrong offset!");

// Class Pal.PalAkComponent
// 0x0000 (0x0490 - 0x0490)
class UPalAkComponent final : public UAkComponent
{
public:
	bool                                          PersistAcrossLevelTransition;                      // 0x0488(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2822[0x7];                                     // 0x0489(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAkComponent">();
	}
	static class UPalAkComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAkComponent>();
	}
};
static_assert(alignof(UPalAkComponent) == 0x000010, "Wrong alignment on UPalAkComponent");
static_assert(sizeof(UPalAkComponent) == 0x000490, "Wrong size on UPalAkComponent");
static_assert(offsetof(UPalAkComponent, PersistAcrossLevelTransition) == 0x000488, "Member 'UPalAkComponent::PersistAcrossLevelTransition' has a wrong offset!");

// Class Pal.PalAIActionBaseCampFighter
// 0x0000 (0x0140 - 0x0140)
class UPalAIActionBaseCampFighter : public UPalAIActionBaseCampBase
{
public:
	void ChangeActionWait();
	void RegisterAssignDefenseModelId(const struct FGuid& InDefenseMapObjectModelId);
	const bool TryGetDefenseMapObjectModel(class UPalMapObjectDefenseModelBase** OutModel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionBaseCampFighter">();
	}
	static class UPalAIActionBaseCampFighter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIActionBaseCampFighter>();
	}
};
static_assert(alignof(UPalAIActionBaseCampFighter) == 0x000008, "Wrong alignment on UPalAIActionBaseCampFighter");
static_assert(sizeof(UPalAIActionBaseCampFighter) == 0x000140, "Wrong size on UPalAIActionBaseCampFighter");

// Class Pal.PalEventNotifyBase
// 0x0000 (0x0028 - 0x0028)
class UPalEventNotifyBase : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalEventNotifyBase">();
	}
	static class UPalEventNotifyBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalEventNotifyBase>();
	}
};
static_assert(alignof(UPalEventNotifyBase) == 0x000008, "Wrong alignment on UPalEventNotifyBase");
static_assert(sizeof(UPalEventNotifyBase) == 0x000028, "Wrong size on UPalEventNotifyBase");

// Class Pal.PalEventNotify_Area
// 0x0020 (0x0048 - 0x0028)
class UPalEventNotify_Area final : public UPalEventNotifyBase
{
public:
	FMulticastInlineDelegateProperty_             OnNotifyEventBeginInvasionInServer;                // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNotifyEventEndInvasionInServer;                  // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UPalEventNotify_Area* GetEventNotify_Area(const class UObject* WorldContextObject);

	void OnBeginAreaInvasion_ServerInternal(class AActor* HitActor, const struct FGuid& AreaInstanceId);
	void OnEndAreaInvasion_ServerInternal(class AActor* HitActor, const struct FGuid& AreaInstanceId);
	void OnRegiterdArea_ServerInternal(class APalTriggerAreaBase* TriggerBase);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalEventNotify_Area">();
	}
	static class UPalEventNotify_Area* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalEventNotify_Area>();
	}
};
static_assert(alignof(UPalEventNotify_Area) == 0x000008, "Wrong alignment on UPalEventNotify_Area");
static_assert(sizeof(UPalEventNotify_Area) == 0x000048, "Wrong size on UPalEventNotify_Area");
static_assert(offsetof(UPalEventNotify_Area, OnNotifyEventBeginInvasionInServer) == 0x000028, "Member 'UPalEventNotify_Area::OnNotifyEventBeginInvasionInServer' has a wrong offset!");
static_assert(offsetof(UPalEventNotify_Area, OnNotifyEventEndInvasionInServer) == 0x000038, "Member 'UPalEventNotify_Area::OnNotifyEventEndInvasionInServer' has a wrong offset!");

// Class Pal.PalLevelObjectActor
// 0x0018 (0x02A8 - 0x0290)
class APalLevelObjectActor : public AActor
{
public:
	uint8                                         Pad_2824[0x8];                                     // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  LevelObjectInstanceId;                             // 0x0298(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, NonPIEDuplicateTransient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	const struct FGuid GetLevelObjectInstanceId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLevelObjectActor">();
	}
	static class APalLevelObjectActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalLevelObjectActor>();
	}
};
static_assert(alignof(APalLevelObjectActor) == 0x000008, "Wrong alignment on APalLevelObjectActor");
static_assert(sizeof(APalLevelObjectActor) == 0x0002A8, "Wrong size on APalLevelObjectActor");
static_assert(offsetof(APalLevelObjectActor, LevelObjectInstanceId) == 0x000298, "Member 'APalLevelObjectActor::LevelObjectInstanceId' has a wrong offset!");

// Class Pal.PalMapObjectSpawnerBase
// 0x0028 (0x02D0 - 0x02A8)
class APalMapObjectSpawnerBase : public APalLevelObjectActor
{
public:
	int32                                         ProbabilityRespawn;                                // 0x02A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LotteryCoolTimeMinutes;                            // 0x02AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPalStageInstanceId                    StageInstanceIdBelongTo;                           // 0x02B0(0x0014)(Edit, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2825[0x4];                                     // 0x02C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USphereComponent*                       LocateSphere;                                      // 0x02C8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnWorldMapObjectSpawnableInServer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectSpawnerBase">();
	}
	static class APalMapObjectSpawnerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalMapObjectSpawnerBase>();
	}
};
static_assert(alignof(APalMapObjectSpawnerBase) == 0x000008, "Wrong alignment on APalMapObjectSpawnerBase");
static_assert(sizeof(APalMapObjectSpawnerBase) == 0x0002D0, "Wrong size on APalMapObjectSpawnerBase");
static_assert(offsetof(APalMapObjectSpawnerBase, ProbabilityRespawn) == 0x0002A8, "Member 'APalMapObjectSpawnerBase::ProbabilityRespawn' has a wrong offset!");
static_assert(offsetof(APalMapObjectSpawnerBase, LotteryCoolTimeMinutes) == 0x0002AC, "Member 'APalMapObjectSpawnerBase::LotteryCoolTimeMinutes' has a wrong offset!");
static_assert(offsetof(APalMapObjectSpawnerBase, StageInstanceIdBelongTo) == 0x0002B0, "Member 'APalMapObjectSpawnerBase::StageInstanceIdBelongTo' has a wrong offset!");
static_assert(offsetof(APalMapObjectSpawnerBase, LocateSphere) == 0x0002C8, "Member 'APalMapObjectSpawnerBase::LocateSphere' has a wrong offset!");

// Class Pal.PalMapObjectSpawnerSingleBase
// 0x0000 (0x02D0 - 0x02D0)
class APalMapObjectSpawnerSingleBase : public APalMapObjectSpawnerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectSpawnerSingleBase">();
	}
	static class APalMapObjectSpawnerSingleBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalMapObjectSpawnerSingleBase>();
	}
};
static_assert(alignof(APalMapObjectSpawnerSingleBase) == 0x000008, "Wrong alignment on APalMapObjectSpawnerSingleBase");
static_assert(sizeof(APalMapObjectSpawnerSingleBase) == 0x0002D0, "Wrong size on APalMapObjectSpawnerSingleBase");

// Class Pal.PalAIActionBaseCampFighterChildBase
// 0x0008 (0x0140 - 0x0138)
class UPalAIActionBaseCampFighterChildBase : public UPalAIActionBaseCampChildBase
{
public:
	TWeakObjectPtr<class UPalAIActionBaseCampFighter> WeakParentFighterActionCache;                      // 0x0138(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UPalAIActionBaseCampFighter* GetParentFighterAction();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionBaseCampFighterChildBase">();
	}
	static class UPalAIActionBaseCampFighterChildBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIActionBaseCampFighterChildBase>();
	}
};
static_assert(alignof(UPalAIActionBaseCampFighterChildBase) == 0x000008, "Wrong alignment on UPalAIActionBaseCampFighterChildBase");
static_assert(sizeof(UPalAIActionBaseCampFighterChildBase) == 0x000140, "Wrong size on UPalAIActionBaseCampFighterChildBase");
static_assert(offsetof(UPalAIActionBaseCampFighterChildBase, WeakParentFighterActionCache) == 0x000138, "Member 'UPalAIActionBaseCampFighterChildBase::WeakParentFighterActionCache' has a wrong offset!");

// Class Pal.PalDamageExplodeComponent
// 0x0028 (0x00C8 - 0x00A0)
class UPalDamageExplodeComponent final : public UActorComponent
{
public:
	uint8                                         Pad_2826[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExplosionDelayTime;                                // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2827[0x4];                                     // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnDamageDelegate_Ex;                               // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          IsExploded;                                        // 0x00C0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2828[0x7];                                     // 0x00C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ForceExplode(class AActor* Attacker);
	void OnDamageDelegate_Ex__DelegateSignature(const struct FPalDamageInfo& DamageInfo);
	void SpawnExplosionActor(class AActor* Attacker);
	void SpawnExplosionActor_Delay(class AActor* Attacker, float DelayTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalDamageExplodeComponent">();
	}
	static class UPalDamageExplodeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalDamageExplodeComponent>();
	}
};
static_assert(alignof(UPalDamageExplodeComponent) == 0x000008, "Wrong alignment on UPalDamageExplodeComponent");
static_assert(sizeof(UPalDamageExplodeComponent) == 0x0000C8, "Wrong size on UPalDamageExplodeComponent");
static_assert(offsetof(UPalDamageExplodeComponent, ExplosionDelayTime) == 0x0000A8, "Member 'UPalDamageExplodeComponent::ExplosionDelayTime' has a wrong offset!");
static_assert(offsetof(UPalDamageExplodeComponent, OnDamageDelegate_Ex) == 0x0000B0, "Member 'UPalDamageExplodeComponent::OnDamageDelegate_Ex' has a wrong offset!");
static_assert(offsetof(UPalDamageExplodeComponent, IsExploded) == 0x0000C0, "Member 'UPalDamageExplodeComponent::IsExploded' has a wrong offset!");

// Class Pal.PalAIActionCombatBase
// 0x0048 (0x0178 - 0x0130)
class UPalAIActionCombatBase : public UPalAIActionBase
{
public:
	uint8                                         Pad_282A[0x8];                                     // 0x0130(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnCombatFinish;                                    // 0x0138(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x0148(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APalCharacter*                          SelfActor;                                         // 0x0150(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalAICombatModule*                     CombatModule;                                      // 0x0158(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          NextIsWaza;                                        // 0x0160(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_282B[0x3];                                     // 0x0161(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NextWazaSlotIndex;                                 // 0x0164(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UPalActionBase>             NextActionClass;                                   // 0x0168(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InterruptSkillSlotID;                              // 0x0170(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bInterruptSkill;                                   // 0x0174(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_282C[0x3];                                     // 0x0175(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeNextAction();
	void CombatFinishDelegate__DelegateSignature();
	class UPalActionComponent* GetActorActionComponentRef();
	class APalAIController* GetControllerRef();
	class UPalCharacterParameterComponent* GetParamCompRef();
	class UPalActiveSkillSlot* GetSkillSlotRef();
	class UPalStaticCharacterParameterComponent* GetStaticParamCompRef();
	void InterruptAction(int32 SkillSlotID);
	bool LineTraceTarget();
	void MoveToTarget();
	void OnDeadDeledate_Event(const struct FPalDeadInfo& DeadInfo);
	void PlayActionWhenDarknessStatus();
	bool PreTickFinishCheck();
	void SetTargetAndNextAction(class AActor* Target);
	void SkillSlotSetUp();
	void StartNextAction_Event(const class UPalActionComponent* ActionComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionCombatBase">();
	}
	static class UPalAIActionCombatBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIActionCombatBase>();
	}
};
static_assert(alignof(UPalAIActionCombatBase) == 0x000008, "Wrong alignment on UPalAIActionCombatBase");
static_assert(sizeof(UPalAIActionCombatBase) == 0x000178, "Wrong size on UPalAIActionCombatBase");
static_assert(offsetof(UPalAIActionCombatBase, OnCombatFinish) == 0x000138, "Member 'UPalAIActionCombatBase::OnCombatFinish' has a wrong offset!");
static_assert(offsetof(UPalAIActionCombatBase, TargetActor) == 0x000148, "Member 'UPalAIActionCombatBase::TargetActor' has a wrong offset!");
static_assert(offsetof(UPalAIActionCombatBase, SelfActor) == 0x000150, "Member 'UPalAIActionCombatBase::SelfActor' has a wrong offset!");
static_assert(offsetof(UPalAIActionCombatBase, CombatModule) == 0x000158, "Member 'UPalAIActionCombatBase::CombatModule' has a wrong offset!");
static_assert(offsetof(UPalAIActionCombatBase, NextIsWaza) == 0x000160, "Member 'UPalAIActionCombatBase::NextIsWaza' has a wrong offset!");
static_assert(offsetof(UPalAIActionCombatBase, NextWazaSlotIndex) == 0x000164, "Member 'UPalAIActionCombatBase::NextWazaSlotIndex' has a wrong offset!");
static_assert(offsetof(UPalAIActionCombatBase, NextActionClass) == 0x000168, "Member 'UPalAIActionCombatBase::NextActionClass' has a wrong offset!");
static_assert(offsetof(UPalAIActionCombatBase, InterruptSkillSlotID) == 0x000170, "Member 'UPalAIActionCombatBase::InterruptSkillSlotID' has a wrong offset!");
static_assert(offsetof(UPalAIActionCombatBase, bInterruptSkill) == 0x000174, "Member 'UPalAIActionCombatBase::bInterruptSkill' has a wrong offset!");

// Class Pal.PalDungeonPointMarker
// 0x0030 (0x02D8 - 0x02A8)
class APalDungeonPointMarker final : public APalLevelObjectActor
{
public:
	TArray<struct FPalDataTableRowName_DungeonSpawnAreaData> SpawnAreaIds;                                      // 0x02A8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bEditSpawnParameter;                               // 0x02B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_282D[0x3];                                     // 0x02B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPalDungeonMarkerPointSpawnParameter   EditSpawnParameter;                                // 0x02BC(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_282E[0x4];                                     // 0x02CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class APalDungeonEntrance>        DungeonEntranceClass;                              // 0x02D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalDungeonPointMarker">();
	}
	static class APalDungeonPointMarker* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalDungeonPointMarker>();
	}
};
static_assert(alignof(APalDungeonPointMarker) == 0x000008, "Wrong alignment on APalDungeonPointMarker");
static_assert(sizeof(APalDungeonPointMarker) == 0x0002D8, "Wrong size on APalDungeonPointMarker");
static_assert(offsetof(APalDungeonPointMarker, SpawnAreaIds) == 0x0002A8, "Member 'APalDungeonPointMarker::SpawnAreaIds' has a wrong offset!");
static_assert(offsetof(APalDungeonPointMarker, bEditSpawnParameter) == 0x0002B8, "Member 'APalDungeonPointMarker::bEditSpawnParameter' has a wrong offset!");
static_assert(offsetof(APalDungeonPointMarker, EditSpawnParameter) == 0x0002BC, "Member 'APalDungeonPointMarker::EditSpawnParameter' has a wrong offset!");
static_assert(offsetof(APalDungeonPointMarker, DungeonEntranceClass) == 0x0002D0, "Member 'APalDungeonPointMarker::DungeonEntranceClass' has a wrong offset!");

// Class Pal.PalMapObjectSwitchOnInWorking
// 0x0000 (0x0218 - 0x0218)
class UPalMapObjectSwitchOnInWorking final : public UPalMapObjectConcreteModelBase
{
public:
	void OnUpdateAssignedCharacter_ServerInternal(class UPalWorkBase* Work);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectSwitchOnInWorking">();
	}
	static class UPalMapObjectSwitchOnInWorking* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectSwitchOnInWorking>();
	}
};
static_assert(alignof(UPalMapObjectSwitchOnInWorking) == 0x000008, "Wrong alignment on UPalMapObjectSwitchOnInWorking");
static_assert(sizeof(UPalMapObjectSwitchOnInWorking) == 0x000218, "Wrong size on UPalMapObjectSwitchOnInWorking");

// Class Pal.PalAIActionBaseCampFighterCombat
// 0x0000 (0x0178 - 0x0178)
class UPalAIActionBaseCampFighterCombat : public UPalAIActionCombatBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionBaseCampFighterCombat">();
	}
	static class UPalAIActionBaseCampFighterCombat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIActionBaseCampFighterCombat>();
	}
};
static_assert(alignof(UPalAIActionBaseCampFighterCombat) == 0x000008, "Wrong alignment on UPalAIActionBaseCampFighterCombat");
static_assert(sizeof(UPalAIActionBaseCampFighterCombat) == 0x000178, "Wrong size on UPalAIActionBaseCampFighterCombat");

// Class Pal.PalAIActionBaseCampFighterCombatGunner
// 0x0010 (0x0188 - 0x0178)
class UPalAIActionBaseCampFighterCombatGunner : public UPalAIActionCombatBase
{
public:
	float                                         FaceAngleRange;                                    // 0x0178(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UPalMapObjectDefenseBulletLauncherModel> WeakDefenseModel;                                  // 0x017C(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_282F[0x4];                                     // 0x0184(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionBaseCampFighterCombatGunner">();
	}
	static class UPalAIActionBaseCampFighterCombatGunner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIActionBaseCampFighterCombatGunner>();
	}
};
static_assert(alignof(UPalAIActionBaseCampFighterCombatGunner) == 0x000008, "Wrong alignment on UPalAIActionBaseCampFighterCombatGunner");
static_assert(sizeof(UPalAIActionBaseCampFighterCombatGunner) == 0x000188, "Wrong size on UPalAIActionBaseCampFighterCombatGunner");
static_assert(offsetof(UPalAIActionBaseCampFighterCombatGunner, FaceAngleRange) == 0x000178, "Member 'UPalAIActionBaseCampFighterCombatGunner::FaceAngleRange' has a wrong offset!");
static_assert(offsetof(UPalAIActionBaseCampFighterCombatGunner, WeakDefenseModel) == 0x00017C, "Member 'UPalAIActionBaseCampFighterCombatGunner::WeakDefenseModel' has a wrong offset!");

// Class Pal.PalAIActionBaseCampFighterWait
// 0x0000 (0x0140 - 0x0140)
class UPalAIActionBaseCampFighterWait : public UPalAIActionBaseCampFighterChildBase
{
public:
	const bool TryGetWaitLocation(struct FVector* Location);
	const bool TrySearchEnemy();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionBaseCampFighterWait">();
	}
	static class UPalAIActionBaseCampFighterWait* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIActionBaseCampFighterWait>();
	}
};
static_assert(alignof(UPalAIActionBaseCampFighterWait) == 0x000008, "Wrong alignment on UPalAIActionBaseCampFighterWait");
static_assert(sizeof(UPalAIActionBaseCampFighterWait) == 0x000140, "Wrong size on UPalAIActionBaseCampFighterWait");

// Class Pal.PalMapObjectCharacterMakeModel
// 0x0008 (0x0220 - 0x0218)
class UPalMapObjectCharacterMakeModel final : public UPalMapObjectConcreteModelBase
{
public:
	TSubclassOf<class UPalUserWidgetOverlayUI>    CharacterMakeWidget;                               // 0x0218(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnCloseCharacterMake(class UPalHUDDispatchParameterBase* Parameter);
	void OnCloseCheckDialog(bool Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectCharacterMakeModel">();
	}
	static class UPalMapObjectCharacterMakeModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectCharacterMakeModel>();
	}
};
static_assert(alignof(UPalMapObjectCharacterMakeModel) == 0x000008, "Wrong alignment on UPalMapObjectCharacterMakeModel");
static_assert(sizeof(UPalMapObjectCharacterMakeModel) == 0x000220, "Wrong size on UPalMapObjectCharacterMakeModel");
static_assert(offsetof(UPalMapObjectCharacterMakeModel, CharacterMakeWidget) == 0x000218, "Member 'UPalMapObjectCharacterMakeModel::CharacterMakeWidget' has a wrong offset!");

// Class Pal.PalBaseCampWorkerEvent_OverworkDeath
// 0x0000 (0x0090 - 0x0090)
class UPalBaseCampWorkerEvent_OverworkDeath final : public UPalBaseCampWorkerEventBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBaseCampWorkerEvent_OverworkDeath">();
	}
	static class UPalBaseCampWorkerEvent_OverworkDeath* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBaseCampWorkerEvent_OverworkDeath>();
	}
};
static_assert(alignof(UPalBaseCampWorkerEvent_OverworkDeath) == 0x000008, "Wrong alignment on UPalBaseCampWorkerEvent_OverworkDeath");
static_assert(sizeof(UPalBaseCampWorkerEvent_OverworkDeath) == 0x000090, "Wrong size on UPalBaseCampWorkerEvent_OverworkDeath");

// Class Pal.PalStageModelBase
// 0x0040 (0x0068 - 0x0028)
class UPalStageModelBase : public UObject
{
public:
	uint8                                         Pad_2831[0x18];                                    // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPalStageInstanceId                    InstanceId;                                        // 0x0040(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2832[0x4];                                     // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPalStagePlayerInfo>            PlayerInfos;                                       // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	void OnCompleteLoadStage_ServerInternal(class UPalStageModelBase* TargetStageModel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalStageModelBase">();
	}
	static class UPalStageModelBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalStageModelBase>();
	}
};
static_assert(alignof(UPalStageModelBase) == 0x000008, "Wrong alignment on UPalStageModelBase");
static_assert(sizeof(UPalStageModelBase) == 0x000068, "Wrong size on UPalStageModelBase");
static_assert(offsetof(UPalStageModelBase, InstanceId) == 0x000040, "Member 'UPalStageModelBase::InstanceId' has a wrong offset!");
static_assert(offsetof(UPalStageModelBase, PlayerInfos) == 0x000058, "Member 'UPalStageModelBase::PlayerInfos' has a wrong offset!");

// Class Pal.PalStageModelDungeon
// 0x0008 (0x0070 - 0x0068)
class UPalStageModelDungeon final : public UPalStageModelBase
{
public:
	class UPalDungeonInstanceModel*               InstanceModel;                                     // 0x0068(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UPalDungeonInstanceModel* GetInstanceModel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalStageModelDungeon">();
	}
	static class UPalStageModelDungeon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalStageModelDungeon>();
	}
};
static_assert(alignof(UPalStageModelDungeon) == 0x000008, "Wrong alignment on UPalStageModelDungeon");
static_assert(sizeof(UPalStageModelDungeon) == 0x000070, "Wrong size on UPalStageModelDungeon");
static_assert(offsetof(UPalStageModelDungeon, InstanceModel) == 0x000068, "Member 'UPalStageModelDungeon::InstanceModel' has a wrong offset!");

// Class Pal.PalAIActionBaseCampInUsingAmusement
// 0x0070 (0x01B0 - 0x0140)
class UPalAIActionBaseCampInUsingAmusement final : public UPalAIActionBaseCampBase
{
public:
	uint8                                         Pad_2833[0x70];                                    // 0x0140(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetUsingTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionBaseCampInUsingAmusement">();
	}
	static class UPalAIActionBaseCampInUsingAmusement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIActionBaseCampInUsingAmusement>();
	}
};
static_assert(alignof(UPalAIActionBaseCampInUsingAmusement) == 0x000008, "Wrong alignment on UPalAIActionBaseCampInUsingAmusement");
static_assert(sizeof(UPalAIActionBaseCampInUsingAmusement) == 0x0001B0, "Wrong size on UPalAIActionBaseCampInUsingAmusement");

// Class Pal.PalAIActionBaseCampRecoverHungry
// 0x0048 (0x0188 - 0x0140)
class UPalAIActionBaseCampRecoverHungry : public UPalAIActionBaseCampBase
{
public:
	uint8                                         Pad_2834[0x8];                                     // 0x0140(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  WantFoodHUDId;                                     // 0x0148(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UPalUserWidgetWorldHUD>     WantFoodHUDClass;                                  // 0x0158(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                WantFoodHUDOffset;                                 // 0x0160(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPalMonsterControllerBaseCampHungryParameter HungeryParameter;                                  // 0x0178(0x000C)(Edit, BlueprintVisible, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2835[0x4];                                     // 0x0184(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeActionApproach();
	void ChangeActionEat();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionBaseCampRecoverHungry">();
	}
	static class UPalAIActionBaseCampRecoverHungry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIActionBaseCampRecoverHungry>();
	}
};
static_assert(alignof(UPalAIActionBaseCampRecoverHungry) == 0x000008, "Wrong alignment on UPalAIActionBaseCampRecoverHungry");
static_assert(sizeof(UPalAIActionBaseCampRecoverHungry) == 0x000188, "Wrong size on UPalAIActionBaseCampRecoverHungry");
static_assert(offsetof(UPalAIActionBaseCampRecoverHungry, WantFoodHUDId) == 0x000148, "Member 'UPalAIActionBaseCampRecoverHungry::WantFoodHUDId' has a wrong offset!");
static_assert(offsetof(UPalAIActionBaseCampRecoverHungry, WantFoodHUDClass) == 0x000158, "Member 'UPalAIActionBaseCampRecoverHungry::WantFoodHUDClass' has a wrong offset!");
static_assert(offsetof(UPalAIActionBaseCampRecoverHungry, WantFoodHUDOffset) == 0x000160, "Member 'UPalAIActionBaseCampRecoverHungry::WantFoodHUDOffset' has a wrong offset!");
static_assert(offsetof(UPalAIActionBaseCampRecoverHungry, HungeryParameter) == 0x000178, "Member 'UPalAIActionBaseCampRecoverHungry::HungeryParameter' has a wrong offset!");

// Class Pal.PalMapObjectBaseCampPoint
// 0x0020 (0x0238 - 0x0218)
class UPalMapObjectBaseCampPoint final : public UPalMapObjectConcreteModelBase
{
public:
	TSubclassOf<class UPalUserWidgetOverlayUI>    PalBoxWiget;                                       // 0x0218(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalUserWidgetOverlayUI>    CampTaskWiget;                                     // 0x0220(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  BaseCampId;                                        // 0x0228(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectBaseCampPoint">();
	}
	static class UPalMapObjectBaseCampPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectBaseCampPoint>();
	}
};
static_assert(alignof(UPalMapObjectBaseCampPoint) == 0x000008, "Wrong alignment on UPalMapObjectBaseCampPoint");
static_assert(sizeof(UPalMapObjectBaseCampPoint) == 0x000238, "Wrong size on UPalMapObjectBaseCampPoint");
static_assert(offsetof(UPalMapObjectBaseCampPoint, PalBoxWiget) == 0x000218, "Member 'UPalMapObjectBaseCampPoint::PalBoxWiget' has a wrong offset!");
static_assert(offsetof(UPalMapObjectBaseCampPoint, CampTaskWiget) == 0x000220, "Member 'UPalMapObjectBaseCampPoint::CampTaskWiget' has a wrong offset!");
static_assert(offsetof(UPalMapObjectBaseCampPoint, BaseCampId) == 0x000228, "Member 'UPalMapObjectBaseCampPoint::BaseCampId' has a wrong offset!");

// Class Pal.PalBuildObjectVisualControlComponent
// 0x00C0 (0x0160 - 0x00A0)
class UPalBuildObjectVisualControlComponent final : public UActorComponent
{
public:
	TMap<class UMeshComponent*, struct FPalBuildObjectMaterialArray> NormalMaterialMapCache;                            // 0x00A0(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<class UDecalComponent*, class UMaterialInterface*> DecalNormalMaterialMapCache;                       // 0x00F0(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2836[0x18];                                    // 0x0140(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      DamageNiagaraComp;                                 // 0x0158(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBuildObjectVisualControlComponent">();
	}
	static class UPalBuildObjectVisualControlComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBuildObjectVisualControlComponent>();
	}
};
static_assert(alignof(UPalBuildObjectVisualControlComponent) == 0x000008, "Wrong alignment on UPalBuildObjectVisualControlComponent");
static_assert(sizeof(UPalBuildObjectVisualControlComponent) == 0x000160, "Wrong size on UPalBuildObjectVisualControlComponent");
static_assert(offsetof(UPalBuildObjectVisualControlComponent, NormalMaterialMapCache) == 0x0000A0, "Member 'UPalBuildObjectVisualControlComponent::NormalMaterialMapCache' has a wrong offset!");
static_assert(offsetof(UPalBuildObjectVisualControlComponent, DecalNormalMaterialMapCache) == 0x0000F0, "Member 'UPalBuildObjectVisualControlComponent::DecalNormalMaterialMapCache' has a wrong offset!");
static_assert(offsetof(UPalBuildObjectVisualControlComponent, DamageNiagaraComp) == 0x000158, "Member 'UPalBuildObjectVisualControlComponent::DamageNiagaraComp' has a wrong offset!");

// Class Pal.PalAIActionBaseCampRecoverHungryChildBase
// 0x0008 (0x0140 - 0x0138)
class UPalAIActionBaseCampRecoverHungryChildBase : public UPalAIActionBaseCampChildBase
{
public:
	uint8                                         Pad_2837[0x8];                                     // 0x0138(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetHungryParameter(struct FPalMonsterControllerBaseCampHungryParameter* HungeryParameter);
	class UPalAIActionBaseCampRecoverHungry* GetParentRecoverHungryAction();
	struct FVector GetTargetLocation();
	bool IsAvailableDistance();
	bool IsExistEnoughFoodInTarget();
	void ToggleShowWantFoodHUD(const bool bShow);
	bool TryGetTargetMapObjectConcreteModel(class UPalMapObjectConcreteModelBase** OutTargetModel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionBaseCampRecoverHungryChildBase">();
	}
	static class UPalAIActionBaseCampRecoverHungryChildBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIActionBaseCampRecoverHungryChildBase>();
	}
};
static_assert(alignof(UPalAIActionBaseCampRecoverHungryChildBase) == 0x000008, "Wrong alignment on UPalAIActionBaseCampRecoverHungryChildBase");
static_assert(sizeof(UPalAIActionBaseCampRecoverHungryChildBase) == 0x000140, "Wrong size on UPalAIActionBaseCampRecoverHungryChildBase");

// Class Pal.PalMapObjectRepairItemParameterComponent
// 0x0008 (0x00A8 - 0x00A0)
class UPalMapObjectRepairItemParameterComponent final : public UActorComponent
{
public:
	float                                         RequiredRepairItemPercent;                         // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2839[0x4];                                     // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectRepairItemParameterComponent">();
	}
	static class UPalMapObjectRepairItemParameterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectRepairItemParameterComponent>();
	}
};
static_assert(alignof(UPalMapObjectRepairItemParameterComponent) == 0x000008, "Wrong alignment on UPalMapObjectRepairItemParameterComponent");
static_assert(sizeof(UPalMapObjectRepairItemParameterComponent) == 0x0000A8, "Wrong size on UPalMapObjectRepairItemParameterComponent");
static_assert(offsetof(UPalMapObjectRepairItemParameterComponent, RequiredRepairItemPercent) == 0x0000A0, "Member 'UPalMapObjectRepairItemParameterComponent::RequiredRepairItemPercent' has a wrong offset!");

// Class Pal.PalAIActionBaseCampRecoverHungryApproachToFoodBox
// 0x0008 (0x0148 - 0x0140)
class UPalAIActionBaseCampRecoverHungryApproachToFoodBox : public UPalAIActionBaseCampRecoverHungryChildBase
{
public:
	uint8                                         Pad_283A[0x8];                                     // 0x0140(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionBaseCampRecoverHungryApproachToFoodBox">();
	}
	static class UPalAIActionBaseCampRecoverHungryApproachToFoodBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIActionBaseCampRecoverHungryApproachToFoodBox>();
	}
};
static_assert(alignof(UPalAIActionBaseCampRecoverHungryApproachToFoodBox) == 0x000008, "Wrong alignment on UPalAIActionBaseCampRecoverHungryApproachToFoodBox");
static_assert(sizeof(UPalAIActionBaseCampRecoverHungryApproachToFoodBox) == 0x000148, "Wrong size on UPalAIActionBaseCampRecoverHungryApproachToFoodBox");

// Class Pal.PalBaseCampWorkerEvent_DodgeWork
// 0x0010 (0x00A0 - 0x0090)
class UPalBaseCampWorkerEvent_DodgeWork : public UPalBaseCampWorkerEventBase
{
public:
	TSubclassOf<class UPalAIActionBase>           ActionClass;                                       // 0x0090(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AIActionDuration;                                  // 0x0098(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TerminateSanityValueOver;                          // 0x009C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBaseCampWorkerEvent_DodgeWork">();
	}
	static class UPalBaseCampWorkerEvent_DodgeWork* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBaseCampWorkerEvent_DodgeWork>();
	}
};
static_assert(alignof(UPalBaseCampWorkerEvent_DodgeWork) == 0x000008, "Wrong alignment on UPalBaseCampWorkerEvent_DodgeWork");
static_assert(sizeof(UPalBaseCampWorkerEvent_DodgeWork) == 0x0000A0, "Wrong size on UPalBaseCampWorkerEvent_DodgeWork");
static_assert(offsetof(UPalBaseCampWorkerEvent_DodgeWork, ActionClass) == 0x000090, "Member 'UPalBaseCampWorkerEvent_DodgeWork::ActionClass' has a wrong offset!");
static_assert(offsetof(UPalBaseCampWorkerEvent_DodgeWork, AIActionDuration) == 0x000098, "Member 'UPalBaseCampWorkerEvent_DodgeWork::AIActionDuration' has a wrong offset!");
static_assert(offsetof(UPalBaseCampWorkerEvent_DodgeWork, TerminateSanityValueOver) == 0x00009C, "Member 'UPalBaseCampWorkerEvent_DodgeWork::TerminateSanityValueOver' has a wrong offset!");

// Class Pal.PalBaseCampWorkerEvent_DodgeWork_Sleep
// 0x0010 (0x00B0 - 0x00A0)
class UPalBaseCampWorkerEvent_DodgeWork_Sleep final : public UPalBaseCampWorkerEvent_DodgeWork
{
public:
	int32                                         SleepMinTime;                                      // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SanityValueStillSleeping;                          // 0x00A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFloatInterval                         WalkTime_BeforeSleep;                              // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBaseCampWorkerEvent_DodgeWork_Sleep">();
	}
	static class UPalBaseCampWorkerEvent_DodgeWork_Sleep* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBaseCampWorkerEvent_DodgeWork_Sleep>();
	}
};
static_assert(alignof(UPalBaseCampWorkerEvent_DodgeWork_Sleep) == 0x000008, "Wrong alignment on UPalBaseCampWorkerEvent_DodgeWork_Sleep");
static_assert(sizeof(UPalBaseCampWorkerEvent_DodgeWork_Sleep) == 0x0000B0, "Wrong size on UPalBaseCampWorkerEvent_DodgeWork_Sleep");
static_assert(offsetof(UPalBaseCampWorkerEvent_DodgeWork_Sleep, SleepMinTime) == 0x0000A0, "Member 'UPalBaseCampWorkerEvent_DodgeWork_Sleep::SleepMinTime' has a wrong offset!");
static_assert(offsetof(UPalBaseCampWorkerEvent_DodgeWork_Sleep, SanityValueStillSleeping) == 0x0000A4, "Member 'UPalBaseCampWorkerEvent_DodgeWork_Sleep::SanityValueStillSleeping' has a wrong offset!");
static_assert(offsetof(UPalBaseCampWorkerEvent_DodgeWork_Sleep, WalkTime_BeforeSleep) == 0x0000A8, "Member 'UPalBaseCampWorkerEvent_DodgeWork_Sleep::WalkTime_BeforeSleep' has a wrong offset!");

// Class Pal.PalUIBaseCampWaitersModel
// 0x0000 (0x0028 - 0x0028)
class UPalUIBaseCampWaitersModel final : public UObject
{
public:
	void SelectHandleSlot(const int32 DisplayIndex, const EPalItemSlotPressType PressType);

	TArray<class UPalIndividualCharacterSlot*> GetCurrentPageSlots() const;
	const int32 GetSlotCountInPage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIBaseCampWaitersModel">();
	}
	static class UPalUIBaseCampWaitersModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIBaseCampWaitersModel>();
	}
};
static_assert(alignof(UPalUIBaseCampWaitersModel) == 0x000008, "Wrong alignment on UPalUIBaseCampWaitersModel");
static_assert(sizeof(UPalUIBaseCampWaitersModel) == 0x000028, "Wrong size on UPalUIBaseCampWaitersModel");

// Class Pal.PalAIActionBaseCampRecoverHungryEat
// 0x0030 (0x0170 - 0x0140)
class UPalAIActionBaseCampRecoverHungryEat : public UPalAIActionBaseCampRecoverHungryChildBase
{
public:
	float                                         EatTime;                                           // 0x0140(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TurnSpeed;                                         // 0x0144(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_283C[0x28];                                    // 0x0148(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFinishEatingTime();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionBaseCampRecoverHungryEat">();
	}
	static class UPalAIActionBaseCampRecoverHungryEat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIActionBaseCampRecoverHungryEat>();
	}
};
static_assert(alignof(UPalAIActionBaseCampRecoverHungryEat) == 0x000008, "Wrong alignment on UPalAIActionBaseCampRecoverHungryEat");
static_assert(sizeof(UPalAIActionBaseCampRecoverHungryEat) == 0x000170, "Wrong size on UPalAIActionBaseCampRecoverHungryEat");
static_assert(offsetof(UPalAIActionBaseCampRecoverHungryEat, EatTime) == 0x000140, "Member 'UPalAIActionBaseCampRecoverHungryEat::EatTime' has a wrong offset!");
static_assert(offsetof(UPalAIActionBaseCampRecoverHungryEat, TurnSpeed) == 0x000144, "Member 'UPalAIActionBaseCampRecoverHungryEat::TurnSpeed' has a wrong offset!");

// Class Pal.PalMapObjectItemDropOnDamagModel
// 0x0028 (0x0240 - 0x0218)
class UPalMapObjectItemDropOnDamagModel final : public UPalMapObjectConcreteModelBase
{
public:
	uint8                                         Pad_283D[0x18];                                    // 0x0218(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPalItemAndNum>                 DropItemInfos;                                     // 0x0230(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	void OnDamage_ServerInternal(class UPalMapObjectModel* Model, const struct FPalDamageInfo& DamageInfo, const int32 LastHp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectItemDropOnDamagModel">();
	}
	static class UPalMapObjectItemDropOnDamagModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectItemDropOnDamagModel>();
	}
};
static_assert(alignof(UPalMapObjectItemDropOnDamagModel) == 0x000008, "Wrong alignment on UPalMapObjectItemDropOnDamagModel");
static_assert(sizeof(UPalMapObjectItemDropOnDamagModel) == 0x000240, "Wrong size on UPalMapObjectItemDropOnDamagModel");
static_assert(offsetof(UPalMapObjectItemDropOnDamagModel, DropItemInfos) == 0x000230, "Member 'UPalMapObjectItemDropOnDamagModel::DropItemInfos' has a wrong offset!");

// Class Pal.PalAIActionBaseCampRecoverHungryProductFood
// 0x0008 (0x0148 - 0x0140)
class UPalAIActionBaseCampRecoverHungryProductFood final : public UPalAIActionBaseCampRecoverHungryChildBase
{
public:
	uint8                                         Pad_283F[0x8];                                     // 0x0140(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionBaseCampRecoverHungryProductFood">();
	}
	static class UPalAIActionBaseCampRecoverHungryProductFood* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIActionBaseCampRecoverHungryProductFood>();
	}
};
static_assert(alignof(UPalAIActionBaseCampRecoverHungryProductFood) == 0x000008, "Wrong alignment on UPalAIActionBaseCampRecoverHungryProductFood");
static_assert(sizeof(UPalAIActionBaseCampRecoverHungryProductFood) == 0x000148, "Wrong size on UPalAIActionBaseCampRecoverHungryProductFood");

// Class Pal.PalEventNotifySystem_Concrete
// 0x0000 (0x0028 - 0x0028)
class UPalEventNotifySystem_Concrete final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalEventNotifySystem_Concrete">();
	}
	static class UPalEventNotifySystem_Concrete* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalEventNotifySystem_Concrete>();
	}
};
static_assert(alignof(UPalEventNotifySystem_Concrete) == 0x000008, "Wrong alignment on UPalEventNotifySystem_Concrete");
static_assert(sizeof(UPalEventNotifySystem_Concrete) == 0x000028, "Wrong size on UPalEventNotifySystem_Concrete");

// Class Pal.PalAIActionBaseCampReturnBack
// 0x0010 (0x0140 - 0x0130)
class UPalAIActionBaseCampReturnBack final : public UPalAIActionBase
{
public:
	uint8                                         Pad_2840[0x10];                                    // 0x0130(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionBaseCampReturnBack">();
	}
	static class UPalAIActionBaseCampReturnBack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIActionBaseCampReturnBack>();
	}
};
static_assert(alignof(UPalAIActionBaseCampReturnBack) == 0x000008, "Wrong alignment on UPalAIActionBaseCampReturnBack");
static_assert(sizeof(UPalAIActionBaseCampReturnBack) == 0x000140, "Wrong size on UPalAIActionBaseCampReturnBack");

// Class Pal.PalMapObjectModelConnectorBase
// 0x0020 (0x0048 - 0x0028)
class UPalMapObjectModelConnectorBase : public UObject
{
public:
	int32                                         SupportedLevel;                                    // 0x0028(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2841[0x4];                                     // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPalMapObjectModelConnectInfo          ConnectInfoAnyPlace;                               // 0x0030(0x0018)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectModelConnectorBase">();
	}
	static class UPalMapObjectModelConnectorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectModelConnectorBase>();
	}
};
static_assert(alignof(UPalMapObjectModelConnectorBase) == 0x000008, "Wrong alignment on UPalMapObjectModelConnectorBase");
static_assert(sizeof(UPalMapObjectModelConnectorBase) == 0x000048, "Wrong size on UPalMapObjectModelConnectorBase");
static_assert(offsetof(UPalMapObjectModelConnectorBase, SupportedLevel) == 0x000028, "Member 'UPalMapObjectModelConnectorBase::SupportedLevel' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModelConnectorBase, ConnectInfoAnyPlace) == 0x000030, "Member 'UPalMapObjectModelConnectorBase::ConnectInfoAnyPlace' has a wrong offset!");

// Class Pal.PalMapObjectModelConnectorAttach
// 0x0000 (0x0048 - 0x0048)
class UPalMapObjectModelConnectorAttach : public UPalMapObjectModelConnectorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectModelConnectorAttach">();
	}
	static class UPalMapObjectModelConnectorAttach* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectModelConnectorAttach>();
	}
};
static_assert(alignof(UPalMapObjectModelConnectorAttach) == 0x000008, "Wrong alignment on UPalMapObjectModelConnectorAttach");
static_assert(sizeof(UPalMapObjectModelConnectorAttach) == 0x000048, "Wrong size on UPalMapObjectModelConnectorAttach");

// Class Pal.PalMapObjectModelConnectorAttachToWall
// 0x0000 (0x0048 - 0x0048)
class UPalMapObjectModelConnectorAttachToWall final : public UPalMapObjectModelConnectorAttach
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectModelConnectorAttachToWall">();
	}
	static class UPalMapObjectModelConnectorAttachToWall* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectModelConnectorAttachToWall>();
	}
};
static_assert(alignof(UPalMapObjectModelConnectorAttachToWall) == 0x000008, "Wrong alignment on UPalMapObjectModelConnectorAttachToWall");
static_assert(sizeof(UPalMapObjectModelConnectorAttachToWall) == 0x000048, "Wrong size on UPalMapObjectModelConnectorAttachToWall");

// Class Pal.PalFunnelCharacterManager
// 0x00A0 (0x0110 - 0x0070)
class UPalFunnelCharacterManager : public UPalWorldSubsystem
{
public:
	TMap<struct FGuid, struct FPalFunnelCharacterManagementInfo> ManagedCharacterInfo;                              // 0x0070(0x0050)(NativeAccessSpecifierPrivate)
	TMap<struct FGuid, struct FPalInstanceID>     PickupTarget;                                      // 0x00C0(0x0050)(NativeAccessSpecifierPrivate)

public:
	void Initialize_BP();
	void InitializeForServer_BP();
	void SetFunnelCharacterActive(class APalFunnelCharacter* FunnelCharacter, bool IsActive);
	void SpawnActorCallback(const struct FGuid& Guid, class AActor* Actor);

	int32 GetIndexOfFunnelsWithinSameTrainer(class APalFunnelCharacter* FunnelCharacter) const;
	class APalCharacter* GetOwnerCharacter(const class APalFunnelCharacter* FunnelCharacter) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalFunnelCharacterManager">();
	}
	static class UPalFunnelCharacterManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalFunnelCharacterManager>();
	}
};
static_assert(alignof(UPalFunnelCharacterManager) == 0x000008, "Wrong alignment on UPalFunnelCharacterManager");
static_assert(sizeof(UPalFunnelCharacterManager) == 0x000110, "Wrong size on UPalFunnelCharacterManager");
static_assert(offsetof(UPalFunnelCharacterManager, ManagedCharacterInfo) == 0x000070, "Member 'UPalFunnelCharacterManager::ManagedCharacterInfo' has a wrong offset!");
static_assert(offsetof(UPalFunnelCharacterManager, PickupTarget) == 0x0000C0, "Member 'UPalFunnelCharacterManager::PickupTarget' has a wrong offset!");

// Class Pal.PalAIActionBaseCampSleep
// 0x0070 (0x01B0 - 0x0140)
class UPalAIActionBaseCampSleep : public UPalAIActionBaseCampBase
{
public:
	uint8                                         Pad_2844[0x70];                                    // 0x0140(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionBaseCampSleep">();
	}
	static class UPalAIActionBaseCampSleep* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIActionBaseCampSleep>();
	}
};
static_assert(alignof(UPalAIActionBaseCampSleep) == 0x000008, "Wrong alignment on UPalAIActionBaseCampSleep");
static_assert(sizeof(UPalAIActionBaseCampSleep) == 0x0001B0, "Wrong size on UPalAIActionBaseCampSleep");

// Class Pal.PalMasterDataTableAccessBase
// 0x0008 (0x0030 - 0x0028)
class UPalMasterDataTableAccessBase : public UObject
{
public:
	class UDataTable*                             DataTable;                                         // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	TArray<class FName> GetRowNames() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMasterDataTableAccessBase">();
	}
	static class UPalMasterDataTableAccessBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMasterDataTableAccessBase>();
	}
};
static_assert(alignof(UPalMasterDataTableAccessBase) == 0x000008, "Wrong alignment on UPalMasterDataTableAccessBase");
static_assert(sizeof(UPalMasterDataTableAccessBase) == 0x000030, "Wrong size on UPalMasterDataTableAccessBase");
static_assert(offsetof(UPalMasterDataTableAccessBase, DataTable) == 0x000028, "Member 'UPalMasterDataTableAccessBase::DataTable' has a wrong offset!");

// Class Pal.PalMasterDataTableAccess_DungeonLevelData
// 0x0000 (0x0030 - 0x0030)
class UPalMasterDataTableAccess_DungeonLevelData final : public UPalMasterDataTableAccessBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMasterDataTableAccess_DungeonLevelData">();
	}
	static class UPalMasterDataTableAccess_DungeonLevelData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMasterDataTableAccess_DungeonLevelData>();
	}
};
static_assert(alignof(UPalMasterDataTableAccess_DungeonLevelData) == 0x000008, "Wrong alignment on UPalMasterDataTableAccess_DungeonLevelData");
static_assert(sizeof(UPalMasterDataTableAccess_DungeonLevelData) == 0x000030, "Wrong size on UPalMasterDataTableAccess_DungeonLevelData");

// Class Pal.PalCharacterContainerDefine
// 0x0000 (0x0028 - 0x0028)
class UPalCharacterContainerDefine final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalCharacterContainerDefine">();
	}
	static class UPalCharacterContainerDefine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalCharacterContainerDefine>();
	}
};
static_assert(alignof(UPalCharacterContainerDefine) == 0x000008, "Wrong alignment on UPalCharacterContainerDefine");
static_assert(sizeof(UPalCharacterContainerDefine) == 0x000028, "Wrong size on UPalCharacterContainerDefine");

// Class Pal.PalAIActionBaseCampSleepActively
// 0x0060 (0x01A0 - 0x0140)
class UPalAIActionBaseCampSleepActively : public UPalAIActionBaseCampBase
{
public:
	uint8                                         Pad_2845[0x8];                                     // 0x0140(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  ReservedBedModelInstanceId;                        // 0x0148(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPalAIActionBaseCampSleepActivelyMode         Mode;                                              // 0x0158(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2846[0x47];                                    // 0x0159(0x0047)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetParameter(const struct FPalAIActionBaseCampSleepActivelyParameter& Parameter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionBaseCampSleepActively">();
	}
	static class UPalAIActionBaseCampSleepActively* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIActionBaseCampSleepActively>();
	}
};
static_assert(alignof(UPalAIActionBaseCampSleepActively) == 0x000008, "Wrong alignment on UPalAIActionBaseCampSleepActively");
static_assert(sizeof(UPalAIActionBaseCampSleepActively) == 0x0001A0, "Wrong size on UPalAIActionBaseCampSleepActively");
static_assert(offsetof(UPalAIActionBaseCampSleepActively, ReservedBedModelInstanceId) == 0x000148, "Member 'UPalAIActionBaseCampSleepActively::ReservedBedModelInstanceId' has a wrong offset!");
static_assert(offsetof(UPalAIActionBaseCampSleepActively, Mode) == 0x000158, "Member 'UPalAIActionBaseCampSleepActively::Mode' has a wrong offset!");

// Class Pal.PalFoliageInstance
// 0x0158 (0x0180 - 0x0028)
class UPalFoliageInstance final : public UObject
{
public:
	uint8                                         Pad_2847[0x20];                                    // 0x0028(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, bool>                             DirtyMap;                                          // 0x0048(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_2848[0x20];                                    // 0x0098(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPalFoliageInstanceId                  InstanceId;                                        // 0x00B8(0x0010)(Edit, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   FoliageTypeId;                                     // 0x00C8(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         HP;                                                // 0x00D0(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAlive;                                            // 0x00D4(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2849[0x3];                                     // 0x00D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPalFoliageInstanceTransform           WorldTransform;                                    // 0x00D8(0x0038)(Edit, Net, DisableEditOnTemplate, Transient, EditConst, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	struct FTransform                             WorldTransformCache;                               // 0x0110(0x0060)(Edit, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameDateTime                          RespawnTimeAt;                                     // 0x0170(0x0008)(Edit, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_284A[0x8];                                     // 0x0178(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FoliageInstanceDelegate__DelegateSignature(class UPalFoliageInstance* Instance);
	void OnRep_Alive(bool bOldValue);
	void OnRep_WorldTransform();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalFoliageInstance">();
	}
	static class UPalFoliageInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalFoliageInstance>();
	}
};
static_assert(alignof(UPalFoliageInstance) == 0x000010, "Wrong alignment on UPalFoliageInstance");
static_assert(sizeof(UPalFoliageInstance) == 0x000180, "Wrong size on UPalFoliageInstance");
static_assert(offsetof(UPalFoliageInstance, DirtyMap) == 0x000048, "Member 'UPalFoliageInstance::DirtyMap' has a wrong offset!");
static_assert(offsetof(UPalFoliageInstance, InstanceId) == 0x0000B8, "Member 'UPalFoliageInstance::InstanceId' has a wrong offset!");
static_assert(offsetof(UPalFoliageInstance, FoliageTypeId) == 0x0000C8, "Member 'UPalFoliageInstance::FoliageTypeId' has a wrong offset!");
static_assert(offsetof(UPalFoliageInstance, HP) == 0x0000D0, "Member 'UPalFoliageInstance::HP' has a wrong offset!");
static_assert(offsetof(UPalFoliageInstance, bAlive) == 0x0000D4, "Member 'UPalFoliageInstance::bAlive' has a wrong offset!");
static_assert(offsetof(UPalFoliageInstance, WorldTransform) == 0x0000D8, "Member 'UPalFoliageInstance::WorldTransform' has a wrong offset!");
static_assert(offsetof(UPalFoliageInstance, WorldTransformCache) == 0x000110, "Member 'UPalFoliageInstance::WorldTransformCache' has a wrong offset!");
static_assert(offsetof(UPalFoliageInstance, RespawnTimeAt) == 0x000170, "Member 'UPalFoliageInstance::RespawnTimeAt' has a wrong offset!");

// Class Pal.PalAIActionBaseCampSpawningForWorker
// 0x0010 (0x0140 - 0x0130)
class UPalAIActionBaseCampSpawningForWorker : public UPalAIActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnLandedWorldStaticDelegate;                       // 0x0130(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void OnLanded(const struct FHitResult& Hit);
	void SimpleMulticastDelegate__DelegateSignature();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionBaseCampSpawningForWorker">();
	}
	static class UPalAIActionBaseCampSpawningForWorker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIActionBaseCampSpawningForWorker>();
	}
};
static_assert(alignof(UPalAIActionBaseCampSpawningForWorker) == 0x000008, "Wrong alignment on UPalAIActionBaseCampSpawningForWorker");
static_assert(sizeof(UPalAIActionBaseCampSpawningForWorker) == 0x000140, "Wrong size on UPalAIActionBaseCampSpawningForWorker");
static_assert(offsetof(UPalAIActionBaseCampSpawningForWorker, OnLandedWorldStaticDelegate) == 0x000130, "Member 'UPalAIActionBaseCampSpawningForWorker::OnLandedWorldStaticDelegate' has a wrong offset!");

// Class Pal.PalMasterDataTableAccess_MapObjectMasterData
// 0x0000 (0x0030 - 0x0030)
class UPalMasterDataTableAccess_MapObjectMasterData final : public UPalMasterDataTableAccessBase
{
public:
	void BPExec_FindRow(class FName RowName, EPalMasterDataExecPinType* ExecType, struct FPalMapObjectMasterData* OutData);

	struct FPalMapObjectMasterData BP_FindRow(class FName RowName, bool* bResult) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMasterDataTableAccess_MapObjectMasterData">();
	}
	static class UPalMasterDataTableAccess_MapObjectMasterData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMasterDataTableAccess_MapObjectMasterData>();
	}
};
static_assert(alignof(UPalMasterDataTableAccess_MapObjectMasterData) == 0x000008, "Wrong alignment on UPalMasterDataTableAccess_MapObjectMasterData");
static_assert(sizeof(UPalMasterDataTableAccess_MapObjectMasterData) == 0x000030, "Wrong size on UPalMasterDataTableAccess_MapObjectMasterData");

// Class Pal.PalAnimNotifyState_HidePalWeapon
// 0x0000 (0x0030 - 0x0030)
class UPalAnimNotifyState_HidePalWeapon final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAnimNotifyState_HidePalWeapon">();
	}
	static class UPalAnimNotifyState_HidePalWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAnimNotifyState_HidePalWeapon>();
	}
};
static_assert(alignof(UPalAnimNotifyState_HidePalWeapon) == 0x000008, "Wrong alignment on UPalAnimNotifyState_HidePalWeapon");
static_assert(sizeof(UPalAnimNotifyState_HidePalWeapon) == 0x000030, "Wrong size on UPalAnimNotifyState_HidePalWeapon");

// Class Pal.PalAIActionBaseCampTrantrum
// 0x0030 (0x0160 - 0x0130)
class UPalAIActionBaseCampTrantrum final : public UPalAIActionBase
{
public:
	float                                         Duration;                                          // 0x0130(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RadiusAttackTo;                                    // 0x0134(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FInt32Interval                         AttackNumRange;                                    // 0x0138(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurnSpeedToAttack;                                 // 0x0140(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  AttackTargetMapObjectInstanceId;                   // 0x0144(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_284D[0xC];                                     // 0x0154(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionBaseCampTrantrum">();
	}
	static class UPalAIActionBaseCampTrantrum* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIActionBaseCampTrantrum>();
	}
};
static_assert(alignof(UPalAIActionBaseCampTrantrum) == 0x000008, "Wrong alignment on UPalAIActionBaseCampTrantrum");
static_assert(sizeof(UPalAIActionBaseCampTrantrum) == 0x000160, "Wrong size on UPalAIActionBaseCampTrantrum");
static_assert(offsetof(UPalAIActionBaseCampTrantrum, Duration) == 0x000130, "Member 'UPalAIActionBaseCampTrantrum::Duration' has a wrong offset!");
static_assert(offsetof(UPalAIActionBaseCampTrantrum, RadiusAttackTo) == 0x000134, "Member 'UPalAIActionBaseCampTrantrum::RadiusAttackTo' has a wrong offset!");
static_assert(offsetof(UPalAIActionBaseCampTrantrum, AttackNumRange) == 0x000138, "Member 'UPalAIActionBaseCampTrantrum::AttackNumRange' has a wrong offset!");
static_assert(offsetof(UPalAIActionBaseCampTrantrum, TurnSpeedToAttack) == 0x000140, "Member 'UPalAIActionBaseCampTrantrum::TurnSpeedToAttack' has a wrong offset!");
static_assert(offsetof(UPalAIActionBaseCampTrantrum, AttackTargetMapObjectInstanceId) == 0x000144, "Member 'UPalAIActionBaseCampTrantrum::AttackTargetMapObjectInstanceId' has a wrong offset!");

// Class Pal.PalGroupManager
// 0x01F8 (0x0268 - 0x0070)
class UPalGroupManager : public UPalWorldSubsystem
{
public:
	uint8                                         Pad_284E[0x8];                                     // 0x0070(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGuid, class UPalGroupBase*>      GroupMap;                                          // 0x0078(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGuid, class UPalGroupGuildBase*> GuildMap;                                          // 0x00C8(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TMap<EPalOrganizationType, EPalGroupType>     StaticOrganizationGroupTypeMap;                    // 0x0118(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<EPalOrganizationType, struct FGuid>      StaticOrganizationGroupIdMap;                      // 0x0168(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_284F[0x10];                                    // 0x01B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGuid, class UPalGuildRequestFlowBase*> GuildRequestFlowMap;                               // 0x01C8(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGuid, struct FPalGuildEnterRequestLogInfo> GuildEnterRequestLogInfoMap;                       // 0x0218(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	static const struct FGuid GetOrganizationGroupId(const class UObject* WorldContextObject, const EPalOrganizationType OrganizationType);

	void Debug_RequestDisposeGroup(const struct FGuid& GroupID, TDelegate<void(EPalGroupOperationResult Result)> Callback);
	void Debug_RequestEnterGroup(const struct FPalInstanceID& IndividualId, const struct FGuid& GroupID, TDelegate<void(EPalGroupOperationResult Result)> Callback);
	void Debug_RequestExitGroup(const struct FPalInstanceID& IndividualId, TDelegate<void(EPalGroupOperationResult Result)> Callback);
	void Debug_RequestNewGroup(const struct FPalGroupCreateParameter& CreateParam, TDelegate<void(EPalGroupOperationResult Result, struct FGuid& GroupID)> Callback);
	bool IsInGuild(const class AActor* TargetActor);
	void OnFinishedGuildRequest_ServerInternal(class UPalGuildRequestFlowBase* Flow);

	class UPalGroupBase* Debug_GetFirstGroupByType(const EPalGroupType Type) const;
	bool IsExistGroup(const class FString& GroupName) const;
	bool TryGetGroupName(const struct FGuid& GroupID, class FString* OutGroupName) const;
	bool TryGetGuildName(const struct FGuid& GroupID, class FString* OutGuildName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGroupManager">();
	}
	static class UPalGroupManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalGroupManager>();
	}
};
static_assert(alignof(UPalGroupManager) == 0x000008, "Wrong alignment on UPalGroupManager");
static_assert(sizeof(UPalGroupManager) == 0x000268, "Wrong size on UPalGroupManager");
static_assert(offsetof(UPalGroupManager, GroupMap) == 0x000078, "Member 'UPalGroupManager::GroupMap' has a wrong offset!");
static_assert(offsetof(UPalGroupManager, GuildMap) == 0x0000C8, "Member 'UPalGroupManager::GuildMap' has a wrong offset!");
static_assert(offsetof(UPalGroupManager, StaticOrganizationGroupTypeMap) == 0x000118, "Member 'UPalGroupManager::StaticOrganizationGroupTypeMap' has a wrong offset!");
static_assert(offsetof(UPalGroupManager, StaticOrganizationGroupIdMap) == 0x000168, "Member 'UPalGroupManager::StaticOrganizationGroupIdMap' has a wrong offset!");
static_assert(offsetof(UPalGroupManager, GuildRequestFlowMap) == 0x0001C8, "Member 'UPalGroupManager::GuildRequestFlowMap' has a wrong offset!");
static_assert(offsetof(UPalGroupManager, GuildEnterRequestLogInfoMap) == 0x000218, "Member 'UPalGroupManager::GuildEnterRequestLogInfoMap' has a wrong offset!");

// Class Pal.PalMapObjectTreasureBox
// 0x0030 (0x03E0 - 0x03B0)
class APalMapObjectTreasureBox final : public APalMapObject
{
public:
	struct FVector                                DropItemLocalLocation;                             // 0x03B0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2857[0x18];                                    // 0x03C8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastTriggerOpen();
	void NotifyStartOpenInAnimation();
	void OnReceiveOpenInServer(class UPalMapObjectConcreteModelBase* ConcreteModel);
	void TriggerOpen();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectTreasureBox">();
	}
	static class APalMapObjectTreasureBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalMapObjectTreasureBox>();
	}
};
static_assert(alignof(APalMapObjectTreasureBox) == 0x000008, "Wrong alignment on APalMapObjectTreasureBox");
static_assert(sizeof(APalMapObjectTreasureBox) == 0x0003E0, "Wrong size on APalMapObjectTreasureBox");
static_assert(offsetof(APalMapObjectTreasureBox, DropItemLocalLocation) == 0x0003B0, "Member 'APalMapObjectTreasureBox::DropItemLocalLocation' has a wrong offset!");

// Class Pal.PalAIActionBaseCampUtility
// 0x0000 (0x0028 - 0x0028)
class UPalAIActionBaseCampUtility final : public UBlueprintFunctionLibrary
{
public:
	static EAIRequestPriority GetRequestSoftScriptPriority(const EPalRequestSoftScriptPriorityAdd AddPriority);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionBaseCampUtility">();
	}
	static class UPalAIActionBaseCampUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIActionBaseCampUtility>();
	}
};
static_assert(alignof(UPalAIActionBaseCampUtility) == 0x000008, "Wrong alignment on UPalAIActionBaseCampUtility");
static_assert(sizeof(UPalAIActionBaseCampUtility) == 0x000028, "Wrong size on UPalAIActionBaseCampUtility");

// Class Pal.PalAIActionCollectItemToStorage
// 0x0000 (0x0130 - 0x0130)
class UPalAIActionCollectItemToStorage final : public UPalAIActionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionCollectItemToStorage">();
	}
	static class UPalAIActionCollectItemToStorage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIActionCollectItemToStorage>();
	}
};
static_assert(alignof(UPalAIActionCollectItemToStorage) == 0x000008, "Wrong alignment on UPalAIActionCollectItemToStorage");
static_assert(sizeof(UPalAIActionCollectItemToStorage) == 0x000130, "Wrong size on UPalAIActionCollectItemToStorage");

// Class Pal.PalWorkProgress
// 0x0050 (0x0370 - 0x0320)
class UPalWorkProgress final : public UPalWorkBase
{
public:
	uint8                                         Pad_2858[0x8];                                     // 0x0318(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnUpdateWorkAmountInServerDelegate;                // 0x0320(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnReflectWorkAmountDelegate;                       // 0x0330(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         RequiredWorkAmount;                                // 0x0340(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentWorkAmount;                                 // 0x0344(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentWorkAmountByLocalPlayer;                    // 0x0348(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2859[0x4];                                     // 0x034C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGuid>                          WorkingPlayerUIds;                                 // 0x0350(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	int32                                         WorkExp;                                           // 0x0360(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AutoWorkSelfAmountBySec;                           // 0x0364(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNotAllowReactionOnWorkComplete;                   // 0x0368(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_285A[0x3];                                     // 0x0369(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProgressTimeSinceLastTick;                         // 0x036C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void NotifyWorkProgressDelegate__DelegateSignature(class UPalWorkProgress* WorkProgress);
	void OnRep_CurrentWorkAmount();

	float GetCurrentWorkAmount() const;
	float GetProgressRate() const;
	float GetRemainWorkAmount() const;
	int32 GetRemainWorkPredicateTime() const;
	float GetRequiredWorkAmount() const;
	bool IsCompleted() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorkProgress">();
	}
	static class UPalWorkProgress* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWorkProgress>();
	}
};
static_assert(alignof(UPalWorkProgress) == 0x000010, "Wrong alignment on UPalWorkProgress");
static_assert(sizeof(UPalWorkProgress) == 0x000370, "Wrong size on UPalWorkProgress");
static_assert(offsetof(UPalWorkProgress, OnUpdateWorkAmountInServerDelegate) == 0x000320, "Member 'UPalWorkProgress::OnUpdateWorkAmountInServerDelegate' has a wrong offset!");
static_assert(offsetof(UPalWorkProgress, OnReflectWorkAmountDelegate) == 0x000330, "Member 'UPalWorkProgress::OnReflectWorkAmountDelegate' has a wrong offset!");
static_assert(offsetof(UPalWorkProgress, RequiredWorkAmount) == 0x000340, "Member 'UPalWorkProgress::RequiredWorkAmount' has a wrong offset!");
static_assert(offsetof(UPalWorkProgress, CurrentWorkAmount) == 0x000344, "Member 'UPalWorkProgress::CurrentWorkAmount' has a wrong offset!");
static_assert(offsetof(UPalWorkProgress, CurrentWorkAmountByLocalPlayer) == 0x000348, "Member 'UPalWorkProgress::CurrentWorkAmountByLocalPlayer' has a wrong offset!");
static_assert(offsetof(UPalWorkProgress, WorkingPlayerUIds) == 0x000350, "Member 'UPalWorkProgress::WorkingPlayerUIds' has a wrong offset!");
static_assert(offsetof(UPalWorkProgress, WorkExp) == 0x000360, "Member 'UPalWorkProgress::WorkExp' has a wrong offset!");
static_assert(offsetof(UPalWorkProgress, AutoWorkSelfAmountBySec) == 0x000364, "Member 'UPalWorkProgress::AutoWorkSelfAmountBySec' has a wrong offset!");
static_assert(offsetof(UPalWorkProgress, bNotAllowReactionOnWorkComplete) == 0x000368, "Member 'UPalWorkProgress::bNotAllowReactionOnWorkComplete' has a wrong offset!");
static_assert(offsetof(UPalWorkProgress, ProgressTimeSinceLastTick) == 0x00036C, "Member 'UPalWorkProgress::ProgressTimeSinceLastTick' has a wrong offset!");

// Class Pal.PalFoliageISMComponent
// 0x0000 (0x0900 - 0x0900)
class UPalFoliageISMComponent : public UFoliageInstancedStaticMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalFoliageISMComponent">();
	}
	static class UPalFoliageISMComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalFoliageISMComponent>();
	}
};
static_assert(alignof(UPalFoliageISMComponent) == 0x000010, "Wrong alignment on UPalFoliageISMComponent");
static_assert(sizeof(UPalFoliageISMComponent) == 0x000900, "Wrong size on UPalFoliageISMComponent");

// Class Pal.PalFoliageISMComponentBase
// 0x0050 (0x0950 - 0x0900)
class UPalFoliageISMComponentBase final : public UPalFoliageISMComponent
{
public:
	TMap<struct FVector, int32>                   InstanceIndexMapByLocation;                        // 0x0900(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)

public:
	void DespawnInstance(class UPalFoliageInstance* Instance);
	void OnDisposeModel(class UPalMapObjectFoliageModel* Model);
	void OnReceiveDamageInClient(const struct FPalDamageInfo& DamageInfo);
	void OnRegisterInstance(const class FName FoliageTypeId, class UPalFoliageInstance* Instance);
	void OnRemoveInstance(const class FName FoliageTypeId, class UPalFoliageInstance* Instance);
	void SpawnInstance(class UPalFoliageInstance* Instance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalFoliageISMComponentBase">();
	}
	static class UPalFoliageISMComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalFoliageISMComponentBase>();
	}
};
static_assert(alignof(UPalFoliageISMComponentBase) == 0x000010, "Wrong alignment on UPalFoliageISMComponentBase");
static_assert(sizeof(UPalFoliageISMComponentBase) == 0x000950, "Wrong size on UPalFoliageISMComponentBase");
static_assert(offsetof(UPalFoliageISMComponentBase, InstanceIndexMapByLocation) == 0x000900, "Member 'UPalFoliageISMComponentBase::InstanceIndexMapByLocation' has a wrong offset!");

// Class Pal.PalCharacterOnCompleteInitializeParameterWrapper
// 0x0010 (0x0038 - 0x0028)
class UPalCharacterOnCompleteInitializeParameterWrapper final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnCompleteInitializeParameterDelegate;             // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void Broadcast(class APalCharacter* Character) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalCharacterOnCompleteInitializeParameterWrapper">();
	}
	static class UPalCharacterOnCompleteInitializeParameterWrapper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalCharacterOnCompleteInitializeParameterWrapper>();
	}
};
static_assert(alignof(UPalCharacterOnCompleteInitializeParameterWrapper) == 0x000008, "Wrong alignment on UPalCharacterOnCompleteInitializeParameterWrapper");
static_assert(sizeof(UPalCharacterOnCompleteInitializeParameterWrapper) == 0x000038, "Wrong size on UPalCharacterOnCompleteInitializeParameterWrapper");
static_assert(offsetof(UPalCharacterOnCompleteInitializeParameterWrapper, OnCompleteInitializeParameterDelegate) == 0x000028, "Member 'UPalCharacterOnCompleteInitializeParameterWrapper::OnCompleteInitializeParameterDelegate' has a wrong offset!");

// Class Pal.PalMapObjectModelInitializeExtraParameterItemDropObject
// 0x0010 (0x0038 - 0x0028)
class UPalMapObjectModelInitializeExtraParameterItemDropObject final : public UPalMapObjectModelInitializeExtraParameterBase
{
public:
	TArray<struct FPalItemAndNum>                 ItemInfos;                                         // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectModelInitializeExtraParameterItemDropObject">();
	}
	static class UPalMapObjectModelInitializeExtraParameterItemDropObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectModelInitializeExtraParameterItemDropObject>();
	}
};
static_assert(alignof(UPalMapObjectModelInitializeExtraParameterItemDropObject) == 0x000008, "Wrong alignment on UPalMapObjectModelInitializeExtraParameterItemDropObject");
static_assert(sizeof(UPalMapObjectModelInitializeExtraParameterItemDropObject) == 0x000038, "Wrong size on UPalMapObjectModelInitializeExtraParameterItemDropObject");
static_assert(offsetof(UPalMapObjectModelInitializeExtraParameterItemDropObject, ItemInfos) == 0x000028, "Member 'UPalMapObjectModelInitializeExtraParameterItemDropObject::ItemInfos' has a wrong offset!");

// Class Pal.PalAIActionCombat_BaseCamp
// 0x0000 (0x0178 - 0x0178)
class UPalAIActionCombat_BaseCamp final : public UPalAIActionCombatBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionCombat_BaseCamp">();
	}
	static class UPalAIActionCombat_BaseCamp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIActionCombat_BaseCamp>();
	}
};
static_assert(alignof(UPalAIActionCombat_BaseCamp) == 0x000008, "Wrong alignment on UPalAIActionCombat_BaseCamp");
static_assert(sizeof(UPalAIActionCombat_BaseCamp) == 0x000178, "Wrong size on UPalAIActionCombat_BaseCamp");

// Class Pal.PalAIActionCombat_Standard
// 0x0000 (0x0178 - 0x0178)
class UPalAIActionCombat_Standard final : public UPalAIActionCombatBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionCombat_Standard">();
	}
	static class UPalAIActionCombat_Standard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIActionCombat_Standard>();
	}
};
static_assert(alignof(UPalAIActionCombat_Standard) == 0x000008, "Wrong alignment on UPalAIActionCombat_Standard");
static_assert(sizeof(UPalAIActionCombat_Standard) == 0x000178, "Wrong size on UPalAIActionCombat_Standard");

// Class Pal.PalAISensorComponent
// 0x0098 (0x0138 - 0x00A0)
class UPalAISensorComponent final : public UActorComponent
{
public:
	class AActor*                                 SelfPawn;                                          // 0x00A0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SightAngleThreshold;                               // 0x00A8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SightDistance;                                     // 0x00AC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HearingRate;                                       // 0x00B0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          HumanAndNoneWeapon;                                // 0x00B4(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsIgnoreSoundReaction;                             // 0x00B5(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_285B[0x2];                                     // 0x00B6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RecentMaxSoundLevel;                               // 0x00B8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_285C[0x8];                                     // 0x00BC(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ResponsedMaxBiologicalGrade;                       // 0x00C4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalAIResponsePreset*                   AIResponsePreset;                                  // 0x00C8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalAISightResponse*                    AISightResponse;                                   // 0x00D0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFlagContainer                         DisableSightFlag;                                  // 0x00D8(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnFReceiveSoundDelegate;                           // 0x0128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void DeadAutoRemoveDelegate(const struct FPalDeadInfo& DeadInfo);
	void DisableHearing();
	void EnableHearing();
	bool IsInSightKillerAndDeadBody(class AActor* Killer, class AActor* DeadBody);
	void OnResponseSpecialLookat();
	void ReceiveSound(int32 SoundRadius, const struct FVector& EmitLocation, class AActor* Emitter);
	void ReceiveSoundDelegate__DelegateSignature(const struct FVector& EmitLocation);
	void ResetResponsedMaxBiologicalGrade();
	EPalAIResponseType SelectResponseBySenses(EPalAIResponseType CurrentBehavior, const TArray<class APalCharacter*>& FindCharacters, bool IsDamaged, class APalCharacter** OutTargetCharacter);
	void SetDebugAIResponse(TSubclassOf<class UPalAIResponsePreset> PresetClass);
	void SetDisableEscape();
	void SetDisableSightFlag(class FName FlagName, bool IsDisable);
	void Setup();
	void SightCheckAllAliveNPC(TArray<class APalCharacter*>* InSightCharacters, bool IgnoreOtomo);
	void SightCheckAllEdibleDeadNPC(TArray<class APalCharacter*>* InSightCharacters);
	void SightCheckAllPlayer(TArray<class APalCharacter*>* InSightPlayers, float RangeRate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAISensorComponent">();
	}
	static class UPalAISensorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAISensorComponent>();
	}
};
static_assert(alignof(UPalAISensorComponent) == 0x000008, "Wrong alignment on UPalAISensorComponent");
static_assert(sizeof(UPalAISensorComponent) == 0x000138, "Wrong size on UPalAISensorComponent");
static_assert(offsetof(UPalAISensorComponent, SelfPawn) == 0x0000A0, "Member 'UPalAISensorComponent::SelfPawn' has a wrong offset!");
static_assert(offsetof(UPalAISensorComponent, SightAngleThreshold) == 0x0000A8, "Member 'UPalAISensorComponent::SightAngleThreshold' has a wrong offset!");
static_assert(offsetof(UPalAISensorComponent, SightDistance) == 0x0000AC, "Member 'UPalAISensorComponent::SightDistance' has a wrong offset!");
static_assert(offsetof(UPalAISensorComponent, HearingRate) == 0x0000B0, "Member 'UPalAISensorComponent::HearingRate' has a wrong offset!");
static_assert(offsetof(UPalAISensorComponent, HumanAndNoneWeapon) == 0x0000B4, "Member 'UPalAISensorComponent::HumanAndNoneWeapon' has a wrong offset!");
static_assert(offsetof(UPalAISensorComponent, IsIgnoreSoundReaction) == 0x0000B5, "Member 'UPalAISensorComponent::IsIgnoreSoundReaction' has a wrong offset!");
static_assert(offsetof(UPalAISensorComponent, RecentMaxSoundLevel) == 0x0000B8, "Member 'UPalAISensorComponent::RecentMaxSoundLevel' has a wrong offset!");
static_assert(offsetof(UPalAISensorComponent, ResponsedMaxBiologicalGrade) == 0x0000C4, "Member 'UPalAISensorComponent::ResponsedMaxBiologicalGrade' has a wrong offset!");
static_assert(offsetof(UPalAISensorComponent, AIResponsePreset) == 0x0000C8, "Member 'UPalAISensorComponent::AIResponsePreset' has a wrong offset!");
static_assert(offsetof(UPalAISensorComponent, AISightResponse) == 0x0000D0, "Member 'UPalAISensorComponent::AISightResponse' has a wrong offset!");
static_assert(offsetof(UPalAISensorComponent, DisableSightFlag) == 0x0000D8, "Member 'UPalAISensorComponent::DisableSightFlag' has a wrong offset!");
static_assert(offsetof(UPalAISensorComponent, OnFReceiveSoundDelegate) == 0x000128, "Member 'UPalAISensorComponent::OnFReceiveSoundDelegate' has a wrong offset!");

// Class Pal.PalHitFilter
// 0x0130 (0x0158 - 0x0028)
class UPalHitFilter : public UObject
{
public:
	uint8                                         Pad_2865[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxHitNum;                                         // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitInterval;                                       // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalHitLocationCalculator>  HitLocationCalculator;                             // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsIntersectionCollision;                          // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2866[0x3];                                     // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         IntersectionNum;                                   // 0x0044(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnHitDelegate;                                     // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnOverlapEndDelegate;                              // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2867[0xF0];                                    // 0x0068(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindPrimitiveComponent(class UPrimitiveComponent* Component);
	void OnBeginOverlap(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& Hit);
	void OnEndOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnHitDelegate__DelegateSignature(class UPrimitiveComponent* MyHitComponent, class AActor* OtherHitActor, class UPrimitiveComponent* OtherHitComponent, const TArray<int32>& FoliageIndex, const struct FVector& HitLocation, int32 HitCount);
	void OverlapEndDelegate__DelegateSignature(class UPrimitiveComponent* MyHitComponent, class AActor* OtherHitActor, class UPrimitiveComponent* OtherHitComponent);
	void ResetFilter();
	void SetAttacker(class AActor* Attacker);
	void SetIntersectionNum(int32 Num);
	void UnbindPrimitiveComponent(class UPrimitiveComponent* Component);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalHitFilter">();
	}
	static class UPalHitFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalHitFilter>();
	}
};
static_assert(alignof(UPalHitFilter) == 0x000008, "Wrong alignment on UPalHitFilter");
static_assert(sizeof(UPalHitFilter) == 0x000158, "Wrong size on UPalHitFilter");
static_assert(offsetof(UPalHitFilter, MaxHitNum) == 0x000030, "Member 'UPalHitFilter::MaxHitNum' has a wrong offset!");
static_assert(offsetof(UPalHitFilter, HitInterval) == 0x000034, "Member 'UPalHitFilter::HitInterval' has a wrong offset!");
static_assert(offsetof(UPalHitFilter, HitLocationCalculator) == 0x000038, "Member 'UPalHitFilter::HitLocationCalculator' has a wrong offset!");
static_assert(offsetof(UPalHitFilter, bIsIntersectionCollision) == 0x000040, "Member 'UPalHitFilter::bIsIntersectionCollision' has a wrong offset!");
static_assert(offsetof(UPalHitFilter, IntersectionNum) == 0x000044, "Member 'UPalHitFilter::IntersectionNum' has a wrong offset!");
static_assert(offsetof(UPalHitFilter, OnHitDelegate) == 0x000048, "Member 'UPalHitFilter::OnHitDelegate' has a wrong offset!");
static_assert(offsetof(UPalHitFilter, OnOverlapEndDelegate) == 0x000058, "Member 'UPalHitFilter::OnOverlapEndDelegate' has a wrong offset!");

// Class Pal.PalAttackFilter
// 0x0040 (0x0198 - 0x0158)
class UPalAttackFilter final : public UPalHitFilter
{
public:
	FMulticastInlineDelegateProperty_             OnAttackDelegate;                                  // 0x0158(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EPalWazaID                                    Waza;                                              // 0x0168(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPalBlowVelocityOwner                         VelocityOwner;                                     // 0x0169(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_286B[0x6];                                     // 0x016A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                NativeBlowVelocity;                                // 0x0170(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WazaPowerRate;                                     // 0x0188(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_286C[0x4];                                     // 0x018C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Attacker;                                          // 0x0190(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAttackFilter">();
	}
	static class UPalAttackFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAttackFilter>();
	}
};
static_assert(alignof(UPalAttackFilter) == 0x000008, "Wrong alignment on UPalAttackFilter");
static_assert(sizeof(UPalAttackFilter) == 0x000198, "Wrong size on UPalAttackFilter");
static_assert(offsetof(UPalAttackFilter, OnAttackDelegate) == 0x000158, "Member 'UPalAttackFilter::OnAttackDelegate' has a wrong offset!");
static_assert(offsetof(UPalAttackFilter, Waza) == 0x000168, "Member 'UPalAttackFilter::Waza' has a wrong offset!");
static_assert(offsetof(UPalAttackFilter, VelocityOwner) == 0x000169, "Member 'UPalAttackFilter::VelocityOwner' has a wrong offset!");
static_assert(offsetof(UPalAttackFilter, NativeBlowVelocity) == 0x000170, "Member 'UPalAttackFilter::NativeBlowVelocity' has a wrong offset!");
static_assert(offsetof(UPalAttackFilter, WazaPowerRate) == 0x000188, "Member 'UPalAttackFilter::WazaPowerRate' has a wrong offset!");
static_assert(offsetof(UPalAttackFilter, Attacker) == 0x000190, "Member 'UPalAttackFilter::Attacker' has a wrong offset!");

// Class Pal.PalStatusCollectItem
// 0x0010 (0x0058 - 0x0048)
class UPalStatusCollectItem : public UPalStatusBase
{
public:
	struct FPalStaticItemIdAndNum                 CollectItemInfo;                                   // 0x0048(0x000C)(NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_286D[0x4];                                     // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DropItem(class FName ItemId, int32 DropNum, const struct FVector& SpawnLocation, const struct FVector& ReleaseDirection);
	void OnBeginSomeStatus_Implementation();
	void OnBeginStatus_Implementation();
	void OnBreakStatus_Implementation();
	void OnEndStatus_Implementation();
	void SetCollectItemInfo(const struct FPalStaticItemIdAndNum& ItemIDAndNum);
	void TickStatus_Implementation(float DeltaTime);

	bool CanSpawnItem() const;
	const struct FPalStaticItemIdAndNum GetCollectItemInfo() const;
	class UPalPlayerInventoryData* GetOwnerPlayerInventoryData() const;
	bool IsBattleMode() const;
	bool IsHealth() const;
	bool IsLifted() const;
	bool IsRestrictedByWork() const;
	bool IsRestrictedByWorkerEvent() const;
	bool IsServer() const;
	bool IsThrown() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalStatusCollectItem">();
	}
	static class UPalStatusCollectItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalStatusCollectItem>();
	}
};
static_assert(alignof(UPalStatusCollectItem) == 0x000008, "Wrong alignment on UPalStatusCollectItem");
static_assert(sizeof(UPalStatusCollectItem) == 0x000058, "Wrong size on UPalStatusCollectItem");
static_assert(offsetof(UPalStatusCollectItem, CollectItemInfo) == 0x000048, "Member 'UPalStatusCollectItem::CollectItemInfo' has a wrong offset!");

// Class Pal.PalAIActionComponent
// 0x0010 (0x00F0 - 0x00E0)
class UPalAIActionComponent final : public UPawnActionsComponent
{
public:
	TArray<class UPalAIActionCompositeBase*>      ActionCompositeRoots;                              // 0x00E0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPrivate)

public:
	void AllCancelAction_Logic_HardScript_Reaction(const class UObject* Instigator);
	void AllCancelActionPriorThanSoftScript(const class UObject* Instigator);
	void AllCancelPushedAction(const class UObject* Instigator);
	void CacheControlledPawn_BP();
	class UPawnAction* GetCurrentAction_BP();
	EPalAIActionCategory GetCurrentAIActionCategory();
	class UPawnAction* GetCurrentTopParentAction_BP();
	bool IsActionEmpty();
	void SetAction(class UPawnAction* NewAction, EAIRequestPriority Priority, class UObject* Instigator);
	class UPalAIActionBase* SetActionClassParameter(TSubclassOf<class UPalAIActionBase> NewActionClass, const struct FPalAIActionDynamicParameter& Parameter);
	void SetRootComposite(class UPalAIActionCompositeBase* NewCompositeAction, EAIRequestPriority Priority);
	void SetWalkSpeed_ForAIAction(EPalMovementSpeedType MoveSpeedType);
	void TerminateCurrentActionByClass(TSubclassOf<class UPalAIActionBase> ActionClass);

	class UPalAIActionCompositeBase* GetCompositeRoot(EAIRequestPriority Priority) const;
	bool HasAction(const TSubclassOf<class UPawnAction>& CheckClass, EAIRequestPriority CheckPriority) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionComponent">();
	}
	static class UPalAIActionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIActionComponent>();
	}
};
static_assert(alignof(UPalAIActionComponent) == 0x000008, "Wrong alignment on UPalAIActionComponent");
static_assert(sizeof(UPalAIActionComponent) == 0x0000F0, "Wrong size on UPalAIActionComponent");
static_assert(offsetof(UPalAIActionComponent, ActionCompositeRoots) == 0x0000E0, "Member 'UPalAIActionComponent::ActionCompositeRoots' has a wrong offset!");

// Class Pal.PalCommonUIActionRouter
// 0x0000 (0x0158 - 0x0158)
class UPalCommonUIActionRouter final : public UCommonUIActionRouterBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalCommonUIActionRouter">();
	}
	static class UPalCommonUIActionRouter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalCommonUIActionRouter>();
	}
};
static_assert(alignof(UPalCommonUIActionRouter) == 0x000008, "Wrong alignment on UPalCommonUIActionRouter");
static_assert(sizeof(UPalCommonUIActionRouter) == 0x000158, "Wrong size on UPalCommonUIActionRouter");

// Class Pal.PalStatusComponent
// 0x00A0 (0x0140 - 0x00A0)
class UPalStatusComponent final : public UActorComponent
{
public:
	TMap<EPalStatusID, TSubclassOf<class UPalStatusBase>> StatusMap;                                         // 0x00A0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAddStatus;                                       // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRemoveStatus;                                    // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UPalStatusBase*>                 ExecutionStatusList;                               // 0x0110(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, RepNotify, NativeAccessSpecifierPrivate)
	TArray<class UPalStatusBase*>                 ExecutionStatusListCache;                          // 0x0120(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<EPalStatusID>                          DisableAddStatusIDs;                               // 0x0130(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void AddStatus(EPalStatusID StatusId);
	void AddStatus_ToServer(EPalStatusID StatusId, const struct FStatusDynamicParameter& Param, int32 IssuerID);
	void AddStatusParameter(EPalStatusID StatusId, const struct FStatusDynamicParameter& Param);
	void BeginPlay();
	class UPalStatusBase* GetExecutionStatus(EPalStatusID StatusId);
	class UPalStatusBase* GetExecutionStatusCache(EPalStatusID StatusId);
	void OnAddStatus__DelegateSignature(const class UPalStatusComponent* StatusComponent, EPalStatusID StatusId, class UPalStatusBase* Status);
	void OnRemoveStatus__DelegateSignature(const class UPalStatusComponent* StatusComponent, EPalStatusID StatusId);
	void OnRep_ExecutionStatusList();
	void RemoveStatus(EPalStatusID StatusId);
	void RemoveStatus_ToServer(EPalStatusID StatusId, int32 IssuerID);
	void SetDisableAddStatusIDs(const TArray<EPalStatusID>& StatusIDs);
	void SomeStatus_ToAll(EPalStatusID StatusId, const struct FStatusDynamicParameter& Param);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalStatusComponent">();
	}
	static class UPalStatusComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalStatusComponent>();
	}
};
static_assert(alignof(UPalStatusComponent) == 0x000008, "Wrong alignment on UPalStatusComponent");
static_assert(sizeof(UPalStatusComponent) == 0x000140, "Wrong size on UPalStatusComponent");
static_assert(offsetof(UPalStatusComponent, StatusMap) == 0x0000A0, "Member 'UPalStatusComponent::StatusMap' has a wrong offset!");
static_assert(offsetof(UPalStatusComponent, OnAddStatus) == 0x0000F0, "Member 'UPalStatusComponent::OnAddStatus' has a wrong offset!");
static_assert(offsetof(UPalStatusComponent, OnRemoveStatus) == 0x000100, "Member 'UPalStatusComponent::OnRemoveStatus' has a wrong offset!");
static_assert(offsetof(UPalStatusComponent, ExecutionStatusList) == 0x000110, "Member 'UPalStatusComponent::ExecutionStatusList' has a wrong offset!");
static_assert(offsetof(UPalStatusComponent, ExecutionStatusListCache) == 0x000120, "Member 'UPalStatusComponent::ExecutionStatusListCache' has a wrong offset!");
static_assert(offsetof(UPalStatusComponent, DisableAddStatusIDs) == 0x000130, "Member 'UPalStatusComponent::DisableAddStatusIDs' has a wrong offset!");

// Class Pal.PalBossBattleSequenceBase
// 0x0018 (0x0040 - 0x0028)
class UPalBossBattleSequenceBase : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnSequenceFinishDelegate;                          // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EPalBossBattleSequenceType                    NextSequenceType;                                  // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_287B[0x7];                                     // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FinishSequence(bool IsSuccess);
	struct FPalBossBattleStaticInfo GetBossBattleStaticInfo();
	class APalPlayerCharacter* GetJoinedLocalControlPlayer();
	bool IsServer();
	void NoticeSequenceEnd_ToServer();
	void OnBeginSequence();
	void SelfFinish_ForBP();
	void SequenceFinishDelegate__DelegateSignature(bool IsSuccess);
	void SetupLevelSequenceActor(class ALevelSequenceActor* LevelSequenceActor, class ULevelSequence* LevelSequence, class ALevelInstance* LevelInstance);
	void TickSequence(float DeltaTime);

	class AActor* GetBossRoomSequenceRootActor(class ALevelInstance* LevelInstance) const;
	class UPalBossBattleSequencer* GetOuterSequencer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBossBattleSequenceBase">();
	}
	static class UPalBossBattleSequenceBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBossBattleSequenceBase>();
	}
};
static_assert(alignof(UPalBossBattleSequenceBase) == 0x000008, "Wrong alignment on UPalBossBattleSequenceBase");
static_assert(sizeof(UPalBossBattleSequenceBase) == 0x000040, "Wrong size on UPalBossBattleSequenceBase");
static_assert(offsetof(UPalBossBattleSequenceBase, OnSequenceFinishDelegate) == 0x000028, "Member 'UPalBossBattleSequenceBase::OnSequenceFinishDelegate' has a wrong offset!");
static_assert(offsetof(UPalBossBattleSequenceBase, NextSequenceType) == 0x000038, "Member 'UPalBossBattleSequenceBase::NextSequenceType' has a wrong offset!");

// Class Pal.PalAIActionCompositeBaseCamp
// 0x0050 (0x0098 - 0x0048)
class UPalAIActionCompositeBaseCamp : public UPalAIActionCompositeBase
{
public:
	float                                         WalkSpeedDefault;                                  // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_287C[0x4C];                                    // 0x004C(0x004C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeActionToFighter();
	void ChangeActionToWorker();
	void InterruptActionToRecoverHungry(const struct FPalMonsterControllerBaseCampHungryParameter& Parameter);
	void InterruptActionToSleep();
	void NotifyOrderCommand(const EPalMapBaseCampWorkerOrderType OrderType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionCompositeBaseCamp">();
	}
	static class UPalAIActionCompositeBaseCamp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIActionCompositeBaseCamp>();
	}
};
static_assert(alignof(UPalAIActionCompositeBaseCamp) == 0x000008, "Wrong alignment on UPalAIActionCompositeBaseCamp");
static_assert(sizeof(UPalAIActionCompositeBaseCamp) == 0x000098, "Wrong size on UPalAIActionCompositeBaseCamp");
static_assert(offsetof(UPalAIActionCompositeBaseCamp, WalkSpeedDefault) == 0x000048, "Member 'UPalAIActionCompositeBaseCamp::WalkSpeedDefault' has a wrong offset!");

// Class Pal.PalUserWidgetWorldHUD
// 0x0000 (0x0408 - 0x0408)
class UPalUserWidgetWorldHUD : public UPalUserWidget
{
public:
	void OnRequestRemove();
	void RemoveSelf();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUserWidgetWorldHUD">();
	}
	static class UPalUserWidgetWorldHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUserWidgetWorldHUD>();
	}
};
static_assert(alignof(UPalUserWidgetWorldHUD) == 0x000008, "Wrong alignment on UPalUserWidgetWorldHUD");
static_assert(sizeof(UPalUserWidgetWorldHUD) == 0x000408, "Wrong size on UPalUserWidgetWorldHUD");

// Class Pal.PalUIItemPossessStatusIndicator
// 0x0000 (0x0408 - 0x0408)
class UPalUIItemPossessStatusIndicator final : public UPalUserWidgetWorldHUD
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIItemPossessStatusIndicator">();
	}
	static class UPalUIItemPossessStatusIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIItemPossessStatusIndicator>();
	}
};
static_assert(alignof(UPalUIItemPossessStatusIndicator) == 0x000008, "Wrong alignment on UPalUIItemPossessStatusIndicator");
static_assert(sizeof(UPalUIItemPossessStatusIndicator) == 0x000408, "Wrong size on UPalUIItemPossessStatusIndicator");

// Class Pal.PalBaseCampModuleObjectMaintenance_WayBase
// 0x0000 (0x0028 - 0x0028)
class UPalBaseCampModuleObjectMaintenance_WayBase : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBaseCampModuleObjectMaintenance_WayBase">();
	}
	static class UPalBaseCampModuleObjectMaintenance_WayBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBaseCampModuleObjectMaintenance_WayBase>();
	}
};
static_assert(alignof(UPalBaseCampModuleObjectMaintenance_WayBase) == 0x000008, "Wrong alignment on UPalBaseCampModuleObjectMaintenance_WayBase");
static_assert(sizeof(UPalBaseCampModuleObjectMaintenance_WayBase) == 0x000028, "Wrong size on UPalBaseCampModuleObjectMaintenance_WayBase");

// Class Pal.PalBaseCampModuleObjectMaintenance_ExtinguishFire
// 0x0000 (0x0028 - 0x0028)
class UPalBaseCampModuleObjectMaintenance_ExtinguishFire final : public UPalBaseCampModuleObjectMaintenance_WayBase
{
public:
	void OnTriggerByReachAccumulateTriggerValue(class UPalMapObjectModelEffect_AccumulateTrigger* Effect_AccumulateTrigger, class UPalMapObjectModel* OwnerModel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBaseCampModuleObjectMaintenance_ExtinguishFire">();
	}
	static class UPalBaseCampModuleObjectMaintenance_ExtinguishFire* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBaseCampModuleObjectMaintenance_ExtinguishFire>();
	}
};
static_assert(alignof(UPalBaseCampModuleObjectMaintenance_ExtinguishFire) == 0x000008, "Wrong alignment on UPalBaseCampModuleObjectMaintenance_ExtinguishFire");
static_assert(sizeof(UPalBaseCampModuleObjectMaintenance_ExtinguishFire) == 0x000028, "Wrong size on UPalBaseCampModuleObjectMaintenance_ExtinguishFire");

// Class Pal.PalAIActionCompositeWorkerModuleBase
// 0x0008 (0x0030 - 0x0028)
class UPalAIActionCompositeWorkerModuleBase : public UObject
{
public:
	class UPalAIActionCompositeWorker*            Owner;                                             // 0x0028(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionCompositeWorkerModuleBase">();
	}
	static class UPalAIActionCompositeWorkerModuleBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIActionCompositeWorkerModuleBase>();
	}
};
static_assert(alignof(UPalAIActionCompositeWorkerModuleBase) == 0x000008, "Wrong alignment on UPalAIActionCompositeWorkerModuleBase");
static_assert(sizeof(UPalAIActionCompositeWorkerModuleBase) == 0x000030, "Wrong size on UPalAIActionCompositeWorkerModuleBase");
static_assert(offsetof(UPalAIActionCompositeWorkerModuleBase, Owner) == 0x000028, "Member 'UPalAIActionCompositeWorkerModuleBase::Owner' has a wrong offset!");

// Class Pal.PalAIActionCompositeWorkerModuleNormal
// 0x0000 (0x0030 - 0x0030)
class UPalAIActionCompositeWorkerModuleNormal final : public UPalAIActionCompositeWorkerModuleBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionCompositeWorkerModuleNormal">();
	}
	static class UPalAIActionCompositeWorkerModuleNormal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIActionCompositeWorkerModuleNormal>();
	}
};
static_assert(alignof(UPalAIActionCompositeWorkerModuleNormal) == 0x000008, "Wrong alignment on UPalAIActionCompositeWorkerModuleNormal");
static_assert(sizeof(UPalAIActionCompositeWorkerModuleNormal) == 0x000030, "Wrong size on UPalAIActionCompositeWorkerModuleNormal");

// Class Pal.PalMapObjectPickupItemParameterComponentBase
// 0x0000 (0x00A0 - 0x00A0)
class UPalMapObjectPickupItemParameterComponentBase : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectPickupItemParameterComponentBase">();
	}
	static class UPalMapObjectPickupItemParameterComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectPickupItemParameterComponentBase>();
	}
};
static_assert(alignof(UPalMapObjectPickupItemParameterComponentBase) == 0x000008, "Wrong alignment on UPalMapObjectPickupItemParameterComponentBase");
static_assert(sizeof(UPalMapObjectPickupItemParameterComponentBase) == 0x0000A0, "Wrong size on UPalMapObjectPickupItemParameterComponentBase");

// Class Pal.PalMapObjectPickupItemParameterComponent
// 0x0018 (0x00B8 - 0x00A0)
class UPalMapObjectPickupItemParameterComponent : public UPalMapObjectPickupItemParameterComponentBase
{
public:
	TArray<struct FPalMapObjectPickupItemData>    DropItems;                                         // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bForceIgnoreSaveItemContainer;                     // 0x00B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_287D[0x7];                                     // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectPickupItemParameterComponent">();
	}
	static class UPalMapObjectPickupItemParameterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectPickupItemParameterComponent>();
	}
};
static_assert(alignof(UPalMapObjectPickupItemParameterComponent) == 0x000008, "Wrong alignment on UPalMapObjectPickupItemParameterComponent");
static_assert(sizeof(UPalMapObjectPickupItemParameterComponent) == 0x0000B8, "Wrong size on UPalMapObjectPickupItemParameterComponent");
static_assert(offsetof(UPalMapObjectPickupItemParameterComponent, DropItems) == 0x0000A0, "Member 'UPalMapObjectPickupItemParameterComponent::DropItems' has a wrong offset!");
static_assert(offsetof(UPalMapObjectPickupItemParameterComponent, bForceIgnoreSaveItemContainer) == 0x0000B0, "Member 'UPalMapObjectPickupItemParameterComponent::bForceIgnoreSaveItemContainer' has a wrong offset!");

// Class Pal.PalMapObjectPickupItemPalEggParameterComponent
// 0x0008 (0x00C0 - 0x00B8)
class UPalMapObjectPickupItemPalEggParameterComponent final : public UPalMapObjectPickupItemParameterComponent
{
public:
	struct FPalMapObjectPickupItemPalEggData      PalEggData;                                        // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectPickupItemPalEggParameterComponent">();
	}
	static class UPalMapObjectPickupItemPalEggParameterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectPickupItemPalEggParameterComponent>();
	}
};
static_assert(alignof(UPalMapObjectPickupItemPalEggParameterComponent) == 0x000008, "Wrong alignment on UPalMapObjectPickupItemPalEggParameterComponent");
static_assert(sizeof(UPalMapObjectPickupItemPalEggParameterComponent) == 0x0000C0, "Wrong size on UPalMapObjectPickupItemPalEggParameterComponent");
static_assert(offsetof(UPalMapObjectPickupItemPalEggParameterComponent, PalEggData) == 0x0000B8, "Member 'UPalMapObjectPickupItemPalEggParameterComponent::PalEggData' has a wrong offset!");

// Class Pal.PalAssetStreamableManager
// 0x0038 (0x0060 - 0x0028)
class UPalAssetStreamableManager : public UObject
{
public:
	uint8                                         Pad_287E[0x38];                                    // 0x0028(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAssetStreamableManager">();
	}
	static class UPalAssetStreamableManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAssetStreamableManager>();
	}
};
static_assert(alignof(UPalAssetStreamableManager) == 0x000008, "Wrong alignment on UPalAssetStreamableManager");
static_assert(sizeof(UPalAssetStreamableManager) == 0x000060, "Wrong size on UPalAssetStreamableManager");

// Class Pal.PalAIActionCompositeWorkerModuleBaseCamp
// 0x0000 (0x0030 - 0x0030)
class UPalAIActionCompositeWorkerModuleBaseCamp final : public UPalAIActionCompositeWorkerModuleBase
{
public:
	class UPalBaseCampModel* GetBaseCampBelongTo() const;
	struct FGuid GetBaseCampIdBelongTo() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionCompositeWorkerModuleBaseCamp">();
	}
	static class UPalAIActionCompositeWorkerModuleBaseCamp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIActionCompositeWorkerModuleBaseCamp>();
	}
};
static_assert(alignof(UPalAIActionCompositeWorkerModuleBaseCamp) == 0x000008, "Wrong alignment on UPalAIActionCompositeWorkerModuleBaseCamp");
static_assert(sizeof(UPalAIActionCompositeWorkerModuleBaseCamp) == 0x000030, "Wrong size on UPalAIActionCompositeWorkerModuleBaseCamp");

// Class Pal.PalFollowingComponent
// 0x0000 (0x02B8 - 0x02B8)
class UPalFollowingComponent final : public UPathFollowingComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalFollowingComponent">();
	}
	static class UPalFollowingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalFollowingComponent>();
	}
};
static_assert(alignof(UPalFollowingComponent) == 0x000008, "Wrong alignment on UPalFollowingComponent");
static_assert(sizeof(UPalFollowingComponent) == 0x0002B8, "Wrong size on UPalFollowingComponent");

// Class Pal.PalMasterDataTableAccess_BuildObjectIconData
// 0x0000 (0x0030 - 0x0030)
class UPalMasterDataTableAccess_BuildObjectIconData final : public UPalMasterDataTableAccessBase
{
public:
	void BPExec_FindRow(class FName RowName, EPalMasterDataExecPinType* ExecType, struct FPalBuildObjectIconData* OutData);

	struct FPalBuildObjectIconData BP_FindRow(class FName RowName, bool* bResult) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMasterDataTableAccess_BuildObjectIconData">();
	}
	static class UPalMasterDataTableAccess_BuildObjectIconData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMasterDataTableAccess_BuildObjectIconData>();
	}
};
static_assert(alignof(UPalMasterDataTableAccess_BuildObjectIconData) == 0x000008, "Wrong alignment on UPalMasterDataTableAccess_BuildObjectIconData");
static_assert(sizeof(UPalMasterDataTableAccess_BuildObjectIconData) == 0x000030, "Wrong size on UPalMasterDataTableAccess_BuildObjectIconData");

// Class Pal.PalAIActionCoopAssaultrifleMode
// 0x00B8 (0x01E8 - 0x0130)
class UPalAIActionCoopAssaultrifleMode final : public UPalAIActionBase
{
public:
	float                                         SearchEnemyRadius;                                 // 0x0130(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SearchLocationRadiusMax;                           // 0x0134(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SearchLocationRadiusStep;                          // 0x0138(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SearchLocationDegStep;                             // 0x013C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SearchingLocationRadius;                           // 0x0140(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2881[0x4];                                     // 0x0144(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APalCharacter*                          TargetCharacter;                                   // 0x0148(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APalCharacter*                          ReticleTarget;                                     // 0x0150(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                AimStartPoint;                                     // 0x0158(0x0018)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2882[0x78];                                    // 0x0170(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearTargetCharacter();
	bool FindLocationToShootEnemy(class APalCharacter* Target, struct FPalCoopSkillAssaultrifleModeCandidateLocation* OutLocation);
	void GetCandidateLocations(float Radius, float DegStep, TArray<struct FPalCoopSkillAssaultrifleModeCandidateLocation>* Results);
	class APalCharacter* GetTargetCharacter();
	void GetTargetEnemies(TArray<class APalCharacter*>* Enemies);
	void OnRoadBlocked();
	void OnUpdateShootingLocation(class APalCharacter* Target, const struct FVector& ShootLocation);
	void Progress_CollectShootableLocation();
	void Progress_VerifyShootableEnemy();
	void ProgressSeraching(float DeltaTime);
	void SearchForTargetAndShootingLocation();
	void SetAimStartPoint(const struct FVector& OffsetLocation);
	void Update(float DeltaTime);

	class APalCharacter* GetReticleTarget() const;
	class APalCharacter* GetTrainer() const;
	bool HasReached(const struct FVector& Goal) const;
	bool IsSearching() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionCoopAssaultrifleMode">();
	}
	static class UPalAIActionCoopAssaultrifleMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIActionCoopAssaultrifleMode>();
	}
};
static_assert(alignof(UPalAIActionCoopAssaultrifleMode) == 0x000008, "Wrong alignment on UPalAIActionCoopAssaultrifleMode");
static_assert(sizeof(UPalAIActionCoopAssaultrifleMode) == 0x0001E8, "Wrong size on UPalAIActionCoopAssaultrifleMode");
static_assert(offsetof(UPalAIActionCoopAssaultrifleMode, SearchEnemyRadius) == 0x000130, "Member 'UPalAIActionCoopAssaultrifleMode::SearchEnemyRadius' has a wrong offset!");
static_assert(offsetof(UPalAIActionCoopAssaultrifleMode, SearchLocationRadiusMax) == 0x000134, "Member 'UPalAIActionCoopAssaultrifleMode::SearchLocationRadiusMax' has a wrong offset!");
static_assert(offsetof(UPalAIActionCoopAssaultrifleMode, SearchLocationRadiusStep) == 0x000138, "Member 'UPalAIActionCoopAssaultrifleMode::SearchLocationRadiusStep' has a wrong offset!");
static_assert(offsetof(UPalAIActionCoopAssaultrifleMode, SearchLocationDegStep) == 0x00013C, "Member 'UPalAIActionCoopAssaultrifleMode::SearchLocationDegStep' has a wrong offset!");
static_assert(offsetof(UPalAIActionCoopAssaultrifleMode, SearchingLocationRadius) == 0x000140, "Member 'UPalAIActionCoopAssaultrifleMode::SearchingLocationRadius' has a wrong offset!");
static_assert(offsetof(UPalAIActionCoopAssaultrifleMode, TargetCharacter) == 0x000148, "Member 'UPalAIActionCoopAssaultrifleMode::TargetCharacter' has a wrong offset!");
static_assert(offsetof(UPalAIActionCoopAssaultrifleMode, ReticleTarget) == 0x000150, "Member 'UPalAIActionCoopAssaultrifleMode::ReticleTarget' has a wrong offset!");
static_assert(offsetof(UPalAIActionCoopAssaultrifleMode, AimStartPoint) == 0x000158, "Member 'UPalAIActionCoopAssaultrifleMode::AimStartPoint' has a wrong offset!");

// Class Pal.PalAIActionFed
// 0x0018 (0x0148 - 0x0130)
class UPalAIActionFed final : public UPalAIActionBase
{
public:
	uint8                                         Pad_2885[0x8];                                     // 0x0130(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class APalCharacter*                          ApproachTarget;                                    // 0x0138(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2886[0x8];                                     // 0x0140(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionFed">();
	}
	static class UPalAIActionFed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIActionFed>();
	}
};
static_assert(alignof(UPalAIActionFed) == 0x000008, "Wrong alignment on UPalAIActionFed");
static_assert(sizeof(UPalAIActionFed) == 0x000148, "Wrong size on UPalAIActionFed");
static_assert(offsetof(UPalAIActionFed, ApproachTarget) == 0x000138, "Member 'UPalAIActionFed::ApproachTarget' has a wrong offset!");

// Class Pal.PalGameInstanceViewActor
// 0x0008 (0x0298 - 0x0290)
class APalGameInstanceViewActor final : public AActor
{
public:
	TWeakObjectPtr<class UObject>                 Target;                                            // 0x0290(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGameInstanceViewActor">();
	}
	static class APalGameInstanceViewActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalGameInstanceViewActor>();
	}
};
static_assert(alignof(APalGameInstanceViewActor) == 0x000008, "Wrong alignment on APalGameInstanceViewActor");
static_assert(sizeof(APalGameInstanceViewActor) == 0x000298, "Wrong size on APalGameInstanceViewActor");
static_assert(offsetof(APalGameInstanceViewActor, Target) == 0x000290, "Member 'APalGameInstanceViewActor::Target' has a wrong offset!");

// Class Pal.PalBuildObjectBreedFarm
// 0x0050 (0x05D0 - 0x0580)
class APalBuildObjectBreedFarm final : public APalBuildObject
{
public:
	struct FComponentReference                    ChestInteractRef;                                  // 0x0580(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FComponentReference                    WalkAroundVolumeRef;                               // 0x05A8(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBuildObjectBreedFarm">();
	}
	static class APalBuildObjectBreedFarm* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalBuildObjectBreedFarm>();
	}
};
static_assert(alignof(APalBuildObjectBreedFarm) == 0x000008, "Wrong alignment on APalBuildObjectBreedFarm");
static_assert(sizeof(APalBuildObjectBreedFarm) == 0x0005D0, "Wrong size on APalBuildObjectBreedFarm");
static_assert(offsetof(APalBuildObjectBreedFarm, ChestInteractRef) == 0x000580, "Member 'APalBuildObjectBreedFarm::ChestInteractRef' has a wrong offset!");
static_assert(offsetof(APalBuildObjectBreedFarm, WalkAroundVolumeRef) == 0x0005A8, "Member 'APalBuildObjectBreedFarm::WalkAroundVolumeRef' has a wrong offset!");

// Class Pal.PalFoliageDamageReactionComponent
// 0x0020 (0x00C0 - 0x00A0)
class UPalFoliageDamageReactionComponent final : public UActorComponent
{
public:
	uint8                                         Pad_2887[0x18];                                    // 0x00A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalHitEffectSlot*                      EffectSlot;                                        // 0x00B8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalFoliageDamageReactionComponent">();
	}
	static class UPalFoliageDamageReactionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalFoliageDamageReactionComponent>();
	}
};
static_assert(alignof(UPalFoliageDamageReactionComponent) == 0x000008, "Wrong alignment on UPalFoliageDamageReactionComponent");
static_assert(sizeof(UPalFoliageDamageReactionComponent) == 0x0000C0, "Wrong size on UPalFoliageDamageReactionComponent");
static_assert(offsetof(UPalFoliageDamageReactionComponent, EffectSlot) == 0x0000B8, "Member 'UPalFoliageDamageReactionComponent::EffectSlot' has a wrong offset!");

// Class Pal.PalMasterDataTableAccess_CharacterUpgradeData
// 0x0008 (0x0038 - 0x0030)
class UPalMasterDataTableAccess_CharacterUpgradeData final : public UPalMasterDataTableAccessBase
{
public:
	uint8                                         Pad_2888[0x8];                                     // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetMaxRank();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMasterDataTableAccess_CharacterUpgradeData">();
	}
	static class UPalMasterDataTableAccess_CharacterUpgradeData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMasterDataTableAccess_CharacterUpgradeData>();
	}
};
static_assert(alignof(UPalMasterDataTableAccess_CharacterUpgradeData) == 0x000008, "Wrong alignment on UPalMasterDataTableAccess_CharacterUpgradeData");
static_assert(sizeof(UPalMasterDataTableAccess_CharacterUpgradeData) == 0x000038, "Wrong size on UPalMasterDataTableAccess_CharacterUpgradeData");

// Class Pal.PalAIActionFunnelCharacterDefault
// 0x0008 (0x0050 - 0x0048)
class UPalAIActionFunnelCharacterDefault : public UPalAIActionCompositeBase
{
public:
	uint8                                         Pad_2889[0x8];                                     // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CreateSkillActionModule(TSubclassOf<class UPalFunnelSkillModule> FunnelSkillModuleClass);
	void OnTick_BP(float DeltaTime);
	void SetOtomoFollowAction();
	void SetSkillAction();

	bool ShouldSetSkillAction() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionFunnelCharacterDefault">();
	}
	static class UPalAIActionFunnelCharacterDefault* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIActionFunnelCharacterDefault>();
	}
};
static_assert(alignof(UPalAIActionFunnelCharacterDefault) == 0x000008, "Wrong alignment on UPalAIActionFunnelCharacterDefault");
static_assert(sizeof(UPalAIActionFunnelCharacterDefault) == 0x000050, "Wrong size on UPalAIActionFunnelCharacterDefault");

// Class Pal.PalAIActionFunnelSkillBase
// 0x0008 (0x0138 - 0x0130)
class UPalAIActionFunnelSkillBase final : public UPalAIActionBase
{
public:
	class UPalFunnelSkillModule*                  Module;                                            // 0x0130(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetModule(class UPalFunnelSkillModule* InModule);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionFunnelSkillBase">();
	}
	static class UPalAIActionFunnelSkillBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIActionFunnelSkillBase>();
	}
};
static_assert(alignof(UPalAIActionFunnelSkillBase) == 0x000008, "Wrong alignment on UPalAIActionFunnelSkillBase");
static_assert(sizeof(UPalAIActionFunnelSkillBase) == 0x000138, "Wrong size on UPalAIActionFunnelSkillBase");
static_assert(offsetof(UPalAIActionFunnelSkillBase, Module) == 0x000130, "Member 'UPalAIActionFunnelSkillBase::Module' has a wrong offset!");

// Class Pal.PalAnimNotifyState_Effect
// 0x0050 (0x00C8 - 0x0078)
class UPalAnimNotifyState_Effect final : public UAnimNotifyState_TimedNiagaraEffect
{
public:
	TMap<class FName, float>                      UserParameterMap;                                  // 0x0078(0x0050)(Edit, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAnimNotifyState_Effect">();
	}
	static class UPalAnimNotifyState_Effect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAnimNotifyState_Effect>();
	}
};
static_assert(alignof(UPalAnimNotifyState_Effect) == 0x000008, "Wrong alignment on UPalAnimNotifyState_Effect");
static_assert(sizeof(UPalAnimNotifyState_Effect) == 0x0000C8, "Wrong size on UPalAnimNotifyState_Effect");
static_assert(offsetof(UPalAnimNotifyState_Effect, UserParameterMap) == 0x000078, "Member 'UPalAnimNotifyState_Effect::UserParameterMap' has a wrong offset!");

// Class Pal.PalAIActionLiftup
// 0x0010 (0x0140 - 0x0130)
class UPalAIActionLiftup final : public UPalAIActionBase
{
public:
	uint8                                         Pad_288A[0x10];                                    // 0x0130(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CallOnLanded(const struct FHitResult& Hit);
	void OnLanded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionLiftup">();
	}
	static class UPalAIActionLiftup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIActionLiftup>();
	}
};
static_assert(alignof(UPalAIActionLiftup) == 0x000008, "Wrong alignment on UPalAIActionLiftup");
static_assert(sizeof(UPalAIActionLiftup) == 0x000140, "Wrong size on UPalAIActionLiftup");

// Class Pal.PalMapObjectFarmBlockV2ModelStateBehaviourSeeding
// 0x0010 (0x0040 - 0x0030)
class UPalMapObjectFarmBlockV2ModelStateBehaviourSeeding final : public UPalMapObjectFarmBlockV2ModelStateBehaviourBase
{
public:
	uint8                                         Pad_288B[0x10];                                    // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFinishWorkInServer(class UPalWorkBase* Work);
	void OnProgressWork(class UPalWorkProgress* WorkProgress);
	void UpdateProgressRateDelegate__DelegateSignature(float ProgressRate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectFarmBlockV2ModelStateBehaviourSeeding">();
	}
	static class UPalMapObjectFarmBlockV2ModelStateBehaviourSeeding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectFarmBlockV2ModelStateBehaviourSeeding>();
	}
};
static_assert(alignof(UPalMapObjectFarmBlockV2ModelStateBehaviourSeeding) == 0x000008, "Wrong alignment on UPalMapObjectFarmBlockV2ModelStateBehaviourSeeding");
static_assert(sizeof(UPalMapObjectFarmBlockV2ModelStateBehaviourSeeding) == 0x000040, "Wrong size on UPalMapObjectFarmBlockV2ModelStateBehaviourSeeding");

// Class Pal.PalAICombatModule
// 0x0000 (0x0028 - 0x0028)
class UPalAICombatModule : public UObject
{
public:
	bool AIMoveToTargetActor(class AActor* Target);
	class AActor* GetTargetActor();
	bool IsBattleMode();
	bool IsReachable_NavMesh(const struct FVector& TargetPos);
	bool IsReachable_NavMesh_ForActor(class AActor* Target);
	void OnBattleFinish();
	void Setup();
	void UpdateBattleState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAICombatModule">();
	}
	static class UPalAICombatModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAICombatModule>();
	}
};
static_assert(alignof(UPalAICombatModule) == 0x000008, "Wrong alignment on UPalAICombatModule");
static_assert(sizeof(UPalAICombatModule) == 0x000028, "Wrong size on UPalAICombatModule");

// Class Pal.PalAICombatModule_RaidBoss
// 0x0040 (0x0068 - 0x0028)
class UPalAICombatModule_RaidBoss final : public UPalAICombatModule
{
public:
	class APalMapObject*                          TargetBaseCampActor;                               // 0x0028(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  TargetBaseCampID;                                  // 0x0030(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UPalBaseCampModel>       TargetCamp;                                        // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_288F[0x20];                                    // 0x0048(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AActor* FindPlayerTarget();
	class AActor* GetBaseCampActor();
	bool JudgeReturnCombatStartPosition();
	void OnBattleFinish_forDelegate(class AActor* Actor);
	void Setup_ForBP(const struct FGuid& CampID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAICombatModule_RaidBoss">();
	}
	static class UPalAICombatModule_RaidBoss* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAICombatModule_RaidBoss>();
	}
};
static_assert(alignof(UPalAICombatModule_RaidBoss) == 0x000008, "Wrong alignment on UPalAICombatModule_RaidBoss");
static_assert(sizeof(UPalAICombatModule_RaidBoss) == 0x000068, "Wrong size on UPalAICombatModule_RaidBoss");
static_assert(offsetof(UPalAICombatModule_RaidBoss, TargetBaseCampActor) == 0x000028, "Member 'UPalAICombatModule_RaidBoss::TargetBaseCampActor' has a wrong offset!");
static_assert(offsetof(UPalAICombatModule_RaidBoss, TargetBaseCampID) == 0x000030, "Member 'UPalAICombatModule_RaidBoss::TargetBaseCampID' has a wrong offset!");
static_assert(offsetof(UPalAICombatModule_RaidBoss, TargetCamp) == 0x000040, "Member 'UPalAICombatModule_RaidBoss::TargetCamp' has a wrong offset!");

// Class Pal.PalTemperatureComponent
// 0x0070 (0x05F0 - 0x0580)
class UPalTemperatureComponent final : public UBoxComponent
{
public:
	FMulticastInlineDelegateProperty_             OnChangeTemperatureDelegate;                       // 0x0578(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2890[0x50];                                    // 0x0588(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentTemperature;                                // 0x05D8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   SelfKeyName;                                       // 0x05DC(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2891[0xC];                                     // 0x05E4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddHeatSource(class FName UniqueName, int32 HeatLevel);
	void AddHeatSourceInfo(class FName UniqueName, const struct FPalHeatSourceInfo& HeatInfo);
	void CallAllDelegate();
	void CallOnChangeTemperature(int32 Next);
	int32 GetCurrentTemperature();
	void OnChangeHour();
	void OnChangeTemperatureDelegate__DelegateSignature(int32 NextTemperature);
	void RemoveHeatSource(class FName UniqueName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalTemperatureComponent">();
	}
	static class UPalTemperatureComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalTemperatureComponent>();
	}
};
static_assert(alignof(UPalTemperatureComponent) == 0x000010, "Wrong alignment on UPalTemperatureComponent");
static_assert(sizeof(UPalTemperatureComponent) == 0x0005F0, "Wrong size on UPalTemperatureComponent");
static_assert(offsetof(UPalTemperatureComponent, OnChangeTemperatureDelegate) == 0x000578, "Member 'UPalTemperatureComponent::OnChangeTemperatureDelegate' has a wrong offset!");
static_assert(offsetof(UPalTemperatureComponent, CurrentTemperature) == 0x0005D8, "Member 'UPalTemperatureComponent::CurrentTemperature' has a wrong offset!");
static_assert(offsetof(UPalTemperatureComponent, SelfKeyName) == 0x0005DC, "Member 'UPalTemperatureComponent::SelfKeyName' has a wrong offset!");

// Class Pal.PalAIActionOtomoDefault
// 0x0008 (0x0050 - 0x0048)
class UPalAIActionOtomoDefault : public UPalAIActionCompositeBase
{
public:
	uint8                                         Pad_2892[0x8];                                     // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetOtomoBaseCampAction();
	void SetOtomoBerserker(class AActor* Target);
	void SetOtomoCombatAction();
	void SetOtomoFollowAction();
	void SetOtomoWorkAction();
	void SetOtomoWorkActionFixedAssign(class AActor* HitActor);

	bool ShouldSetCombatAction() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionOtomoDefault">();
	}
	static class UPalAIActionOtomoDefault* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIActionOtomoDefault>();
	}
};
static_assert(alignof(UPalAIActionOtomoDefault) == 0x000008, "Wrong alignment on UPalAIActionOtomoDefault");
static_assert(sizeof(UPalAIActionOtomoDefault) == 0x000050, "Wrong size on UPalAIActionOtomoDefault");

// Class Pal.PalAIActionWorkerApproachToWorkArea
// 0x0048 (0x0180 - 0x0138)
class UPalAIActionWorkerApproachToWorkArea : public UPalAIActionWorkerChildBase
{
public:
	uint8                                         Pad_2893[0x48];                                    // 0x0138(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionWorkerApproachToWorkArea">();
	}
	static class UPalAIActionWorkerApproachToWorkArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIActionWorkerApproachToWorkArea>();
	}
};
static_assert(alignof(UPalAIActionWorkerApproachToWorkArea) == 0x000008, "Wrong alignment on UPalAIActionWorkerApproachToWorkArea");
static_assert(sizeof(UPalAIActionWorkerApproachToWorkArea) == 0x000180, "Wrong size on UPalAIActionWorkerApproachToWorkArea");

// Class Pal.PalMapObjectEnergyModule
// 0x0038 (0x0068 - 0x0030)
class UPalMapObjectEnergyModule final : public UPalMapObjectConcreteModelModuleBase
{
public:
	FMulticastInlineDelegateProperty_             OnUpdateCurrentStateDelegate;                      // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EPalEnergyType                                EnergyType;                                        // 0x0040(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2894[0x3];                                     // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConsumeEnergySpeed;                                // 0x0044(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentConsumeEnergySpeed;                         // 0x0048(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPalMapObjectEnergyModuleStatusType           CurrentState;                                      // 0x004C(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRequiredConsumeEnergy;                            // 0x004D(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2895[0x2];                                     // 0x004E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  StatusHUDId;                                       // 0x0050(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2896[0x8];                                     // 0x0060(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_CurrentState();
	void RemoveHUD();
	void ReturnSelfMulticastDelegate__DelegateSignature(class UPalMapObjectEnergyModule* Module);

	bool CanConsumeEnergy() const;
	float GetConsumeEnergySpeed() const;
	float GetCurrentConsumeEnergySpeed() const;
	EPalMapObjectEnergyModuleStatusType GetCurrentState() const;
	EPalEnergyType GetEnergyType() const;
	bool IsRequiredEnergy() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectEnergyModule">();
	}
	static class UPalMapObjectEnergyModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectEnergyModule>();
	}
};
static_assert(alignof(UPalMapObjectEnergyModule) == 0x000008, "Wrong alignment on UPalMapObjectEnergyModule");
static_assert(sizeof(UPalMapObjectEnergyModule) == 0x000068, "Wrong size on UPalMapObjectEnergyModule");
static_assert(offsetof(UPalMapObjectEnergyModule, OnUpdateCurrentStateDelegate) == 0x000030, "Member 'UPalMapObjectEnergyModule::OnUpdateCurrentStateDelegate' has a wrong offset!");
static_assert(offsetof(UPalMapObjectEnergyModule, EnergyType) == 0x000040, "Member 'UPalMapObjectEnergyModule::EnergyType' has a wrong offset!");
static_assert(offsetof(UPalMapObjectEnergyModule, ConsumeEnergySpeed) == 0x000044, "Member 'UPalMapObjectEnergyModule::ConsumeEnergySpeed' has a wrong offset!");
static_assert(offsetof(UPalMapObjectEnergyModule, CurrentConsumeEnergySpeed) == 0x000048, "Member 'UPalMapObjectEnergyModule::CurrentConsumeEnergySpeed' has a wrong offset!");
static_assert(offsetof(UPalMapObjectEnergyModule, CurrentState) == 0x00004C, "Member 'UPalMapObjectEnergyModule::CurrentState' has a wrong offset!");
static_assert(offsetof(UPalMapObjectEnergyModule, bRequiredConsumeEnergy) == 0x00004D, "Member 'UPalMapObjectEnergyModule::bRequiredConsumeEnergy' has a wrong offset!");
static_assert(offsetof(UPalMapObjectEnergyModule, StatusHUDId) == 0x000050, "Member 'UPalMapObjectEnergyModule::StatusHUDId' has a wrong offset!");

// Class Pal.PalBaseCampModuleObjectMaintenance
// 0x0010 (0x0038 - 0x0028)
class UPalBaseCampModuleObjectMaintenance final : public UPalBaseCampFunctionModuleBase
{
public:
	TArray<class UPalBaseCampModuleObjectMaintenance_WayBase*> MaintenanceWayDOs;                                 // 0x0028(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void OnDisposeMapObject_ServerInternal(class UPalMapObjectModel* Model, const struct FPalMapObjectDisposeOptions& Options);
	void OnGrantedEffectToMapObject_ServerInternal(class UPalMapObjectModel* Model, class UPalMapObjectModelEffectBase* Effect);
	void OnRegisteredMapObject_ServerInternal(class UPalMapObjectModel* Model);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBaseCampModuleObjectMaintenance">();
	}
	static class UPalBaseCampModuleObjectMaintenance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBaseCampModuleObjectMaintenance>();
	}
};
static_assert(alignof(UPalBaseCampModuleObjectMaintenance) == 0x000008, "Wrong alignment on UPalBaseCampModuleObjectMaintenance");
static_assert(sizeof(UPalBaseCampModuleObjectMaintenance) == 0x000038, "Wrong size on UPalBaseCampModuleObjectMaintenance");
static_assert(offsetof(UPalBaseCampModuleObjectMaintenance, MaintenanceWayDOs) == 0x000028, "Member 'UPalBaseCampModuleObjectMaintenance::MaintenanceWayDOs' has a wrong offset!");

// Class Pal.PalAIActionWorkerReaction
// 0x0010 (0x0140 - 0x0130)
class UPalAIActionWorkerReaction final : public UPalAIActionBase
{
public:
	class APalCharacter*                          LookTargetCharacter;                               // 0x0130(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2897[0x8];                                     // 0x0138(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionWorkerReaction">();
	}
	static class UPalAIActionWorkerReaction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIActionWorkerReaction>();
	}
};
static_assert(alignof(UPalAIActionWorkerReaction) == 0x000008, "Wrong alignment on UPalAIActionWorkerReaction");
static_assert(sizeof(UPalAIActionWorkerReaction) == 0x000140, "Wrong size on UPalAIActionWorkerReaction");
static_assert(offsetof(UPalAIActionWorkerReaction, LookTargetCharacter) == 0x000130, "Member 'UPalAIActionWorkerReaction::LookTargetCharacter' has a wrong offset!");

// Class Pal.PalMapObjectDefenseModelBase
// 0x0000 (0x0218 - 0x0218)
class UPalMapObjectDefenseModelBase : public UPalMapObjectConcreteModelBase
{
public:
	EPalMapObjectDefenseType GetDefenseType() const;
	const struct FVector GetLocation() const;
	bool TryGetLauncherControlMapObject(class APalMapObject** OutMapObject) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectDefenseModelBase">();
	}
	static class UPalMapObjectDefenseModelBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectDefenseModelBase>();
	}
};
static_assert(alignof(UPalMapObjectDefenseModelBase) == 0x000008, "Wrong alignment on UPalMapObjectDefenseModelBase");
static_assert(sizeof(UPalMapObjectDefenseModelBase) == 0x000218, "Wrong size on UPalMapObjectDefenseModelBase");

// Class Pal.PalMapObjectDefenseBulletLauncherModel
// 0x0020 (0x0238 - 0x0218)
class UPalMapObjectDefenseBulletLauncherModel final : public UPalMapObjectDefenseModelBase
{
public:
	TWeakObjectPtr<class APalMapObject>           WeakLauncherControlMapObject;                      // 0x0218(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class APalStationaryWeaponBase> WeakWeapon;                                        // 0x0220(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RemainingBulletsNum;                               // 0x0228(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MagazineSize;                                      // 0x022C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   BulletItemName;                                    // 0x0230(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnUpdateEnergyModuleState(class UPalMapObjectEnergyModule* EnergyModule);
	void ReloadBullets(int32 ReloadBulletsNum);
	void SetEnableTrigger(bool EnableTrigger);
	void SetOwnerCharacter(const class APalCharacter* OwnerCharacter);
	void TurnToTarget(const class AActor* TargetActor, float DeltaTime);
	void UseBullet();

	bool CanAvailable() const;
	float GetAttackableAngle() const;
	float GetAttackableDistance() const;
	class FName GetBulletName() const;
	int32 GetMagazineSize() const;
	int32 GetRemainingBulletsNum() const;
	bool TryGetWeapon(class APalStationaryWeaponBase** OutWeapon) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectDefenseBulletLauncherModel">();
	}
	static class UPalMapObjectDefenseBulletLauncherModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectDefenseBulletLauncherModel>();
	}
};
static_assert(alignof(UPalMapObjectDefenseBulletLauncherModel) == 0x000008, "Wrong alignment on UPalMapObjectDefenseBulletLauncherModel");
static_assert(sizeof(UPalMapObjectDefenseBulletLauncherModel) == 0x000238, "Wrong size on UPalMapObjectDefenseBulletLauncherModel");
static_assert(offsetof(UPalMapObjectDefenseBulletLauncherModel, WeakLauncherControlMapObject) == 0x000218, "Member 'UPalMapObjectDefenseBulletLauncherModel::WeakLauncherControlMapObject' has a wrong offset!");
static_assert(offsetof(UPalMapObjectDefenseBulletLauncherModel, WeakWeapon) == 0x000220, "Member 'UPalMapObjectDefenseBulletLauncherModel::WeakWeapon' has a wrong offset!");
static_assert(offsetof(UPalMapObjectDefenseBulletLauncherModel, RemainingBulletsNum) == 0x000228, "Member 'UPalMapObjectDefenseBulletLauncherModel::RemainingBulletsNum' has a wrong offset!");
static_assert(offsetof(UPalMapObjectDefenseBulletLauncherModel, MagazineSize) == 0x00022C, "Member 'UPalMapObjectDefenseBulletLauncherModel::MagazineSize' has a wrong offset!");
static_assert(offsetof(UPalMapObjectDefenseBulletLauncherModel, BulletItemName) == 0x000230, "Member 'UPalMapObjectDefenseBulletLauncherModel::BulletItemName' has a wrong offset!");

// Class Pal.PalAIActionWorkerWait
// 0x0020 (0x0158 - 0x0138)
class UPalAIActionWorkerWait : public UPalAIActionWorkerChildBase
{
public:
	uint8                                         Pad_289B[0x20];                                    // 0x0138(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CalcWalkAroundDestination(const float Radius, struct FVector* OutDestination);
	EPathFollowingRequestResult MoveToLocation(const struct FVector& ToLocation);
	EPathFollowingRequestResult MoveToLocationInBaseCamp(const struct FVector& ToLocation, float DeltaTime);
	void OnTickForWait(float DeltaTime);
	void ReturnToDefaultPosition();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionWorkerWait">();
	}
	static class UPalAIActionWorkerWait* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIActionWorkerWait>();
	}
};
static_assert(alignof(UPalAIActionWorkerWait) == 0x000008, "Wrong alignment on UPalAIActionWorkerWait");
static_assert(sizeof(UPalAIActionWorkerWait) == 0x000158, "Wrong size on UPalAIActionWorkerWait");

// Class Pal.PalUIInframeRenderer
// 0x0000 (0x0290 - 0x0290)
class APalUIInframeRenderer : public AActor
{
public:
	void ClearOverrideMaterials(class USkeletalMeshComponent* TargetSkeletalMesh);
	class USkeletalMeshComponent* GetSkeletalMeshComponentFromActorClass(const TSubclassOf<class AActor>& TargetActorClass);
	class UPalStaticCharacterParameterComponent* GetStaticParameteComponentFromActorClassr(const TSubclassOf<class AActor>& TargetActorClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIInframeRenderer">();
	}
	static class APalUIInframeRenderer* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalUIInframeRenderer>();
	}
};
static_assert(alignof(APalUIInframeRenderer) == 0x000008, "Wrong alignment on APalUIInframeRenderer");
static_assert(sizeof(APalUIInframeRenderer) == 0x000290, "Wrong size on APalUIInframeRenderer");

// Class Pal.PalBossEntryWaitInfoHUD
// 0x0018 (0x0420 - 0x0408)
class UPalBossEntryWaitInfoHUD final : public UPalUserWidgetWorldHUD
{
public:
	bool                                          EnableCountDown;                                   // 0x0408(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28A0[0x7];                                     // 0x0409(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class APalBossTower*                          BossTower;                                         // 0x0410(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              TimeLimitDate;                                     // 0x0418(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnCloseHUD();
	void UpdateCountDown();
	void UpdateWaitInfo(bool bIsCountDown, const struct FDateTime& TimeLimit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBossEntryWaitInfoHUD">();
	}
	static class UPalBossEntryWaitInfoHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBossEntryWaitInfoHUD>();
	}
};
static_assert(alignof(UPalBossEntryWaitInfoHUD) == 0x000008, "Wrong alignment on UPalBossEntryWaitInfoHUD");
static_assert(sizeof(UPalBossEntryWaitInfoHUD) == 0x000420, "Wrong size on UPalBossEntryWaitInfoHUD");
static_assert(offsetof(UPalBossEntryWaitInfoHUD, EnableCountDown) == 0x000408, "Member 'UPalBossEntryWaitInfoHUD::EnableCountDown' has a wrong offset!");
static_assert(offsetof(UPalBossEntryWaitInfoHUD, BossTower) == 0x000410, "Member 'UPalBossEntryWaitInfoHUD::BossTower' has a wrong offset!");
static_assert(offsetof(UPalBossEntryWaitInfoHUD, TimeLimitDate) == 0x000418, "Member 'UPalBossEntryWaitInfoHUD::TimeLimitDate' has a wrong offset!");

// Class Pal.PalAIActionWorkerWaitForWorkable
// 0x0018 (0x0150 - 0x0138)
class UPalAIActionWorkerWaitForWorkable : public UPalAIActionWorkerChildBase
{
public:
	uint8                                         Pad_28A2[0x18];                                    // 0x0138(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionWorkerWaitForWorkable">();
	}
	static class UPalAIActionWorkerWaitForWorkable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIActionWorkerWaitForWorkable>();
	}
};
static_assert(alignof(UPalAIActionWorkerWaitForWorkable) == 0x000008, "Wrong alignment on UPalAIActionWorkerWaitForWorkable");
static_assert(sizeof(UPalAIActionWorkerWaitForWorkable) == 0x000150, "Wrong size on UPalAIActionWorkerWaitForWorkable");

// Class Pal.PalMapObjectMonsterFarmModel
// 0x0000 (0x0218 - 0x0218)
class UPalMapObjectMonsterFarmModel final : public UPalMapObjectConcreteModelBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectMonsterFarmModel">();
	}
	static class UPalMapObjectMonsterFarmModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectMonsterFarmModel>();
	}
};
static_assert(alignof(UPalMapObjectMonsterFarmModel) == 0x000008, "Wrong alignment on UPalMapObjectMonsterFarmModel");
static_assert(sizeof(UPalMapObjectMonsterFarmModel) == 0x000218, "Wrong size on UPalMapObjectMonsterFarmModel");

// Class Pal.PalAIActionWorkerWorking
// 0x0028 (0x0160 - 0x0138)
class UPalAIActionWorkerWorking : public UPalAIActionWorkerChildBase
{
public:
	EPalWorkType                                  CurrentWorkType;                                   // 0x0138(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28A3[0x3];                                     // 0x0139(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurnSpeedToTarget;                                 // 0x013C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28A4[0x20];                                    // 0x0140(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionWorkerWorking">();
	}
	static class UPalAIActionWorkerWorking* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIActionWorkerWorking>();
	}
};
static_assert(alignof(UPalAIActionWorkerWorking) == 0x000008, "Wrong alignment on UPalAIActionWorkerWorking");
static_assert(sizeof(UPalAIActionWorkerWorking) == 0x000160, "Wrong size on UPalAIActionWorkerWorking");
static_assert(offsetof(UPalAIActionWorkerWorking, CurrentWorkType) == 0x000138, "Member 'UPalAIActionWorkerWorking::CurrentWorkType' has a wrong offset!");
static_assert(offsetof(UPalAIActionWorkerWorking, TurnSpeedToTarget) == 0x00013C, "Member 'UPalAIActionWorkerWorking::TurnSpeedToTarget' has a wrong offset!");

// Class Pal.PalAIAction_LeaveBase
// 0x0018 (0x0148 - 0x0130)
class UPalAIAction_LeaveBase : public UPalAIActionBase
{
public:
	class AActor*                                 TargetActor;                                       // 0x0130(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APalCharacter*                          SelfActor;                                         // 0x0138(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalCharacterMovementComponent*         Movement;                                          // 0x0140(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InitializeObject(class AActor* CombatTarget, class APalCharacter* SelfCharactor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIAction_LeaveBase">();
	}
	static class UPalAIAction_LeaveBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIAction_LeaveBase>();
	}
};
static_assert(alignof(UPalAIAction_LeaveBase) == 0x000008, "Wrong alignment on UPalAIAction_LeaveBase");
static_assert(sizeof(UPalAIAction_LeaveBase) == 0x000148, "Wrong size on UPalAIAction_LeaveBase");
static_assert(offsetof(UPalAIAction_LeaveBase, TargetActor) == 0x000130, "Member 'UPalAIAction_LeaveBase::TargetActor' has a wrong offset!");
static_assert(offsetof(UPalAIAction_LeaveBase, SelfActor) == 0x000138, "Member 'UPalAIAction_LeaveBase::SelfActor' has a wrong offset!");
static_assert(offsetof(UPalAIAction_LeaveBase, Movement) == 0x000140, "Member 'UPalAIAction_LeaveBase::Movement' has a wrong offset!");

// Class Pal.PalCaptureReactionComponent
// 0x0000 (0x00A0 - 0x00A0)
class UPalCaptureReactionComponent final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalCaptureReactionComponent">();
	}
	static class UPalCaptureReactionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalCaptureReactionComponent>();
	}
};
static_assert(alignof(UPalCaptureReactionComponent) == 0x000008, "Wrong alignment on UPalCaptureReactionComponent");
static_assert(sizeof(UPalCaptureReactionComponent) == 0x0000A0, "Wrong size on UPalCaptureReactionComponent");

// Class Pal.PalAIBlackboardBase
// 0x0000 (0x0028 - 0x0028)
class UPalAIBlackboardBase : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIBlackboardBase">();
	}
	static class UPalAIBlackboardBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIBlackboardBase>();
	}
};
static_assert(alignof(UPalAIBlackboardBase) == 0x000008, "Wrong alignment on UPalAIBlackboardBase");
static_assert(sizeof(UPalAIBlackboardBase) == 0x000028, "Wrong size on UPalAIBlackboardBase");

// Class Pal.PalMapObjectLampModel
// 0x0000 (0x0218 - 0x0218)
class UPalMapObjectLampModel final : public UPalMapObjectConcreteModelBase
{
public:
	void OnUpdateEnergyModuleState(class UPalMapObjectEnergyModule* EnergyModule);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectLampModel">();
	}
	static class UPalMapObjectLampModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectLampModel>();
	}
};
static_assert(alignof(UPalMapObjectLampModel) == 0x000008, "Wrong alignment on UPalMapObjectLampModel");
static_assert(sizeof(UPalMapObjectLampModel) == 0x000218, "Wrong size on UPalMapObjectLampModel");

// Class Pal.PalBaseCampWorkerEventUtility
// 0x0000 (0x0028 - 0x0028)
class UPalBaseCampWorkerEventUtility final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBaseCampWorkerEventUtility">();
	}
	static class UPalBaseCampWorkerEventUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBaseCampWorkerEventUtility>();
	}
};
static_assert(alignof(UPalBaseCampWorkerEventUtility) == 0x000008, "Wrong alignment on UPalBaseCampWorkerEventUtility");
static_assert(sizeof(UPalBaseCampWorkerEventUtility) == 0x000028, "Wrong size on UPalBaseCampWorkerEventUtility");

// Class Pal.PalUIBaseCampManageModel
// 0x0040 (0x0068 - 0x0028)
class UPalUIBaseCampManageModel final : public UObject
{
public:
	TSubclassOf<class UPalUIPalBoxModel>          PalBoxClass;                                       // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalUIPalBoxModel*                      PalBox;                                            // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UPalUIBaseCampWorkersModel> BaseCampWorkersClass;                              // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalUIBaseCampWorkersModel*             BaseCampWorkers;                                   // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UPalUIBaseCampWaitersModel> BaseCampWaitersClass;                              // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalUIBaseCampWaitersModel*             BaseCampWaiters;                                   // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UPalUIBaseCampPartyModel>   BaseCampPartyClass;                                // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalUIBaseCampPartyModel*               BaseCampParty;                                     // 0x0060(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Initialize(const struct FGuid& BaseCampId);
	void MoveSlotToLost(class UPalIndividualCharacterSlot* Slot);
	void MoveSlotToParty(class UPalIndividualCharacterSlot* Slot);
	void MoveSlotToPosses(class UPalIndividualCharacterSlot* Slot);
	void MoveWaiterToWorker(const int32 SlotIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIBaseCampManageModel">();
	}
	static class UPalUIBaseCampManageModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIBaseCampManageModel>();
	}
};
static_assert(alignof(UPalUIBaseCampManageModel) == 0x000008, "Wrong alignment on UPalUIBaseCampManageModel");
static_assert(sizeof(UPalUIBaseCampManageModel) == 0x000068, "Wrong size on UPalUIBaseCampManageModel");
static_assert(offsetof(UPalUIBaseCampManageModel, PalBoxClass) == 0x000028, "Member 'UPalUIBaseCampManageModel::PalBoxClass' has a wrong offset!");
static_assert(offsetof(UPalUIBaseCampManageModel, PalBox) == 0x000030, "Member 'UPalUIBaseCampManageModel::PalBox' has a wrong offset!");
static_assert(offsetof(UPalUIBaseCampManageModel, BaseCampWorkersClass) == 0x000038, "Member 'UPalUIBaseCampManageModel::BaseCampWorkersClass' has a wrong offset!");
static_assert(offsetof(UPalUIBaseCampManageModel, BaseCampWorkers) == 0x000040, "Member 'UPalUIBaseCampManageModel::BaseCampWorkers' has a wrong offset!");
static_assert(offsetof(UPalUIBaseCampManageModel, BaseCampWaitersClass) == 0x000048, "Member 'UPalUIBaseCampManageModel::BaseCampWaitersClass' has a wrong offset!");
static_assert(offsetof(UPalUIBaseCampManageModel, BaseCampWaiters) == 0x000050, "Member 'UPalUIBaseCampManageModel::BaseCampWaiters' has a wrong offset!");
static_assert(offsetof(UPalUIBaseCampManageModel, BaseCampPartyClass) == 0x000058, "Member 'UPalUIBaseCampManageModel::BaseCampPartyClass' has a wrong offset!");
static_assert(offsetof(UPalUIBaseCampManageModel, BaseCampParty) == 0x000060, "Member 'UPalUIBaseCampManageModel::BaseCampParty' has a wrong offset!");

// Class Pal.PalAICombatModule_BaseCamp
// 0x0008 (0x0030 - 0x0028)
class UPalAICombatModule_BaseCamp final : public UPalAICombatModule
{
public:
	TWeakObjectPtr<class UPalAIActionBaseCampFighter> ParentFighterAction;                               // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAICombatModule_BaseCamp">();
	}
	static class UPalAICombatModule_BaseCamp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAICombatModule_BaseCamp>();
	}
};
static_assert(alignof(UPalAICombatModule_BaseCamp) == 0x000008, "Wrong alignment on UPalAICombatModule_BaseCamp");
static_assert(sizeof(UPalAICombatModule_BaseCamp) == 0x000030, "Wrong size on UPalAICombatModule_BaseCamp");
static_assert(offsetof(UPalAICombatModule_BaseCamp, ParentFighterAction) == 0x000028, "Member 'UPalAICombatModule_BaseCamp::ParentFighterAction' has a wrong offset!");

// Class Pal.PalMapObjectItemChestParameterComponent
// 0x0030 (0x00D0 - 0x00A0)
class UPalMapObjectItemChestParameterComponent final : public UActorComponent
{
public:
	int32                                         SlotNum;                                           // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28A5[0x4];                                     // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EPalItemTypeA>                         TargetTypesA;                                      // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EPalItemTypeB>                         TargetTypesB;                                      // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	EPalContainerOperationRestrictType            OperationRestrictType;                             // 0x00C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoDestroyIfEmpty;                               // 0x00C9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28A6[0x2];                                     // 0x00CA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CorruptionMultiplier;                              // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectItemChestParameterComponent">();
	}
	static class UPalMapObjectItemChestParameterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectItemChestParameterComponent>();
	}
};
static_assert(alignof(UPalMapObjectItemChestParameterComponent) == 0x000008, "Wrong alignment on UPalMapObjectItemChestParameterComponent");
static_assert(sizeof(UPalMapObjectItemChestParameterComponent) == 0x0000D0, "Wrong size on UPalMapObjectItemChestParameterComponent");
static_assert(offsetof(UPalMapObjectItemChestParameterComponent, SlotNum) == 0x0000A0, "Member 'UPalMapObjectItemChestParameterComponent::SlotNum' has a wrong offset!");
static_assert(offsetof(UPalMapObjectItemChestParameterComponent, TargetTypesA) == 0x0000A8, "Member 'UPalMapObjectItemChestParameterComponent::TargetTypesA' has a wrong offset!");
static_assert(offsetof(UPalMapObjectItemChestParameterComponent, TargetTypesB) == 0x0000B8, "Member 'UPalMapObjectItemChestParameterComponent::TargetTypesB' has a wrong offset!");
static_assert(offsetof(UPalMapObjectItemChestParameterComponent, OperationRestrictType) == 0x0000C8, "Member 'UPalMapObjectItemChestParameterComponent::OperationRestrictType' has a wrong offset!");
static_assert(offsetof(UPalMapObjectItemChestParameterComponent, bAutoDestroyIfEmpty) == 0x0000C9, "Member 'UPalMapObjectItemChestParameterComponent::bAutoDestroyIfEmpty' has a wrong offset!");
static_assert(offsetof(UPalMapObjectItemChestParameterComponent, CorruptionMultiplier) == 0x0000CC, "Member 'UPalMapObjectItemChestParameterComponent::CorruptionMultiplier' has a wrong offset!");

// Class Pal.PalBaseCampModel
// 0x01A8 (0x01D0 - 0x0028)
class UPalBaseCampModel final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnUpdateStatusDelegate;                            // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDisposeDelegate;                                 // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_28A7[0x10];                                    // 0x0048(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  ID;                                                // 0x0058(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 BaseCampName;                                      // 0x0068(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPalBaseCampState                             CurrentState;                                      // 0x0078(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28A8[0x7];                                     // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0080(0x0060)(Edit, Net, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AreaRange;                                         // 0x00E0(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  GroupIdBelongTo;                                   // 0x00E4(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28A9[0xC];                                     // 0x00F4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             FastTravelLocalTransform;                          // 0x0100(0x0060)(Edit, Net, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalBaseCampWorkerDirector*             WorkerDirector;                                    // 0x0160(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalBaseCampMapObjectCollection*        MapObjectCollection;                               // 0x0168(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalBaseCampWorkCollection*             WorkCollection;                                    // 0x0170(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalBaseCampEnemyObserver*              EnemyObserver;                                     // 0x0178(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UPalBaseCampFunctionModuleBase*> ModuleArray;                                       // 0x0180(0x0010)(Edit, Net, ZeroConstructor, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGuid>                          PlayerUIdsExistsInsideInServer;                    // 0x0190(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	struct FGuid                                  OwnerMapObjectInstanceId;                          // 0x01A0(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Level_InGuildProperty;                             // 0x01B0(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  LocationId;                                        // 0x01B4(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPalBaseCampSignificanceInfo           SignificanceInfo;                                  // 0x01C4(0x0008)(Edit, DisableEditOnTemplate, Transient, EditConst, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         ProgressTimeSinceLastTick;                         // 0x01CC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void BaseCampGuildPalStorageUpdateDelegate__DelegateSignature(class UPalBaseCampModel* Model, class UPalGuildPalStorage* GuildPalStorage);
	bool FindNearestAssignableObject(const class UPalIndividualCharacterHandle* AssignIndividualHandle, const struct FTransform& Origin, const float Range, const bool bFixedAssign, TScriptInterface<class IPalBaseCampAssignableObjectInterface>* FoundObject);
	bool FindWorkAssignableObject(const class UPalIndividualCharacterHandle* AssignIndividualHandle, const struct FGuid& WorkId, const bool bFixedAssign, class UPalWorkBase** FoundObject);
	void OnAddNewWorker(class UPalIndividualCharacterHandle* AddCharacterHandle);
	void OnDamageInCampActor(const struct FPalDamageResult& DamageResult);
	void OnFirstAppearEnemy();
	void OnPassedTimeAfterEmptyEnemy();
	void OnRep_Level_InGuildProperty(int32 OldLevel);
	void ReflectLevel_InGuildProperty_Internal(int32 NewLevel);
	void SimpleDelegate__DelegateSignature(class UPalBaseCampModel* Model);
	void UpdateLevel_ServerInternal(int32 PlayerId, int32 NewLevel);

	class FString GetBaseCampName() const;
	class UPalBaseCampEnemyObserver* GetEnemyObserver() const;
	const struct FGuid GetGroupIdBelongTo() const;
	const struct FGuid GetId() const;
	int32 GetLevel() const;
	const struct FGuid GetOwnerMapObjectInstanceId() const;
	float GetRange() const;
	EPalBaseCampState GetState() const;
	struct FTransform GetTransform() const;
	class UPalBaseCampWorkCollection* GetWorkCollection() const;
	bool TryGetRandomPositionInside(const struct FVector& Origin, const float Radius, struct FVector* ToLocation) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBaseCampModel">();
	}
	static class UPalBaseCampModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBaseCampModel>();
	}
};
static_assert(alignof(UPalBaseCampModel) == 0x000010, "Wrong alignment on UPalBaseCampModel");
static_assert(sizeof(UPalBaseCampModel) == 0x0001D0, "Wrong size on UPalBaseCampModel");
static_assert(offsetof(UPalBaseCampModel, OnUpdateStatusDelegate) == 0x000028, "Member 'UPalBaseCampModel::OnUpdateStatusDelegate' has a wrong offset!");
static_assert(offsetof(UPalBaseCampModel, OnDisposeDelegate) == 0x000038, "Member 'UPalBaseCampModel::OnDisposeDelegate' has a wrong offset!");
static_assert(offsetof(UPalBaseCampModel, ID) == 0x000058, "Member 'UPalBaseCampModel::ID' has a wrong offset!");
static_assert(offsetof(UPalBaseCampModel, BaseCampName) == 0x000068, "Member 'UPalBaseCampModel::BaseCampName' has a wrong offset!");
static_assert(offsetof(UPalBaseCampModel, CurrentState) == 0x000078, "Member 'UPalBaseCampModel::CurrentState' has a wrong offset!");
static_assert(offsetof(UPalBaseCampModel, Transform) == 0x000080, "Member 'UPalBaseCampModel::Transform' has a wrong offset!");
static_assert(offsetof(UPalBaseCampModel, AreaRange) == 0x0000E0, "Member 'UPalBaseCampModel::AreaRange' has a wrong offset!");
static_assert(offsetof(UPalBaseCampModel, GroupIdBelongTo) == 0x0000E4, "Member 'UPalBaseCampModel::GroupIdBelongTo' has a wrong offset!");
static_assert(offsetof(UPalBaseCampModel, FastTravelLocalTransform) == 0x000100, "Member 'UPalBaseCampModel::FastTravelLocalTransform' has a wrong offset!");
static_assert(offsetof(UPalBaseCampModel, WorkerDirector) == 0x000160, "Member 'UPalBaseCampModel::WorkerDirector' has a wrong offset!");
static_assert(offsetof(UPalBaseCampModel, MapObjectCollection) == 0x000168, "Member 'UPalBaseCampModel::MapObjectCollection' has a wrong offset!");
static_assert(offsetof(UPalBaseCampModel, WorkCollection) == 0x000170, "Member 'UPalBaseCampModel::WorkCollection' has a wrong offset!");
static_assert(offsetof(UPalBaseCampModel, EnemyObserver) == 0x000178, "Member 'UPalBaseCampModel::EnemyObserver' has a wrong offset!");
static_assert(offsetof(UPalBaseCampModel, ModuleArray) == 0x000180, "Member 'UPalBaseCampModel::ModuleArray' has a wrong offset!");
static_assert(offsetof(UPalBaseCampModel, PlayerUIdsExistsInsideInServer) == 0x000190, "Member 'UPalBaseCampModel::PlayerUIdsExistsInsideInServer' has a wrong offset!");
static_assert(offsetof(UPalBaseCampModel, OwnerMapObjectInstanceId) == 0x0001A0, "Member 'UPalBaseCampModel::OwnerMapObjectInstanceId' has a wrong offset!");
static_assert(offsetof(UPalBaseCampModel, Level_InGuildProperty) == 0x0001B0, "Member 'UPalBaseCampModel::Level_InGuildProperty' has a wrong offset!");
static_assert(offsetof(UPalBaseCampModel, LocationId) == 0x0001B4, "Member 'UPalBaseCampModel::LocationId' has a wrong offset!");
static_assert(offsetof(UPalBaseCampModel, SignificanceInfo) == 0x0001C4, "Member 'UPalBaseCampModel::SignificanceInfo' has a wrong offset!");
static_assert(offsetof(UPalBaseCampModel, ProgressTimeSinceLastTick) == 0x0001CC, "Member 'UPalBaseCampModel::ProgressTimeSinceLastTick' has a wrong offset!");

// Class Pal.PalAICombatModule_EnemyNormal
// 0x0000 (0x0028 - 0x0028)
class UPalAICombatModule_EnemyNormal final : public UPalAICombatModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAICombatModule_EnemyNormal">();
	}
	static class UPalAICombatModule_EnemyNormal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAICombatModule_EnemyNormal>();
	}
};
static_assert(alignof(UPalAICombatModule_EnemyNormal) == 0x000008, "Wrong alignment on UPalAICombatModule_EnemyNormal");
static_assert(sizeof(UPalAICombatModule_EnemyNormal) == 0x000028, "Wrong size on UPalAICombatModule_EnemyNormal");

// Class Pal.PalDungeonWorldSubsystem
// 0x0138 (0x01A8 - 0x0070)
class UPalDungeonWorldSubsystem final : public UPalWorldSubsystem
{
public:
	uint8                                         Pad_28B1[0x10];                                    // 0x0070(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGuid, struct FPalDungeonMarkerPointData> MarkerPointDataMap;                                // 0x0080(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGuid, class UPalDungeonInstanceModel*> InstanceModelMap;                                  // 0x00D0(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	struct FVector                                DungeonMargin;                                     // 0x0120(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TickInterval;                                      // 0x0138(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28B2[0x4];                                     // 0x013C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FPalDungeonDataLayerAssetSet> DataLayerAssetMap;                                 // 0x0140(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class APalDungeonPointMarker*>         PointMarkersWaitSystemInitializeInServer;          // 0x0190(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	bool                                          bInitializedWithSaveData;                          // 0x01A0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28B3[0x7];                                     // 0x01A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FGuid Debug_GetDungeonInstanceIdByIndex(const int32 Param_Index) const;
	bool TryGetDungeonInfo(const struct FPalStageInstanceId& StageInstanceId, struct FPalDungeonInfoParameter* OutInfo) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalDungeonWorldSubsystem">();
	}
	static class UPalDungeonWorldSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalDungeonWorldSubsystem>();
	}
};
static_assert(alignof(UPalDungeonWorldSubsystem) == 0x000008, "Wrong alignment on UPalDungeonWorldSubsystem");
static_assert(sizeof(UPalDungeonWorldSubsystem) == 0x0001A8, "Wrong size on UPalDungeonWorldSubsystem");
static_assert(offsetof(UPalDungeonWorldSubsystem, MarkerPointDataMap) == 0x000080, "Member 'UPalDungeonWorldSubsystem::MarkerPointDataMap' has a wrong offset!");
static_assert(offsetof(UPalDungeonWorldSubsystem, InstanceModelMap) == 0x0000D0, "Member 'UPalDungeonWorldSubsystem::InstanceModelMap' has a wrong offset!");
static_assert(offsetof(UPalDungeonWorldSubsystem, DungeonMargin) == 0x000120, "Member 'UPalDungeonWorldSubsystem::DungeonMargin' has a wrong offset!");
static_assert(offsetof(UPalDungeonWorldSubsystem, TickInterval) == 0x000138, "Member 'UPalDungeonWorldSubsystem::TickInterval' has a wrong offset!");
static_assert(offsetof(UPalDungeonWorldSubsystem, DataLayerAssetMap) == 0x000140, "Member 'UPalDungeonWorldSubsystem::DataLayerAssetMap' has a wrong offset!");
static_assert(offsetof(UPalDungeonWorldSubsystem, PointMarkersWaitSystemInitializeInServer) == 0x000190, "Member 'UPalDungeonWorldSubsystem::PointMarkersWaitSystemInitializeInServer' has a wrong offset!");
static_assert(offsetof(UPalDungeonWorldSubsystem, bInitializedWithSaveData) == 0x0001A0, "Member 'UPalDungeonWorldSubsystem::bInitializedWithSaveData' has a wrong offset!");

// Class Pal.PalMasterDataTablesUtility
// 0x0000 (0x0028 - 0x0028)
class UPalMasterDataTablesUtility final : public UBlueprintFunctionLibrary
{
public:
	static class UDataTable* GetBaseCampLevelDataTable(const class UObject* WorldContextObject);
	static class UPalMasterDataTableAccess_BaseCampLevelData* GetBaseCampLevelDataTableAccess(const class UObject* WorldContextObject);
	static class UDataTable* GetBuildObjectDataTable(const class UObject* WorldContextObject);
	static class UPalMasterDataTableAccess_BuildObjectData* GetBuildObjectDataTableAccess(const class UObject* WorldContextObject);
	static class UDataTable* GetBuildObjectIconDataTable(const class UObject* WorldContextObject);
	static class UPalMasterDataTableAccess_BuildObjectIconData* GetBuildObjectIconDataTableAccess(const class UObject* WorldContextObject);
	static class UDataTable* GetCharacterUpgradeDataTable(const class UObject* WorldContextObject);
	static class UPalMasterDataTableAccess_CharacterUpgradeData* GetCharacterUpgradeDataTableAccess(const class UObject* WorldContextObject);
	static class UDataTable* GetDungeonEnemySpawnerDataTable(const class UObject* WorldContextObject);
	static class UPalMasterDataTableAccess_DungeonEnemySpawnerData* GetDungeonEnemySpawnerDataTableAccess(const class UObject* WorldContextObject);
	static class UDataTable* GetDungeonItemLotteryDataTable(const class UObject* WorldContextObject);
	static class UPalMasterDataTableAccess_DungeonItemLotteryData* GetDungeonItemLotteryDataTableAccess(const class UObject* WorldContextObject);
	static class UDataTable* GetDungeonLevelDataTable(const class UObject* WorldContextObject);
	static class UPalMasterDataTableAccess_DungeonLevelData* GetDungeonLevelDataTableAccess(const class UObject* WorldContextObject);
	static class UDataTable* GetDungeonSpawnAreaDataTable(const class UObject* WorldContextObject);
	static class UPalMasterDataTableAccess_DungeonSpawnAreaData* GetDungeonSpawnAreaDataTableAccess(const class UObject* WorldContextObject);
	static class UDataTable* GetFarmCropDataTable(const class UObject* WorldContextObject);
	static class UPalMasterDataTableAccess_FarmCropData* GetFarmCropDataTableAccess(const class UObject* WorldContextObject);
	static class UDataTable* GetFieldLotteryNameDataTable(const class UObject* WorldContextObject);
	static class UPalMasterDataTableAccess_FieldLotteryNameData* GetFieldLotteryNameDataTableAccess(const class UObject* WorldContextObject);
	static const class UPalNoteDataAsset* GetHelpGuideDataAsset(const class UObject* WorldContextObject);
	static class UDataTable* GetItemLotteryDataTable(const class UObject* WorldContextObject);
	static class UPalMasterDataTableAccess_ItemLotteryData* GetItemLotteryDataTableAccess(const class UObject* WorldContextObject);
	static class UDataTable* GetItemRecipeDataTable(const class UObject* WorldContextObject);
	static class UPalMasterDataTableAccess_ItemRecipe* GetItemRecipeDataTableAccess(const class UObject* WorldContextObject);
	static class UDataTable* GetItemShopDataTable(const class UObject* WorldContextObject);
	static class UPalMasterDataTableAccess_ItemShop* GetItemShopDataTableAccess(const class UObject* WorldContextObject);
	static class UDataTable* GetItemShopLotteryDataTable(const class UObject* WorldContextObject);
	static class UPalMasterDataTableAccess_ItemShopLottery* GetItemShopLotteryDataTableAccess(const class UObject* WorldContextObject);
	static class FText GetLocalizedText(const class UObject* WorldContextObject, EPalLocalizeTextCategory TextCategory, class FName TextId);
	static class UDataTable* GetMapObjectDataTable(const class UObject* WorldContextObject);
	static class UPalMasterDataTableAccess_MapObjectMasterData* GetMapObjectDataTableAccess(const class UObject* WorldContextObject);
	static const class UPalNoteDataAsset* GetNoteDataAsset(const class UObject* WorldContextObject);
	static class UDataTable* GetPalShopDataTable(const class UObject* WorldContextObject);
	static class UPalMasterDataTableAccess_PalShop* GetPalShopDataTableAccess(const class UObject* WorldContextObject);
	static class UDataTable* GetPlayerStatusRankDataTable(const class UObject* WorldContextObject);
	static class UPalMasterDataTableAccess_PlayerStatusRankData* GetPlayerStatusRankDataTableAccess(const class UObject* WorldContextObject);
	static class UDataTable* GetUIInputActionDataTable(const class UObject* WorldContextObject);
	static class UPalMasterDataTableAccess_UIInputActionData* GetUIInputActionDataTableAccess(const class UObject* WorldContextObject);
	static class UDataTable* GetWildSpawnerDataTable(const class UObject* WorldContextObject);
	static class UPalMasterDataTableAccess_WildSpawnerData* GetWildSpawnerDataTableAccess(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMasterDataTablesUtility">();
	}
	static class UPalMasterDataTablesUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMasterDataTablesUtility>();
	}
};
static_assert(alignof(UPalMasterDataTablesUtility) == 0x000008, "Wrong alignment on UPalMasterDataTablesUtility");
static_assert(sizeof(UPalMasterDataTablesUtility) == 0x000028, "Wrong size on UPalMasterDataTablesUtility");

// Class Pal.PalAICombatModule_Invader
// 0x0018 (0x0040 - 0x0028)
class UPalAICombatModule_Invader final : public UPalAICombatModule
{
public:
	uint8                                         Pad_28B8[0x18];                                    // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBattleFinish_forDelegate(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAICombatModule_Invader">();
	}
	static class UPalAICombatModule_Invader* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAICombatModule_Invader>();
	}
};
static_assert(alignof(UPalAICombatModule_Invader) == 0x000008, "Wrong alignment on UPalAICombatModule_Invader");
static_assert(sizeof(UPalAICombatModule_Invader) == 0x000040, "Wrong size on UPalAICombatModule_Invader");

// Class Pal.PalUIRecoverPalBase
// 0x0000 (0x0430 - 0x0430)
class UPalUIRecoverPalBase final : public UPalUserWidgetOverlayUI
{
public:
	void SelectCharacterSlot(class UPalIndividualCharacterSlot* TargetSlot, const EPalItemSlotPressType PressType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIRecoverPalBase">();
	}
	static class UPalUIRecoverPalBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIRecoverPalBase>();
	}
};
static_assert(alignof(UPalUIRecoverPalBase) == 0x000008, "Wrong alignment on UPalUIRecoverPalBase");
static_assert(sizeof(UPalUIRecoverPalBase) == 0x000430, "Wrong size on UPalUIRecoverPalBase");

// Class Pal.PalHUDDispatchParameter_CharacterDisplay
// 0x0008 (0x0040 - 0x0038)
class UPalHUDDispatchParameter_CharacterDisplay final : public UPalHUDDispatchParameterBase
{
public:
	class UPalMapObjectDisplayCharacterModel*     Model;                                             // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalHUDDispatchParameter_CharacterDisplay">();
	}
	static class UPalHUDDispatchParameter_CharacterDisplay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalHUDDispatchParameter_CharacterDisplay>();
	}
};
static_assert(alignof(UPalHUDDispatchParameter_CharacterDisplay) == 0x000008, "Wrong alignment on UPalHUDDispatchParameter_CharacterDisplay");
static_assert(sizeof(UPalHUDDispatchParameter_CharacterDisplay) == 0x000040, "Wrong size on UPalHUDDispatchParameter_CharacterDisplay");
static_assert(offsetof(UPalHUDDispatchParameter_CharacterDisplay, Model) == 0x000038, "Member 'UPalHUDDispatchParameter_CharacterDisplay::Model' has a wrong offset!");

// Class Pal.PalAICombatModule_Otomo
// 0x0000 (0x0028 - 0x0028)
class UPalAICombatModule_Otomo final : public UPalAICombatModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAICombatModule_Otomo">();
	}
	static class UPalAICombatModule_Otomo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAICombatModule_Otomo>();
	}
};
static_assert(alignof(UPalAICombatModule_Otomo) == 0x000008, "Wrong alignment on UPalAICombatModule_Otomo");
static_assert(sizeof(UPalAICombatModule_Otomo) == 0x000028, "Wrong size on UPalAICombatModule_Otomo");

// Class Pal.PalUIMapObjectStatusIndicatorParameterBase
// 0x0010 (0x0048 - 0x0038)
class UPalUIMapObjectStatusIndicatorParameterBase : public UPalHUDDispatchParameterBase
{
public:
	uint8                                         Pad_28BA[0x10];                                    // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UPalMapObjectConcreteModelBase* GetConcreteModel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIMapObjectStatusIndicatorParameterBase">();
	}
	static class UPalUIMapObjectStatusIndicatorParameterBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIMapObjectStatusIndicatorParameterBase>();
	}
};
static_assert(alignof(UPalUIMapObjectStatusIndicatorParameterBase) == 0x000008, "Wrong alignment on UPalUIMapObjectStatusIndicatorParameterBase");
static_assert(sizeof(UPalUIMapObjectStatusIndicatorParameterBase) == 0x000048, "Wrong size on UPalUIMapObjectStatusIndicatorParameterBase");

// Class Pal.PalUIRecoverPalStatusIndicatorParameter
// 0x0000 (0x0048 - 0x0048)
class UPalUIRecoverPalStatusIndicatorParameter final : public UPalUIMapObjectStatusIndicatorParameterBase
{
public:
	bool TryGetConcreteModel(class UPalMapObjectRecoverOtomoModel** ConcreteModel) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIRecoverPalStatusIndicatorParameter">();
	}
	static class UPalUIRecoverPalStatusIndicatorParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIRecoverPalStatusIndicatorParameter>();
	}
};
static_assert(alignof(UPalUIRecoverPalStatusIndicatorParameter) == 0x000008, "Wrong alignment on UPalUIRecoverPalStatusIndicatorParameter");
static_assert(sizeof(UPalUIRecoverPalStatusIndicatorParameter) == 0x000048, "Wrong size on UPalUIRecoverPalStatusIndicatorParameter");

// Class Pal.PalHUD
// 0x0000 (0x0380 - 0x0380)
class APalHUD final : public AHUD
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalHUD">();
	}
	static class APalHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalHUD>();
	}
};
static_assert(alignof(APalHUD) == 0x000008, "Wrong alignment on APalHUD");
static_assert(sizeof(APalHUD) == 0x000380, "Wrong size on APalHUD");

// Class Pal.PalAICombatModule_Wild
// 0x0028 (0x0050 - 0x0028)
class UPalAICombatModule_Wild final : public UPalAICombatModule
{
public:
	uint8                                         Pad_28BC[0x28];                                    // 0x0028(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool JudgeReturnCombatStartPosition();
	void OnBattleFinish_forDelegate(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAICombatModule_Wild">();
	}
	static class UPalAICombatModule_Wild* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAICombatModule_Wild>();
	}
};
static_assert(alignof(UPalAICombatModule_Wild) == 0x000008, "Wrong alignment on UPalAICombatModule_Wild");
static_assert(sizeof(UPalAICombatModule_Wild) == 0x000050, "Wrong size on UPalAICombatModule_Wild");

// Class Pal.PalAIController
// 0x0170 (0x0528 - 0x03B8)
class APalAIController : public AAIController
{
public:
	TArray<class AActor*>                         TargetPlayers;                                     // 0x03B8(0x0010)(BlueprintVisible, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         TargetNPCs;                                        // 0x03C8(0x0010)(BlueprintVisible, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalAICombatModule>         CombatModuleClass;                                 // 0x03D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalActiveSkillSlot*                    SkillSlot;                                         // 0x03E0(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DebugOrganizationName;                             // 0x03E8(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APalCharacter*                          R1AttackTarget;                                    // 0x03F8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinAIActionComponentTickInterval;                  // 0x0400(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28BD[0xC];                                     // 0x0404(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsActive;                                         // 0x0410(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsSquadBehaviour;                                  // 0x0411(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsNotSleepWildLife;                                // 0x0412(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28BE[0x5];                                     // 0x0413(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalSquad*                              MySquad;                                           // 0x0418(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalHate*                               HateSystem;                                        // 0x0420(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalAIActionComponent*                  AIActionComponent;                                 // 0x0428(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalAIBlackboardBase*                   PalAIBlackboard;                                   // 0x0430(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28BF[0x88];                                    // 0x0438(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bOverwriteBlockDetectionParams;                    // 0x04C0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28C0[0x3];                                     // 0x04C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPalPathFollowingBlockDetectionParams  BlockDetectionParams;                              // 0x04C4(0x000C)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	TSubclassOf<class UPalAIBlackboardBase>       PalBlackboardClass;                                // 0x04D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28C1[0x8];                                     // 0x04D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           DeadBodyDeleteTimerHandle;                         // 0x04E0(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsDeadBodyTimeDelate;                              // 0x04E8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsSelfTimeDelate_FromSpawnTime;                    // 0x04E9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28C2[0x6];                                     // 0x04EA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           SelfDeleteTimerHandle;                             // 0x04F0(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsSelfTimeDelate_FromSpawnTime_ForVisitor;         // 0x04F8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28C3[0x7];                                     // 0x04F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShouldCheckStuckByTick;                           // 0x0500(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28C4[0x27];                                    // 0x0501(0x0027)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddTargetNPC(class AActor* NPC);
	void AddTargetPlayer_ForEnemy(class AActor* PlayerOrPal);
	class AActor* CopyTargetFromOtherAI(const class AActor* FromAcotr);
	void CreatePalBlackboard();
	void DeleteSelfDeadBody();
	bool FindNearestNavmeshPointFromSelf(struct FVector* OutLocation);
	bool FindReachablePathLocation(const TArray<struct FVector>& RequestLocationArray, struct FVector* OutGoalLocation);
	class UPalAIActionComponent* GetAIActionComponent();
	class UPalHate* GetHateSystem();
	bool GetIsnotSleepWildLife();
	bool GetIsSquadBehaviour();
	class UPalAIBlackboardBase* GetMyPalBlackboard();
	class UPalSquad* GetSquad();
	class APalCharacter* GetSquadLeader();
	bool IsExistPathForLocation_ForBP_HeightRangeCheck(const struct FVector& Location, const float AcceptanceRadius, const float UpOffset, const float DownOffset, struct FVector* OutGoalLocation);
	bool IsLeader();
	bool IsOnNavMesh();
	bool IsOnNavMesh_TargetLocation(const struct FVector& TargetLocation);
	void MoveToDirectly(const struct FVector& GoalLocation);
	void MoveToLocation_ErrorSupportMove(const struct FVector& GoalLocation);
	void NotifyTalkEnd(class APalPlayerCharacter* TalkPlayer);
	void NotifyTalkStart(class APalPlayerCharacter* TalkPlayer);
	void OnChangeChangeImportance(EPalCharacterImportanceType Next);
	void OnChangedActiveCharacter(const bool bActive);
	void OnDeadTimerStart(const struct FPalDeadInfo& Info);
	EPathFollowingRequestResult PalMoveToLocation(const struct FVector& Dest, float AcceptanceRadius, bool bStopOnOverlap, bool bUsePathfinding, bool bProjectDestinationToNavigation, bool bCanStrafe, TSubclassOf<class UNavigationQueryFilter> FilterClass, bool bAllowPartialPaths);
	void RPCDummy();
	void SetActiveAI(bool Active);
	void SetInitialValue(bool IsSquad, bool NotSleep);
	void ShowActionDebug();
	void ShowHateArrow();
	void SimpleMoveToActorWithLineTraceGround(const class AActor* GoalActor);
	void WaitForSeconds(float Time);

	class UPalAIBlackboardBase* GetLeaderPalBlackboard() const;
	bool IsActiveAI() const;
	bool IsExistPathForLocation_ForBP(const struct FVector& Location, const float AcceptanceRadius) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIController">();
	}
	static class APalAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalAIController>();
	}
};
static_assert(alignof(APalAIController) == 0x000008, "Wrong alignment on APalAIController");
static_assert(sizeof(APalAIController) == 0x000528, "Wrong size on APalAIController");
static_assert(offsetof(APalAIController, TargetPlayers) == 0x0003B8, "Member 'APalAIController::TargetPlayers' has a wrong offset!");
static_assert(offsetof(APalAIController, TargetNPCs) == 0x0003C8, "Member 'APalAIController::TargetNPCs' has a wrong offset!");
static_assert(offsetof(APalAIController, CombatModuleClass) == 0x0003D8, "Member 'APalAIController::CombatModuleClass' has a wrong offset!");
static_assert(offsetof(APalAIController, SkillSlot) == 0x0003E0, "Member 'APalAIController::SkillSlot' has a wrong offset!");
static_assert(offsetof(APalAIController, DebugOrganizationName) == 0x0003E8, "Member 'APalAIController::DebugOrganizationName' has a wrong offset!");
static_assert(offsetof(APalAIController, R1AttackTarget) == 0x0003F8, "Member 'APalAIController::R1AttackTarget' has a wrong offset!");
static_assert(offsetof(APalAIController, MinAIActionComponentTickInterval) == 0x000400, "Member 'APalAIController::MinAIActionComponentTickInterval' has a wrong offset!");
static_assert(offsetof(APalAIController, bIsActive) == 0x000410, "Member 'APalAIController::bIsActive' has a wrong offset!");
static_assert(offsetof(APalAIController, IsSquadBehaviour) == 0x000411, "Member 'APalAIController::IsSquadBehaviour' has a wrong offset!");
static_assert(offsetof(APalAIController, IsNotSleepWildLife) == 0x000412, "Member 'APalAIController::IsNotSleepWildLife' has a wrong offset!");
static_assert(offsetof(APalAIController, MySquad) == 0x000418, "Member 'APalAIController::MySquad' has a wrong offset!");
static_assert(offsetof(APalAIController, HateSystem) == 0x000420, "Member 'APalAIController::HateSystem' has a wrong offset!");
static_assert(offsetof(APalAIController, AIActionComponent) == 0x000428, "Member 'APalAIController::AIActionComponent' has a wrong offset!");
static_assert(offsetof(APalAIController, PalAIBlackboard) == 0x000430, "Member 'APalAIController::PalAIBlackboard' has a wrong offset!");
static_assert(offsetof(APalAIController, bOverwriteBlockDetectionParams) == 0x0004C0, "Member 'APalAIController::bOverwriteBlockDetectionParams' has a wrong offset!");
static_assert(offsetof(APalAIController, BlockDetectionParams) == 0x0004C4, "Member 'APalAIController::BlockDetectionParams' has a wrong offset!");
static_assert(offsetof(APalAIController, PalBlackboardClass) == 0x0004D0, "Member 'APalAIController::PalBlackboardClass' has a wrong offset!");
static_assert(offsetof(APalAIController, DeadBodyDeleteTimerHandle) == 0x0004E0, "Member 'APalAIController::DeadBodyDeleteTimerHandle' has a wrong offset!");
static_assert(offsetof(APalAIController, IsDeadBodyTimeDelate) == 0x0004E8, "Member 'APalAIController::IsDeadBodyTimeDelate' has a wrong offset!");
static_assert(offsetof(APalAIController, IsSelfTimeDelate_FromSpawnTime) == 0x0004E9, "Member 'APalAIController::IsSelfTimeDelate_FromSpawnTime' has a wrong offset!");
static_assert(offsetof(APalAIController, SelfDeleteTimerHandle) == 0x0004F0, "Member 'APalAIController::SelfDeleteTimerHandle' has a wrong offset!");
static_assert(offsetof(APalAIController, IsSelfTimeDelate_FromSpawnTime_ForVisitor) == 0x0004F8, "Member 'APalAIController::IsSelfTimeDelate_FromSpawnTime_ForVisitor' has a wrong offset!");
static_assert(offsetof(APalAIController, bShouldCheckStuckByTick) == 0x000500, "Member 'APalAIController::bShouldCheckStuckByTick' has a wrong offset!");

// Class Pal.PalHiddenBoxComponent
// 0x0000 (0x0580 - 0x0580)
class UPalHiddenBoxComponent final : public UBoxComponent
{
public:
	void BeginOverlapEvent(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void EndOverlapEvent(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalHiddenBoxComponent">();
	}
	static class UPalHiddenBoxComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalHiddenBoxComponent>();
	}
};
static_assert(alignof(UPalHiddenBoxComponent) == 0x000010, "Wrong alignment on UPalHiddenBoxComponent");
static_assert(sizeof(UPalHiddenBoxComponent) == 0x000580, "Wrong size on UPalHiddenBoxComponent");

// Class Pal.PalAIControllerBaseCampStatus
// 0x0010 (0x0038 - 0x0028)
class UPalAIControllerBaseCampStatus final : public UObject
{
public:
	uint8                                         Pad_28CE[0x10];                                    // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UPalBaseCampModel* GetBaseCamp() const;
	const struct FGuid GetBaseCampId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIControllerBaseCampStatus">();
	}
	static class UPalAIControllerBaseCampStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIControllerBaseCampStatus>();
	}
};
static_assert(alignof(UPalAIControllerBaseCampStatus) == 0x000008, "Wrong alignment on UPalAIControllerBaseCampStatus");
static_assert(sizeof(UPalAIControllerBaseCampStatus) == 0x000038, "Wrong size on UPalAIControllerBaseCampStatus");

// Class Pal.PalTimeManager
// 0x00C0 (0x0130 - 0x0070)
class UPalTimeManager : public UPalWorldSubsystem
{
public:
	uint8                                         Pad_28CF[0x10];                                    // 0x0070(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnNightStartDelegate;                              // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNightEndDelegate;                                // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPreNightSkipDelegate;                            // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNightSkipDelegate;                               // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeHoursDelegate;                             // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeMinutesDelegate;                           // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_28D0[0x20];                                    // 0x00E0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APalPlayerCharacter*>            SleepingPlayers;                                   // 0x0100(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28D1[0x18];                                    // 0x0110(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           NightSkipTimerHandle;                              // 0x0128(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static void ClearTimer(const class UObject* WorldContextObject, const struct FPalTimerHandle& Handle);
	static class FString PalTimeSecondsToString(float InSeconds);

	void AddSleepPlayer(class APalPlayerCharacter* Player);
	struct FPalTimerHandle AddTimerEventBySpan(const TDelegate<void()>& Delegate, const float Hours, const float Minutes, const float Seconds);
	void TimerEventDelegate__DelegateSignature();
	float GetCurrentPalWorldHoursFloat();
	float GetDayTimePassRate();
	void OnChangeHoursDelegate__DelegateSignature();
	void OnChangeMinutesDelegate__DelegateSignature();
	void OnNightEndDelegate__DelegateSignature();
	void OnNightSkipDelegate__DelegateSignature();
	void OnNightStartDelegate__DelegateSignature();
	void RemoveSleepPlayer(class APalPlayerCharacter* Player);
	void SetGameTime_FixDay(const int32 NextHour);
	void Tick_BP(float DeltaTime);

	EPalOneDayTimeType GetCurrentDayTimeType() const;
	int32 GetCurrentPalWorldTime_Day() const;
	int32 GetCurrentPalWorldTime_Hour() const;
	int32 GetCurrentPalWorldTime_Minute() const;
	int32 GetCurrentPalWorldTime_Second() const;
	int32 GetCurrentPalWorldTime_TotalDay() const;
	class FString GetDebugTimeString() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalTimeManager">();
	}
	static class UPalTimeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalTimeManager>();
	}
};
static_assert(alignof(UPalTimeManager) == 0x000008, "Wrong alignment on UPalTimeManager");
static_assert(sizeof(UPalTimeManager) == 0x000130, "Wrong size on UPalTimeManager");
static_assert(offsetof(UPalTimeManager, OnNightStartDelegate) == 0x000080, "Member 'UPalTimeManager::OnNightStartDelegate' has a wrong offset!");
static_assert(offsetof(UPalTimeManager, OnNightEndDelegate) == 0x000090, "Member 'UPalTimeManager::OnNightEndDelegate' has a wrong offset!");
static_assert(offsetof(UPalTimeManager, OnPreNightSkipDelegate) == 0x0000A0, "Member 'UPalTimeManager::OnPreNightSkipDelegate' has a wrong offset!");
static_assert(offsetof(UPalTimeManager, OnNightSkipDelegate) == 0x0000B0, "Member 'UPalTimeManager::OnNightSkipDelegate' has a wrong offset!");
static_assert(offsetof(UPalTimeManager, OnChangeHoursDelegate) == 0x0000C0, "Member 'UPalTimeManager::OnChangeHoursDelegate' has a wrong offset!");
static_assert(offsetof(UPalTimeManager, OnChangeMinutesDelegate) == 0x0000D0, "Member 'UPalTimeManager::OnChangeMinutesDelegate' has a wrong offset!");
static_assert(offsetof(UPalTimeManager, SleepingPlayers) == 0x000100, "Member 'UPalTimeManager::SleepingPlayers' has a wrong offset!");
static_assert(offsetof(UPalTimeManager, NightSkipTimerHandle) == 0x000128, "Member 'UPalTimeManager::NightSkipTimerHandle' has a wrong offset!");

// Class Pal.PalHUDDispatchParameter_MapObjectEnergyModule
// 0x0008 (0x0040 - 0x0038)
class UPalHUDDispatchParameter_MapObjectEnergyModule final : public UPalHUDDispatchParameterBase
{
public:
	class UPalMapObjectEnergyModule*              EnergyModule;                                      // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalHUDDispatchParameter_MapObjectEnergyModule">();
	}
	static class UPalHUDDispatchParameter_MapObjectEnergyModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalHUDDispatchParameter_MapObjectEnergyModule>();
	}
};
static_assert(alignof(UPalHUDDispatchParameter_MapObjectEnergyModule) == 0x000008, "Wrong alignment on UPalHUDDispatchParameter_MapObjectEnergyModule");
static_assert(sizeof(UPalHUDDispatchParameter_MapObjectEnergyModule) == 0x000040, "Wrong size on UPalHUDDispatchParameter_MapObjectEnergyModule");
static_assert(offsetof(UPalHUDDispatchParameter_MapObjectEnergyModule, EnergyModule) == 0x000038, "Member 'UPalHUDDispatchParameter_MapObjectEnergyModule::EnergyModule' has a wrong offset!");

// Class Pal.PalAIControllerWorkerModuleNormal
// 0x0000 (0x0028 - 0x0028)
class UPalAIControllerWorkerModuleNormal final : public UPalAIControllerWorkerModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIControllerWorkerModuleNormal">();
	}
	static class UPalAIControllerWorkerModuleNormal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIControllerWorkerModuleNormal>();
	}
};
static_assert(alignof(UPalAIControllerWorkerModuleNormal) == 0x000008, "Wrong alignment on UPalAIControllerWorkerModuleNormal");
static_assert(sizeof(UPalAIControllerWorkerModuleNormal) == 0x000028, "Wrong size on UPalAIControllerWorkerModuleNormal");

// Class Pal.PalWorkSuitabilityUtility
// 0x0000 (0x0028 - 0x0028)
class UPalWorkSuitabilityUtility final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorkSuitabilityUtility">();
	}
	static class UPalWorkSuitabilityUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWorkSuitabilityUtility>();
	}
};
static_assert(alignof(UPalWorkSuitabilityUtility) == 0x000008, "Wrong alignment on UPalWorkSuitabilityUtility");
static_assert(sizeof(UPalWorkSuitabilityUtility) == 0x000028, "Wrong size on UPalWorkSuitabilityUtility");

// Class Pal.PalHUDInGame
// 0x0288 (0x0608 - 0x0380)
class APalHUDInGame : public AHUD
{
public:
	uint8                                         Pad_28D3[0x8];                                     // 0x0380(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UPalUIHUDLayoutBase>        HUDLayoutClass;                                    // 0x0388(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UPalUIInputGuard>           PlayerInputGuardClass;                             // 0x0390(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalUIHUDLayoutBase*                    HUDLayout;                                         // 0x0398(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FGuid, class UPalUserWidgetWorldHUD*> WorldHUDWidgetMap;                                 // 0x03A0(0x0050)(Edit, ExportObject, DisableEditOnTemplate, Transient, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UPalUserWidget*>                 HUDWidgets;                                        // 0x03F0(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UPalUserWidgetStackableUI*>      StackableUIWidgets;                                // 0x0400(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UPalUILiftSlotModel*                    LiftSlotModel;                                     // 0x0410(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            HoverWidget;                                       // 0x0418(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UPalWorldHUDDisplayInfo*>        WorldHUDDisplayInfos;                              // 0x0420(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class UPalWorldHUDDisplayInfo*>        ActiveWorldHUDDisplayInfos;                        // 0x0430(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TMap<EPalWidgetBlueprintType, TSoftClassPtr<class UClass>> CommonUIClassMap;                                  // 0x0440(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<EPalWorldHUDWidgetBlueprintType, TSoftClassPtr<class UClass>> WorldHUDClassMap;                                  // 0x0490(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<EPalWidgetBlueprintType, TSubclassOf<class UPalUserWidgetStackableUI>> LoadedCommonUIClassMap;                            // 0x04E0(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<EPalWorldHUDWidgetBlueprintType, TSubclassOf<class UPalUserWidgetWorldHUD>> LoadedWorldHUDClassMap;                            // 0x0530(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_28D4[0x18];                                    // 0x0580(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalSoundPlayer*                        SoundPlayer;                                       // 0x0598(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28D5[0x8];                                     // 0x05A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   GameMenuLayerTagOrder;                             // 0x05A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<struct FGameplayTag, struct FFlagContainer> LayerHideFlagMap;                                  // 0x05B8(0x0050)(NativeAccessSpecifierPrivate)

public:
	struct FGuid AddHUD(TSubclassOf<class UPalUserWidget> WidgetClass, const EPalHUDWidgetPriority Priority, class UPalHUDDispatchParameterBase* Parameter);
	struct FGuid AddWorldHUD(const struct FPalWorldHUDParameter& Parameter);
	void BindGameOverUI();
	void BP_SetupPlayerUI();
	void CloseHUDWidget(class UPalUserWidget* Widget);
	void CloseOverlayUI(const struct FGuid& ID);
	void CloseWorldHUDWidget(const struct FGuid& WidgetId);
	class UPalUserWidget* CreateHUDWidget(TSubclassOf<class UPalUserWidget> WidgetClass, const EPalHUDWidgetPriority Priority, class UPalHUDDispatchParameterBase* Parameter);
	class UPalUserWidgetWorldHUD* CreateWorldHUDWidget(TSubclassOf<class UPalUserWidgetWorldHUD> WidgetClass, class UPalHUDDispatchParameterBase* Parameter);
	void Debug_DrawInteractPoints();
	void HideLiftIcon();
	void Initialize();
	void OnApplicationActivationStateChanged(bool bIsFocused);
	struct FGuid PushWidgetStackableUI(TSubclassOf<class UPalUserWidgetStackableUI> WidgetClass, class UPalHUDDispatchParameterBase* Parameter);
	void RemoveHUD(const struct FGuid& ID);
	void RemoveWorldHUD(const struct FGuid& ID);
	void RemoveWorldHUDFromWidgetId(const struct FGuid& ID);
	void ShowLiftIcon();
	void TickWorldHUDs();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalHUDInGame">();
	}
	static class APalHUDInGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalHUDInGame>();
	}
};
static_assert(alignof(APalHUDInGame) == 0x000008, "Wrong alignment on APalHUDInGame");
static_assert(sizeof(APalHUDInGame) == 0x000608, "Wrong size on APalHUDInGame");
static_assert(offsetof(APalHUDInGame, HUDLayoutClass) == 0x000388, "Member 'APalHUDInGame::HUDLayoutClass' has a wrong offset!");
static_assert(offsetof(APalHUDInGame, PlayerInputGuardClass) == 0x000390, "Member 'APalHUDInGame::PlayerInputGuardClass' has a wrong offset!");
static_assert(offsetof(APalHUDInGame, HUDLayout) == 0x000398, "Member 'APalHUDInGame::HUDLayout' has a wrong offset!");
static_assert(offsetof(APalHUDInGame, WorldHUDWidgetMap) == 0x0003A0, "Member 'APalHUDInGame::WorldHUDWidgetMap' has a wrong offset!");
static_assert(offsetof(APalHUDInGame, HUDWidgets) == 0x0003F0, "Member 'APalHUDInGame::HUDWidgets' has a wrong offset!");
static_assert(offsetof(APalHUDInGame, StackableUIWidgets) == 0x000400, "Member 'APalHUDInGame::StackableUIWidgets' has a wrong offset!");
static_assert(offsetof(APalHUDInGame, LiftSlotModel) == 0x000410, "Member 'APalHUDInGame::LiftSlotModel' has a wrong offset!");
static_assert(offsetof(APalHUDInGame, HoverWidget) == 0x000418, "Member 'APalHUDInGame::HoverWidget' has a wrong offset!");
static_assert(offsetof(APalHUDInGame, WorldHUDDisplayInfos) == 0x000420, "Member 'APalHUDInGame::WorldHUDDisplayInfos' has a wrong offset!");
static_assert(offsetof(APalHUDInGame, ActiveWorldHUDDisplayInfos) == 0x000430, "Member 'APalHUDInGame::ActiveWorldHUDDisplayInfos' has a wrong offset!");
static_assert(offsetof(APalHUDInGame, CommonUIClassMap) == 0x000440, "Member 'APalHUDInGame::CommonUIClassMap' has a wrong offset!");
static_assert(offsetof(APalHUDInGame, WorldHUDClassMap) == 0x000490, "Member 'APalHUDInGame::WorldHUDClassMap' has a wrong offset!");
static_assert(offsetof(APalHUDInGame, LoadedCommonUIClassMap) == 0x0004E0, "Member 'APalHUDInGame::LoadedCommonUIClassMap' has a wrong offset!");
static_assert(offsetof(APalHUDInGame, LoadedWorldHUDClassMap) == 0x000530, "Member 'APalHUDInGame::LoadedWorldHUDClassMap' has a wrong offset!");
static_assert(offsetof(APalHUDInGame, SoundPlayer) == 0x000598, "Member 'APalHUDInGame::SoundPlayer' has a wrong offset!");
static_assert(offsetof(APalHUDInGame, GameMenuLayerTagOrder) == 0x0005A8, "Member 'APalHUDInGame::GameMenuLayerTagOrder' has a wrong offset!");
static_assert(offsetof(APalHUDInGame, LayerHideFlagMap) == 0x0005B8, "Member 'APalHUDInGame::LayerHideFlagMap' has a wrong offset!");

// Class Pal.PalAIControllerWorkerInterface
// 0x0000 (0x0028 - 0x0028)
class IPalAIControllerWorkerInterface final : public IInterface
{
public:
	TSubclassOf<class UPalAIControllerWorkerModule> GetWorkerModuleClass();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIControllerWorkerInterface">();
	}
	static class IPalAIControllerWorkerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPalAIControllerWorkerInterface>();
	}
};
static_assert(alignof(IPalAIControllerWorkerInterface) == 0x000008, "Wrong alignment on IPalAIControllerWorkerInterface");
static_assert(sizeof(IPalAIControllerWorkerInterface) == 0x000028, "Wrong size on IPalAIControllerWorkerInterface");

// Class Pal.PalWorkEffectComponent
// 0x0010 (0x07E0 - 0x07D0)
class UPalWorkEffectComponent final : public UNiagaraComponent
{
public:
	int32                                         LocationIndex;                                     // 0x07D0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bActiveFX;                                         // 0x07D4(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28D8[0xB];                                     // 0x07D5(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_ActiveFX();
	void OnWorkEnded(class UPalWorkBase* Work, const struct FPalInstanceID& IndividualId);
	void OnWorkStarted(class UPalWorkBase* Work, const struct FPalInstanceID& IndividualId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorkEffectComponent">();
	}
	static class UPalWorkEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWorkEffectComponent>();
	}
};
static_assert(alignof(UPalWorkEffectComponent) == 0x000010, "Wrong alignment on UPalWorkEffectComponent");
static_assert(sizeof(UPalWorkEffectComponent) == 0x0007E0, "Wrong size on UPalWorkEffectComponent");
static_assert(offsetof(UPalWorkEffectComponent, LocationIndex) == 0x0007D0, "Member 'UPalWorkEffectComponent::LocationIndex' has a wrong offset!");
static_assert(offsetof(UPalWorkEffectComponent, bActiveFX) == 0x0007D4, "Member 'UPalWorkEffectComponent::bActiveFX' has a wrong offset!");

// Class Pal.PalHUDDispatchParameter_WorkerRadialMenu
// 0x0010 (0x0048 - 0x0038)
class UPalHUDDispatchParameter_WorkerRadialMenu final : public UPalHUDDispatchParameterBase
{
public:
	class UPalIndividualCharacterHandle*          IndividualHandle;                                  // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPalWorkerRadialMenuResult                    ResultType;                                        // 0x0040(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28D9[0x7];                                     // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalHUDDispatchParameter_WorkerRadialMenu">();
	}
	static class UPalHUDDispatchParameter_WorkerRadialMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalHUDDispatchParameter_WorkerRadialMenu>();
	}
};
static_assert(alignof(UPalHUDDispatchParameter_WorkerRadialMenu) == 0x000008, "Wrong alignment on UPalHUDDispatchParameter_WorkerRadialMenu");
static_assert(sizeof(UPalHUDDispatchParameter_WorkerRadialMenu) == 0x000048, "Wrong size on UPalHUDDispatchParameter_WorkerRadialMenu");
static_assert(offsetof(UPalHUDDispatchParameter_WorkerRadialMenu, IndividualHandle) == 0x000038, "Member 'UPalHUDDispatchParameter_WorkerRadialMenu::IndividualHandle' has a wrong offset!");
static_assert(offsetof(UPalHUDDispatchParameter_WorkerRadialMenu, ResultType) == 0x000040, "Member 'UPalHUDDispatchParameter_WorkerRadialMenu::ResultType' has a wrong offset!");

// Class Pal.PalAIResponsePreset
// 0x0008 (0x0030 - 0x0028)
class UPalAIResponsePreset : public UObject
{
public:
	EPalAIResponseType                            Discover_Player;                                   // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPalAIResponseType                            Discover_Greater;                                  // 0x0029(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPalAIResponseType                            Discover_Equal;                                    // 0x002A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPalAIResponseType                            Discover_Smaller;                                  // 0x002B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPalAIResponseType                            Damaged_Player;                                    // 0x002C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPalAIResponseType                            Damaged_Greater;                                   // 0x002D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPalAIResponseType                            Damaged_Equal;                                     // 0x002E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPalAIResponseType                            Damaged_Smaller;                                   // 0x002F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIResponsePreset">();
	}
	static class UPalAIResponsePreset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAIResponsePreset>();
	}
};
static_assert(alignof(UPalAIResponsePreset) == 0x000008, "Wrong alignment on UPalAIResponsePreset");
static_assert(sizeof(UPalAIResponsePreset) == 0x000030, "Wrong size on UPalAIResponsePreset");
static_assert(offsetof(UPalAIResponsePreset, Discover_Player) == 0x000028, "Member 'UPalAIResponsePreset::Discover_Player' has a wrong offset!");
static_assert(offsetof(UPalAIResponsePreset, Discover_Greater) == 0x000029, "Member 'UPalAIResponsePreset::Discover_Greater' has a wrong offset!");
static_assert(offsetof(UPalAIResponsePreset, Discover_Equal) == 0x00002A, "Member 'UPalAIResponsePreset::Discover_Equal' has a wrong offset!");
static_assert(offsetof(UPalAIResponsePreset, Discover_Smaller) == 0x00002B, "Member 'UPalAIResponsePreset::Discover_Smaller' has a wrong offset!");
static_assert(offsetof(UPalAIResponsePreset, Damaged_Player) == 0x00002C, "Member 'UPalAIResponsePreset::Damaged_Player' has a wrong offset!");
static_assert(offsetof(UPalAIResponsePreset, Damaged_Greater) == 0x00002D, "Member 'UPalAIResponsePreset::Damaged_Greater' has a wrong offset!");
static_assert(offsetof(UPalAIResponsePreset, Damaged_Equal) == 0x00002E, "Member 'UPalAIResponsePreset::Damaged_Equal' has a wrong offset!");
static_assert(offsetof(UPalAIResponsePreset, Damaged_Smaller) == 0x00002F, "Member 'UPalAIResponsePreset::Damaged_Smaller' has a wrong offset!");

// Class Pal.PalHUDDispatchParameter_MonsterDetail
// 0x0008 (0x0040 - 0x0038)
class UPalHUDDispatchParameter_MonsterDetail final : public UPalHUDDispatchParameterBase
{
public:
	class UPalIndividualCharacterHandle*          IndividualHandle;                                  // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalHUDDispatchParameter_MonsterDetail">();
	}
	static class UPalHUDDispatchParameter_MonsterDetail* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalHUDDispatchParameter_MonsterDetail>();
	}
};
static_assert(alignof(UPalHUDDispatchParameter_MonsterDetail) == 0x000008, "Wrong alignment on UPalHUDDispatchParameter_MonsterDetail");
static_assert(sizeof(UPalHUDDispatchParameter_MonsterDetail) == 0x000040, "Wrong size on UPalHUDDispatchParameter_MonsterDetail");
static_assert(offsetof(UPalHUDDispatchParameter_MonsterDetail, IndividualHandle) == 0x000038, "Member 'UPalHUDDispatchParameter_MonsterDetail::IndividualHandle' has a wrong offset!");

// Class Pal.PalAISightResponsePreset
// 0x00B0 (0x00D8 - 0x0028)
class UPalAISightResponsePreset : public UObject
{
public:
	TMap<EPalAISightJudgementType, TSubclassOf<class UPalAIActionBase>> AIActionMap;                                       // 0x0028(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             AimedByPlayerDelegate;                             // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<EPalAISightJudgementType, FMulticastInlineDelegateProperty_> DelegateMap;                                       // 0x0088(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	void BlueprintDelegateSetup();
	void FindDelegate__DelegateSignature(class APalCharacter* SelfCharacter, class APalCharacter* FoundCharacter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAISightResponsePreset">();
	}
	static class UPalAISightResponsePreset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAISightResponsePreset>();
	}
};
static_assert(alignof(UPalAISightResponsePreset) == 0x000008, "Wrong alignment on UPalAISightResponsePreset");
static_assert(sizeof(UPalAISightResponsePreset) == 0x0000D8, "Wrong size on UPalAISightResponsePreset");
static_assert(offsetof(UPalAISightResponsePreset, AIActionMap) == 0x000028, "Member 'UPalAISightResponsePreset::AIActionMap' has a wrong offset!");
static_assert(offsetof(UPalAISightResponsePreset, AimedByPlayerDelegate) == 0x000078, "Member 'UPalAISightResponsePreset::AimedByPlayerDelegate' has a wrong offset!");
static_assert(offsetof(UPalAISightResponsePreset, DelegateMap) == 0x000088, "Member 'UPalAISightResponsePreset::DelegateMap' has a wrong offset!");

// Class Pal.PalAISightResponseTransitionableInterface
// 0x0000 (0x0028 - 0x0028)
class IPalAISightResponseTransitionableInterface final : public IInterface
{
public:
	void GetTransitionableJudgementType(TArray<EPalAISightJudgementType>* JudgeTypeList);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAISightResponseTransitionableInterface">();
	}
	static class IPalAISightResponseTransitionableInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPalAISightResponseTransitionableInterface>();
	}
};
static_assert(alignof(IPalAISightResponseTransitionableInterface) == 0x000008, "Wrong alignment on IPalAISightResponseTransitionableInterface");
static_assert(sizeof(IPalAISightResponseTransitionableInterface) == 0x000028, "Wrong size on IPalAISightResponseTransitionableInterface");

// Class Pal.PalTutorialTriggerBase
// 0x0018 (0x0040 - 0x0028)
class UPalTutorialTriggerBase : public UObject
{
public:
	bool                                          Checked;                                           // 0x0028(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanTriggerMultiple;                                // 0x0029(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28DA[0x6];                                     // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    TutorialMsgID;                                     // 0x0030(0x0010)(BlueprintVisible, NoDestructor, ExposeOnSpawn, NativeAccessSpecifierPublic)

public:
	EPalTutorialTriggerType GetType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalTutorialTriggerBase">();
	}
	static class UPalTutorialTriggerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalTutorialTriggerBase>();
	}
};
static_assert(alignof(UPalTutorialTriggerBase) == 0x000008, "Wrong alignment on UPalTutorialTriggerBase");
static_assert(sizeof(UPalTutorialTriggerBase) == 0x000040, "Wrong size on UPalTutorialTriggerBase");
static_assert(offsetof(UPalTutorialTriggerBase, Checked) == 0x000028, "Member 'UPalTutorialTriggerBase::Checked' has a wrong offset!");
static_assert(offsetof(UPalTutorialTriggerBase, CanTriggerMultiple) == 0x000029, "Member 'UPalTutorialTriggerBase::CanTriggerMultiple' has a wrong offset!");
static_assert(offsetof(UPalTutorialTriggerBase, TutorialMsgID) == 0x000030, "Member 'UPalTutorialTriggerBase::TutorialMsgID' has a wrong offset!");

// Class Pal.PalTutorialTrigger_Common
// 0x0008 (0x0048 - 0x0040)
class UPalTutorialTrigger_Common final : public UPalTutorialTriggerBase
{
public:
	EPalTutorialTriggerConditionType              TriggerType;                                       // 0x0040(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28DB[0x7];                                     // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalTutorialTrigger_Common">();
	}
	static class UPalTutorialTrigger_Common* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalTutorialTrigger_Common>();
	}
};
static_assert(alignof(UPalTutorialTrigger_Common) == 0x000008, "Wrong alignment on UPalTutorialTrigger_Common");
static_assert(sizeof(UPalTutorialTrigger_Common) == 0x000048, "Wrong size on UPalTutorialTrigger_Common");
static_assert(offsetof(UPalTutorialTrigger_Common, TriggerType) == 0x000040, "Member 'UPalTutorialTrigger_Common::TriggerType' has a wrong offset!");

// Class Pal.PalHUDDispatchParameter_CutsceneOverlay
// 0x0008 (0x0040 - 0x0038)
class UPalHUDDispatchParameter_CutsceneOverlay final : public UPalHUDDispatchParameterBase
{
public:
	class UPalCutsceneComponent*                  CutsceneComponent;                                 // 0x0038(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalHUDDispatchParameter_CutsceneOverlay">();
	}
	static class UPalHUDDispatchParameter_CutsceneOverlay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalHUDDispatchParameter_CutsceneOverlay>();
	}
};
static_assert(alignof(UPalHUDDispatchParameter_CutsceneOverlay) == 0x000008, "Wrong alignment on UPalHUDDispatchParameter_CutsceneOverlay");
static_assert(sizeof(UPalHUDDispatchParameter_CutsceneOverlay) == 0x000040, "Wrong size on UPalHUDDispatchParameter_CutsceneOverlay");
static_assert(offsetof(UPalHUDDispatchParameter_CutsceneOverlay, CutsceneComponent) == 0x000038, "Member 'UPalHUDDispatchParameter_CutsceneOverlay::CutsceneComponent' has a wrong offset!");

// Class Pal.PalAISightResponse
// 0x0058 (0x0080 - 0x0028)
class UPalAISightResponse final : public UObject
{
public:
	class UPalAISightResponsePreset*              SightResponsePreset;                               // 0x0028(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28DC[0x50];                                    // 0x0030(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAISightResponse">();
	}
	static class UPalAISightResponse* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAISightResponse>();
	}
};
static_assert(alignof(UPalAISightResponse) == 0x000008, "Wrong alignment on UPalAISightResponse");
static_assert(sizeof(UPalAISightResponse) == 0x000080, "Wrong size on UPalAISightResponse");
static_assert(offsetof(UPalAISightResponse, SightResponsePreset) == 0x000028, "Member 'UPalAISightResponse::SightResponsePreset' has a wrong offset!");

// Class Pal.PalWorldPartitionLoadingRangeVolume
// 0x0050 (0x02E0 - 0x0290)
class APalWorldPartitionLoadingRangeVolume final : public AActor
{
public:
	TMap<int32, float>                            LoadingRangeMap;                                   // 0x0290(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	void SetOverrideLoadingRange(bool Enable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorldPartitionLoadingRangeVolume">();
	}
	static class APalWorldPartitionLoadingRangeVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalWorldPartitionLoadingRangeVolume>();
	}
};
static_assert(alignof(APalWorldPartitionLoadingRangeVolume) == 0x000008, "Wrong alignment on APalWorldPartitionLoadingRangeVolume");
static_assert(sizeof(APalWorldPartitionLoadingRangeVolume) == 0x0002E0, "Wrong size on APalWorldPartitionLoadingRangeVolume");
static_assert(offsetof(APalWorldPartitionLoadingRangeVolume, LoadingRangeMap) == 0x000290, "Member 'APalWorldPartitionLoadingRangeVolume::LoadingRangeMap' has a wrong offset!");

// Class Pal.PalIncidentNotifyListener
// 0x0040 (0x0068 - 0x0028)
class UPalIncidentNotifyListener : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnIncidentStateNotifyDelegate;                     // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UObject*                                FilterOccuredObject;                               // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                FilterOwnerObject;                                 // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           FilterIncidentIds;                                 // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           FilterIncidentTypes;                               // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void IncidentStateNotifyDelegate__DelegateSignature(class UPalIncidentNotifyListener* Listener, EPalIncidentState IncidentState, const struct FPalIncidentNotifyParameter& Parameter);
	void OnIncidentStateNotify(class UPalIncidentNotifyListener* Listener, EPalIncidentState IncidentState, const struct FPalIncidentNotifyParameter& Parameter);
	void RegisterToIncidentSystem();
	void RegisterToIncidentSystemWithFilterId(class FName FilterId);
	void RegisterToIncidentSystemWithFilterIdOccured(class FName FilterId, class UObject* FilterOccured);
	void RegisterToIncidentSystemWithFilterIdOccuredOwner(class FName FilterId, class UObject* FilterOccured, class UObject* FilterOwner);
	void RegisterToIncidentSystemWithFilterIdOwner(class FName FilterId, class UObject* FilterOwner);
	void RegisterToIncidentSystemWithFilterIds(const TArray<class FName>& FilterIds);
	void RegisterToIncidentSystemWithFilterIdsOccured(const TArray<class FName>& FilterIds, class UObject* FilterOccured);
	void RegisterToIncidentSystemWithFilterIdsOccuredOwner(const TArray<class FName>& FilterIds, class UObject* FilterOccured, class UObject* FilterOwner);
	void RegisterToIncidentSystemWithFilterIdsOwner(const TArray<class FName>& FilterIds, class UObject* FilterOwner);
	void RegisterToIncidentSystemWithFilterOccured(class UObject* FilterOccured);
	void RegisterToIncidentSystemWithFilterOccuredOwner(class UObject* FilterOccured, class UObject* FilterOwner);
	void RegisterToIncidentSystemWithFilterOwner(class UObject* FilterOwner);
	void UnregisterFromIncidentSystem();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalIncidentNotifyListener">();
	}
	static class UPalIncidentNotifyListener* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalIncidentNotifyListener>();
	}
};
static_assert(alignof(UPalIncidentNotifyListener) == 0x000008, "Wrong alignment on UPalIncidentNotifyListener");
static_assert(sizeof(UPalIncidentNotifyListener) == 0x000068, "Wrong size on UPalIncidentNotifyListener");
static_assert(offsetof(UPalIncidentNotifyListener, OnIncidentStateNotifyDelegate) == 0x000028, "Member 'UPalIncidentNotifyListener::OnIncidentStateNotifyDelegate' has a wrong offset!");
static_assert(offsetof(UPalIncidentNotifyListener, FilterOccuredObject) == 0x000038, "Member 'UPalIncidentNotifyListener::FilterOccuredObject' has a wrong offset!");
static_assert(offsetof(UPalIncidentNotifyListener, FilterOwnerObject) == 0x000040, "Member 'UPalIncidentNotifyListener::FilterOwnerObject' has a wrong offset!");
static_assert(offsetof(UPalIncidentNotifyListener, FilterIncidentIds) == 0x000048, "Member 'UPalIncidentNotifyListener::FilterIncidentIds' has a wrong offset!");
static_assert(offsetof(UPalIncidentNotifyListener, FilterIncidentTypes) == 0x000058, "Member 'UPalIncidentNotifyListener::FilterIncidentTypes' has a wrong offset!");

// Class Pal.PalAmbientSoundAreaBase
// 0x0030 (0x02C0 - 0x0290)
class APalAmbientSoundAreaBase final : public AActor
{
public:
	int32                                         AmbientPriority;                                   // 0x0290(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28DF[0x4];                                     // 0x0294(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAkAudioEvent*>                  DayAmbientEvents;                                  // 0x0298(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class UAkAudioEvent*>                  NightAmbientEvents;                                // 0x02A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsOverlappedLocalPlayer;                          // 0x02B8(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28E0[0x7];                                     // 0x02B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class APalPlayerCharacter* PlayerCharacter);
	void OnEndOverlap(class UPrimitiveComponent* OverlappedComponent, class APalPlayerCharacter* PlayerCharacter);

	struct FPalAmbientSoundAreaData GetAmbientSoundAreaData() const;
	class UPrimitiveComponent* GetAreaCollision() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAmbientSoundAreaBase">();
	}
	static class APalAmbientSoundAreaBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalAmbientSoundAreaBase>();
	}
};
static_assert(alignof(APalAmbientSoundAreaBase) == 0x000008, "Wrong alignment on APalAmbientSoundAreaBase");
static_assert(sizeof(APalAmbientSoundAreaBase) == 0x0002C0, "Wrong size on APalAmbientSoundAreaBase");
static_assert(offsetof(APalAmbientSoundAreaBase, AmbientPriority) == 0x000290, "Member 'APalAmbientSoundAreaBase::AmbientPriority' has a wrong offset!");
static_assert(offsetof(APalAmbientSoundAreaBase, DayAmbientEvents) == 0x000298, "Member 'APalAmbientSoundAreaBase::DayAmbientEvents' has a wrong offset!");
static_assert(offsetof(APalAmbientSoundAreaBase, NightAmbientEvents) == 0x0002A8, "Member 'APalAmbientSoundAreaBase::NightAmbientEvents' has a wrong offset!");
static_assert(offsetof(APalAmbientSoundAreaBase, bIsOverlappedLocalPlayer) == 0x0002B8, "Member 'APalAmbientSoundAreaBase::bIsOverlappedLocalPlayer' has a wrong offset!");

// Class Pal.PalAmbientSoundLineBase
// 0x0018 (0x02A8 - 0x0290)
class APalAmbientSoundLineBase final : public AActor
{
public:
	class UAkComponent*                           AkComponent;                                       // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          ActivateTrigger;                                   // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalAmbientSoundLineObject*             AmbinetSoundLineObject;                            // 0x02A0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAmbientSoundLineBase">();
	}
	static class APalAmbientSoundLineBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalAmbientSoundLineBase>();
	}
};
static_assert(alignof(APalAmbientSoundLineBase) == 0x000008, "Wrong alignment on APalAmbientSoundLineBase");
static_assert(sizeof(APalAmbientSoundLineBase) == 0x0002A8, "Wrong size on APalAmbientSoundLineBase");
static_assert(offsetof(APalAmbientSoundLineBase, AkComponent) == 0x000290, "Member 'APalAmbientSoundLineBase::AkComponent' has a wrong offset!");
static_assert(offsetof(APalAmbientSoundLineBase, ActivateTrigger) == 0x000298, "Member 'APalAmbientSoundLineBase::ActivateTrigger' has a wrong offset!");
static_assert(offsetof(APalAmbientSoundLineBase, AmbinetSoundLineObject) == 0x0002A0, "Member 'APalAmbientSoundLineBase::AmbinetSoundLineObject' has a wrong offset!");

// Class Pal.PalSoundPlayerInEditorComponent
// 0x0038 (0x00D8 - 0x00A0)
class UPalSoundPlayerInEditorComponent final : public UActorComponent
{
public:
	TSoftClassPtr<class UClass>                   PalSoundSlotClass;                                 // 0x00A0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalSoundSlot*                          PalSoundSlotCache;                                 // 0x00D0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetPhysicalMaterial(EPhysicalSurface PhysicalSurface);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalSoundPlayerInEditorComponent">();
	}
	static class UPalSoundPlayerInEditorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalSoundPlayerInEditorComponent>();
	}
};
static_assert(alignof(UPalSoundPlayerInEditorComponent) == 0x000008, "Wrong alignment on UPalSoundPlayerInEditorComponent");
static_assert(sizeof(UPalSoundPlayerInEditorComponent) == 0x0000D8, "Wrong size on UPalSoundPlayerInEditorComponent");
static_assert(offsetof(UPalSoundPlayerInEditorComponent, PalSoundSlotClass) == 0x0000A0, "Member 'UPalSoundPlayerInEditorComponent::PalSoundSlotClass' has a wrong offset!");
static_assert(offsetof(UPalSoundPlayerInEditorComponent, PalSoundSlotCache) == 0x0000D0, "Member 'UPalSoundPlayerInEditorComponent::PalSoundSlotCache' has a wrong offset!");

// Class Pal.PalWorldSecurityDefine
// 0x0000 (0x0028 - 0x0028)
class UPalWorldSecurityDefine final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorldSecurityDefine">();
	}
	static class UPalWorldSecurityDefine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWorldSecurityDefine>();
	}
};
static_assert(alignof(UPalWorldSecurityDefine) == 0x000008, "Wrong alignment on UPalWorldSecurityDefine");
static_assert(sizeof(UPalWorldSecurityDefine) == 0x000028, "Wrong size on UPalWorldSecurityDefine");

// Class Pal.PalHUDServiceProviderInterface
// 0x0000 (0x0028 - 0x0028)
class IPalHUDServiceProviderInterface final : public IInterface
{
public:
	class UPalSoundPlayer* GetSoundPlayer();
	void PlayAkSound(class UAkAudioEvent* AkEvent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalHUDServiceProviderInterface">();
	}
	static class IPalHUDServiceProviderInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPalHUDServiceProviderInterface>();
	}
};
static_assert(alignof(IPalHUDServiceProviderInterface) == 0x000008, "Wrong alignment on IPalHUDServiceProviderInterface");
static_assert(sizeof(IPalHUDServiceProviderInterface) == 0x000028, "Wrong size on IPalHUDServiceProviderInterface");

// Class Pal.PalAmbientSoundLineComponent
// 0x0020 (0x05A0 - 0x0580)
class UPalAmbientSoundLineComponent final : public UBoxComponent
{
public:
	class UAkAudioEvent*                          AmbientEvent;                                      // 0x0578(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEnableAmbientSound;                             // 0x0580(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28E1[0x7];                                     // 0x0581(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalAmbientSoundLineObject*             AmbinetSoundLineObject;                            // 0x0588(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkComponent*                           AkComponent;                                       // 0x0590(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28E2[0x8];                                     // 0x0598(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAmbientSoundLineComponent">();
	}
	static class UPalAmbientSoundLineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAmbientSoundLineComponent>();
	}
};
static_assert(alignof(UPalAmbientSoundLineComponent) == 0x000010, "Wrong alignment on UPalAmbientSoundLineComponent");
static_assert(sizeof(UPalAmbientSoundLineComponent) == 0x0005A0, "Wrong size on UPalAmbientSoundLineComponent");
static_assert(offsetof(UPalAmbientSoundLineComponent, AmbientEvent) == 0x000578, "Member 'UPalAmbientSoundLineComponent::AmbientEvent' has a wrong offset!");
static_assert(offsetof(UPalAmbientSoundLineComponent, bIsEnableAmbientSound) == 0x000580, "Member 'UPalAmbientSoundLineComponent::bIsEnableAmbientSound' has a wrong offset!");
static_assert(offsetof(UPalAmbientSoundLineComponent, AmbinetSoundLineObject) == 0x000588, "Member 'UPalAmbientSoundLineComponent::AmbinetSoundLineObject' has a wrong offset!");
static_assert(offsetof(UPalAmbientSoundLineComponent, AkComponent) == 0x000590, "Member 'UPalAmbientSoundLineComponent::AkComponent' has a wrong offset!");

// Class Pal.PalAmbientSoundLineObject
// 0x0028 (0x0050 - 0x0028)
class UPalAmbientSoundLineObject final : public UObject
{
public:
	uint8                                         Pad_28E3[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USplineComponent*>               SplineComponents;                                  // 0x0030(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          ActivateTrigger;                                   // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkComponent*                           AkComponent;                                       // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnActivateTriggerLineOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnActivateTriggerOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAmbientSoundLineObject">();
	}
	static class UPalAmbientSoundLineObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAmbientSoundLineObject>();
	}
};
static_assert(alignof(UPalAmbientSoundLineObject) == 0x000008, "Wrong alignment on UPalAmbientSoundLineObject");
static_assert(sizeof(UPalAmbientSoundLineObject) == 0x000050, "Wrong size on UPalAmbientSoundLineObject");
static_assert(offsetof(UPalAmbientSoundLineObject, SplineComponents) == 0x000030, "Member 'UPalAmbientSoundLineObject::SplineComponents' has a wrong offset!");
static_assert(offsetof(UPalAmbientSoundLineObject, ActivateTrigger) == 0x000040, "Member 'UPalAmbientSoundLineObject::ActivateTrigger' has a wrong offset!");
static_assert(offsetof(UPalAmbientSoundLineObject, AkComponent) == 0x000048, "Member 'UPalAmbientSoundLineObject::AkComponent' has a wrong offset!");

// Class Pal.PalHUDDispatchParameter_Invader
// 0x0030 (0x0068 - 0x0038)
class UPalHUDDispatchParameter_Invader final : public UPalHUDDispatchParameterBase
{
public:
	TSoftObjectPtr<class APalCharacter>           ParentCharacter;                                   // 0x0038(0x0030)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalHUDDispatchParameter_Invader">();
	}
	static class UPalHUDDispatchParameter_Invader* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalHUDDispatchParameter_Invader>();
	}
};
static_assert(alignof(UPalHUDDispatchParameter_Invader) == 0x000008, "Wrong alignment on UPalHUDDispatchParameter_Invader");
static_assert(sizeof(UPalHUDDispatchParameter_Invader) == 0x000068, "Wrong size on UPalHUDDispatchParameter_Invader");
static_assert(offsetof(UPalHUDDispatchParameter_Invader, ParentCharacter) == 0x000038, "Member 'UPalHUDDispatchParameter_Invader::ParentCharacter' has a wrong offset!");

// Class Pal.PalAnimInstance
// 0x02C0 (0x0610 - 0x0350)
class UPalAnimInstance : public UAnimInstance
{
public:
	FMulticastInlineDelegateProperty_             OnMontageNotifyBeginDelegate;                      // 0x0348(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMontageNotifyEndDelegate;                        // 0x0358(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UAnimInstance>>      ImplementationClassList;                           // 0x0368(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FGeneralAnimationParameter             GeneralAnimationParameter;                         // 0x0378(0x0168)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          IsRotateYawInterpolation;                          // 0x04E0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28E6[0x3];                                     // 0x04E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotateYawInterpolation_Acceleration;               // 0x04E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, class UPalBoneInfo*>        BoneListFullBody;                                  // 0x04E8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class FName, class UPalBoneInfo*>        BoneListOnlySpines;                                // 0x0538(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TArray<struct FReserveMontage>                ReservedMontageList;                               // 0x0588(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28E7[0x8];                                     // 0x0598(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatContainer                        AdditiveAnimationRate;                             // 0x05A0(0x0010)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28E8[0x8];                                     // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFlagContainer                         DisableUpperOverrideFlag;                          // 0x05B8(0x0050)(Edit, Transient, DisableEditOnInstance, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28E9[0x8];                                     // 0x0608(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddList(class FName BoneName);
	void AddSpinesListFromBoneList(class FName BoneName);
	void BodyInstance_SetSimulate(class FName BoneName, bool SimulateActive);
	void CalcLength(class FName Target, class FName NextBone, float TipLength);
	class UPalBoneInfo* GetBoneInfo(class FName BoneName);
	struct FVector GetBonePosition(class FName BoneName);
	struct FQuat GetBoneRotation(class FName BoneName);
	struct FQuat GetBoneRotationComponentSpace(class FName BoneName);
	struct FTransform GetBoneTransform(class FName BoneName);
	float GetCurrentMontagePlayTimeToEnd();
	class FName GetNearBoneInFullBody(const struct FVector& FromPos);
	class FName GetNearBoneInSpines(const struct FVector& FromPos);
	void Montage_PlayList(const TArray<struct FReserveMontage>& MontageList);
	void OnMontageEndedCallback(class UAnimMontage* Montage, bool bInterrupted);
	void OnMontageNotifyBegin__DelegateSignature(class UAnimMontage* Montage, class FName NotifyName);
	void OnMontageNotifyEnd__DelegateSignature(class UAnimMontage* Montage, class FName NotifyName);
	void OnNotifyBeginReceived(class FName NotifyName, const struct FBranchingPointNotifyPayload& BranchingPointNotifyPayload);
	void OnNotifyEndReceived(class FName NotifyName, const struct FBranchingPointNotifyPayload& BranchingPointNotifyPayload);
	void SetAdditiveAnimationRate(class FName FlagName, float Rate);
	void SetUpperOverrideDisableFlag(class FName FlagName, bool IsDisable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAnimInstance">();
	}
	static class UPalAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAnimInstance>();
	}
};
static_assert(alignof(UPalAnimInstance) == 0x000010, "Wrong alignment on UPalAnimInstance");
static_assert(sizeof(UPalAnimInstance) == 0x000610, "Wrong size on UPalAnimInstance");
static_assert(offsetof(UPalAnimInstance, OnMontageNotifyBeginDelegate) == 0x000348, "Member 'UPalAnimInstance::OnMontageNotifyBeginDelegate' has a wrong offset!");
static_assert(offsetof(UPalAnimInstance, OnMontageNotifyEndDelegate) == 0x000358, "Member 'UPalAnimInstance::OnMontageNotifyEndDelegate' has a wrong offset!");
static_assert(offsetof(UPalAnimInstance, ImplementationClassList) == 0x000368, "Member 'UPalAnimInstance::ImplementationClassList' has a wrong offset!");
static_assert(offsetof(UPalAnimInstance, GeneralAnimationParameter) == 0x000378, "Member 'UPalAnimInstance::GeneralAnimationParameter' has a wrong offset!");
static_assert(offsetof(UPalAnimInstance, IsRotateYawInterpolation) == 0x0004E0, "Member 'UPalAnimInstance::IsRotateYawInterpolation' has a wrong offset!");
static_assert(offsetof(UPalAnimInstance, RotateYawInterpolation_Acceleration) == 0x0004E4, "Member 'UPalAnimInstance::RotateYawInterpolation_Acceleration' has a wrong offset!");
static_assert(offsetof(UPalAnimInstance, BoneListFullBody) == 0x0004E8, "Member 'UPalAnimInstance::BoneListFullBody' has a wrong offset!");
static_assert(offsetof(UPalAnimInstance, BoneListOnlySpines) == 0x000538, "Member 'UPalAnimInstance::BoneListOnlySpines' has a wrong offset!");
static_assert(offsetof(UPalAnimInstance, ReservedMontageList) == 0x000588, "Member 'UPalAnimInstance::ReservedMontageList' has a wrong offset!");
static_assert(offsetof(UPalAnimInstance, AdditiveAnimationRate) == 0x0005A0, "Member 'UPalAnimInstance::AdditiveAnimationRate' has a wrong offset!");
static_assert(offsetof(UPalAnimInstance, DisableUpperOverrideFlag) == 0x0005B8, "Member 'UPalAnimInstance::DisableUpperOverrideFlag' has a wrong offset!");

// Class Pal.PalAnimNotifyDynamicParameterBase
// 0x0008 (0x0030 - 0x0028)
class UPalAnimNotifyDynamicParameterBase : public UObject
{
public:
	uint8                                         Pad_28F0[0x8];                                     // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAnimNotifyDynamicParameterBase">();
	}
	static class UPalAnimNotifyDynamicParameterBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAnimNotifyDynamicParameterBase>();
	}
};
static_assert(alignof(UPalAnimNotifyDynamicParameterBase) == 0x000008, "Wrong alignment on UPalAnimNotifyDynamicParameterBase");
static_assert(sizeof(UPalAnimNotifyDynamicParameterBase) == 0x000030, "Wrong size on UPalAnimNotifyDynamicParameterBase");

// Class Pal.PalSpeedCollisionComponent
// 0x0020 (0x0580 - 0x0560)
class UPalSpeedCollisionComponent final : public USphereComponent
{
public:
	bool                                          IsSelfEnable;                                      // 0x0560(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28F1[0x7];                                     // 0x0561(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPalInstanceID>                 HitPalList;                                        // 0x0568(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28F2[0x8];                                     // 0x0578(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginOverlapEvent(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void DelayRemoveInterval();
	void OnActionBegin(const class UPalActionBase* Action);
	void OnAllActionEnd(const class UPalActionComponent* ActionComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalSpeedCollisionComponent">();
	}
	static class UPalSpeedCollisionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalSpeedCollisionComponent>();
	}
};
static_assert(alignof(UPalSpeedCollisionComponent) == 0x000010, "Wrong alignment on UPalSpeedCollisionComponent");
static_assert(sizeof(UPalSpeedCollisionComponent) == 0x000580, "Wrong size on UPalSpeedCollisionComponent");
static_assert(offsetof(UPalSpeedCollisionComponent, IsSelfEnable) == 0x000560, "Member 'UPalSpeedCollisionComponent::IsSelfEnable' has a wrong offset!");
static_assert(offsetof(UPalSpeedCollisionComponent, HitPalList) == 0x000568, "Member 'UPalSpeedCollisionComponent::HitPalList' has a wrong offset!");

// Class Pal.PalIncidentBase
// 0x0138 (0x0160 - 0x0028)
class UPalIncidentBase : public UObject
{
public:
	struct FPalIncidentExecutionSettings          ExecSettings;                                      // 0x0028(0x0001)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_28F4[0x7];                                     // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPalIncidentIdParameter                IdParameter;                                       // 0x0030(0x0038)(Edit, EditConst, NativeAccessSpecifierPrivate)
	class UPalIncidentBase*                       ParentIncident;                                    // 0x0068(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalIncidentDynamicParameter*           DynamicParameter;                                  // 0x0070(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28F5[0x8];                                     // 0x0078(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPalIncidentSystemFunctionAccessor     FunctionAccessor;                                  // 0x0080(0x00C0)(Edit, EditConst, NativeAccessSpecifierPrivate)
	bool                                          bForceStop;                                        // 0x0140(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28F6[0x7];                                     // 0x0141(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                OccuredObject;                                     // 0x0148(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UObject*                                OwnerObject;                                       // 0x0150(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPalIncidentState                             ExecState;                                         // 0x0158(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28F7[0x7];                                     // 0x0159(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DropItem(class FName ItemId, int32 DropNum, const struct FVector& SpawnLocation, const struct FVector& ReleaseDirection);
	void Finish();
	void ForceStop();
	void OnBegin();
	void OnCanceled();
	void OnChildInitialized(class UPalIncidentBase* Child);
	void OnEnd();
	void OnForceStop();
	void OnGenerated();
	void OnInitialized();
	int32 RequestConsumeInventoryItem(class UPalPlayerInventoryData* InventoryData, class FName ItemId, int32 ConsumeNum);
	void SetDynamicParameter(class UPalIncidentDynamicParameter* Parameter);
	void Tick(float DeltaTime);

	class FName GetArg(int32 Param_Index) const;
	const TArray<class FName> GetArgs() const;
	class UPalIncidentDynamicParameter* GetDynamicParameter() const;
	const class FName GetIncidentId() const;
	const class FName GetIncidentType() const;
	class UObject* GetOccuredObject() const;
	class UObject* GetOwner() const;
	class UPalIncidentBase* GetParentIncident() const;
	const class UPalIncidentBase* GetRootIncident() const;
	bool HasOption(const class FName& Option) const;
	bool IsCanceled() const;
	bool IsCompleted() const;
	bool IsExecuting() const;
	bool IsInitialized() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalIncidentBase">();
	}
	static class UPalIncidentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalIncidentBase>();
	}
};
static_assert(alignof(UPalIncidentBase) == 0x000010, "Wrong alignment on UPalIncidentBase");
static_assert(sizeof(UPalIncidentBase) == 0x000160, "Wrong size on UPalIncidentBase");
static_assert(offsetof(UPalIncidentBase, ExecSettings) == 0x000028, "Member 'UPalIncidentBase::ExecSettings' has a wrong offset!");
static_assert(offsetof(UPalIncidentBase, IdParameter) == 0x000030, "Member 'UPalIncidentBase::IdParameter' has a wrong offset!");
static_assert(offsetof(UPalIncidentBase, ParentIncident) == 0x000068, "Member 'UPalIncidentBase::ParentIncident' has a wrong offset!");
static_assert(offsetof(UPalIncidentBase, DynamicParameter) == 0x000070, "Member 'UPalIncidentBase::DynamicParameter' has a wrong offset!");
static_assert(offsetof(UPalIncidentBase, FunctionAccessor) == 0x000080, "Member 'UPalIncidentBase::FunctionAccessor' has a wrong offset!");
static_assert(offsetof(UPalIncidentBase, bForceStop) == 0x000140, "Member 'UPalIncidentBase::bForceStop' has a wrong offset!");
static_assert(offsetof(UPalIncidentBase, OccuredObject) == 0x000148, "Member 'UPalIncidentBase::OccuredObject' has a wrong offset!");
static_assert(offsetof(UPalIncidentBase, OwnerObject) == 0x000150, "Member 'UPalIncidentBase::OwnerObject' has a wrong offset!");
static_assert(offsetof(UPalIncidentBase, ExecState) == 0x000158, "Member 'UPalIncidentBase::ExecState' has a wrong offset!");

// Class Pal.PalAnimNotifyDynamicParameterAttackCollision
// 0x0030 (0x0060 - 0x0030)
class UPalAnimNotifyDynamicParameterAttackCollision final : public UPalAnimNotifyDynamicParameterBase
{
public:
	class UPalHitFilter*                          AttackFilter;                                      // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UShapeComponent*>                TransientShapeComponents;                          // 0x0038(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         HitStopCount;                                      // 0x0048(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28FA[0x4];                                     // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 MyMesh;                                            // 0x0050(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 MyActor;                                           // 0x0058(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAnimNotifyDynamicParameterAttackCollision">();
	}
	static class UPalAnimNotifyDynamicParameterAttackCollision* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAnimNotifyDynamicParameterAttackCollision>();
	}
};
static_assert(alignof(UPalAnimNotifyDynamicParameterAttackCollision) == 0x000008, "Wrong alignment on UPalAnimNotifyDynamicParameterAttackCollision");
static_assert(sizeof(UPalAnimNotifyDynamicParameterAttackCollision) == 0x000060, "Wrong size on UPalAnimNotifyDynamicParameterAttackCollision");
static_assert(offsetof(UPalAnimNotifyDynamicParameterAttackCollision, AttackFilter) == 0x000030, "Member 'UPalAnimNotifyDynamicParameterAttackCollision::AttackFilter' has a wrong offset!");
static_assert(offsetof(UPalAnimNotifyDynamicParameterAttackCollision, TransientShapeComponents) == 0x000038, "Member 'UPalAnimNotifyDynamicParameterAttackCollision::TransientShapeComponents' has a wrong offset!");
static_assert(offsetof(UPalAnimNotifyDynamicParameterAttackCollision, HitStopCount) == 0x000048, "Member 'UPalAnimNotifyDynamicParameterAttackCollision::HitStopCount' has a wrong offset!");
static_assert(offsetof(UPalAnimNotifyDynamicParameterAttackCollision, MyMesh) == 0x000050, "Member 'UPalAnimNotifyDynamicParameterAttackCollision::MyMesh' has a wrong offset!");
static_assert(offsetof(UPalAnimNotifyDynamicParameterAttackCollision, MyActor) == 0x000058, "Member 'UPalAnimNotifyDynamicParameterAttackCollision::MyActor' has a wrong offset!");

// Class Pal.PalAnimNotifyDynamicParameterAvoidTime
// 0x0050 (0x0080 - 0x0030)
class UPalAnimNotifyDynamicParameterAvoidTime final : public UPalAnimNotifyDynamicParameterBase
{
public:
	TMap<class UPrimitiveComponent*, ECollisionResponse> AttackResponseMap;                                 // 0x0030(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAnimNotifyDynamicParameterAvoidTime">();
	}
	static class UPalAnimNotifyDynamicParameterAvoidTime* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAnimNotifyDynamicParameterAvoidTime>();
	}
};
static_assert(alignof(UPalAnimNotifyDynamicParameterAvoidTime) == 0x000008, "Wrong alignment on UPalAnimNotifyDynamicParameterAvoidTime");
static_assert(sizeof(UPalAnimNotifyDynamicParameterAvoidTime) == 0x000080, "Wrong size on UPalAnimNotifyDynamicParameterAvoidTime");
static_assert(offsetof(UPalAnimNotifyDynamicParameterAvoidTime, AttackResponseMap) == 0x000030, "Member 'UPalAnimNotifyDynamicParameterAvoidTime::AttackResponseMap' has a wrong offset!");

// Class Pal.PalAnimNotifyParameterComponent
// 0x0050 (0x00F0 - 0x00A0)
class UPalAnimNotifyParameterComponent final : public UActorComponent
{
public:
	TMap<class FString, class UPalAnimNotifyDynamicParameterBase*> DynamicParameterMap;                               // 0x00A0(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAnimNotifyParameterComponent">();
	}
	static class UPalAnimNotifyParameterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAnimNotifyParameterComponent>();
	}
};
static_assert(alignof(UPalAnimNotifyParameterComponent) == 0x000008, "Wrong alignment on UPalAnimNotifyParameterComponent");
static_assert(sizeof(UPalAnimNotifyParameterComponent) == 0x0000F0, "Wrong size on UPalAnimNotifyParameterComponent");
static_assert(offsetof(UPalAnimNotifyParameterComponent, DynamicParameterMap) == 0x0000A0, "Member 'UPalAnimNotifyParameterComponent::DynamicParameterMap' has a wrong offset!");

// Class Pal.PalAnimNotifyState_AvoidTime
// 0x00A0 (0x00D0 - 0x0030)
class UPalAnimNotifyState_AvoidTime final : public UAnimNotifyState
{
public:
	TMap<class UPrimitiveComponent*, ECollisionResponse> AttackResponseMap;                                 // 0x0030(0x0050)(BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<class UPrimitiveComponent*, ECollisionResponse> BulletResponseMap;                                 // 0x0080(0x0050)(BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAnimNotifyState_AvoidTime">();
	}
	static class UPalAnimNotifyState_AvoidTime* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAnimNotifyState_AvoidTime>();
	}
};
static_assert(alignof(UPalAnimNotifyState_AvoidTime) == 0x000008, "Wrong alignment on UPalAnimNotifyState_AvoidTime");
static_assert(sizeof(UPalAnimNotifyState_AvoidTime) == 0x0000D0, "Wrong size on UPalAnimNotifyState_AvoidTime");
static_assert(offsetof(UPalAnimNotifyState_AvoidTime, AttackResponseMap) == 0x000030, "Member 'UPalAnimNotifyState_AvoidTime::AttackResponseMap' has a wrong offset!");
static_assert(offsetof(UPalAnimNotifyState_AvoidTime, BulletResponseMap) == 0x000080, "Member 'UPalAnimNotifyState_AvoidTime::BulletResponseMap' has a wrong offset!");

// Class Pal.PalImGui
// 0x0128 (0x03B8 - 0x0290)
class APalImGui final : public AActor
{
public:
	uint8                                         Pad_28FB[0x118];                                   // 0x0290(0x0118)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class APalCharacter>           WeakCharacterForParameterDisplay;                  // 0x03A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28FC[0x8];                                     // 0x03B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalImGui">();
	}
	static class APalImGui* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalImGui>();
	}
};
static_assert(alignof(APalImGui) == 0x000008, "Wrong alignment on APalImGui");
static_assert(sizeof(APalImGui) == 0x0003B8, "Wrong size on APalImGui");
static_assert(offsetof(APalImGui, WeakCharacterForParameterDisplay) == 0x0003A8, "Member 'APalImGui::WeakCharacterForParameterDisplay' has a wrong offset!");

// Class Pal.PalAnimNotifyState_FacialEye
// 0x0008 (0x0038 - 0x0030)
class UPalAnimNotifyState_FacialEye final : public UAnimNotifyState
{
public:
	EPalFacialEyeType                             EyeType;                                           // 0x0030(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoDefaultWhenEnd;                                // 0x0031(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28FD[0x6];                                     // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAnimNotifyState_FacialEye">();
	}
	static class UPalAnimNotifyState_FacialEye* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAnimNotifyState_FacialEye>();
	}
};
static_assert(alignof(UPalAnimNotifyState_FacialEye) == 0x000008, "Wrong alignment on UPalAnimNotifyState_FacialEye");
static_assert(sizeof(UPalAnimNotifyState_FacialEye) == 0x000038, "Wrong size on UPalAnimNotifyState_FacialEye");
static_assert(offsetof(UPalAnimNotifyState_FacialEye, EyeType) == 0x000030, "Member 'UPalAnimNotifyState_FacialEye::EyeType' has a wrong offset!");
static_assert(offsetof(UPalAnimNotifyState_FacialEye, AutoDefaultWhenEnd) == 0x000031, "Member 'UPalAnimNotifyState_FacialEye::AutoDefaultWhenEnd' has a wrong offset!");

// Class Pal.PalAnimNotifyState_FacialMouth
// 0x0008 (0x0038 - 0x0030)
class UPalAnimNotifyState_FacialMouth final : public UAnimNotifyState
{
public:
	EPalFacialMouthType                           MouthType;                                         // 0x0030(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoDefaultWhenEnd;                                // 0x0031(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28FE[0x6];                                     // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAnimNotifyState_FacialMouth">();
	}
	static class UPalAnimNotifyState_FacialMouth* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAnimNotifyState_FacialMouth>();
	}
};
static_assert(alignof(UPalAnimNotifyState_FacialMouth) == 0x000008, "Wrong alignment on UPalAnimNotifyState_FacialMouth");
static_assert(sizeof(UPalAnimNotifyState_FacialMouth) == 0x000038, "Wrong size on UPalAnimNotifyState_FacialMouth");
static_assert(offsetof(UPalAnimNotifyState_FacialMouth, MouthType) == 0x000030, "Member 'UPalAnimNotifyState_FacialMouth::MouthType' has a wrong offset!");
static_assert(offsetof(UPalAnimNotifyState_FacialMouth, AutoDefaultWhenEnd) == 0x000031, "Member 'UPalAnimNotifyState_FacialMouth::AutoDefaultWhenEnd' has a wrong offset!");

// Class Pal.PalAnimNotifyState_FlyMeshHeight
// 0x0008 (0x0038 - 0x0030)
class UPalAnimNotifyState_FlyMeshHeight final : public UAnimNotifyState
{
public:
	bool                                          IsToLand;                                          // 0x0030(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28FF[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAnimNotifyState_FlyMeshHeight">();
	}
	static class UPalAnimNotifyState_FlyMeshHeight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAnimNotifyState_FlyMeshHeight>();
	}
};
static_assert(alignof(UPalAnimNotifyState_FlyMeshHeight) == 0x000008, "Wrong alignment on UPalAnimNotifyState_FlyMeshHeight");
static_assert(sizeof(UPalAnimNotifyState_FlyMeshHeight) == 0x000038, "Wrong size on UPalAnimNotifyState_FlyMeshHeight");
static_assert(offsetof(UPalAnimNotifyState_FlyMeshHeight, IsToLand) == 0x000030, "Member 'UPalAnimNotifyState_FlyMeshHeight::IsToLand' has a wrong offset!");

// Class Pal.PalVisualEffectBase
// 0x0048 (0x0070 - 0x0028)
class UPalVisualEffectBase : public UObject
{
public:
	bool                                          bIsEndVisualEffect;                                // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanDeleteInstance;                                // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2900[0x6];                                     // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnCompleteDelegate;                                // 0x0030(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<EPalVisualEffectID>                    ConflictIDList;                                    // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	EPalVisualEffectID                            VisualEffectID;                                    // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2901[0x7];                                     // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPalVisualEffectDynamicParameter       DynamicParameter;                                  // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	bool                                          IsCallEndOnComponentEndPlay;                       // 0x0068(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2902[0x7];                                     // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanDeleteInstance();
	float GetFloatParameter(class FName Param_Name, float DefaultValue);
	bool IsEndVisualEffect();
	void OnBeginVisualEffect();
	void OnBreakVisualEffect(bool bByConflict);
	void OnComplete__DelegateSignature(class UPalVisualEffectBase* VisualEffect);
	void OnDeleteInstance();
	void OnEndVisualEffect();
	void TerminatingTickVisualEffect(float DeltaTime);
	void TickVisualEffect(float DeltaTime);

	void GetAllMesh(TArray<class USceneComponent*>* OutComponent) const;
	class APalCharacter* GetCharacter() const;
	const TArray<EPalVisualEffectID> GetConflictIDList() const;
	TArray<class UMaterialInstanceDynamic*> GetMainAndHeadMeshMaterials() const;
	class USkeletalMeshComponent* GetMainMesh() const;
	TArray<class UMaterialInstanceDynamic*> GetMainMeshMaterials() const;
	class AActor* GetOwner() const;
	class USkeletalMeshComponent* GetPlayerHeadMesh() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalVisualEffectBase">();
	}
	static class UPalVisualEffectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalVisualEffectBase>();
	}
};
static_assert(alignof(UPalVisualEffectBase) == 0x000008, "Wrong alignment on UPalVisualEffectBase");
static_assert(sizeof(UPalVisualEffectBase) == 0x000070, "Wrong size on UPalVisualEffectBase");
static_assert(offsetof(UPalVisualEffectBase, bIsEndVisualEffect) == 0x000028, "Member 'UPalVisualEffectBase::bIsEndVisualEffect' has a wrong offset!");
static_assert(offsetof(UPalVisualEffectBase, bCanDeleteInstance) == 0x000029, "Member 'UPalVisualEffectBase::bCanDeleteInstance' has a wrong offset!");
static_assert(offsetof(UPalVisualEffectBase, OnCompleteDelegate) == 0x000030, "Member 'UPalVisualEffectBase::OnCompleteDelegate' has a wrong offset!");
static_assert(offsetof(UPalVisualEffectBase, ConflictIDList) == 0x000040, "Member 'UPalVisualEffectBase::ConflictIDList' has a wrong offset!");
static_assert(offsetof(UPalVisualEffectBase, VisualEffectID) == 0x000050, "Member 'UPalVisualEffectBase::VisualEffectID' has a wrong offset!");
static_assert(offsetof(UPalVisualEffectBase, DynamicParameter) == 0x000058, "Member 'UPalVisualEffectBase::DynamicParameter' has a wrong offset!");
static_assert(offsetof(UPalVisualEffectBase, IsCallEndOnComponentEndPlay) == 0x000068, "Member 'UPalVisualEffectBase::IsCallEndOnComponentEndPlay' has a wrong offset!");

// Class Pal.PalIndividualCharacterSlotsObserver
// 0x0038 (0x0060 - 0x0028)
class UPalIndividualCharacterSlotsObserver final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnUpdateContainerDelegate;                         // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2903[0x28];                                    // 0x0038(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnUpdateContainer(class UPalIndividualCharacterContainer* Container);
	void OnUpdateContainerSize(class UPalIndividualCharacterContainer* Container);
	void OnUpdateContainerSlots(class UPalIndividualCharacterContainer* Container);
	void OnUpdateSlot(class UPalIndividualCharacterSlot* Slot, class UPalIndividualCharacterHandle* LastHandle);
	void UpdateContainerDelegate__DelegateSignature();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalIndividualCharacterSlotsObserver">();
	}
	static class UPalIndividualCharacterSlotsObserver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalIndividualCharacterSlotsObserver>();
	}
};
static_assert(alignof(UPalIndividualCharacterSlotsObserver) == 0x000008, "Wrong alignment on UPalIndividualCharacterSlotsObserver");
static_assert(sizeof(UPalIndividualCharacterSlotsObserver) == 0x000060, "Wrong size on UPalIndividualCharacterSlotsObserver");
static_assert(offsetof(UPalIndividualCharacterSlotsObserver, OnUpdateContainerDelegate) == 0x000028, "Member 'UPalIndividualCharacterSlotsObserver::OnUpdateContainerDelegate' has a wrong offset!");

// Class Pal.PalAnimNotifyState_LookAtDisable
// 0x0000 (0x0030 - 0x0030)
class UPalAnimNotifyState_LookAtDisable final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAnimNotifyState_LookAtDisable">();
	}
	static class UPalAnimNotifyState_LookAtDisable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAnimNotifyState_LookAtDisable>();
	}
};
static_assert(alignof(UPalAnimNotifyState_LookAtDisable) == 0x000008, "Wrong alignment on UPalAnimNotifyState_LookAtDisable");
static_assert(sizeof(UPalAnimNotifyState_LookAtDisable) == 0x000030, "Wrong size on UPalAnimNotifyState_LookAtDisable");

// Class Pal.PalAnimNotifyState_MovementControl
// 0x0020 (0x0050 - 0x0030)
class UPalAnimNotifyState_MovementControl final : public UAnimNotifyState
{
public:
	float                                         MovementSpeedRate;                                 // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirControlXYRate;                                  // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawRotatorRate;                                    // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GravityRate;                                       // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FixedGravityZ;                                     // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlideAlpha;                                        // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDisableMovement;                                // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDisableJump;                                    // 0x0049(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2904[0x6];                                     // 0x004A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAnimNotifyState_MovementControl">();
	}
	static class UPalAnimNotifyState_MovementControl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAnimNotifyState_MovementControl>();
	}
};
static_assert(alignof(UPalAnimNotifyState_MovementControl) == 0x000008, "Wrong alignment on UPalAnimNotifyState_MovementControl");
static_assert(sizeof(UPalAnimNotifyState_MovementControl) == 0x000050, "Wrong size on UPalAnimNotifyState_MovementControl");
static_assert(offsetof(UPalAnimNotifyState_MovementControl, MovementSpeedRate) == 0x000030, "Member 'UPalAnimNotifyState_MovementControl::MovementSpeedRate' has a wrong offset!");
static_assert(offsetof(UPalAnimNotifyState_MovementControl, AirControlXYRate) == 0x000034, "Member 'UPalAnimNotifyState_MovementControl::AirControlXYRate' has a wrong offset!");
static_assert(offsetof(UPalAnimNotifyState_MovementControl, YawRotatorRate) == 0x000038, "Member 'UPalAnimNotifyState_MovementControl::YawRotatorRate' has a wrong offset!");
static_assert(offsetof(UPalAnimNotifyState_MovementControl, GravityRate) == 0x00003C, "Member 'UPalAnimNotifyState_MovementControl::GravityRate' has a wrong offset!");
static_assert(offsetof(UPalAnimNotifyState_MovementControl, FixedGravityZ) == 0x000040, "Member 'UPalAnimNotifyState_MovementControl::FixedGravityZ' has a wrong offset!");
static_assert(offsetof(UPalAnimNotifyState_MovementControl, SlideAlpha) == 0x000044, "Member 'UPalAnimNotifyState_MovementControl::SlideAlpha' has a wrong offset!");
static_assert(offsetof(UPalAnimNotifyState_MovementControl, bIsDisableMovement) == 0x000048, "Member 'UPalAnimNotifyState_MovementControl::bIsDisableMovement' has a wrong offset!");
static_assert(offsetof(UPalAnimNotifyState_MovementControl, bIsDisableJump) == 0x000049, "Member 'UPalAnimNotifyState_MovementControl::bIsDisableJump' has a wrong offset!");

// Class Pal.PalReplicationGraphNode_PlayerStateFrequencyLimiter
// 0x0028 (0x0078 - 0x0050)
class UPalReplicationGraphNode_PlayerStateFrequencyLimiter final : public UReplicationGraphNode
{
public:
	uint8                                         Pad_2905[0x28];                                    // 0x0050(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalReplicationGraphNode_PlayerStateFrequencyLimiter">();
	}
	static class UPalReplicationGraphNode_PlayerStateFrequencyLimiter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalReplicationGraphNode_PlayerStateFrequencyLimiter>();
	}
};
static_assert(alignof(UPalReplicationGraphNode_PlayerStateFrequencyLimiter) == 0x000008, "Wrong alignment on UPalReplicationGraphNode_PlayerStateFrequencyLimiter");
static_assert(sizeof(UPalReplicationGraphNode_PlayerStateFrequencyLimiter) == 0x000078, "Wrong size on UPalReplicationGraphNode_PlayerStateFrequencyLimiter");

// Class Pal.PalVisualEffectDataBase
// 0x00B0 (0x00D8 - 0x0028)
class UPalVisualEffectDataBase : public UObject
{
public:
	TMap<EPalVisualEffectID, TSoftClassPtr<class UClass>> VisualEffectClassDataReference;                    // 0x0028(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UMaterialParameterCollection*           MosaicMaterialParameterCollection;                 // 0x0078(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EPalVisualEffectID, TSubclassOf<class UPalVisualEffectBase>> VisualEffectClassDataAsset;                        // 0x0080(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2906[0x8];                                     // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FName GetMosaicKeyName();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalVisualEffectDataBase">();
	}
	static class UPalVisualEffectDataBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalVisualEffectDataBase>();
	}
};
static_assert(alignof(UPalVisualEffectDataBase) == 0x000008, "Wrong alignment on UPalVisualEffectDataBase");
static_assert(sizeof(UPalVisualEffectDataBase) == 0x0000D8, "Wrong size on UPalVisualEffectDataBase");
static_assert(offsetof(UPalVisualEffectDataBase, VisualEffectClassDataReference) == 0x000028, "Member 'UPalVisualEffectDataBase::VisualEffectClassDataReference' has a wrong offset!");
static_assert(offsetof(UPalVisualEffectDataBase, MosaicMaterialParameterCollection) == 0x000078, "Member 'UPalVisualEffectDataBase::MosaicMaterialParameterCollection' has a wrong offset!");
static_assert(offsetof(UPalVisualEffectDataBase, VisualEffectClassDataAsset) == 0x000080, "Member 'UPalVisualEffectDataBase::VisualEffectClassDataAsset' has a wrong offset!");

// Class Pal.PalIndividualCharacterSaveParameterUtility
// 0x0000 (0x0028 - 0x0028)
class UPalIndividualCharacterSaveParameterUtility final : public UObject
{
public:
	static bool IsValid(const struct FPalIndividualCharacterSaveParameter& SaveParameter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalIndividualCharacterSaveParameterUtility">();
	}
	static class UPalIndividualCharacterSaveParameterUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalIndividualCharacterSaveParameterUtility>();
	}
};
static_assert(alignof(UPalIndividualCharacterSaveParameterUtility) == 0x000008, "Wrong alignment on UPalIndividualCharacterSaveParameterUtility");
static_assert(sizeof(UPalIndividualCharacterSaveParameterUtility) == 0x000028, "Wrong size on UPalIndividualCharacterSaveParameterUtility");

// Class Pal.PalNetworkWorkProgressComponent
// 0x0050 (0x00F0 - 0x00A0)
class UPalNetworkWorkProgressComponent final : public UActorComponent
{
public:
	uint8                                         Pad_2908[0x50];                                    // 0x00A0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddCompleteBuildWorkLog(const struct FPalNetArchive& Archive);
	void ReceiveStartPlayerWork_ToRequestClient(const struct FGuid& RequestID, const EPalWorkRequestResult Result);
	void RequestEndPlayerWork_ToServer(const struct FGuid& WorkId);
	void RequestStartPlayerWork_ToServer(const struct FGuid& RequestID, const struct FGuid& WorkProgressId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalNetworkWorkProgressComponent">();
	}
	static class UPalNetworkWorkProgressComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalNetworkWorkProgressComponent>();
	}
};
static_assert(alignof(UPalNetworkWorkProgressComponent) == 0x000008, "Wrong alignment on UPalNetworkWorkProgressComponent");
static_assert(sizeof(UPalNetworkWorkProgressComponent) == 0x0000F0, "Wrong size on UPalNetworkWorkProgressComponent");

// Class Pal.PalAnimNotifyState_WeaponControl
// 0x0008 (0x0038 - 0x0030)
class UPalAnimNotifyState_WeaponControl final : public UAnimNotifyState
{
public:
	bool                                          bIsDisableShoot;                                   // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDisableAim;                                     // 0x0031(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDisableAttachLeftHand;                          // 0x0032(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDisableReload;                                  // 0x0033(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDisableChangeWeapon;                            // 0x0034(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPalShooterFlagContainerPriority              Priority;                                          // 0x0035(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_290A[0x2];                                     // 0x0036(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAnimNotifyState_WeaponControl">();
	}
	static class UPalAnimNotifyState_WeaponControl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAnimNotifyState_WeaponControl>();
	}
};
static_assert(alignof(UPalAnimNotifyState_WeaponControl) == 0x000008, "Wrong alignment on UPalAnimNotifyState_WeaponControl");
static_assert(sizeof(UPalAnimNotifyState_WeaponControl) == 0x000038, "Wrong size on UPalAnimNotifyState_WeaponControl");
static_assert(offsetof(UPalAnimNotifyState_WeaponControl, bIsDisableShoot) == 0x000030, "Member 'UPalAnimNotifyState_WeaponControl::bIsDisableShoot' has a wrong offset!");
static_assert(offsetof(UPalAnimNotifyState_WeaponControl, bIsDisableAim) == 0x000031, "Member 'UPalAnimNotifyState_WeaponControl::bIsDisableAim' has a wrong offset!");
static_assert(offsetof(UPalAnimNotifyState_WeaponControl, bIsDisableAttachLeftHand) == 0x000032, "Member 'UPalAnimNotifyState_WeaponControl::bIsDisableAttachLeftHand' has a wrong offset!");
static_assert(offsetof(UPalAnimNotifyState_WeaponControl, bIsDisableReload) == 0x000033, "Member 'UPalAnimNotifyState_WeaponControl::bIsDisableReload' has a wrong offset!");
static_assert(offsetof(UPalAnimNotifyState_WeaponControl, bIsDisableChangeWeapon) == 0x000034, "Member 'UPalAnimNotifyState_WeaponControl::bIsDisableChangeWeapon' has a wrong offset!");
static_assert(offsetof(UPalAnimNotifyState_WeaponControl, Priority) == 0x000035, "Member 'UPalAnimNotifyState_WeaponControl::Priority' has a wrong offset!");

// Class Pal.PalAnimNotify_FacialEye
// 0x0008 (0x0040 - 0x0038)
class UPalAnimNotify_FacialEye final : public UAnimNotify
{
public:
	EPalFacialEyeType                             EyeType;                                           // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_290B[0x7];                                     // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAnimNotify_FacialEye">();
	}
	static class UPalAnimNotify_FacialEye* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAnimNotify_FacialEye>();
	}
};
static_assert(alignof(UPalAnimNotify_FacialEye) == 0x000008, "Wrong alignment on UPalAnimNotify_FacialEye");
static_assert(sizeof(UPalAnimNotify_FacialEye) == 0x000040, "Wrong size on UPalAnimNotify_FacialEye");
static_assert(offsetof(UPalAnimNotify_FacialEye, EyeType) == 0x000038, "Member 'UPalAnimNotify_FacialEye::EyeType' has a wrong offset!");

// Class Pal.PalIncidentDynamicParameter
// 0x0008 (0x0030 - 0x0028)
class UPalIncidentDynamicParameter : public UObject
{
public:
	class AActor*                                 Other;                                             // 0x0028(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalIncidentDynamicParameter">();
	}
	static class UPalIncidentDynamicParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalIncidentDynamicParameter>();
	}
};
static_assert(alignof(UPalIncidentDynamicParameter) == 0x000008, "Wrong alignment on UPalIncidentDynamicParameter");
static_assert(sizeof(UPalIncidentDynamicParameter) == 0x000030, "Wrong size on UPalIncidentDynamicParameter");
static_assert(offsetof(UPalIncidentDynamicParameter, Other) == 0x000028, "Member 'UPalIncidentDynamicParameter::Other' has a wrong offset!");

// Class Pal.PalIncidentDynamicParameterRandom
// 0x0010 (0x0040 - 0x0030)
class UPalIncidentDynamicParameterRandom final : public UPalIncidentDynamicParameter
{
public:
	class FName                                   SettingName;                                       // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerId;                                          // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_290C[0x4];                                     // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalIncidentDynamicParameterRandom">();
	}
	static class UPalIncidentDynamicParameterRandom* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalIncidentDynamicParameterRandom>();
	}
};
static_assert(alignof(UPalIncidentDynamicParameterRandom) == 0x000008, "Wrong alignment on UPalIncidentDynamicParameterRandom");
static_assert(sizeof(UPalIncidentDynamicParameterRandom) == 0x000040, "Wrong size on UPalIncidentDynamicParameterRandom");
static_assert(offsetof(UPalIncidentDynamicParameterRandom, SettingName) == 0x000030, "Member 'UPalIncidentDynamicParameterRandom::SettingName' has a wrong offset!");
static_assert(offsetof(UPalIncidentDynamicParameterRandom, PlayerId) == 0x000038, "Member 'UPalIncidentDynamicParameterRandom::PlayerId' has a wrong offset!");

// Class Pal.PalAnimNotify_FacialMouth
// 0x0008 (0x0040 - 0x0038)
class UPalAnimNotify_FacialMouth final : public UAnimNotify
{
public:
	EPalFacialMouthType                           MouthType;                                         // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_290D[0x7];                                     // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAnimNotify_FacialMouth">();
	}
	static class UPalAnimNotify_FacialMouth* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAnimNotify_FacialMouth>();
	}
};
static_assert(alignof(UPalAnimNotify_FacialMouth) == 0x000008, "Wrong alignment on UPalAnimNotify_FacialMouth");
static_assert(sizeof(UPalAnimNotify_FacialMouth) == 0x000040, "Wrong size on UPalAnimNotify_FacialMouth");
static_assert(offsetof(UPalAnimNotify_FacialMouth, MouthType) == 0x000038, "Member 'UPalAnimNotify_FacialMouth::MouthType' has a wrong offset!");

// Class Pal.PalAnimNotify_FootStep
// 0x0038 (0x0070 - 0x0038)
class UPalAnimNotify_FootStep : public UAnimNotify
{
public:
	TSoftClassPtr<class UClass>                   DefaultEffectAssetClass;                           // 0x0038(0x0030)(Edit, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalFootStepEffectAssetBase*            EffectAssetCache;                                  // 0x0068(0x0008)(BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool GetFloorPosition(class AActor* Owner, const struct FTransform& FootTransform, struct FHitResult* HitResult) const;
	void SpawnFootStepDecal(class AActor* Owner, EPhysicalSurface PhysicalSurface, EPalFootType FootType, const struct FVector& Location, const struct FVector& CurrentNormal, float LifeSpan, float FadeTime) const;
	void SpawnFootStepEffect(class UObject* WorldObject, EPalLandingType LandingType, EPhysicalSurface PhysicalSurface, const struct FVector& Location, const struct FRotator& Rotation, class UPalStaticCharacterParameterComponent* StaticParam) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAnimNotify_FootStep">();
	}
	static class UPalAnimNotify_FootStep* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAnimNotify_FootStep>();
	}
};
static_assert(alignof(UPalAnimNotify_FootStep) == 0x000008, "Wrong alignment on UPalAnimNotify_FootStep");
static_assert(sizeof(UPalAnimNotify_FootStep) == 0x000070, "Wrong size on UPalAnimNotify_FootStep");
static_assert(offsetof(UPalAnimNotify_FootStep, DefaultEffectAssetClass) == 0x000038, "Member 'UPalAnimNotify_FootStep::DefaultEffectAssetClass' has a wrong offset!");
static_assert(offsetof(UPalAnimNotify_FootStep, EffectAssetCache) == 0x000068, "Member 'UPalAnimNotify_FootStep::EffectAssetCache' has a wrong offset!");

// Class Pal.PalRetainerBox
// 0x0000 (0x0198 - 0x0198)
class UPalRetainerBox final : public URetainerBox
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalRetainerBox">();
	}
	static class UPalRetainerBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalRetainerBox>();
	}
};
static_assert(alignof(UPalRetainerBox) == 0x000008, "Wrong alignment on UPalRetainerBox");
static_assert(sizeof(UPalRetainerBox) == 0x000198, "Wrong size on UPalRetainerBox");

// Class Pal.PalIndividualCharacterSlot
// 0x0090 (0x00B8 - 0x0028)
class UPalIndividualCharacterSlot : public UObject
{
public:
	uint8                                         Pad_2912[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnUpdateSlotHandleDelegate;                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateSlotLockDelegate;                          // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UPalIndividualCharacterHandle*          Handle;                                            // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPalInstanceID                         ReplicateHandleID;                                 // 0x0058(0x0030)(Edit, Net, DisableEditOnTemplate, Transient, EditConst, RepNotify, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2913[0x8];                                     // 0x0088(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPalContainerId                        ContainerId;                                       // 0x0090(0x0010)(Edit, Net, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SlotIndex;                                         // 0x00A0(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  LockPlayerUId;                                     // 0x00A4(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPalTribeID                                   PermissionTribeID;                                 // 0x00B4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsReplicateCharacterParameter;                    // 0x00B5(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2914[0x2];                                     // 0x00B6(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_HandleID();
	void OnRep_LockPlayerUId();
	void Setup(const int32 InSlotIndex, const struct FPalContainerId& InContainerId);
	void UpdateSlotHandleDelegate__DelegateSignature(class UPalIndividualCharacterSlot* Slot, class UPalIndividualCharacterHandle* LastHandle);
	void UpdateSlotLockDelegate__DelegateSignature(class UPalIndividualCharacterSlot* Slot);

	bool CanSetHandle(class UPalIndividualCharacterHandle* InHandle) const;
	class UPalIndividualCharacterHandle* GetHandle() const;
	const struct FGuid GetLockPlayerUId() const;
	struct FPalCharacterSlotId GetSlotId() const;
	int32 GetSlotIndex() const;
	bool IsEmpty() const;
	bool IsLocked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalIndividualCharacterSlot">();
	}
	static class UPalIndividualCharacterSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalIndividualCharacterSlot>();
	}
};
static_assert(alignof(UPalIndividualCharacterSlot) == 0x000008, "Wrong alignment on UPalIndividualCharacterSlot");
static_assert(sizeof(UPalIndividualCharacterSlot) == 0x0000B8, "Wrong size on UPalIndividualCharacterSlot");
static_assert(offsetof(UPalIndividualCharacterSlot, OnUpdateSlotHandleDelegate) == 0x000030, "Member 'UPalIndividualCharacterSlot::OnUpdateSlotHandleDelegate' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterSlot, OnUpdateSlotLockDelegate) == 0x000040, "Member 'UPalIndividualCharacterSlot::OnUpdateSlotLockDelegate' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterSlot, Handle) == 0x000050, "Member 'UPalIndividualCharacterSlot::Handle' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterSlot, ReplicateHandleID) == 0x000058, "Member 'UPalIndividualCharacterSlot::ReplicateHandleID' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterSlot, ContainerId) == 0x000090, "Member 'UPalIndividualCharacterSlot::ContainerId' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterSlot, SlotIndex) == 0x0000A0, "Member 'UPalIndividualCharacterSlot::SlotIndex' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterSlot, LockPlayerUId) == 0x0000A4, "Member 'UPalIndividualCharacterSlot::LockPlayerUId' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterSlot, PermissionTribeID) == 0x0000B4, "Member 'UPalIndividualCharacterSlot::PermissionTribeID' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterSlot, bIsReplicateCharacterParameter) == 0x0000B5, "Member 'UPalIndividualCharacterSlot::bIsReplicateCharacterParameter' has a wrong offset!");

// Class Pal.PalNoteData
// 0x0038 (0x0060 - 0x0028)
class UPalNoteData final : public UObject
{
public:
	class FName                                   TextId_Description;                                // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Texture;                                           // 0x0030(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalNoteData">();
	}
	static class UPalNoteData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalNoteData>();
	}
};
static_assert(alignof(UPalNoteData) == 0x000008, "Wrong alignment on UPalNoteData");
static_assert(sizeof(UPalNoteData) == 0x000060, "Wrong size on UPalNoteData");
static_assert(offsetof(UPalNoteData, TextId_Description) == 0x000028, "Member 'UPalNoteData::TextId_Description' has a wrong offset!");
static_assert(offsetof(UPalNoteData, Texture) == 0x000030, "Member 'UPalNoteData::Texture' has a wrong offset!");

// Class Pal.PalAnimNotify_PlayNiagaraEffect
// 0x0050 (0x0120 - 0x00D0)
class UPalAnimNotify_PlayNiagaraEffect final : public UAnimNotify_PlayNiagaraEffect
{
public:
	TMap<class FName, float>                      UserParameterMap;                                  // 0x00D0(0x0050)(Edit, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAnimNotify_PlayNiagaraEffect">();
	}
	static class UPalAnimNotify_PlayNiagaraEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAnimNotify_PlayNiagaraEffect>();
	}
};
static_assert(alignof(UPalAnimNotify_PlayNiagaraEffect) == 0x000010, "Wrong alignment on UPalAnimNotify_PlayNiagaraEffect");
static_assert(sizeof(UPalAnimNotify_PlayNiagaraEffect) == 0x000120, "Wrong size on UPalAnimNotify_PlayNiagaraEffect");
static_assert(offsetof(UPalAnimNotify_PlayNiagaraEffect, UserParameterMap) == 0x0000D0, "Member 'UPalAnimNotify_PlayNiagaraEffect::UserParameterMap' has a wrong offset!");

// Class Pal.PalAnimNotify_RequestJump
// 0x0000 (0x0038 - 0x0038)
class UPalAnimNotify_RequestJump final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAnimNotify_RequestJump">();
	}
	static class UPalAnimNotify_RequestJump* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAnimNotify_RequestJump>();
	}
};
static_assert(alignof(UPalAnimNotify_RequestJump) == 0x000008, "Wrong alignment on UPalAnimNotify_RequestJump");
static_assert(sizeof(UPalAnimNotify_RequestJump) == 0x000038, "Wrong size on UPalAnimNotify_RequestJump");

// Class Pal.PalMapObjectHPWorldHUDParameter
// 0x0008 (0x0040 - 0x0038)
class UPalMapObjectHPWorldHUDParameter final : public UPalHUDDispatchParameterBase
{
public:
	class APalMapObject*                          MapObject;                                         // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectHPWorldHUDParameter">();
	}
	static class UPalMapObjectHPWorldHUDParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectHPWorldHUDParameter>();
	}
};
static_assert(alignof(UPalMapObjectHPWorldHUDParameter) == 0x000008, "Wrong alignment on UPalMapObjectHPWorldHUDParameter");
static_assert(sizeof(UPalMapObjectHPWorldHUDParameter) == 0x000040, "Wrong size on UPalMapObjectHPWorldHUDParameter");
static_assert(offsetof(UPalMapObjectHPWorldHUDParameter, MapObject) == 0x000038, "Member 'UPalMapObjectHPWorldHUDParameter::MapObject' has a wrong offset!");

// Class Pal.PalInteractiveObjectActionInfoUtility
// 0x0000 (0x0028 - 0x0028)
class UPalInteractiveObjectActionInfoUtility final : public UObject
{
public:
	static struct FPalInteractiveObjectActionBy CreateSituationInfo(const class UObject* WorldContextObject);
	static EPalInteractiveObjectIndicatorType GetIndicatorType(const struct FPalInteractiveObjectActionInfoSet& ActionInfo, const EPalInteractiveObjectActionType ActionType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalInteractiveObjectActionInfoUtility">();
	}
	static class UPalInteractiveObjectActionInfoUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalInteractiveObjectActionInfoUtility>();
	}
};
static_assert(alignof(UPalInteractiveObjectActionInfoUtility) == 0x000008, "Wrong alignment on UPalInteractiveObjectActionInfoUtility");
static_assert(sizeof(UPalInteractiveObjectActionInfoUtility) == 0x000028, "Wrong size on UPalInteractiveObjectActionInfoUtility");

// Class Pal.PalAnimNotify_RequestRideShakeAnimation
// 0x0028 (0x0060 - 0x0038)
class UPalAnimNotify_RequestRideShakeAnimation final : public UAnimNotify
{
public:
	float                                         ApplyRate;                                         // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlaySpeedRate;                                     // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAdjustAnimationSpeed;                           // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2917[0x3];                                     // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class APalCharacter>           CacheCharacter;                                    // 0x0044(0x0008)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2918[0x4];                                     // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 RateList;                                          // 0x0050(0x0010)(BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void OnEndMotion(class UAnimMontage* Montage, bool bInterrupted) const;
	void OnStartAim() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAnimNotify_RequestRideShakeAnimation">();
	}
	static class UPalAnimNotify_RequestRideShakeAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAnimNotify_RequestRideShakeAnimation>();
	}
};
static_assert(alignof(UPalAnimNotify_RequestRideShakeAnimation) == 0x000008, "Wrong alignment on UPalAnimNotify_RequestRideShakeAnimation");
static_assert(sizeof(UPalAnimNotify_RequestRideShakeAnimation) == 0x000060, "Wrong size on UPalAnimNotify_RequestRideShakeAnimation");
static_assert(offsetof(UPalAnimNotify_RequestRideShakeAnimation, ApplyRate) == 0x000038, "Member 'UPalAnimNotify_RequestRideShakeAnimation::ApplyRate' has a wrong offset!");
static_assert(offsetof(UPalAnimNotify_RequestRideShakeAnimation, PlaySpeedRate) == 0x00003C, "Member 'UPalAnimNotify_RequestRideShakeAnimation::PlaySpeedRate' has a wrong offset!");
static_assert(offsetof(UPalAnimNotify_RequestRideShakeAnimation, bIsAdjustAnimationSpeed) == 0x000040, "Member 'UPalAnimNotify_RequestRideShakeAnimation::bIsAdjustAnimationSpeed' has a wrong offset!");
static_assert(offsetof(UPalAnimNotify_RequestRideShakeAnimation, CacheCharacter) == 0x000044, "Member 'UPalAnimNotify_RequestRideShakeAnimation::CacheCharacter' has a wrong offset!");
static_assert(offsetof(UPalAnimNotify_RequestRideShakeAnimation, RateList) == 0x000050, "Member 'UPalAnimNotify_RequestRideShakeAnimation::RateList' has a wrong offset!");

// Class Pal.PalAnimNotify_SendActionEvent
// 0x0008 (0x0040 - 0x0038)
class UPalAnimNotify_SendActionEvent final : public UAnimNotify
{
public:
	EPalCurrentActionNotifyType                   NotifyType;                                        // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_291A[0x7];                                     // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAnimNotify_SendActionEvent">();
	}
	static class UPalAnimNotify_SendActionEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAnimNotify_SendActionEvent>();
	}
};
static_assert(alignof(UPalAnimNotify_SendActionEvent) == 0x000008, "Wrong alignment on UPalAnimNotify_SendActionEvent");
static_assert(sizeof(UPalAnimNotify_SendActionEvent) == 0x000040, "Wrong size on UPalAnimNotify_SendActionEvent");
static_assert(offsetof(UPalAnimNotify_SendActionEvent, NotifyType) == 0x000038, "Member 'UPalAnimNotify_SendActionEvent::NotifyType' has a wrong offset!");

// Class Pal.PalUIMapObjectStatusIndicatorBase
// 0x0000 (0x0408 - 0x0408)
class UPalUIMapObjectStatusIndicatorBase : public UPalUserWidgetWorldHUD
{
public:
	EPalWorkSuitability GetWorkSuitability() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIMapObjectStatusIndicatorBase">();
	}
	static class UPalUIMapObjectStatusIndicatorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIMapObjectStatusIndicatorBase>();
	}
};
static_assert(alignof(UPalUIMapObjectStatusIndicatorBase) == 0x000008, "Wrong alignment on UPalUIMapObjectStatusIndicatorBase");
static_assert(sizeof(UPalUIMapObjectStatusIndicatorBase) == 0x000408, "Wrong size on UPalUIMapObjectStatusIndicatorBase");

// Class Pal.PalInsideBaseCampCheckComponent
// 0x0030 (0x00D0 - 0x00A0)
class UPalInsideBaseCampCheckComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnEnterBaseCampDelegate;                           // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLeaveBaseCampDelegate;                           // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGuid                                  NowInsideBaseCampID;                               // 0x00C0(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	const struct FGuid GetInsideBaseCampID();
	class UPalBaseCampModel* GetInsideBaseCampModel();
	bool IsInsideBaseCamp();
	void OnEnterBaseCampDelegate__DelegateSignature(class UPalBaseCampModel* Model);
	void OnLeaveBaseCampDelegate__DelegateSignature();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalInsideBaseCampCheckComponent">();
	}
	static class UPalInsideBaseCampCheckComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalInsideBaseCampCheckComponent>();
	}
};
static_assert(alignof(UPalInsideBaseCampCheckComponent) == 0x000008, "Wrong alignment on UPalInsideBaseCampCheckComponent");
static_assert(sizeof(UPalInsideBaseCampCheckComponent) == 0x0000D0, "Wrong size on UPalInsideBaseCampCheckComponent");
static_assert(offsetof(UPalInsideBaseCampCheckComponent, OnEnterBaseCampDelegate) == 0x0000A0, "Member 'UPalInsideBaseCampCheckComponent::OnEnterBaseCampDelegate' has a wrong offset!");
static_assert(offsetof(UPalInsideBaseCampCheckComponent, OnLeaveBaseCampDelegate) == 0x0000B0, "Member 'UPalInsideBaseCampCheckComponent::OnLeaveBaseCampDelegate' has a wrong offset!");
static_assert(offsetof(UPalInsideBaseCampCheckComponent, NowInsideBaseCampID) == 0x0000C0, "Member 'UPalInsideBaseCampCheckComponent::NowInsideBaseCampID' has a wrong offset!");

// Class Pal.PalAnimNotify_SpawnActor
// 0x0038 (0x0070 - 0x0038)
class UPalAnimNotify_SpawnActor final : public UAnimNotify
{
public:
	TSubclassOf<class AActor>                     SpawnActorClass;                                   // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SpawnLocationOffset;                               // 0x0040(0x0018)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               SpawnRotationOffset;                               // 0x0058(0x0018)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAnimNotify_SpawnActor">();
	}
	static class UPalAnimNotify_SpawnActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAnimNotify_SpawnActor>();
	}
};
static_assert(alignof(UPalAnimNotify_SpawnActor) == 0x000008, "Wrong alignment on UPalAnimNotify_SpawnActor");
static_assert(sizeof(UPalAnimNotify_SpawnActor) == 0x000070, "Wrong size on UPalAnimNotify_SpawnActor");
static_assert(offsetof(UPalAnimNotify_SpawnActor, SpawnActorClass) == 0x000038, "Member 'UPalAnimNotify_SpawnActor::SpawnActorClass' has a wrong offset!");
static_assert(offsetof(UPalAnimNotify_SpawnActor, SpawnLocationOffset) == 0x000040, "Member 'UPalAnimNotify_SpawnActor::SpawnLocationOffset' has a wrong offset!");
static_assert(offsetof(UPalAnimNotify_SpawnActor, SpawnRotationOffset) == 0x000058, "Member 'UPalAnimNotify_SpawnActor::SpawnRotationOffset' has a wrong offset!");

// Class Pal.PalAnimNotify_StaminaMeleeAttack
// 0x0000 (0x0038 - 0x0038)
class UPalAnimNotify_StaminaMeleeAttack final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAnimNotify_StaminaMeleeAttack">();
	}
	static class UPalAnimNotify_StaminaMeleeAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAnimNotify_StaminaMeleeAttack>();
	}
};
static_assert(alignof(UPalAnimNotify_StaminaMeleeAttack) == 0x000008, "Wrong alignment on UPalAnimNotify_StaminaMeleeAttack");
static_assert(sizeof(UPalAnimNotify_StaminaMeleeAttack) == 0x000038, "Wrong size on UPalAnimNotify_StaminaMeleeAttack");

// Class Pal.PalIndividualCharacterSaveParameterObject
// 0x0280 (0x02A8 - 0x0028)
class UPalIndividualCharacterSaveParameterObject final : public UObject
{
public:
	struct FPalIndividualCharacterSaveParameter   SaveParameter;                                     // 0x0028(0x0280)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalIndividualCharacterSaveParameterObject">();
	}
	static class UPalIndividualCharacterSaveParameterObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalIndividualCharacterSaveParameterObject>();
	}
};
static_assert(alignof(UPalIndividualCharacterSaveParameterObject) == 0x000008, "Wrong alignment on UPalIndividualCharacterSaveParameterObject");
static_assert(sizeof(UPalIndividualCharacterSaveParameterObject) == 0x0002A8, "Wrong size on UPalIndividualCharacterSaveParameterObject");
static_assert(offsetof(UPalIndividualCharacterSaveParameterObject, SaveParameter) == 0x000028, "Member 'UPalIndividualCharacterSaveParameterObject::SaveParameter' has a wrong offset!");

// Class Pal.PalAnimNotify_WeaponNotify
// 0x0008 (0x0040 - 0x0038)
class UPalAnimNotify_WeaponNotify final : public UAnimNotify
{
public:
	EWeaponNotifyType                             WeaponNotifyType;                                  // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_291B[0x7];                                     // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAnimNotify_WeaponNotify">();
	}
	static class UPalAnimNotify_WeaponNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAnimNotify_WeaponNotify>();
	}
};
static_assert(alignof(UPalAnimNotify_WeaponNotify) == 0x000008, "Wrong alignment on UPalAnimNotify_WeaponNotify");
static_assert(sizeof(UPalAnimNotify_WeaponNotify) == 0x000040, "Wrong size on UPalAnimNotify_WeaponNotify");
static_assert(offsetof(UPalAnimNotify_WeaponNotify, WeaponNotifyType) == 0x000038, "Member 'UPalAnimNotify_WeaponNotify::WeaponNotifyType' has a wrong offset!");

// Class Pal.PalInteractiveObjectBoxComponent
// 0x0070 (0x05F0 - 0x0580)
class UPalInteractiveObjectBoxComponent final : public UBoxComponent
{
public:
	uint8                                         Pad_291C[0x10];                                    // 0x0578(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalInteractDelegates*                  InteractDelegates;                                 // 0x0588(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsEnableTriggerInteract;                          // 0x0590(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsImplementedTriggerInteract;                     // 0x0591(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsEnableInteractingTick;                          // 0x0592(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsEnableInteractingTickInClientOnly;              // 0x0593(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_291D[0x4];                                     // 0x0594(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FComponentReference                    IndicatorOriginRef;                                // 0x0598(0x0028)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsAdjustIndicatorLocationZForPlayer;              // 0x05C0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_291E[0x7];                                     // 0x05C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TScriptInterface<class IPalInteractiveObjectIndicatorInterface> IndicatorInterface;                                // 0x05C8(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnCreateInteractDelegatesDelegate;                 // 0x05D8(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_291F[0x8];                                     // 0x05E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CallOrRegisterOnCreateInteractDelegates(TDelegate<void(class UPalInteractDelegates* InteractDelegates)> Delegate);
	void OnCreateInteractsDelegates__DelegateSignature(class UPalInteractDelegates* Param_InteractDelegates);
	void EnableTriggerInteract();
	struct FVector GetIndicatorLocation(bool bNoShapeOffset);
	void OnCreateInteractDelegatesMultiCast__DelegateSignature(class UPalInteractDelegates* Param_InteractDelegates);
	void OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnOverlapEnd(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void SetForceDisableInteract();
	void SetIndicatorInterface(TScriptInterface<class IPalInteractiveObjectIndicatorInterface> InIndicatorInterface);

	class UPalInteractDelegates* Delegates() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalInteractiveObjectBoxComponent">();
	}
	static class UPalInteractiveObjectBoxComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalInteractiveObjectBoxComponent>();
	}
};
static_assert(alignof(UPalInteractiveObjectBoxComponent) == 0x000010, "Wrong alignment on UPalInteractiveObjectBoxComponent");
static_assert(sizeof(UPalInteractiveObjectBoxComponent) == 0x0005F0, "Wrong size on UPalInteractiveObjectBoxComponent");
static_assert(offsetof(UPalInteractiveObjectBoxComponent, InteractDelegates) == 0x000588, "Member 'UPalInteractiveObjectBoxComponent::InteractDelegates' has a wrong offset!");
static_assert(offsetof(UPalInteractiveObjectBoxComponent, bIsEnableTriggerInteract) == 0x000590, "Member 'UPalInteractiveObjectBoxComponent::bIsEnableTriggerInteract' has a wrong offset!");
static_assert(offsetof(UPalInteractiveObjectBoxComponent, bIsImplementedTriggerInteract) == 0x000591, "Member 'UPalInteractiveObjectBoxComponent::bIsImplementedTriggerInteract' has a wrong offset!");
static_assert(offsetof(UPalInteractiveObjectBoxComponent, bIsEnableInteractingTick) == 0x000592, "Member 'UPalInteractiveObjectBoxComponent::bIsEnableInteractingTick' has a wrong offset!");
static_assert(offsetof(UPalInteractiveObjectBoxComponent, bIsEnableInteractingTickInClientOnly) == 0x000593, "Member 'UPalInteractiveObjectBoxComponent::bIsEnableInteractingTickInClientOnly' has a wrong offset!");
static_assert(offsetof(UPalInteractiveObjectBoxComponent, IndicatorOriginRef) == 0x000598, "Member 'UPalInteractiveObjectBoxComponent::IndicatorOriginRef' has a wrong offset!");
static_assert(offsetof(UPalInteractiveObjectBoxComponent, bIsAdjustIndicatorLocationZForPlayer) == 0x0005C0, "Member 'UPalInteractiveObjectBoxComponent::bIsAdjustIndicatorLocationZForPlayer' has a wrong offset!");
static_assert(offsetof(UPalInteractiveObjectBoxComponent, IndicatorInterface) == 0x0005C8, "Member 'UPalInteractiveObjectBoxComponent::IndicatorInterface' has a wrong offset!");
static_assert(offsetof(UPalInteractiveObjectBoxComponent, OnCreateInteractDelegatesDelegate) == 0x0005D8, "Member 'UPalInteractiveObjectBoxComponent::OnCreateInteractDelegatesDelegate' has a wrong offset!");

// Class Pal.PalArenaTestManager
// 0x0088 (0x0318 - 0x0290)
class APalArenaTestManager final : public AActor
{
public:
	struct FPalArenaTestParameter                 TestParameter;                                     // 0x0290(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<class APalPlayerState*>                PlayerStates;                                      // 0x02E0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class APalPlayerState*                        Player1;                                           // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APalPlayerState*                        Player2;                                           // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2923[0x18];                                    // 0x0300(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivatePlayerOtomoPal();
	void DelayRidePlayer();
	void EnemyCombatMode();
	void GetOffAllPlayer();
	void InactivatePlayerOtomoPal();
	void LoadWaza_Client();
	void OtomoInitializeTimer_Client();
	void OtomoInitializeTimer_Server();
	void PlayBGM(EPalAudioStateGroup StateGroup);
	void RidePlayer(class APalPlayerState* PlayerState, int32 RideIndex);
	void SendClientSetup();
	void SendClientStart();
	void Setup();
	void Start();
	void ToggleRandomPartyMode();

	TArray<struct FPalDebugOtomoPalInfo> CreateRandomParty() const;
	class UPalOtomoHolderComponentBase* GetOtomoHolder(const class APlayerState* TargetPlayerState) const;
	TArray<struct FTransform> GetPalSpawnTransform(EPalArenaPlayer ArenaPlayer) const;
	bool IsOtomoActorInitialized(const class APlayerState* PlayerState) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalArenaTestManager">();
	}
	static class APalArenaTestManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalArenaTestManager>();
	}
};
static_assert(alignof(APalArenaTestManager) == 0x000008, "Wrong alignment on APalArenaTestManager");
static_assert(sizeof(APalArenaTestManager) == 0x000318, "Wrong size on APalArenaTestManager");
static_assert(offsetof(APalArenaTestManager, TestParameter) == 0x000290, "Member 'APalArenaTestManager::TestParameter' has a wrong offset!");
static_assert(offsetof(APalArenaTestManager, PlayerStates) == 0x0002E0, "Member 'APalArenaTestManager::PlayerStates' has a wrong offset!");
static_assert(offsetof(APalArenaTestManager, Player1) == 0x0002F0, "Member 'APalArenaTestManager::Player1' has a wrong offset!");
static_assert(offsetof(APalArenaTestManager, Player2) == 0x0002F8, "Member 'APalArenaTestManager::Player2' has a wrong offset!");

// Class Pal.PalUIPalBoxModel
// 0x0018 (0x0040 - 0x0028)
class UPalUIPalBoxModel final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnUpdatePageDelegate;                              // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         CurrentPageIndex;                                  // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2927[0x4];                                     // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SelectHandleSlot(const int32 DisplayIndex, const EPalItemSlotPressType PressType);
	void ToNextPage();
	void ToPrevPage();
	void UpdatePageDelegate__DelegateSignature(class UPalUIPalBoxModel* Model);

	const TArray<class UPalIndividualCharacterSlot*> GetCurrentPageSlots() const;
	const int32 GetSlotCountInPage() const;
	const int32 GetWholePageCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIPalBoxModel">();
	}
	static class UPalUIPalBoxModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIPalBoxModel>();
	}
};
static_assert(alignof(UPalUIPalBoxModel) == 0x000008, "Wrong alignment on UPalUIPalBoxModel");
static_assert(sizeof(UPalUIPalBoxModel) == 0x000040, "Wrong size on UPalUIPalBoxModel");
static_assert(offsetof(UPalUIPalBoxModel, OnUpdatePageDelegate) == 0x000028, "Member 'UPalUIPalBoxModel::OnUpdatePageDelegate' has a wrong offset!");
static_assert(offsetof(UPalUIPalBoxModel, CurrentPageIndex) == 0x000038, "Member 'UPalUIPalBoxModel::CurrentPageIndex' has a wrong offset!");

// Class Pal.PalInvaderIncidentBase
// 0x00C0 (0x0220 - 0x0160)
class UPalInvaderIncidentBase : public UPalIncidentBase
{
public:
	EPalInvaderType                               InvaderType;                                       // 0x0160(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2929[0x7];                                     // 0x0161(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             InvaderDataTable;                                  // 0x0168(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class APalAIController>           MonsterAIControllerClass;                          // 0x0170(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class APalAIController>           EnemyAIControllerClass;                            // 0x0178(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FPalInvaderSpawnCharacterParameter> InvaderMember;                                     // 0x0180(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class APalAIController*>               MemberController;                                  // 0x0190(0x0010)(BlueprintVisible, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class FName                                   ChosenInvaderDataRowName;                          // 0x01A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  GroupGuid;                                         // 0x01A8(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCanExecute;                                       // 0x01B8(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_292A[0x7];                                     // 0x01B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalSquad*                              Squad;                                             // 0x01C0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<struct FPalInstanceID, struct FGuid>     LocationMap;                                       // 0x01C8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_292B[0x8];                                     // 0x0218(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddGroupCharacter(class UPalIndividualCharacterHandle* AddIndividualHandle, EPalCharacterLocationType LocationType);
	void EndInvadeByTimelimit();
	void GetBroadcastParameter(struct FPalIncidentBroadcastParameter* OutParameter);
	int32 GetCandidateStartLocations(TArray<struct FVector>* Result);
	bool GetInvaderStartPoint(struct FVector* Result);
	void OnEndInvade();
	void OnInvaderArrived();
	void OnStartInvade();
	void RemoveGroupCharacter(class UPalIndividualCharacterHandle* RemoveIndividualHandle);
	bool SelectInvaders(int32 Grade, EPalBiomeType Biome, TArray<struct FPalInvaderSpawnCharacterParameter>* OutInvaderMember);
	void SpawnMemberCharacters(const struct FVector& StartLocation);
	void StartInvader();

	int32 GetAliveInvaderNum() const;
	void GetChosenInvaderGroupName(class FText* OutText) const;
	int32 GetInvadeReturnTimeMinutes() const;
	class UPalBaseCampModel* GetTargetCampModel() const;
	int32 GetVisitorNPCReturnTimeMinutes() const;
	bool IsGroupCharacter(class UPalIndividualCharacterHandle* IndividualHandle) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalInvaderIncidentBase">();
	}
	static class UPalInvaderIncidentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalInvaderIncidentBase>();
	}
};
static_assert(alignof(UPalInvaderIncidentBase) == 0x000010, "Wrong alignment on UPalInvaderIncidentBase");
static_assert(sizeof(UPalInvaderIncidentBase) == 0x000220, "Wrong size on UPalInvaderIncidentBase");
static_assert(offsetof(UPalInvaderIncidentBase, InvaderType) == 0x000160, "Member 'UPalInvaderIncidentBase::InvaderType' has a wrong offset!");
static_assert(offsetof(UPalInvaderIncidentBase, InvaderDataTable) == 0x000168, "Member 'UPalInvaderIncidentBase::InvaderDataTable' has a wrong offset!");
static_assert(offsetof(UPalInvaderIncidentBase, MonsterAIControllerClass) == 0x000170, "Member 'UPalInvaderIncidentBase::MonsterAIControllerClass' has a wrong offset!");
static_assert(offsetof(UPalInvaderIncidentBase, EnemyAIControllerClass) == 0x000178, "Member 'UPalInvaderIncidentBase::EnemyAIControllerClass' has a wrong offset!");
static_assert(offsetof(UPalInvaderIncidentBase, InvaderMember) == 0x000180, "Member 'UPalInvaderIncidentBase::InvaderMember' has a wrong offset!");
static_assert(offsetof(UPalInvaderIncidentBase, MemberController) == 0x000190, "Member 'UPalInvaderIncidentBase::MemberController' has a wrong offset!");
static_assert(offsetof(UPalInvaderIncidentBase, ChosenInvaderDataRowName) == 0x0001A0, "Member 'UPalInvaderIncidentBase::ChosenInvaderDataRowName' has a wrong offset!");
static_assert(offsetof(UPalInvaderIncidentBase, GroupGuid) == 0x0001A8, "Member 'UPalInvaderIncidentBase::GroupGuid' has a wrong offset!");
static_assert(offsetof(UPalInvaderIncidentBase, bCanExecute) == 0x0001B8, "Member 'UPalInvaderIncidentBase::bCanExecute' has a wrong offset!");
static_assert(offsetof(UPalInvaderIncidentBase, Squad) == 0x0001C0, "Member 'UPalInvaderIncidentBase::Squad' has a wrong offset!");
static_assert(offsetof(UPalInvaderIncidentBase, LocationMap) == 0x0001C8, "Member 'UPalInvaderIncidentBase::LocationMap' has a wrong offset!");

// Class Pal.PalUIPalCharacterRankUpModel
// 0x0060 (0x0088 - 0x0028)
class UPalUIPalCharacterRankUpModel final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnUpdateTargetSlotDelegate;                        // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateResourceSlotDelegate;                      // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateSelectModeDelegate;                        // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FPalContainerId                        LocalContainerId;                                  // 0x0058(0x0010)(Edit, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UPalUIPalStorageModel>      PalStorageModelClass;                              // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalUIPalStorageModel*                  PalStorageModel;                                   // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPalUIPalCharacterRankUpSelectMode            SelectMode;                                        // 0x0078(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2932[0xF];                                     // 0x0079(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearResourceCharacters();
	void ClearSelected();
	class UPalIndividualCharacterParameter* CreatePredicateTargetCharacterParameter();
	void Dispose();
	void InvokeRankUp();
	void ModelDelegate__DelegateSignature(class UPalUIPalCharacterRankUpModel* Model);
	void OnUpdateResourceSlot(class UPalIndividualCharacterReferenceSlot* Slot, const struct FPalInstanceID& LastIndividualId);
	void OnUpdateTargetCharacterRank(const int32 NowRank, const int32 OldRank);
	void OnUpdateTargetSlot(class UPalIndividualCharacterReferenceSlot* Slot, const struct FPalInstanceID& LastIndividualId);
	bool SelectResourceCharacterTo(class UPalIndividualCharacterHandle* Handle, const int32 ToResourceSlotIndex);
	void SelectResourcesAuto(const EPalUIPalCharacterRankUpSelectResourceType SelectType);
	void SelectTargetCharacter(class UPalIndividualCharacterHandle* Handle);
	void Setup(class UPalHUDDispatchParameter_CharacterRankUp* Parameter);
	bool ToggleResourceCharacter(class UPalIndividualCharacterHandle* Handle);

	void CalcRankByCurrentSelectForUI(int32* OutToRank, int32* OutToRankUpExp, int32* OutTotalRankUpExp) const;
	EPalUIPalCharacterRankUpRequestResult CanInvokeRankUp() const;
	int32 GetCurrentResourceCount() const;
	void GetResourceSlots(TArray<class UPalIndividualCharacterSlot*>* Slots) const;
	class UPalIndividualCharacterReferenceSlot* GetSlot(const int32 SlotIndex) const;
	class UPalIndividualCharacterReferenceSlot* GetTargetSlot() const;
	bool IsFilledResourcesForTarget() const;
	bool IsOverflowResourcesForTarget() const;
	bool IsSelectableSlotInternal(const class UPalIndividualCharacterSlot* Slot) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIPalCharacterRankUpModel">();
	}
	static class UPalUIPalCharacterRankUpModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIPalCharacterRankUpModel>();
	}
};
static_assert(alignof(UPalUIPalCharacterRankUpModel) == 0x000008, "Wrong alignment on UPalUIPalCharacterRankUpModel");
static_assert(sizeof(UPalUIPalCharacterRankUpModel) == 0x000088, "Wrong size on UPalUIPalCharacterRankUpModel");
static_assert(offsetof(UPalUIPalCharacterRankUpModel, OnUpdateTargetSlotDelegate) == 0x000028, "Member 'UPalUIPalCharacterRankUpModel::OnUpdateTargetSlotDelegate' has a wrong offset!");
static_assert(offsetof(UPalUIPalCharacterRankUpModel, OnUpdateResourceSlotDelegate) == 0x000038, "Member 'UPalUIPalCharacterRankUpModel::OnUpdateResourceSlotDelegate' has a wrong offset!");
static_assert(offsetof(UPalUIPalCharacterRankUpModel, OnUpdateSelectModeDelegate) == 0x000048, "Member 'UPalUIPalCharacterRankUpModel::OnUpdateSelectModeDelegate' has a wrong offset!");
static_assert(offsetof(UPalUIPalCharacterRankUpModel, LocalContainerId) == 0x000058, "Member 'UPalUIPalCharacterRankUpModel::LocalContainerId' has a wrong offset!");
static_assert(offsetof(UPalUIPalCharacterRankUpModel, PalStorageModelClass) == 0x000068, "Member 'UPalUIPalCharacterRankUpModel::PalStorageModelClass' has a wrong offset!");
static_assert(offsetof(UPalUIPalCharacterRankUpModel, PalStorageModel) == 0x000070, "Member 'UPalUIPalCharacterRankUpModel::PalStorageModel' has a wrong offset!");
static_assert(offsetof(UPalUIPalCharacterRankUpModel, SelectMode) == 0x000078, "Member 'UPalUIPalCharacterRankUpModel::SelectMode' has a wrong offset!");

// Class Pal.PalInteractiveObjectIndicatorInterface
// 0x0000 (0x0028 - 0x0028)
class IPalInteractiveObjectIndicatorInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalInteractiveObjectIndicatorInterface">();
	}
	static class IPalInteractiveObjectIndicatorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPalInteractiveObjectIndicatorInterface>();
	}
};
static_assert(alignof(IPalInteractiveObjectIndicatorInterface) == 0x000008, "Wrong alignment on IPalInteractiveObjectIndicatorInterface");
static_assert(sizeof(IPalInteractiveObjectIndicatorInterface) == 0x000028, "Wrong size on IPalInteractiveObjectIndicatorInterface");

// Class Pal.PalAudioSettingSystem
// 0x00A8 (0x00D0 - 0x0028)
class UPalAudioSettingSystem : public UObject
{
public:
	uint8                                         Pad_2937[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EPalAudioBus, struct FFloatContainer>    BusVolumeMap;                                      // 0x0030(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<EPalAudioBus, struct FPalAudioFadeParameter> BussFadeMap;                                       // 0x0080(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	void Initialize();
	void SetAudioBusMute(EPalAudioBus AudioBus, bool IsMute);
	void SetAudioBusVolume(EPalAudioBus AudioBus, const class FName& Key, float Volume);
	void StartAudioFade(EPalAudioBus AudioBus, EPalAudioFadeType FadeType, bool bImmediately);
	void Tick_BP(float DeltaTime);

	float GetAudioBusVolume(EPalAudioBus AudioBus) const;
	bool IsAudioBusMute(EPalAudioBus AudioBus) const;
	class FString PalAudioBusToString(EPalAudioBus AudioBus) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAudioSettingSystem">();
	}
	static class UPalAudioSettingSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAudioSettingSystem>();
	}
};
static_assert(alignof(UPalAudioSettingSystem) == 0x000008, "Wrong alignment on UPalAudioSettingSystem");
static_assert(sizeof(UPalAudioSettingSystem) == 0x0000D0, "Wrong size on UPalAudioSettingSystem");
static_assert(offsetof(UPalAudioSettingSystem, BusVolumeMap) == 0x000030, "Member 'UPalAudioSettingSystem::BusVolumeMap' has a wrong offset!");
static_assert(offsetof(UPalAudioSettingSystem, BussFadeMap) == 0x000080, "Member 'UPalAudioSettingSystem::BussFadeMap' has a wrong offset!");

// Class Pal.PalAudioUtility
// 0x0000 (0x0028 - 0x0028)
class UPalAudioUtility final : public UBlueprintFunctionLibrary
{
public:
	static void OnPlayerEnterAmbientArea(class UObject* WorldContextObject, class APalPlayerCharacter* Player, class APalAmbientSoundAreaBase* SpotArea);
	static void OnPlayerEnterBaseCamp(class UObject* WorldContextObject, class APalPlayerCharacter* Player, class UPalBaseCampModel* BaseCampModel);
	static void OnPlayerEnterSpot(class UObject* WorldContextObject, class APalPlayerCharacter* Player, class APalSpotAreaBase* SpotArea);
	static void OnPlayerExitAmbientArea(class UObject* WorldContextObject, class APalPlayerCharacter* Player, class APalAmbientSoundAreaBase* SpotArea);
	static void OnPlayerExitBaseCamp(class UObject* WorldContextObject, class APalPlayerCharacter* Player, class UPalBaseCampModel* BaseCampModel);
	static void OnPlayerExitSpot(class UObject* WorldContextObject, class APalPlayerCharacter* Player, class APalSpotAreaBase* SpotArea);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAudioUtility">();
	}
	static class UPalAudioUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAudioUtility>();
	}
};
static_assert(alignof(UPalAudioUtility) == 0x000008, "Wrong alignment on UPalAudioUtility");
static_assert(sizeof(UPalAudioUtility) == 0x000028, "Wrong size on UPalAudioUtility");

// Class Pal.PalInteractiveObjectSphereComponent
// 0x0070 (0x05D0 - 0x0560)
class UPalInteractiveObjectSphereComponent : public USphereComponent
{
public:
	uint8                                         Pad_293B[0x10];                                    // 0x0560(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalInteractDelegates*                  InteractDelegates;                                 // 0x0570(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsEnableTriggerInteract;                          // 0x0578(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsImplementedTriggerInteract;                     // 0x0579(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsEnableInteractingTick;                          // 0x057A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsEnableInteractingTickInClientOnly;              // 0x057B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_293C[0x4];                                     // 0x057C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FComponentReference                    IndicatorOriginRef;                                // 0x0580(0x0028)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TScriptInterface<class IPalInteractiveObjectIndicatorInterface> IndicatorInterface;                                // 0x05A8(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnCreateInteractDelegatesDelegate;                 // 0x05B8(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_293D[0x8];                                     // 0x05C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CallOrRegisterOnCreateInteractDelegates(TDelegate<void(class UPalInteractDelegates* InteractDelegates)> Delegate);
	void OnCreateInteractsDelegates__DelegateSignature(class UPalInteractDelegates* Param_InteractDelegates);
	void EnableTriggerInteract();
	struct FVector GetIndicatorLocation(bool bNoShapeOffset);
	void OnCreateInteractDelegatesMultiCast__DelegateSignature(class UPalInteractDelegates* Param_InteractDelegates);
	void OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnOverlapEnd(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void SetIndicatorInterface(TScriptInterface<class IPalInteractiveObjectIndicatorInterface> InIndicatorInterface);

	class UPalInteractDelegates* Delegates() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalInteractiveObjectSphereComponent">();
	}
	static class UPalInteractiveObjectSphereComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalInteractiveObjectSphereComponent>();
	}
};
static_assert(alignof(UPalInteractiveObjectSphereComponent) == 0x000010, "Wrong alignment on UPalInteractiveObjectSphereComponent");
static_assert(sizeof(UPalInteractiveObjectSphereComponent) == 0x0005D0, "Wrong size on UPalInteractiveObjectSphereComponent");
static_assert(offsetof(UPalInteractiveObjectSphereComponent, InteractDelegates) == 0x000570, "Member 'UPalInteractiveObjectSphereComponent::InteractDelegates' has a wrong offset!");
static_assert(offsetof(UPalInteractiveObjectSphereComponent, bIsEnableTriggerInteract) == 0x000578, "Member 'UPalInteractiveObjectSphereComponent::bIsEnableTriggerInteract' has a wrong offset!");
static_assert(offsetof(UPalInteractiveObjectSphereComponent, bIsImplementedTriggerInteract) == 0x000579, "Member 'UPalInteractiveObjectSphereComponent::bIsImplementedTriggerInteract' has a wrong offset!");
static_assert(offsetof(UPalInteractiveObjectSphereComponent, bIsEnableInteractingTick) == 0x00057A, "Member 'UPalInteractiveObjectSphereComponent::bIsEnableInteractingTick' has a wrong offset!");
static_assert(offsetof(UPalInteractiveObjectSphereComponent, bIsEnableInteractingTickInClientOnly) == 0x00057B, "Member 'UPalInteractiveObjectSphereComponent::bIsEnableInteractingTickInClientOnly' has a wrong offset!");
static_assert(offsetof(UPalInteractiveObjectSphereComponent, IndicatorOriginRef) == 0x000580, "Member 'UPalInteractiveObjectSphereComponent::IndicatorOriginRef' has a wrong offset!");
static_assert(offsetof(UPalInteractiveObjectSphereComponent, IndicatorInterface) == 0x0005A8, "Member 'UPalInteractiveObjectSphereComponent::IndicatorInterface' has a wrong offset!");
static_assert(offsetof(UPalInteractiveObjectSphereComponent, OnCreateInteractDelegatesDelegate) == 0x0005B8, "Member 'UPalInteractiveObjectSphereComponent::OnCreateInteractDelegatesDelegate' has a wrong offset!");

// Class Pal.PalInteractableSphereComponentNative
// 0x0000 (0x05D0 - 0x05D0)
class UPalInteractableSphereComponentNative final : public UPalInteractiveObjectSphereComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalInteractableSphereComponentNative">();
	}
	static class UPalInteractableSphereComponentNative* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalInteractableSphereComponentNative>();
	}
};
static_assert(alignof(UPalInteractableSphereComponentNative) == 0x000010, "Wrong alignment on UPalInteractableSphereComponentNative");
static_assert(sizeof(UPalInteractableSphereComponentNative) == 0x0005D0, "Wrong size on UPalInteractableSphereComponentNative");

// Class Pal.PalAudioWorldSubsystem
// 0x0010 (0x0080 - 0x0070)
class UPalAudioWorldSubsystem final : public UPalWorldSubsystem
{
public:
	int32                                         FadeDuration;                                      // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2941[0x4];                                     // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalSoundPlayer*                        SoundPlayer;                                       // 0x0078(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void BeginPlay();
	void FadeOutByPlayingId(int32 PlayingID);
	void InitializeSystem(class AActor* AkOwnerActor);
	void OnAkPostEventCallback(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo);
	void OnEndOfEvent();
	void OnPlayerEnterAmbientArea(class APalPlayerCharacter* Player, class APalAmbientSoundAreaBase* AmbientSoundArea);
	void OnPlayerEnterBaseCamp(class APalPlayerCharacter* Player, class UPalBaseCampModel* BaseCampModel);
	void OnPlayerEnterSpotArea(class APalPlayerCharacter* Player, class APalSpotAreaBase* SpotArea);
	void OnPlayerExitAmbientArea(class APalPlayerCharacter* Player, class APalAmbientSoundAreaBase* AmbientSoundArea);
	void OnPlayerExitBaseCamp(class APalPlayerCharacter* Player, class UPalBaseCampModel* BaseCampModel);
	void OnPlayerExitSpotArea(class APalPlayerCharacter* Player, class APalSpotAreaBase* SpotArea);
	void OnSpawnedLocalPlayerCharacter(class APawn* Pawn, class AController* Controller);
	int32 PlaySound(class UAkAudioEvent* AudioEvent, const struct FPalSoundOptions& Options);
	void PostTriggerByEnum(EPalAudioTrigger Trigger);
	void PostTriggerByString(const class FString& Trigger);
	void SetOutputBusVolume(float Volume);
	void SetRTPCValueByEnum(EPalAudioRTPC RTPC, float Value, float InterpolSec);
	void SetRTPCValueByName(const class FName& Param_Name, float Value, float InterpolSec);
	void SetSoundPlayerLocation(const struct FVector& Location);
	void SetStateByEnum(EPalAudioStateGroup StateGroup, EPalAudioState State);
	void SetStateByName(class FName StateGroup, class FName State);
	void SetStateFlagByEnum(EPalAudioStateGroup StateGroup, bool Flg);
	void SetStateFlagByName(class FName StateGroup, bool Flg);
	void SetSwitch(const class FString& SwitchGroup, const class FString& SwitchState);
	void StopSound();
	void Tick_BP(float DeltaTime);

	void GetSoundPlayerLocation(struct FVector* OutLocation) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAudioWorldSubsystem">();
	}
	static class UPalAudioWorldSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAudioWorldSubsystem>();
	}
};
static_assert(alignof(UPalAudioWorldSubsystem) == 0x000008, "Wrong alignment on UPalAudioWorldSubsystem");
static_assert(sizeof(UPalAudioWorldSubsystem) == 0x000080, "Wrong size on UPalAudioWorldSubsystem");
static_assert(offsetof(UPalAudioWorldSubsystem, FadeDuration) == 0x000070, "Member 'UPalAudioWorldSubsystem::FadeDuration' has a wrong offset!");
static_assert(offsetof(UPalAudioWorldSubsystem, SoundPlayer) == 0x000078, "Member 'UPalAudioWorldSubsystem::SoundPlayer' has a wrong offset!");

// Class Pal.PalAutoDestroyActorHolder
// 0x0010 (0x0038 - 0x0028)
class UPalAutoDestroyActorHolder final : public UObject
{
public:
	TArray<TWeakObjectPtr<class AActor>>          HoldActors;                                        // 0x0028(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	void AddActor(class AActor* TargetActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAutoDestroyActorHolder">();
	}
	static class UPalAutoDestroyActorHolder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalAutoDestroyActorHolder>();
	}
};
static_assert(alignof(UPalAutoDestroyActorHolder) == 0x000008, "Wrong alignment on UPalAutoDestroyActorHolder");
static_assert(sizeof(UPalAutoDestroyActorHolder) == 0x000038, "Wrong size on UPalAutoDestroyActorHolder");
static_assert(offsetof(UPalAutoDestroyActorHolder, HoldActors) == 0x000028, "Member 'UPalAutoDestroyActorHolder::HoldActors' has a wrong offset!");

// Class Pal.PalGameSystemNeedSync
// 0x0000 (0x0028 - 0x0028)
class IPalGameSystemNeedSync final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGameSystemNeedSync">();
	}
	static class IPalGameSystemNeedSync* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPalGameSystemNeedSync>();
	}
};
static_assert(alignof(IPalGameSystemNeedSync) == 0x000008, "Wrong alignment on IPalGameSystemNeedSync");
static_assert(sizeof(IPalGameSystemNeedSync) == 0x000028, "Wrong size on IPalGameSystemNeedSync");

// Class Pal.PalInteractiveObjectComponentUtility
// 0x0000 (0x0028 - 0x0028)
class UPalInteractiveObjectComponentUtility final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalInteractiveObjectComponentUtility">();
	}
	static class UPalInteractiveObjectComponentUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalInteractiveObjectComponentUtility>();
	}
};
static_assert(alignof(UPalInteractiveObjectComponentUtility) == 0x000008, "Wrong alignment on UPalInteractiveObjectComponentUtility");
static_assert(sizeof(UPalInteractiveObjectComponentUtility) == 0x000028, "Wrong size on UPalInteractiveObjectComponentUtility");

// Class Pal.PalBackWeaponBase
// 0x0058 (0x02E8 - 0x0290)
class APalBackWeaponBase : public AActor
{
public:
	bool                                          InFirstOrSecondSlot;                               // 0x0290(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsEquipHand;                                       // 0x0291(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2945[0x6];                                     // 0x0292(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFlagContainer                         HiddenBackWeapon;                                  // 0x0298(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBackWeaponBase">();
	}
	static class APalBackWeaponBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalBackWeaponBase>();
	}
};
static_assert(alignof(APalBackWeaponBase) == 0x000008, "Wrong alignment on APalBackWeaponBase");
static_assert(sizeof(APalBackWeaponBase) == 0x0002E8, "Wrong size on APalBackWeaponBase");
static_assert(offsetof(APalBackWeaponBase, InFirstOrSecondSlot) == 0x000290, "Member 'APalBackWeaponBase::InFirstOrSecondSlot' has a wrong offset!");
static_assert(offsetof(APalBackWeaponBase, IsEquipHand) == 0x000291, "Member 'APalBackWeaponBase::IsEquipHand' has a wrong offset!");
static_assert(offsetof(APalBackWeaponBase, HiddenBackWeapon) == 0x000298, "Member 'APalBackWeaponBase::HiddenBackWeapon' has a wrong offset!");

// Class Pal.PalBaseCampAssignableObjectInterface
// 0x0000 (0x0028 - 0x0028)
class IPalBaseCampAssignableObjectInterface final : public IInterface
{
public:
	TScriptInterface<class IPalMapObjectModelInterface> ToMapObjectModel();

	EPalBaseCampAssignType GetAssignType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBaseCampAssignableObjectInterface">();
	}
	static class IPalBaseCampAssignableObjectInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPalBaseCampAssignableObjectInterface>();
	}
};
static_assert(alignof(IPalBaseCampAssignableObjectInterface) == 0x000008, "Wrong alignment on IPalBaseCampAssignableObjectInterface");
static_assert(sizeof(IPalBaseCampAssignableObjectInterface) == 0x000028, "Wrong size on IPalBaseCampAssignableObjectInterface");

// Class Pal.PalUIPalShopBase
// 0x0030 (0x0460 - 0x0430)
class UPalUIPalShopBase final : public UPalUserWidgetOverlayUI
{
public:
	uint8                                         Pad_2946[0x30];                                    // 0x0430(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetPalStorageSlots(class UPalIndividualCharacterContainer** OutContainer);
	void RequestCollectLocalLostPalData();
	bool TryBuy(const struct FGuid& buyProductID);
	bool TrySell(const TArray<class UPalIndividualCharacterSlot*>& SellPalSlots);
	void UpdateLocalLostPalProduct();

	bool GetMyShop(class UPalShopBase** OutShop) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIPalShopBase">();
	}
	static class UPalUIPalShopBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIPalShopBase>();
	}
};
static_assert(alignof(UPalUIPalShopBase) == 0x000008, "Wrong alignment on UPalUIPalShopBase");
static_assert(sizeof(UPalUIPalShopBase) == 0x000460, "Wrong size on UPalUIPalShopBase");

// Class Pal.PalHitLocationCalculator
// 0x0000 (0x0028 - 0x0028)
class UPalHitLocationCalculator : public UObject
{
public:
	struct FVector CalcLocation(class UPrimitiveComponent* MyHitComponent, class UPrimitiveComponent* OtherHitComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalHitLocationCalculator">();
	}
	static class UPalHitLocationCalculator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalHitLocationCalculator>();
	}
};
static_assert(alignof(UPalHitLocationCalculator) == 0x000008, "Wrong alignment on UPalHitLocationCalculator");
static_assert(sizeof(UPalHitLocationCalculator) == 0x000028, "Wrong size on UPalHitLocationCalculator");

// Class Pal.PalBaseCampWorkerDirectionBattleTypeUtility
// 0x0000 (0x0028 - 0x0028)
class UPalBaseCampWorkerDirectionBattleTypeUtility final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBaseCampWorkerDirectionBattleTypeUtility">();
	}
	static class UPalBaseCampWorkerDirectionBattleTypeUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBaseCampWorkerDirectionBattleTypeUtility>();
	}
};
static_assert(alignof(UPalBaseCampWorkerDirectionBattleTypeUtility) == 0x000008, "Wrong alignment on UPalBaseCampWorkerDirectionBattleTypeUtility");
static_assert(sizeof(UPalBaseCampWorkerDirectionBattleTypeUtility) == 0x000028, "Wrong size on UPalBaseCampWorkerDirectionBattleTypeUtility");

// Class Pal.PalBaseCampModuleTransportItemRequirerInterface
// 0x0000 (0x0028 - 0x0028)
class IPalBaseCampModuleTransportItemRequirerInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBaseCampModuleTransportItemRequirerInterface">();
	}
	static class IPalBaseCampModuleTransportItemRequirerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPalBaseCampModuleTransportItemRequirerInterface>();
	}
};
static_assert(alignof(IPalBaseCampModuleTransportItemRequirerInterface) == 0x000008, "Wrong alignment on IPalBaseCampModuleTransportItemRequirerInterface");
static_assert(sizeof(IPalBaseCampModuleTransportItemRequirerInterface) == 0x000028, "Wrong size on IPalBaseCampModuleTransportItemRequirerInterface");

// Class Pal.PalEditorTalkTreeDataUtility
// 0x0000 (0x0028 - 0x0028)
class UPalEditorTalkTreeDataUtility final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalEditorTalkTreeDataUtility">();
	}
	static class UPalEditorTalkTreeDataUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalEditorTalkTreeDataUtility>();
	}
};
static_assert(alignof(UPalEditorTalkTreeDataUtility) == 0x000008, "Wrong alignment on UPalEditorTalkTreeDataUtility");
static_assert(sizeof(UPalEditorTalkTreeDataUtility) == 0x000028, "Wrong size on UPalEditorTalkTreeDataUtility");

// Class Pal.PalUIPalStorageManageRightModel
// 0x0048 (0x0070 - 0x0028)
class UPalUIPalStorageManageRightModel final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnUpdatePageDelegate;                              // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGuid                                  OwnerBaseCampId;                                   // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPalPalStorageManageRightType                 CurrentPageType;                                   // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_294B[0x7];                                     // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UPalUIBaseCampWorkerListModel> BaseCampWorkerListClass;                           // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalUIBaseCampWorkerListModel*          BaseCampWorkerList;                                // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UPalUIOtomoListModel>       OtomoListClass;                                    // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalUIOtomoListModel*                   OtomoList;                                         // 0x0068(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ToNextPage();
	void ToPrevPage();
	void UpdatePageDelegate__DelegateSignature(class UPalUIPalStorageManageRightModel* Model);

	bool CanMoveToNext() const;
	bool CanMoveToPrev() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIPalStorageManageRightModel">();
	}
	static class UPalUIPalStorageManageRightModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIPalStorageManageRightModel>();
	}
};
static_assert(alignof(UPalUIPalStorageManageRightModel) == 0x000008, "Wrong alignment on UPalUIPalStorageManageRightModel");
static_assert(sizeof(UPalUIPalStorageManageRightModel) == 0x000070, "Wrong size on UPalUIPalStorageManageRightModel");
static_assert(offsetof(UPalUIPalStorageManageRightModel, OnUpdatePageDelegate) == 0x000028, "Member 'UPalUIPalStorageManageRightModel::OnUpdatePageDelegate' has a wrong offset!");
static_assert(offsetof(UPalUIPalStorageManageRightModel, OwnerBaseCampId) == 0x000038, "Member 'UPalUIPalStorageManageRightModel::OwnerBaseCampId' has a wrong offset!");
static_assert(offsetof(UPalUIPalStorageManageRightModel, CurrentPageType) == 0x000048, "Member 'UPalUIPalStorageManageRightModel::CurrentPageType' has a wrong offset!");
static_assert(offsetof(UPalUIPalStorageManageRightModel, BaseCampWorkerListClass) == 0x000050, "Member 'UPalUIPalStorageManageRightModel::BaseCampWorkerListClass' has a wrong offset!");
static_assert(offsetof(UPalUIPalStorageManageRightModel, BaseCampWorkerList) == 0x000058, "Member 'UPalUIPalStorageManageRightModel::BaseCampWorkerList' has a wrong offset!");
static_assert(offsetof(UPalUIPalStorageManageRightModel, OtomoListClass) == 0x000060, "Member 'UPalUIPalStorageManageRightModel::OtomoListClass' has a wrong offset!");
static_assert(offsetof(UPalUIPalStorageManageRightModel, OtomoList) == 0x000068, "Member 'UPalUIPalStorageManageRightModel::OtomoList' has a wrong offset!");

// Class Pal.PalHiddenAreaBase
// 0x0008 (0x0298 - 0x0290)
class APalHiddenAreaBase : public AActor
{
public:
	class UPalProceduralFoliageComponent*         ProceduralComponent;                               // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalHiddenAreaBase">();
	}
	static class APalHiddenAreaBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalHiddenAreaBase>();
	}
};
static_assert(alignof(APalHiddenAreaBase) == 0x000008, "Wrong alignment on APalHiddenAreaBase");
static_assert(sizeof(APalHiddenAreaBase) == 0x000298, "Wrong size on APalHiddenAreaBase");
static_assert(offsetof(APalHiddenAreaBase, ProceduralComponent) == 0x000290, "Member 'APalHiddenAreaBase::ProceduralComponent' has a wrong offset!");

// Class Pal.PalHiddenAreaBox
// 0x0008 (0x02A0 - 0x0298)
class APalHiddenAreaBox final : public APalHiddenAreaBase
{
public:
	class UPalHiddenBoxComponent*                 HiddenBoxComponent;                                // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalHiddenAreaBox">();
	}
	static class APalHiddenAreaBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalHiddenAreaBox>();
	}
};
static_assert(alignof(APalHiddenAreaBox) == 0x000008, "Wrong alignment on APalHiddenAreaBox");
static_assert(sizeof(APalHiddenAreaBox) == 0x0002A0, "Wrong size on APalHiddenAreaBox");
static_assert(offsetof(APalHiddenAreaBox, HiddenBoxComponent) == 0x000298, "Member 'APalHiddenAreaBox::HiddenBoxComponent' has a wrong offset!");

// Class Pal.PalBaseCampModuleTransportItemDepotInterface
// 0x0000 (0x0028 - 0x0028)
class IPalBaseCampModuleTransportItemDepotInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBaseCampModuleTransportItemDepotInterface">();
	}
	static class IPalBaseCampModuleTransportItemDepotInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPalBaseCampModuleTransportItemDepotInterface>();
	}
};
static_assert(alignof(IPalBaseCampModuleTransportItemDepotInterface) == 0x000008, "Wrong alignment on IPalBaseCampModuleTransportItemDepotInterface");
static_assert(sizeof(IPalBaseCampModuleTransportItemDepotInterface) == 0x000028, "Wrong size on IPalBaseCampModuleTransportItemDepotInterface");

// Class Pal.PalBaseCampEnemyObserver
// 0x0078 (0x00A0 - 0x0028)
class UPalBaseCampEnemyObserver final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnFirstAppearEnemyDelegate;                        // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEmptyEnemyDelegate;                              // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPassedTimeAfterEmptyEnemyDelegate;               // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGuid                                  BaseCampId;                                        // 0x0058(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UPalIndividualCharacterHandle*>  EnemyList;                                         // 0x0068(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	float                                         CampAreaRange;                                     // 0x0078(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_294C[0x4];                                     // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CampLocation;                                      // 0x0080(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_294D[0x8];                                     // 0x0098(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BaseCampEnemyDelegate__DelegateSignature();
	void OnDeadEnemy(const struct FPalDeadInfo& DeadInfo);
	void OnEndPlayEnemy(class AActor* Actor, EEndPlayReason EndPlayReason);

	bool IsBattleMode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBaseCampEnemyObserver">();
	}
	static class UPalBaseCampEnemyObserver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBaseCampEnemyObserver>();
	}
};
static_assert(alignof(UPalBaseCampEnemyObserver) == 0x000008, "Wrong alignment on UPalBaseCampEnemyObserver");
static_assert(sizeof(UPalBaseCampEnemyObserver) == 0x0000A0, "Wrong size on UPalBaseCampEnemyObserver");
static_assert(offsetof(UPalBaseCampEnemyObserver, OnFirstAppearEnemyDelegate) == 0x000028, "Member 'UPalBaseCampEnemyObserver::OnFirstAppearEnemyDelegate' has a wrong offset!");
static_assert(offsetof(UPalBaseCampEnemyObserver, OnEmptyEnemyDelegate) == 0x000038, "Member 'UPalBaseCampEnemyObserver::OnEmptyEnemyDelegate' has a wrong offset!");
static_assert(offsetof(UPalBaseCampEnemyObserver, OnPassedTimeAfterEmptyEnemyDelegate) == 0x000048, "Member 'UPalBaseCampEnemyObserver::OnPassedTimeAfterEmptyEnemyDelegate' has a wrong offset!");
static_assert(offsetof(UPalBaseCampEnemyObserver, BaseCampId) == 0x000058, "Member 'UPalBaseCampEnemyObserver::BaseCampId' has a wrong offset!");
static_assert(offsetof(UPalBaseCampEnemyObserver, EnemyList) == 0x000068, "Member 'UPalBaseCampEnemyObserver::EnemyList' has a wrong offset!");
static_assert(offsetof(UPalBaseCampEnemyObserver, CampAreaRange) == 0x000078, "Member 'UPalBaseCampEnemyObserver::CampAreaRange' has a wrong offset!");
static_assert(offsetof(UPalBaseCampEnemyObserver, CampLocation) == 0x000080, "Member 'UPalBaseCampEnemyObserver::CampLocation' has a wrong offset!");

// Class Pal.PalInteractiveInterface
// 0x0000 (0x0028 - 0x0028)
class IPalInteractiveInterface : public IInterface
{
public:
	bool IsEnableTriggerInteract() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalInteractiveInterface">();
	}
	static class IPalInteractiveInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPalInteractiveInterface>();
	}
};
static_assert(alignof(IPalInteractiveInterface) == 0x000008, "Wrong alignment on IPalInteractiveInterface");
static_assert(sizeof(IPalInteractiveInterface) == 0x000028, "Wrong size on IPalInteractiveInterface");

// Class Pal.PalHitCollision
// 0x0008 (0x0298 - 0x0290)
class APalHitCollision : public AActor
{
public:
	class UPalHitFilter*                          HitFilter;                                         // 0x0290(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalHitCollision">();
	}
	static class APalHitCollision* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalHitCollision>();
	}
};
static_assert(alignof(APalHitCollision) == 0x000008, "Wrong alignment on APalHitCollision");
static_assert(sizeof(APalHitCollision) == 0x000298, "Wrong size on APalHitCollision");
static_assert(offsetof(APalHitCollision, HitFilter) == 0x000290, "Member 'APalHitCollision::HitFilter' has a wrong offset!");

// Class Pal.PalBaseCampMapObjectCollection
// 0x0060 (0x0088 - 0x0028)
class UPalBaseCampMapObjectCollection final : public UObject
{
public:
	TArray<struct FGuid>                          BurningMapObjectInstanceIds;                       // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnRegisteredMapObjectInstance;                     // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAvailableConcreteModelDelegate;                  // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNotAvailableConcreteModelDelegate;               // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FGuid>                          MapObjectInstanceIds;                              // 0x0068(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_294F[0x10];                                    // 0x0078(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MapObjectConcreteModelDelegate__DelegateSignature(class UPalMapObjectConcreteModelBase* Model);
	void MapObjectInstanceDelegate__DelegateSignature(class UPalMapObjectModel* Model);
	void OnAvailableConcreteModel(class UPalMapObjectConcreteModelBase* Model);
	void OnDisposeMapObject(class UPalMapObjectModel* Model, const struct FPalMapObjectDisposeOptions& Options);
	void OnGrantedEffectAnyMapObject(class UPalMapObjectModel* OwnerModel, class UPalMapObjectModelEffectBase* Effect);
	void OnNotAvailableConcreteModel(class UPalMapObjectConcreteModelBase* Model);
	void OnRemovedEffectAnyMapObject(class UPalMapObjectModel* OwnerModel, class UPalMapObjectModelEffectBase* Effect, EPalStatusID StatusId);
	void OnTriggeredBurnAnyMapObject(class UPalMapObjectModelEffect_AccumulateTrigger* Self, class UPalMapObjectModel* OwnerModel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBaseCampMapObjectCollection">();
	}
	static class UPalBaseCampMapObjectCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBaseCampMapObjectCollection>();
	}
};
static_assert(alignof(UPalBaseCampMapObjectCollection) == 0x000008, "Wrong alignment on UPalBaseCampMapObjectCollection");
static_assert(sizeof(UPalBaseCampMapObjectCollection) == 0x000088, "Wrong size on UPalBaseCampMapObjectCollection");
static_assert(offsetof(UPalBaseCampMapObjectCollection, BurningMapObjectInstanceIds) == 0x000028, "Member 'UPalBaseCampMapObjectCollection::BurningMapObjectInstanceIds' has a wrong offset!");
static_assert(offsetof(UPalBaseCampMapObjectCollection, OnRegisteredMapObjectInstance) == 0x000038, "Member 'UPalBaseCampMapObjectCollection::OnRegisteredMapObjectInstance' has a wrong offset!");
static_assert(offsetof(UPalBaseCampMapObjectCollection, OnAvailableConcreteModelDelegate) == 0x000048, "Member 'UPalBaseCampMapObjectCollection::OnAvailableConcreteModelDelegate' has a wrong offset!");
static_assert(offsetof(UPalBaseCampMapObjectCollection, OnNotAvailableConcreteModelDelegate) == 0x000058, "Member 'UPalBaseCampMapObjectCollection::OnNotAvailableConcreteModelDelegate' has a wrong offset!");
static_assert(offsetof(UPalBaseCampMapObjectCollection, MapObjectInstanceIds) == 0x000068, "Member 'UPalBaseCampMapObjectCollection::MapObjectInstanceIds' has a wrong offset!");

// Class Pal.PalBaseCampEnergyGeneratorInterface
// 0x0000 (0x0028 - 0x0028)
class IPalBaseCampEnergyGeneratorInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBaseCampEnergyGeneratorInterface">();
	}
	static class IPalBaseCampEnergyGeneratorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPalBaseCampEnergyGeneratorInterface>();
	}
};
static_assert(alignof(IPalBaseCampEnergyGeneratorInterface) == 0x000008, "Wrong alignment on IPalBaseCampEnergyGeneratorInterface");
static_assert(sizeof(IPalBaseCampEnergyGeneratorInterface) == 0x000028, "Wrong size on IPalBaseCampEnergyGeneratorInterface");

// Class Pal.PalUIInGameMainMenuInventoryModel
// 0x0000 (0x0028 - 0x0028)
class UPalUIInGameMainMenuInventoryModel final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIInGameMainMenuInventoryModel">();
	}
	static class UPalUIInGameMainMenuInventoryModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIInGameMainMenuInventoryModel>();
	}
};
static_assert(alignof(UPalUIInGameMainMenuInventoryModel) == 0x000008, "Wrong alignment on UPalUIInGameMainMenuInventoryModel");
static_assert(sizeof(UPalUIInGameMainMenuInventoryModel) == 0x000028, "Wrong size on UPalUIInGameMainMenuInventoryModel");

// Class Pal.PalBaseCampModuleEnergy
// 0x0010 (0x0038 - 0x0028)
class UPalBaseCampModuleEnergy final : public UPalBaseCampFunctionModuleBase
{
public:
	TArray<class UPalBaseCampModuleEnergy_FunctionBase*> FunctionArray;                                     // 0x0028(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBaseCampModuleEnergy">();
	}
	static class UPalBaseCampModuleEnergy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBaseCampModuleEnergy>();
	}
};
static_assert(alignof(UPalBaseCampModuleEnergy) == 0x000008, "Wrong alignment on UPalBaseCampModuleEnergy");
static_assert(sizeof(UPalBaseCampModuleEnergy) == 0x000038, "Wrong size on UPalBaseCampModuleEnergy");
static_assert(offsetof(UPalBaseCampModuleEnergy, FunctionArray) == 0x000028, "Member 'UPalBaseCampModuleEnergy::FunctionArray' has a wrong offset!");

// Class Pal.PalBaseCampModuleEnergy_FunctionBase
// 0x0038 (0x0060 - 0x0028)
class UPalBaseCampModuleEnergy_FunctionBase : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnUpdateEnergyAmountDelegate;                      // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FGuid>                          EnergyGeneratorConcreteModelIds;                   // 0x0038(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGuid>                          EnergyConsumerConcreteModelIds;                    // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	EPalBaseCampModuleEnergyState                 CurrentState;                                      // 0x0058(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2951[0x3];                                     // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProvideWaitRemainTime;                             // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InvokeOnUpdateEnergyAmount(class UPalMapObjectGenerateEnergyModel* Model);
	void UpdateEnergyAmountDelegate__DelegateSignature(class UPalBaseCampModuleEnergy_FunctionBase* Function);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBaseCampModuleEnergy_FunctionBase">();
	}
	static class UPalBaseCampModuleEnergy_FunctionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBaseCampModuleEnergy_FunctionBase>();
	}
};
static_assert(alignof(UPalBaseCampModuleEnergy_FunctionBase) == 0x000008, "Wrong alignment on UPalBaseCampModuleEnergy_FunctionBase");
static_assert(sizeof(UPalBaseCampModuleEnergy_FunctionBase) == 0x000060, "Wrong size on UPalBaseCampModuleEnergy_FunctionBase");
static_assert(offsetof(UPalBaseCampModuleEnergy_FunctionBase, OnUpdateEnergyAmountDelegate) == 0x000028, "Member 'UPalBaseCampModuleEnergy_FunctionBase::OnUpdateEnergyAmountDelegate' has a wrong offset!");
static_assert(offsetof(UPalBaseCampModuleEnergy_FunctionBase, EnergyGeneratorConcreteModelIds) == 0x000038, "Member 'UPalBaseCampModuleEnergy_FunctionBase::EnergyGeneratorConcreteModelIds' has a wrong offset!");
static_assert(offsetof(UPalBaseCampModuleEnergy_FunctionBase, EnergyConsumerConcreteModelIds) == 0x000048, "Member 'UPalBaseCampModuleEnergy_FunctionBase::EnergyConsumerConcreteModelIds' has a wrong offset!");
static_assert(offsetof(UPalBaseCampModuleEnergy_FunctionBase, CurrentState) == 0x000058, "Member 'UPalBaseCampModuleEnergy_FunctionBase::CurrentState' has a wrong offset!");
static_assert(offsetof(UPalBaseCampModuleEnergy_FunctionBase, ProvideWaitRemainTime) == 0x00005C, "Member 'UPalBaseCampModuleEnergy_FunctionBase::ProvideWaitRemainTime' has a wrong offset!");

// Class Pal.PalBaseCampModuleEnergy_Electric
// 0x0000 (0x0060 - 0x0060)
class UPalBaseCampModuleEnergy_Electric final : public UPalBaseCampModuleEnergy_FunctionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBaseCampModuleEnergy_Electric">();
	}
	static class UPalBaseCampModuleEnergy_Electric* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBaseCampModuleEnergy_Electric>();
	}
};
static_assert(alignof(UPalBaseCampModuleEnergy_Electric) == 0x000008, "Wrong alignment on UPalBaseCampModuleEnergy_Electric");
static_assert(sizeof(UPalBaseCampModuleEnergy_Electric) == 0x000060, "Wrong size on UPalBaseCampModuleEnergy_Electric");

// Class Pal.PalBaseCampModuleFacilityReservation
// 0x0060 (0x0088 - 0x0028)
class UPalBaseCampModuleFacilityReservation final : public UPalBaseCampFunctionModuleBase
{
public:
	TMap<EPalMapObjectWorkerAvailableFacilityType, struct FPalBaseCampFacilityUsageInfoSet> FacilityUsageInfoSetMap;                           // 0x0028(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	TArray<struct FPalBaseCampFacilityCountPair>  FacilityCounts;                                    // 0x0078(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)

public:
	void OnAvailableMapObjectInServer(class UPalMapObjectConcreteModelBase* ConcreteModel);
	void OnFinishUseFacility_ServerInternal(class UPalMapObjectConcreteModelBase* Model);
	void OnNotAvailableMapObjectInServer(class UPalMapObjectConcreteModelBase* ConcreteModel);
	void OnStartUseFacility_ServerInternal(class UPalMapObjectConcreteModelBase* Model, class UPalIndividualCharacterHandle* IndividualHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBaseCampModuleFacilityReservation">();
	}
	static class UPalBaseCampModuleFacilityReservation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBaseCampModuleFacilityReservation>();
	}
};
static_assert(alignof(UPalBaseCampModuleFacilityReservation) == 0x000008, "Wrong alignment on UPalBaseCampModuleFacilityReservation");
static_assert(sizeof(UPalBaseCampModuleFacilityReservation) == 0x000088, "Wrong size on UPalBaseCampModuleFacilityReservation");
static_assert(offsetof(UPalBaseCampModuleFacilityReservation, FacilityUsageInfoSetMap) == 0x000028, "Member 'UPalBaseCampModuleFacilityReservation::FacilityUsageInfoSetMap' has a wrong offset!");
static_assert(offsetof(UPalBaseCampModuleFacilityReservation, FacilityCounts) == 0x000078, "Member 'UPalBaseCampModuleFacilityReservation::FacilityCounts' has a wrong offset!");

// Class Pal.PalBaseCampModuleMedical
// 0x0010 (0x0038 - 0x0028)
class UPalBaseCampModuleMedical final : public UPalBaseCampFunctionModuleBase
{
public:
	TArray<struct FGuid>                          ReviveWorkIds;                                     // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)

public:
	void OnRemovedWorkerInServer(class UPalIndividualCharacterHandle* IndividualHandle);
	void OnReviveCharacter_ServerInternal(class UPalIndividualCharacterParameter* IndividualParameter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBaseCampModuleMedical">();
	}
	static class UPalBaseCampModuleMedical* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBaseCampModuleMedical>();
	}
};
static_assert(alignof(UPalBaseCampModuleMedical) == 0x000008, "Wrong alignment on UPalBaseCampModuleMedical");
static_assert(sizeof(UPalBaseCampModuleMedical) == 0x000038, "Wrong size on UPalBaseCampModuleMedical");
static_assert(offsetof(UPalBaseCampModuleMedical, ReviveWorkIds) == 0x000028, "Member 'UPalBaseCampModuleMedical::ReviveWorkIds' has a wrong offset!");

// Class Pal.PalBaseCampModulePassiveEffectWorkSpeedApplierInterface
// 0x0000 (0x0028 - 0x0028)
class IPalBaseCampModulePassiveEffectWorkSpeedApplierInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBaseCampModulePassiveEffectWorkSpeedApplierInterface">();
	}
	static class IPalBaseCampModulePassiveEffectWorkSpeedApplierInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPalBaseCampModulePassiveEffectWorkSpeedApplierInterface>();
	}
};
static_assert(alignof(IPalBaseCampModulePassiveEffectWorkSpeedApplierInterface) == 0x000008, "Wrong alignment on IPalBaseCampModulePassiveEffectWorkSpeedApplierInterface");
static_assert(sizeof(IPalBaseCampModulePassiveEffectWorkSpeedApplierInterface) == 0x000028, "Wrong size on IPalBaseCampModulePassiveEffectWorkSpeedApplierInterface");

// Class Pal.PalBaseCampModulePassiveEffect
// 0x0118 (0x0140 - 0x0028)
class UPalBaseCampModulePassiveEffect final : public UPalBaseCampFunctionModuleBase
{
public:
	struct FPalFastBaseCampPassiveEffectRepInfoArray RepInfoArray;                                      // 0x0028(0x0118)(Edit, Net, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)

public:
	void OnAvailableMapObjectInServer(class UPalMapObjectConcreteModelBase* Model);
	void OnNotAvailableMapObjectInServer(class UPalMapObjectConcreteModelBase* Model);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBaseCampModulePassiveEffect">();
	}
	static class UPalBaseCampModulePassiveEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBaseCampModulePassiveEffect>();
	}
};
static_assert(alignof(UPalBaseCampModulePassiveEffect) == 0x000008, "Wrong alignment on UPalBaseCampModulePassiveEffect");
static_assert(sizeof(UPalBaseCampModulePassiveEffect) == 0x000140, "Wrong size on UPalBaseCampModulePassiveEffect");
static_assert(offsetof(UPalBaseCampModulePassiveEffect, RepInfoArray) == 0x000028, "Member 'UPalBaseCampModulePassiveEffect::RepInfoArray' has a wrong offset!");

// Class Pal.PalBaseCampPassiveEffect_WorkHard
// 0x0020 (0x0098 - 0x0078)
class UPalBaseCampPassiveEffect_WorkHard final : public UPalBaseCampPassiveEffectBase
{
public:
	uint8                                         Pad_2952[0x8];                                     // 0x0078(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnUpdateWorkHardTypeDelegate;                      // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EPalBaseCampPassiveEffectWorkHardType         WorkHardType;                                      // 0x0090(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2953[0x7];                                     // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_WorkHardType();
	void ReturnSelfDelegate__DelegateSignature(class UPalBaseCampPassiveEffect_WorkHard* Self);

	EPalBaseCampPassiveEffectWorkHardType GetWorkHardType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBaseCampPassiveEffect_WorkHard">();
	}
	static class UPalBaseCampPassiveEffect_WorkHard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBaseCampPassiveEffect_WorkHard>();
	}
};
static_assert(alignof(UPalBaseCampPassiveEffect_WorkHard) == 0x000008, "Wrong alignment on UPalBaseCampPassiveEffect_WorkHard");
static_assert(sizeof(UPalBaseCampPassiveEffect_WorkHard) == 0x000098, "Wrong size on UPalBaseCampPassiveEffect_WorkHard");
static_assert(offsetof(UPalBaseCampPassiveEffect_WorkHard, OnUpdateWorkHardTypeDelegate) == 0x000080, "Member 'UPalBaseCampPassiveEffect_WorkHard::OnUpdateWorkHardTypeDelegate' has a wrong offset!");
static_assert(offsetof(UPalBaseCampPassiveEffect_WorkHard, WorkHardType) == 0x000090, "Member 'UPalBaseCampPassiveEffect_WorkHard::WorkHardType' has a wrong offset!");

// Class Pal.PalBaseCampModuleResourceCollectorTargetInterface
// 0x0000 (0x0028 - 0x0028)
class IPalBaseCampModuleResourceCollectorTargetInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBaseCampModuleResourceCollectorTargetInterface">();
	}
	static class IPalBaseCampModuleResourceCollectorTargetInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPalBaseCampModuleResourceCollectorTargetInterface>();
	}
};
static_assert(alignof(IPalBaseCampModuleResourceCollectorTargetInterface) == 0x000008, "Wrong alignment on IPalBaseCampModuleResourceCollectorTargetInterface");
static_assert(sizeof(IPalBaseCampModuleResourceCollectorTargetInterface) == 0x000028, "Wrong size on IPalBaseCampModuleResourceCollectorTargetInterface");

// Class Pal.PalBaseCampModuleResourceCollector
// 0x0050 (0x0078 - 0x0028)
class UPalBaseCampModuleResourceCollector final : public UPalBaseCampFunctionModuleBase
{
public:
	TMap<struct FGuid, struct FPalBaseCampModuleResourceCollectWorkInfo> MapObjectWorkInfoMap;                              // 0x0028(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)

public:
	void OnDestroyedFoliageInstance(class UPalFoliageInstance* Instance);
	void OnDestroyedMapObjectModel(class UPalMapObjectModel* Model, const struct FPalMapObjectDisposeOptions& Options);
	void OnRegisteredFoliageModel_ServerInternal(class UPalFoliageInstance* Instance);
	void OnRegisteredMapObjectModel(class UPalMapObjectModel* Model);
	void OnRespawnFoliageInstance(class UPalFoliageInstance* Instance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBaseCampModuleResourceCollector">();
	}
	static class UPalBaseCampModuleResourceCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBaseCampModuleResourceCollector>();
	}
};
static_assert(alignof(UPalBaseCampModuleResourceCollector) == 0x000008, "Wrong alignment on UPalBaseCampModuleResourceCollector");
static_assert(sizeof(UPalBaseCampModuleResourceCollector) == 0x000078, "Wrong size on UPalBaseCampModuleResourceCollector");
static_assert(offsetof(UPalBaseCampModuleResourceCollector, MapObjectWorkInfoMap) == 0x000028, "Member 'UPalBaseCampModuleResourceCollector::MapObjectWorkInfoMap' has a wrong offset!");

// Class Pal.PalPrimaryGameLayoutBase
// 0x0000 (0x0308 - 0x0308)
class UPalPrimaryGameLayoutBase : public UPrimaryGameLayout
{
public:
	void FadeIn(EPalFadeWidgetLayerType LayerType, class UPalHUDDispatchParameter_FadeWidget* FadeParameter);
	void FadeOut(EPalFadeWidgetLayerType LayerType);
	void HideCommonItemInfo();
	void HideFocusCursor();
	void HideLiftIcon();
	void SetupLiftIcon();
	void ShowCommonItemInfo(const struct FPalUICommonItemInfoDisplayData& DisplayData);
	void ShowCommonReward(const struct FPalUICommonRewardDisplayData& RewardDisplayData);
	void ShowFocusCursor(class UWidget* TargetWidget);
	void ShowLiftIcon();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalPrimaryGameLayoutBase">();
	}
	static class UPalPrimaryGameLayoutBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalPrimaryGameLayoutBase>();
	}
};
static_assert(alignof(UPalPrimaryGameLayoutBase) == 0x000008, "Wrong alignment on UPalPrimaryGameLayoutBase");
static_assert(sizeof(UPalPrimaryGameLayoutBase) == 0x000308, "Wrong size on UPalPrimaryGameLayoutBase");

// Class Pal.PalBaseCampModuleTransportItemDirector
// 0x00A0 (0x00C8 - 0x0028)
class UPalBaseCampModuleTransportItemDirector final : public UPalBaseCampFunctionModuleBase
{
public:
	TMap<struct FGuid, struct FPalBaseCampModuleTransportItemStatus> TransportItemStatusMap;                            // 0x0028(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGuid, struct FPalBaseCampModuleTransportItemTarget> TransportTargetMap;                                // 0x0078(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	void OnAssignWorkRequirement(class UPalWorkBase* Work, const struct FPalInstanceID& IndividualId);
	void OnAssignWorkTransportItemTarget(class UPalWorkBase* Work, const struct FPalInstanceID& IndividualId);
	void OnAvailableMapObjectConcreteModel(class UPalMapObjectConcreteModelBase* ConcreteModel);
	void OnNotAvailableMapObjectConcreteModel(class UPalMapObjectConcreteModelBase* ConcreteModel);
	void OnUnassignWorkRequirement(class UPalWorkBase* Work, const struct FPalInstanceID& IndividualId);
	void OnUnassignWorkTransportItemTarget(class UPalWorkBase* Work, const struct FPalInstanceID& IndividualId);
	void OnUpdateMapObjectContainer(class UPalMapObjectItemContainerModule* ContainerModule);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBaseCampModuleTransportItemDirector">();
	}
	static class UPalBaseCampModuleTransportItemDirector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBaseCampModuleTransportItemDirector>();
	}
};
static_assert(alignof(UPalBaseCampModuleTransportItemDirector) == 0x000008, "Wrong alignment on UPalBaseCampModuleTransportItemDirector");
static_assert(sizeof(UPalBaseCampModuleTransportItemDirector) == 0x0000C8, "Wrong size on UPalBaseCampModuleTransportItemDirector");
static_assert(offsetof(UPalBaseCampModuleTransportItemDirector, TransportItemStatusMap) == 0x000028, "Member 'UPalBaseCampModuleTransportItemDirector::TransportItemStatusMap' has a wrong offset!");
static_assert(offsetof(UPalBaseCampModuleTransportItemDirector, TransportTargetMap) == 0x000078, "Member 'UPalBaseCampModuleTransportItemDirector::TransportTargetMap' has a wrong offset!");

// Class Pal.PalTutorialTrigger_Capture
// 0x0008 (0x0048 - 0x0040)
class UPalTutorialTrigger_Capture final : public UPalTutorialTriggerBase
{
public:
	EPalTutorialTriggerConditionType              TriggerType;                                       // 0x0040(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2955[0x3];                                     // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TriggerCount;                                      // 0x0044(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalTutorialTrigger_Capture">();
	}
	static class UPalTutorialTrigger_Capture* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalTutorialTrigger_Capture>();
	}
};
static_assert(alignof(UPalTutorialTrigger_Capture) == 0x000008, "Wrong alignment on UPalTutorialTrigger_Capture");
static_assert(sizeof(UPalTutorialTrigger_Capture) == 0x000048, "Wrong size on UPalTutorialTrigger_Capture");
static_assert(offsetof(UPalTutorialTrigger_Capture, TriggerType) == 0x000040, "Member 'UPalTutorialTrigger_Capture::TriggerType' has a wrong offset!");
static_assert(offsetof(UPalTutorialTrigger_Capture, TriggerCount) == 0x000044, "Member 'UPalTutorialTrigger_Capture::TriggerCount' has a wrong offset!");

// Class Pal.PalGameStateReplicatorBase
// 0x0000 (0x0028 - 0x0028)
class UPalGameStateReplicatorBase : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGameStateReplicatorBase">();
	}
	static class UPalGameStateReplicatorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalGameStateReplicatorBase>();
	}
};
static_assert(alignof(UPalGameStateReplicatorBase) == 0x000008, "Wrong alignment on UPalGameStateReplicatorBase");
static_assert(sizeof(UPalGameStateReplicatorBase) == 0x000028, "Wrong size on UPalGameStateReplicatorBase");

// Class Pal.PalBaseCampReplicator
// 0x0198 (0x01C0 - 0x0028)
class UPalBaseCampReplicator final : public UPalGameStateReplicatorBase
{
public:
	struct FFastPalBaseCampRepInfoArray           RepInfoArray;                                      // 0x0028(0x0148)(Edit, Net, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2956[0x50];                                    // 0x0170(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBaseCampReplicator">();
	}
	static class UPalBaseCampReplicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBaseCampReplicator>();
	}
};
static_assert(alignof(UPalBaseCampReplicator) == 0x000008, "Wrong alignment on UPalBaseCampReplicator");
static_assert(sizeof(UPalBaseCampReplicator) == 0x0001C0, "Wrong size on UPalBaseCampReplicator");
static_assert(offsetof(UPalBaseCampReplicator, RepInfoArray) == 0x000028, "Member 'UPalBaseCampReplicator::RepInfoArray' has a wrong offset!");

// Class Pal.PalBaseCampTaskChecker
// 0x0008 (0x0030 - 0x0028)
class UPalBaseCampTaskChecker final : public UObject
{
public:
	class UDataTable*                             TaskDataTable;                                     // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBaseCampTaskChecker">();
	}
	static class UPalBaseCampTaskChecker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBaseCampTaskChecker>();
	}
};
static_assert(alignof(UPalBaseCampTaskChecker) == 0x000008, "Wrong alignment on UPalBaseCampTaskChecker");
static_assert(sizeof(UPalBaseCampTaskChecker) == 0x000030, "Wrong size on UPalBaseCampTaskChecker");
static_assert(offsetof(UPalBaseCampTaskChecker, TaskDataTable) == 0x000028, "Member 'UPalBaseCampTaskChecker::TaskDataTable' has a wrong offset!");

// Class Pal.PalProgressBar
// 0x0000 (0x0440 - 0x0440)
class UPalProgressBar final : public UProgressBar
{
public:
	void SetFillImage(const struct FSlateBrush& NewImage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalProgressBar">();
	}
	static class UPalProgressBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalProgressBar>();
	}
};
static_assert(alignof(UPalProgressBar) == 0x000010, "Wrong alignment on UPalProgressBar");
static_assert(sizeof(UPalProgressBar) == 0x000440, "Wrong size on UPalProgressBar");

// Class Pal.PalBaseCampUtility
// 0x0000 (0x0028 - 0x0028)
class UPalBaseCampUtility final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBaseCampUtility">();
	}
	static class UPalBaseCampUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBaseCampUtility>();
	}
};
static_assert(alignof(UPalBaseCampUtility) == 0x000008, "Wrong alignment on UPalBaseCampUtility");
static_assert(sizeof(UPalBaseCampUtility) == 0x000028, "Wrong size on UPalBaseCampUtility");

// Class Pal.PalContainerIdUtility
// 0x0000 (0x0028 - 0x0028)
class UPalContainerIdUtility final : public UBlueprintFunctionLibrary
{
public:
	static bool BP_Equal(const struct FPalContainerId& A, const struct FPalContainerId& B);
	static bool BP_NotEqual(const struct FPalContainerId& A, const struct FPalContainerId& B);
	static bool IsNoneContainerId(const struct FPalContainerId& ContainerId);
	static struct FPalContainerId NoneContainerId();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalContainerIdUtility">();
	}
	static class UPalContainerIdUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalContainerIdUtility>();
	}
};
static_assert(alignof(UPalContainerIdUtility) == 0x000008, "Wrong alignment on UPalContainerIdUtility");
static_assert(sizeof(UPalContainerIdUtility) == 0x000028, "Wrong size on UPalContainerIdUtility");

// Class Pal.PalBaseCampWorkCollection
// 0x00A0 (0x00C8 - 0x0028)
class UPalBaseCampWorkCollection final : public UObject
{
public:
	uint8                                         Pad_295A[0x10];                                    // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnUnassignWorkDelegate;                            // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGuid                                  BaseCampId;                                        // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FGuid>                          WorkIds;                                           // 0x0058(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_295B[0x8];                                     // 0x0068(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGuid, struct FPalBaseCampWorkCollectionStashInfo> CannotMoveToWorkInfoMap;                           // 0x0070(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_295C[0x8];                                     // 0x00C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRequiredAssign_ServerInternal(class UPalWorkBase* Work, const struct FPalWorkAssignRequirementParameter& RequirementParameter);
	void OnUnassignWork_ServerInternal(class UPalWorkBase* Work, const struct FPalInstanceID& IndividualId);
	void WorkAssignRequirementDelegate__DelegateSignature(class UPalWorkBase* Work, const struct FPalWorkAssignRequirementParameter& RequirementParameter);
	void WorkAssignUpdateDelegate__DelegateSignature(class UPalWorkBase* Work, const struct FPalInstanceID& IndividualId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBaseCampWorkCollection">();
	}
	static class UPalBaseCampWorkCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBaseCampWorkCollection>();
	}
};
static_assert(alignof(UPalBaseCampWorkCollection) == 0x000008, "Wrong alignment on UPalBaseCampWorkCollection");
static_assert(sizeof(UPalBaseCampWorkCollection) == 0x0000C8, "Wrong size on UPalBaseCampWorkCollection");
static_assert(offsetof(UPalBaseCampWorkCollection, OnUnassignWorkDelegate) == 0x000038, "Member 'UPalBaseCampWorkCollection::OnUnassignWorkDelegate' has a wrong offset!");
static_assert(offsetof(UPalBaseCampWorkCollection, BaseCampId) == 0x000048, "Member 'UPalBaseCampWorkCollection::BaseCampId' has a wrong offset!");
static_assert(offsetof(UPalBaseCampWorkCollection, WorkIds) == 0x000058, "Member 'UPalBaseCampWorkCollection::WorkIds' has a wrong offset!");
static_assert(offsetof(UPalBaseCampWorkCollection, CannotMoveToWorkInfoMap) == 0x000070, "Member 'UPalBaseCampWorkCollection::CannotMoveToWorkInfoMap' has a wrong offset!");

// Class Pal.PalQuestBlock
// 0x0028 (0x0050 - 0x0028)
class UPalQuestBlock : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnUpdatedBlockDelegate;                            // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCompletedBlockDelegate;                          // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          IsAutoComplete;                                    // 0x0048(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_295D[0x7];                                     // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CallUpdateBlockDelegate_ForBP();
	bool CanComplete();
	void Complete();
	void CompletedBlockDelegate__DelegateSignature(class UPalQuestBlock* CompletedQuestBlock);
	void GetDescriptionText(class FText* OutText);
	void GetProgressText(class FText* OutText);
	void OnComplete();
	void OnComplete_ForBP();
	void OnSetup();
	void OnSetup_ForBP();
	void SetCanComplete(bool Flag);
	void Setup();
	void UpdatedBlockDelegate__DelegateSignature(class UPalQuestBlock* UpdatedQuestBlock);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalQuestBlock">();
	}
	static class UPalQuestBlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalQuestBlock>();
	}
};
static_assert(alignof(UPalQuestBlock) == 0x000008, "Wrong alignment on UPalQuestBlock");
static_assert(sizeof(UPalQuestBlock) == 0x000050, "Wrong size on UPalQuestBlock");
static_assert(offsetof(UPalQuestBlock, OnUpdatedBlockDelegate) == 0x000028, "Member 'UPalQuestBlock::OnUpdatedBlockDelegate' has a wrong offset!");
static_assert(offsetof(UPalQuestBlock, OnCompletedBlockDelegate) == 0x000038, "Member 'UPalQuestBlock::OnCompletedBlockDelegate' has a wrong offset!");
static_assert(offsetof(UPalQuestBlock, IsAutoComplete) == 0x000048, "Member 'UPalQuestBlock::IsAutoComplete' has a wrong offset!");

// Class Pal.PalQuestBlock_BaseCampLevel
// 0x0010 (0x0060 - 0x0050)
class UPalQuestBlock_BaseCampLevel final : public UPalQuestBlock
{
public:
	int32                                         RequireLevel;                                      // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NowBaseCampLevel;                                  // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           CheckTimerHandle;                                  // 0x0058(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnTimer_CheckBaseCampLevel();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalQuestBlock_BaseCampLevel">();
	}
	static class UPalQuestBlock_BaseCampLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalQuestBlock_BaseCampLevel>();
	}
};
static_assert(alignof(UPalQuestBlock_BaseCampLevel) == 0x000008, "Wrong alignment on UPalQuestBlock_BaseCampLevel");
static_assert(sizeof(UPalQuestBlock_BaseCampLevel) == 0x000060, "Wrong size on UPalQuestBlock_BaseCampLevel");
static_assert(offsetof(UPalQuestBlock_BaseCampLevel, RequireLevel) == 0x000050, "Member 'UPalQuestBlock_BaseCampLevel::RequireLevel' has a wrong offset!");
static_assert(offsetof(UPalQuestBlock_BaseCampLevel, NowBaseCampLevel) == 0x000054, "Member 'UPalQuestBlock_BaseCampLevel::NowBaseCampLevel' has a wrong offset!");
static_assert(offsetof(UPalQuestBlock_BaseCampLevel, CheckTimerHandle) == 0x000058, "Member 'UPalQuestBlock_BaseCampLevel::CheckTimerHandle' has a wrong offset!");

// Class Pal.PalBaseCampWorkerEvent_DestroyBuilding
// 0x0000 (0x0090 - 0x0090)
class UPalBaseCampWorkerEvent_DestroyBuilding final : public UPalBaseCampWorkerEventBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBaseCampWorkerEvent_DestroyBuilding">();
	}
	static class UPalBaseCampWorkerEvent_DestroyBuilding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBaseCampWorkerEvent_DestroyBuilding>();
	}
};
static_assert(alignof(UPalBaseCampWorkerEvent_DestroyBuilding) == 0x000008, "Wrong alignment on UPalBaseCampWorkerEvent_DestroyBuilding");
static_assert(sizeof(UPalBaseCampWorkerEvent_DestroyBuilding) == 0x000090, "Wrong size on UPalBaseCampWorkerEvent_DestroyBuilding");

// Class Pal.PalBaseCampWorkerEvent_DodgeWork_Short
// 0x0000 (0x00A0 - 0x00A0)
class UPalBaseCampWorkerEvent_DodgeWork_Short final : public UPalBaseCampWorkerEvent_DodgeWork
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBaseCampWorkerEvent_DodgeWork_Short">();
	}
	static class UPalBaseCampWorkerEvent_DodgeWork_Short* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBaseCampWorkerEvent_DodgeWork_Short>();
	}
};
static_assert(alignof(UPalBaseCampWorkerEvent_DodgeWork_Short) == 0x000008, "Wrong alignment on UPalBaseCampWorkerEvent_DodgeWork_Short");
static_assert(sizeof(UPalBaseCampWorkerEvent_DodgeWork_Short) == 0x0000A0, "Wrong size on UPalBaseCampWorkerEvent_DodgeWork_Short");

// Class Pal.PalQuestBlock_CollectItem
// 0x0000 (0x0050 - 0x0050)
class UPalQuestBlock_CollectItem final : public UPalQuestBlock
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalQuestBlock_CollectItem">();
	}
	static class UPalQuestBlock_CollectItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalQuestBlock_CollectItem>();
	}
};
static_assert(alignof(UPalQuestBlock_CollectItem) == 0x000008, "Wrong alignment on UPalQuestBlock_CollectItem");
static_assert(sizeof(UPalQuestBlock_CollectItem) == 0x000050, "Wrong size on UPalQuestBlock_CollectItem");

// Class Pal.PalBaseCampWorkerEvent_EatTooMuch
// 0x0008 (0x0098 - 0x0090)
class UPalBaseCampWorkerEvent_EatTooMuch final : public UPalBaseCampWorkerEventBase
{
public:
	float                                         RecoverSanityTo;                                   // 0x0090(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         EatMaxNum;                                         // 0x0094(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBaseCampWorkerEvent_EatTooMuch">();
	}
	static class UPalBaseCampWorkerEvent_EatTooMuch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBaseCampWorkerEvent_EatTooMuch>();
	}
};
static_assert(alignof(UPalBaseCampWorkerEvent_EatTooMuch) == 0x000008, "Wrong alignment on UPalBaseCampWorkerEvent_EatTooMuch");
static_assert(sizeof(UPalBaseCampWorkerEvent_EatTooMuch) == 0x000098, "Wrong size on UPalBaseCampWorkerEvent_EatTooMuch");
static_assert(offsetof(UPalBaseCampWorkerEvent_EatTooMuch, RecoverSanityTo) == 0x000090, "Member 'UPalBaseCampWorkerEvent_EatTooMuch::RecoverSanityTo' has a wrong offset!");
static_assert(offsetof(UPalBaseCampWorkerEvent_EatTooMuch, EatMaxNum) == 0x000094, "Member 'UPalBaseCampWorkerEvent_EatTooMuch::EatMaxNum' has a wrong offset!");

// Class Pal.PalBaseCampWorkerEvent_Escape
// 0x0000 (0x0090 - 0x0090)
class UPalBaseCampWorkerEvent_Escape final : public UPalBaseCampWorkerEventBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBaseCampWorkerEvent_Escape">();
	}
	static class UPalBaseCampWorkerEvent_Escape* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBaseCampWorkerEvent_Escape>();
	}
};
static_assert(alignof(UPalBaseCampWorkerEvent_Escape) == 0x000008, "Wrong alignment on UPalBaseCampWorkerEvent_Escape");
static_assert(sizeof(UPalBaseCampWorkerEvent_Escape) == 0x000090, "Wrong size on UPalBaseCampWorkerEvent_Escape");

// Class Pal.PalBaseCampWorkerEvent_FightWithFriend
// 0x0000 (0x0090 - 0x0090)
class UPalBaseCampWorkerEvent_FightWithFriend final : public UPalBaseCampWorkerEventBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBaseCampWorkerEvent_FightWithFriend">();
	}
	static class UPalBaseCampWorkerEvent_FightWithFriend* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBaseCampWorkerEvent_FightWithFriend>();
	}
};
static_assert(alignof(UPalBaseCampWorkerEvent_FightWithFriend) == 0x000008, "Wrong alignment on UPalBaseCampWorkerEvent_FightWithFriend");
static_assert(sizeof(UPalBaseCampWorkerEvent_FightWithFriend) == 0x000090, "Wrong size on UPalBaseCampWorkerEvent_FightWithFriend");

// Class Pal.PalBaseCampWorkerEvent_Sick
// 0x0000 (0x0090 - 0x0090)
class UPalBaseCampWorkerEvent_Sick final : public UPalBaseCampWorkerEventBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBaseCampWorkerEvent_Sick">();
	}
	static class UPalBaseCampWorkerEvent_Sick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBaseCampWorkerEvent_Sick>();
	}
};
static_assert(alignof(UPalBaseCampWorkerEvent_Sick) == 0x000008, "Wrong alignment on UPalBaseCampWorkerEvent_Sick");
static_assert(sizeof(UPalBaseCampWorkerEvent_Sick) == 0x000090, "Wrong size on UPalBaseCampWorkerEvent_Sick");

// Class Pal.PalBaseCampWorkerEvent_TurnFoodBox
// 0x0000 (0x0090 - 0x0090)
class UPalBaseCampWorkerEvent_TurnFoodBox final : public UPalBaseCampWorkerEventBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBaseCampWorkerEvent_TurnFoodBox">();
	}
	static class UPalBaseCampWorkerEvent_TurnFoodBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBaseCampWorkerEvent_TurnFoodBox>();
	}
};
static_assert(alignof(UPalBaseCampWorkerEvent_TurnFoodBox) == 0x000008, "Wrong alignment on UPalBaseCampWorkerEvent_TurnFoodBox");
static_assert(sizeof(UPalBaseCampWorkerEvent_TurnFoodBox) == 0x000090, "Wrong size on UPalBaseCampWorkerEvent_TurnFoodBox");

// Class Pal.PalBaseCampWorkerTaskBase
// 0x0010 (0x0038 - 0x0028)
class UPalBaseCampWorkerTaskBase : public UObject
{
public:
	struct FGuid                                  OwnerBaseCampId;                                   // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBaseCampWorkerTaskBase">();
	}
	static class UPalBaseCampWorkerTaskBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBaseCampWorkerTaskBase>();
	}
};
static_assert(alignof(UPalBaseCampWorkerTaskBase) == 0x000008, "Wrong alignment on UPalBaseCampWorkerTaskBase");
static_assert(sizeof(UPalBaseCampWorkerTaskBase) == 0x000038, "Wrong size on UPalBaseCampWorkerTaskBase");
static_assert(offsetof(UPalBaseCampWorkerTaskBase, OwnerBaseCampId) == 0x000028, "Member 'UPalBaseCampWorkerTaskBase::OwnerBaseCampId' has a wrong offset!");

// Class Pal.PalBaseCampWorkerTask_IgnitionTorchAtNight
// 0x0010 (0x0048 - 0x0038)
class UPalBaseCampWorkerTask_IgnitionTorchAtNight final : public UPalBaseCampWorkerTaskBase
{
public:
	TArray<struct FGuid>                          TorchInstanceIds;                                  // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)

public:
	void OnAvailableMapObjectInServer(class UPalMapObjectConcreteModelBase* ConcreteModel);
	void OnNotAvailableMapObjectInServer(class UPalMapObjectConcreteModelBase* ConcreteModel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBaseCampWorkerTask_IgnitionTorchAtNight">();
	}
	static class UPalBaseCampWorkerTask_IgnitionTorchAtNight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBaseCampWorkerTask_IgnitionTorchAtNight>();
	}
};
static_assert(alignof(UPalBaseCampWorkerTask_IgnitionTorchAtNight) == 0x000008, "Wrong alignment on UPalBaseCampWorkerTask_IgnitionTorchAtNight");
static_assert(sizeof(UPalBaseCampWorkerTask_IgnitionTorchAtNight) == 0x000048, "Wrong size on UPalBaseCampWorkerTask_IgnitionTorchAtNight");
static_assert(offsetof(UPalBaseCampWorkerTask_IgnitionTorchAtNight, TorchInstanceIds) == 0x000038, "Member 'UPalBaseCampWorkerTask_IgnitionTorchAtNight::TorchInstanceIds' has a wrong offset!");

// Class Pal.PalBattleManager
// 0x00A0 (0x0110 - 0x0070)
class UPalBattleManager : public UPalWorldSubsystem
{
public:
	TMap<class AActor*, struct FActorArray>       EnemyListPerPlayer;                                // 0x0070(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_295E[0x8];                                     // 0x00C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class APalNPCSpawnerBase>         DebugSpawnerClass;                                 // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFExclamationMarkDelegate;                        // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFQuestionMarkDelegate;                           // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFEmitSoundDelegate;                              // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFEmitSoundOnlyPalmiDelegate;                     // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void ActionMenaceStart(class APalCharacter* SelfCharacter);
	void AddEnemyActor_PlayerOrOtomo(class AActor* PlayerOrOtomo, class AActor* Enemy);
	void EmitSound(class FName SoundRowName, class AActor* Emitter, const struct FVector& EmitLocation, float VolumeRate);
	void EmitSoundDelegate__DelegateSignature(int32 SoundRadius, const struct FVector& EmitLocation, class AActor* Emitter);
	void EmitSoundOnlyPalmiDelegate__DelegateSignature(int32 SoundLevel);
	void EnemyNearPlayerListUpdate(class AActor* Enemy, float Distance);
	void ExclamationMarkDelegate__DelegateSignature(class APalCharacter* TargetCharacter);
	void GetAllPlayerAndOtomo_ForEnemySelf(const TArray<class AActor*>& TargetPlayers, TArray<class AActor*>* OutCharacters);
	bool GetConflictEnemies(class AActor* Player, TArray<class AActor*>* OutEnemyes, bool IgnoreOtomoStopByBall);
	class AActor* GetNearestActor(const TArray<class AActor*>& TargetList, const struct FVector& Location);
	class AActor* GetRandomActor(const TArray<class AActor*>& TargetList);
	bool IsBattleModeAnyPlayer();
	void QuestionMarkDelegate__DelegateSignature(class APalCharacter* TargetCharacter);
	void RemoveEnemyActor(class AActor* Player, class AActor* Enemy, EPalPlayerBattleFinishType FinishType);
	void RemoveEnemyActor_AllPlayer(class AActor* Enemy, EPalPlayerBattleFinishType FinishType);
	void RemovePlayerMap(class AActor* Player);
	void SetUpPlayerMap(class AActor* Player);
	void SoundReactionStart(class APalCharacter* SelfCharacter);
	bool TargetIsPlayerOrPlayersOtomoPal(class AActor* TargetCharacter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBattleManager">();
	}
	static class UPalBattleManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBattleManager>();
	}
};
static_assert(alignof(UPalBattleManager) == 0x000008, "Wrong alignment on UPalBattleManager");
static_assert(sizeof(UPalBattleManager) == 0x000110, "Wrong size on UPalBattleManager");
static_assert(offsetof(UPalBattleManager, EnemyListPerPlayer) == 0x000070, "Member 'UPalBattleManager::EnemyListPerPlayer' has a wrong offset!");
static_assert(offsetof(UPalBattleManager, DebugSpawnerClass) == 0x0000C8, "Member 'UPalBattleManager::DebugSpawnerClass' has a wrong offset!");
static_assert(offsetof(UPalBattleManager, OnFExclamationMarkDelegate) == 0x0000D0, "Member 'UPalBattleManager::OnFExclamationMarkDelegate' has a wrong offset!");
static_assert(offsetof(UPalBattleManager, OnFQuestionMarkDelegate) == 0x0000E0, "Member 'UPalBattleManager::OnFQuestionMarkDelegate' has a wrong offset!");
static_assert(offsetof(UPalBattleManager, OnFEmitSoundDelegate) == 0x0000F0, "Member 'UPalBattleManager::OnFEmitSoundDelegate' has a wrong offset!");
static_assert(offsetof(UPalBattleManager, OnFEmitSoundOnlyPalmiDelegate) == 0x000100, "Member 'UPalBattleManager::OnFEmitSoundOnlyPalmiDelegate' has a wrong offset!");

// Class Pal.PalBiomeAreaTriggerBase
// 0x0008 (0x0298 - 0x0290)
class APalBiomeAreaTriggerBase final : public AActor
{
public:
	EPalBiomeType                                 BindBiomeType;                                     // 0x0290(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2966[0x7];                                     // 0x0291(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEndOverlap(class AActor* OtherActor, EPalBiomeType BiomeType);
	void OnOverlap(class AActor* OtherActor, EPalBiomeType BiomeType);

	EPalBiomeType GetBiomeType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBiomeAreaTriggerBase">();
	}
	static class APalBiomeAreaTriggerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalBiomeAreaTriggerBase>();
	}
};
static_assert(alignof(APalBiomeAreaTriggerBase) == 0x000008, "Wrong alignment on APalBiomeAreaTriggerBase");
static_assert(sizeof(APalBiomeAreaTriggerBase) == 0x000298, "Wrong size on APalBiomeAreaTriggerBase");
static_assert(offsetof(APalBiomeAreaTriggerBase, BindBiomeType) == 0x000290, "Member 'APalBiomeAreaTriggerBase::BindBiomeType' has a wrong offset!");

// Class Pal.PalBiomeDetectComponent
// 0x0018 (0x00B8 - 0x00A0)
class UPalBiomeDetectComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnChangedBiome;                                    // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2969[0x8];                                     // 0x00B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeBiome(class APalBiomeAreaTriggerBase* BiomeTriggerActor);
	void OnChangedBiomeDelegate__DelegateSignature(class AActor* OverlapActor, class APalBiomeAreaTriggerBase* BiomeTriggerActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBiomeDetectComponent">();
	}
	static class UPalBiomeDetectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBiomeDetectComponent>();
	}
};
static_assert(alignof(UPalBiomeDetectComponent) == 0x000008, "Wrong alignment on UPalBiomeDetectComponent");
static_assert(sizeof(UPalBiomeDetectComponent) == 0x0000B8, "Wrong size on UPalBiomeDetectComponent");
static_assert(offsetof(UPalBiomeDetectComponent, OnChangedBiome) == 0x0000A0, "Member 'UPalBiomeDetectComponent::OnChangedBiome' has a wrong offset!");

// Class Pal.PalStaticItemDataAsset
// 0x0080 (0x00B0 - 0x0030)
class UPalStaticItemDataAsset final : public UDataAsset
{
public:
	TMap<class FName, class UPalStaticItemDataBase*> StaticItemDataMap;                                 // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   UndefinedVisualBlueprintClassSoft;                 // 0x0080(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalStaticItemDataAsset">();
	}
	static class UPalStaticItemDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalStaticItemDataAsset>();
	}
};
static_assert(alignof(UPalStaticItemDataAsset) == 0x000008, "Wrong alignment on UPalStaticItemDataAsset");
static_assert(sizeof(UPalStaticItemDataAsset) == 0x0000B0, "Wrong size on UPalStaticItemDataAsset");
static_assert(offsetof(UPalStaticItemDataAsset, StaticItemDataMap) == 0x000030, "Member 'UPalStaticItemDataAsset::StaticItemDataMap' has a wrong offset!");
static_assert(offsetof(UPalStaticItemDataAsset, UndefinedVisualBlueprintClassSoft) == 0x000080, "Member 'UPalStaticItemDataAsset::UndefinedVisualBlueprintClassSoft' has a wrong offset!");

// Class Pal.PalBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UPalBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool EqualEqual_PalInstanceIDPalInstanceID(const struct FPalInstanceID& A, const struct FPalInstanceID& B);
	static bool NotEqual_PalInstanceIDPalInstanceID(const struct FPalInstanceID& A, const struct FPalInstanceID& B);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBlueprintLibrary">();
	}
	static class UPalBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBlueprintLibrary>();
	}
};
static_assert(alignof(UPalBlueprintLibrary) == 0x000008, "Wrong alignment on UPalBlueprintLibrary");
static_assert(sizeof(UPalBlueprintLibrary) == 0x000028, "Wrong size on UPalBlueprintLibrary");

// Class Pal.PalBodyPartsBoxComponent
// 0x0010 (0x0590 - 0x0580)
class UPalBodyPartsBoxComponent final : public UBoxComponent
{
public:
	EPalBodyPartsType                             BodyPartsType;                                     // 0x0578(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_296C[0x3];                                     // 0x0579(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DefaultCollisionProfileName;                       // 0x057C(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   BroadcastCollisionProfileName;                     // 0x0584(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_296D[0x4];                                     // 0x058C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_BroadcastCollisionProfileName();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBodyPartsBoxComponent">();
	}
	static class UPalBodyPartsBoxComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBodyPartsBoxComponent>();
	}
};
static_assert(alignof(UPalBodyPartsBoxComponent) == 0x000010, "Wrong alignment on UPalBodyPartsBoxComponent");
static_assert(sizeof(UPalBodyPartsBoxComponent) == 0x000590, "Wrong size on UPalBodyPartsBoxComponent");
static_assert(offsetof(UPalBodyPartsBoxComponent, BodyPartsType) == 0x000578, "Member 'UPalBodyPartsBoxComponent::BodyPartsType' has a wrong offset!");
static_assert(offsetof(UPalBodyPartsBoxComponent, DefaultCollisionProfileName) == 0x00057C, "Member 'UPalBodyPartsBoxComponent::DefaultCollisionProfileName' has a wrong offset!");
static_assert(offsetof(UPalBodyPartsBoxComponent, BroadcastCollisionProfileName) == 0x000584, "Member 'UPalBodyPartsBoxComponent::BroadcastCollisionProfileName' has a wrong offset!");

// Class Pal.PalBodyPartsSphereComponent
// 0x0020 (0x0580 - 0x0560)
class UPalBodyPartsSphereComponent final : public USphereComponent
{
public:
	EPalBodyPartsType                             BodyPartsType;                                     // 0x0560(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_296E[0x3];                                     // 0x0561(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DefaultCollisionProfileName;                       // 0x0564(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   BroadcastCollisionProfileName;                     // 0x056C(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_296F[0xC];                                     // 0x0574(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_BroadcastCollisionProfileName();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBodyPartsSphereComponent">();
	}
	static class UPalBodyPartsSphereComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBodyPartsSphereComponent>();
	}
};
static_assert(alignof(UPalBodyPartsSphereComponent) == 0x000010, "Wrong alignment on UPalBodyPartsSphereComponent");
static_assert(sizeof(UPalBodyPartsSphereComponent) == 0x000580, "Wrong size on UPalBodyPartsSphereComponent");
static_assert(offsetof(UPalBodyPartsSphereComponent, BodyPartsType) == 0x000560, "Member 'UPalBodyPartsSphereComponent::BodyPartsType' has a wrong offset!");
static_assert(offsetof(UPalBodyPartsSphereComponent, DefaultCollisionProfileName) == 0x000564, "Member 'UPalBodyPartsSphereComponent::DefaultCollisionProfileName' has a wrong offset!");
static_assert(offsetof(UPalBodyPartsSphereComponent, BroadcastCollisionProfileName) == 0x00056C, "Member 'UPalBodyPartsSphereComponent::BroadcastCollisionProfileName' has a wrong offset!");

// Class Pal.PalBodyTemperatureComponent
// 0x00B0 (0x0150 - 0x00A0)
class UPalBodyTemperatureComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnChangeTemperatureDelegate;                       // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeResistRankDelegate;                        // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeBodyStateDelegate;                         // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<class FName, struct FPalHeatSourceInfo>  HeatSourceInfoMap;                                 // 0x00D0(0x0050)(NativeAccessSpecifierPrivate)
	class FName                                   SelfKeyName;                                       // 0x0120(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           SlipDamageTimer;                                   // 0x0128(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPalTemperatureInfo                    TemperatureInfo;                                   // 0x0130(0x0010)(Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	struct FPalTemperatureInfo                    TemperatureInfo_Pre_ForClient;                     // 0x0140(0x0010)(Transient, NoDestructor, NativeAccessSpecifierPrivate)

public:
	void AddHeatSource(class FName UniqueName, int32 HeatLevel);
	void AddHeatSourceInfo(class FName UniqueName, const struct FPalHeatSourceInfo& HeatInfo);
	void CallAllDelegate();
	void CallOnChangeBodyState(EPalBodyTemperatureState State);
	void CallOnChangeResistRank(int32 Heat, int32 Cold);
	void CallOnChangeTemperature(int32 Next);
	void OnChangeBodyStateDelegate__DelegateSignature(EPalBodyTemperatureState BodyState);
	void OnChangeHour();
	void OnChangeResistRankDelegate__DelegateSignature(int32 NextResistHeat, int32 NextResistCold);
	void OnChangeTemperatureDelegate__DelegateSignature(int32 NextTemperature);
	void OnEndPassiveSkill(EPalPassiveSkillEffectType EffectType);
	void OnInitializedPlayer(class APalCharacter* Character);
	void OnRep_TemperatureInfo();
	void OnUpdateEquipment(class UPalItemSlot* ItemSlot, EPalPlayerEquipItemSlotType SlotType);
	void OnUpdatePassiveSkill(EPalPassiveSkillEffectType EffectType, float Value);
	void RemoveHeatSource(class FName UniqueName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBodyTemperatureComponent">();
	}
	static class UPalBodyTemperatureComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBodyTemperatureComponent>();
	}
};
static_assert(alignof(UPalBodyTemperatureComponent) == 0x000008, "Wrong alignment on UPalBodyTemperatureComponent");
static_assert(sizeof(UPalBodyTemperatureComponent) == 0x000150, "Wrong size on UPalBodyTemperatureComponent");
static_assert(offsetof(UPalBodyTemperatureComponent, OnChangeTemperatureDelegate) == 0x0000A0, "Member 'UPalBodyTemperatureComponent::OnChangeTemperatureDelegate' has a wrong offset!");
static_assert(offsetof(UPalBodyTemperatureComponent, OnChangeResistRankDelegate) == 0x0000B0, "Member 'UPalBodyTemperatureComponent::OnChangeResistRankDelegate' has a wrong offset!");
static_assert(offsetof(UPalBodyTemperatureComponent, OnChangeBodyStateDelegate) == 0x0000C0, "Member 'UPalBodyTemperatureComponent::OnChangeBodyStateDelegate' has a wrong offset!");
static_assert(offsetof(UPalBodyTemperatureComponent, HeatSourceInfoMap) == 0x0000D0, "Member 'UPalBodyTemperatureComponent::HeatSourceInfoMap' has a wrong offset!");
static_assert(offsetof(UPalBodyTemperatureComponent, SelfKeyName) == 0x000120, "Member 'UPalBodyTemperatureComponent::SelfKeyName' has a wrong offset!");
static_assert(offsetof(UPalBodyTemperatureComponent, SlipDamageTimer) == 0x000128, "Member 'UPalBodyTemperatureComponent::SlipDamageTimer' has a wrong offset!");
static_assert(offsetof(UPalBodyTemperatureComponent, TemperatureInfo) == 0x000130, "Member 'UPalBodyTemperatureComponent::TemperatureInfo' has a wrong offset!");
static_assert(offsetof(UPalBodyTemperatureComponent, TemperatureInfo_Pre_ForClient) == 0x000140, "Member 'UPalBodyTemperatureComponent::TemperatureInfo_Pre_ForClient' has a wrong offset!");

// Class Pal.PalUIDelayGaugeCalculator
// 0x0040 (0x0068 - 0x0028)
class UPalUIDelayGaugeCalculator final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnStartDelayGaugeTimerDelegate;                    // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEndDelayGaugeDelegate;                           // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UProgressBar*                           MainBar;                                           // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UProgressBar*                           SubBar;                                            // 0x0050(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DelayGaugeTimer;                                   // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DelayGaugeStartTime;                               // 0x005C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DelayGaugeProgressPerSecond;                       // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2972[0x4];                                     // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndDelayGaugeDelegate__DelegateSignature();
	void SetPercent(float Percent);
	void SetPercentForce(float Percent);
	void Setup(class UProgressBar* InMainBar, class UProgressBar* InSubBar);
	void StartDelayGaugeTimerDelegate__DelegateSignature();
	void Update(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIDelayGaugeCalculator">();
	}
	static class UPalUIDelayGaugeCalculator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIDelayGaugeCalculator>();
	}
};
static_assert(alignof(UPalUIDelayGaugeCalculator) == 0x000008, "Wrong alignment on UPalUIDelayGaugeCalculator");
static_assert(sizeof(UPalUIDelayGaugeCalculator) == 0x000068, "Wrong size on UPalUIDelayGaugeCalculator");
static_assert(offsetof(UPalUIDelayGaugeCalculator, OnStartDelayGaugeTimerDelegate) == 0x000028, "Member 'UPalUIDelayGaugeCalculator::OnStartDelayGaugeTimerDelegate' has a wrong offset!");
static_assert(offsetof(UPalUIDelayGaugeCalculator, OnEndDelayGaugeDelegate) == 0x000038, "Member 'UPalUIDelayGaugeCalculator::OnEndDelayGaugeDelegate' has a wrong offset!");
static_assert(offsetof(UPalUIDelayGaugeCalculator, MainBar) == 0x000048, "Member 'UPalUIDelayGaugeCalculator::MainBar' has a wrong offset!");
static_assert(offsetof(UPalUIDelayGaugeCalculator, SubBar) == 0x000050, "Member 'UPalUIDelayGaugeCalculator::SubBar' has a wrong offset!");
static_assert(offsetof(UPalUIDelayGaugeCalculator, DelayGaugeTimer) == 0x000058, "Member 'UPalUIDelayGaugeCalculator::DelayGaugeTimer' has a wrong offset!");
static_assert(offsetof(UPalUIDelayGaugeCalculator, DelayGaugeStartTime) == 0x00005C, "Member 'UPalUIDelayGaugeCalculator::DelayGaugeStartTime' has a wrong offset!");
static_assert(offsetof(UPalUIDelayGaugeCalculator, DelayGaugeProgressPerSecond) == 0x000060, "Member 'UPalUIDelayGaugeCalculator::DelayGaugeProgressPerSecond' has a wrong offset!");

// Class Pal.PalBoneInfo
// 0x0008 (0x0030 - 0x0028)
class UPalBoneInfo final : public UObject
{
public:
	float                                         Length;                                            // 0x0028(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x002C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBoneInfo">();
	}
	static class UPalBoneInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBoneInfo>();
	}
};
static_assert(alignof(UPalBoneInfo) == 0x000008, "Wrong alignment on UPalBoneInfo");
static_assert(sizeof(UPalBoneInfo) == 0x000030, "Wrong size on UPalBoneInfo");
static_assert(offsetof(UPalBoneInfo, Length) == 0x000028, "Member 'UPalBoneInfo::Length' has a wrong offset!");
static_assert(offsetof(UPalBoneInfo, Radius) == 0x00002C, "Member 'UPalBoneInfo::Radius' has a wrong offset!");

// Class Pal.PalBossBattleInstanceModel
// 0x02F8 (0x0320 - 0x0028)
class UPalBossBattleInstanceModel final : public UObject
{
public:
	uint8                                         Pad_2973[0x58];                                    // 0x0028(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             FrontWarpPointTransform;                           // 0x0080(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector_NetQuantize                    RepFrontWarpPointtLocation;                        // 0x00E0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2974[0x8];                                     // 0x00F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             TopWarpPointTransform;                             // 0x0100(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             StartPointTransform;                               // 0x0160(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             DeadItemDropTransform;                             // 0x01C0(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPalStageInstanceId                    StageInstanceId;                                   // 0x0220(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPalBossType                                  BossType;                                          // 0x0234(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2975[0x3];                                     // 0x0235(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   IntroCutsceneActor;                                // 0x0238(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnTemplate, Transient, EditConst, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   BossRoomLevelInstanceAsset;                        // 0x0268(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAkAudioEvent>           BGMAudioEvent;                                     // 0x0298(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnTemplate, Transient, EditConst, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Level;                                             // 0x02C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CombatTimeMax;                                     // 0x02CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APalBossBattleLevelInstance*            BossBattleLevelInstance;                           // 0x02D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APalBossTower*                          BossTower;                                         // 0x02D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPalBossBattleState                           BossBattleState;                                   // 0x02E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2976[0x7];                                     // 0x02E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APalPlayerCharacter*>            EntryPlayers;                                      // 0x02E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, RepNotify, Protected, NativeAccessSpecifierProtected)
	TArray<class APalPlayerCharacter*>            WonPlayers;                                        // 0x02F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	struct FDateTime                              CombatTimeLimit;                                   // 0x0308(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalBossBattleSequencer*                LocalBattleSequencer;                              // 0x0310(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataLayerAsset*                        ReservedDataLayerAsset;                            // 0x0318(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnChangeBossBattleStateDelegate__DelegateSignature(EPalBossBattleState Param_BossBattleState);
	void OnChangeCombatTimeLimitDelegate__DelegateSignature(const struct FDateTime& Param_CombatTimeLimit);
	void OnChangeEntryPlayerDelegate__DelegateSignature(const TArray<class APalPlayerCharacter*>& Param_EntryPlayers);
	void OnRep_BossBattleLevelInstance();
	void OnRep_BossBattleState();
	void OnRep_CombatTimeLimit();
	void OnRep_EntryPlayers();
	void OnUpdateBossBattleState();
	void OnUpdateCombatTimeLimit();

	EPalBossBattleState GetBossBattleState() const;
	EPalBossType GetBossType() const;
	int32 GetLevel() const;
	bool IsLevelInstanceLoaded() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBossBattleInstanceModel">();
	}
	static class UPalBossBattleInstanceModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBossBattleInstanceModel>();
	}
};
static_assert(alignof(UPalBossBattleInstanceModel) == 0x000010, "Wrong alignment on UPalBossBattleInstanceModel");
static_assert(sizeof(UPalBossBattleInstanceModel) == 0x000320, "Wrong size on UPalBossBattleInstanceModel");
static_assert(offsetof(UPalBossBattleInstanceModel, FrontWarpPointTransform) == 0x000080, "Member 'UPalBossBattleInstanceModel::FrontWarpPointTransform' has a wrong offset!");
static_assert(offsetof(UPalBossBattleInstanceModel, RepFrontWarpPointtLocation) == 0x0000E0, "Member 'UPalBossBattleInstanceModel::RepFrontWarpPointtLocation' has a wrong offset!");
static_assert(offsetof(UPalBossBattleInstanceModel, TopWarpPointTransform) == 0x000100, "Member 'UPalBossBattleInstanceModel::TopWarpPointTransform' has a wrong offset!");
static_assert(offsetof(UPalBossBattleInstanceModel, StartPointTransform) == 0x000160, "Member 'UPalBossBattleInstanceModel::StartPointTransform' has a wrong offset!");
static_assert(offsetof(UPalBossBattleInstanceModel, DeadItemDropTransform) == 0x0001C0, "Member 'UPalBossBattleInstanceModel::DeadItemDropTransform' has a wrong offset!");
static_assert(offsetof(UPalBossBattleInstanceModel, StageInstanceId) == 0x000220, "Member 'UPalBossBattleInstanceModel::StageInstanceId' has a wrong offset!");
static_assert(offsetof(UPalBossBattleInstanceModel, BossType) == 0x000234, "Member 'UPalBossBattleInstanceModel::BossType' has a wrong offset!");
static_assert(offsetof(UPalBossBattleInstanceModel, IntroCutsceneActor) == 0x000238, "Member 'UPalBossBattleInstanceModel::IntroCutsceneActor' has a wrong offset!");
static_assert(offsetof(UPalBossBattleInstanceModel, BossRoomLevelInstanceAsset) == 0x000268, "Member 'UPalBossBattleInstanceModel::BossRoomLevelInstanceAsset' has a wrong offset!");
static_assert(offsetof(UPalBossBattleInstanceModel, BGMAudioEvent) == 0x000298, "Member 'UPalBossBattleInstanceModel::BGMAudioEvent' has a wrong offset!");
static_assert(offsetof(UPalBossBattleInstanceModel, Level) == 0x0002C8, "Member 'UPalBossBattleInstanceModel::Level' has a wrong offset!");
static_assert(offsetof(UPalBossBattleInstanceModel, CombatTimeMax) == 0x0002CC, "Member 'UPalBossBattleInstanceModel::CombatTimeMax' has a wrong offset!");
static_assert(offsetof(UPalBossBattleInstanceModel, BossBattleLevelInstance) == 0x0002D0, "Member 'UPalBossBattleInstanceModel::BossBattleLevelInstance' has a wrong offset!");
static_assert(offsetof(UPalBossBattleInstanceModel, BossTower) == 0x0002D8, "Member 'UPalBossBattleInstanceModel::BossTower' has a wrong offset!");
static_assert(offsetof(UPalBossBattleInstanceModel, BossBattleState) == 0x0002E0, "Member 'UPalBossBattleInstanceModel::BossBattleState' has a wrong offset!");
static_assert(offsetof(UPalBossBattleInstanceModel, EntryPlayers) == 0x0002E8, "Member 'UPalBossBattleInstanceModel::EntryPlayers' has a wrong offset!");
static_assert(offsetof(UPalBossBattleInstanceModel, WonPlayers) == 0x0002F8, "Member 'UPalBossBattleInstanceModel::WonPlayers' has a wrong offset!");
static_assert(offsetof(UPalBossBattleInstanceModel, CombatTimeLimit) == 0x000308, "Member 'UPalBossBattleInstanceModel::CombatTimeLimit' has a wrong offset!");
static_assert(offsetof(UPalBossBattleInstanceModel, LocalBattleSequencer) == 0x000310, "Member 'UPalBossBattleInstanceModel::LocalBattleSequencer' has a wrong offset!");
static_assert(offsetof(UPalBossBattleInstanceModel, ReservedDataLayerAsset) == 0x000318, "Member 'UPalBossBattleInstanceModel::ReservedDataLayerAsset' has a wrong offset!");

// Class Pal.PalBossBattleLevelInstance
// 0x0018 (0x0338 - 0x0320)
class APalBossBattleLevelInstance final : public ALevelInstance
{
public:
	FMulticastInlineDelegateProperty_             OnBossSpawnedDelegate;                             // 0x0320(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsLoaded;                                         // 0x0330(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2977[0x7];                                     // 0x0331(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BossSpawned(class APalCharacter* SpawnedCharacter);
	void OnBossSpawnedDelegate__DelegateSignature(class APalCharacter* SpawnedCharacter);
	void ResetBossLocation();
	void SpawnBossSpawner(EPalBossType BossType, int32 JoinPlayerNum);

	bool CheckLevelLoaded() const;
	struct FTransform GetPlayerStartTransform() const;
	struct FTransform GetSequencerTransform() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBossBattleLevelInstance">();
	}
	static class APalBossBattleLevelInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalBossBattleLevelInstance>();
	}
};
static_assert(alignof(APalBossBattleLevelInstance) == 0x000008, "Wrong alignment on APalBossBattleLevelInstance");
static_assert(sizeof(APalBossBattleLevelInstance) == 0x000338, "Wrong size on APalBossBattleLevelInstance");
static_assert(offsetof(APalBossBattleLevelInstance, OnBossSpawnedDelegate) == 0x000320, "Member 'APalBossBattleLevelInstance::OnBossSpawnedDelegate' has a wrong offset!");
static_assert(offsetof(APalBossBattleLevelInstance, bIsLoaded) == 0x000330, "Member 'APalBossBattleLevelInstance::bIsLoaded' has a wrong offset!");

// Class Pal.PalDialogParameterBase
// 0x0048 (0x0080 - 0x0038)
class UPalDialogParameterBase : public UPalHUDDispatchParameterBase
{
public:
	EPalDialogType                                DialogType;                                        // 0x0038(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2979[0x7];                                     // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Message;                                           // 0x0040(0x0018)(BlueprintVisible, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	TDelegate<void(bool bResult)>                 Callback;                                          // 0x0058(0x0010)(BlueprintVisible, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(bool bResult, class UPalDialogParameterBase* Parameter)> CallbackWithParameter;                             // 0x0068(0x0010)(BlueprintVisible, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCloseWhenDamaged;                                // 0x0078(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEnableShortcutConfirmInput;                      // 0x0079(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_297A[0x6];                                     // 0x007A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InvokeCallback(const bool bResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalDialogParameterBase">();
	}
	static class UPalDialogParameterBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalDialogParameterBase>();
	}
};
static_assert(alignof(UPalDialogParameterBase) == 0x000008, "Wrong alignment on UPalDialogParameterBase");
static_assert(sizeof(UPalDialogParameterBase) == 0x000080, "Wrong size on UPalDialogParameterBase");
static_assert(offsetof(UPalDialogParameterBase, DialogType) == 0x000038, "Member 'UPalDialogParameterBase::DialogType' has a wrong offset!");
static_assert(offsetof(UPalDialogParameterBase, Message) == 0x000040, "Member 'UPalDialogParameterBase::Message' has a wrong offset!");
static_assert(offsetof(UPalDialogParameterBase, Callback) == 0x000058, "Member 'UPalDialogParameterBase::Callback' has a wrong offset!");
static_assert(offsetof(UPalDialogParameterBase, CallbackWithParameter) == 0x000068, "Member 'UPalDialogParameterBase::CallbackWithParameter' has a wrong offset!");
static_assert(offsetof(UPalDialogParameterBase, IsCloseWhenDamaged) == 0x000078, "Member 'UPalDialogParameterBase::IsCloseWhenDamaged' has a wrong offset!");
static_assert(offsetof(UPalDialogParameterBase, IsEnableShortcutConfirmInput) == 0x000079, "Member 'UPalDialogParameterBase::IsEnableShortcutConfirmInput' has a wrong offset!");

// Class Pal.PalDialogParameterDialog
// 0x0008 (0x0088 - 0x0080)
class UPalDialogParameterDialog : public UPalDialogParameterBase
{
public:
	bool                                          bDefaultNegative;                                  // 0x0080(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_297B[0x7];                                     // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetParameters(const class FText& InMessage, const EPalDialogType InDialogType, const bool bInNegativeDefault);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalDialogParameterDialog">();
	}
	static class UPalDialogParameterDialog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalDialogParameterDialog>();
	}
};
static_assert(alignof(UPalDialogParameterDialog) == 0x000008, "Wrong alignment on UPalDialogParameterDialog");
static_assert(sizeof(UPalDialogParameterDialog) == 0x000088, "Wrong size on UPalDialogParameterDialog");
static_assert(offsetof(UPalDialogParameterDialog, bDefaultNegative) == 0x000080, "Member 'UPalDialogParameterDialog::bDefaultNegative' has a wrong offset!");

// Class Pal.PalDialogParameter_RequestMapObjectDismantle
// 0x0010 (0x0098 - 0x0088)
class UPalDialogParameter_RequestMapObjectDismantle final : public UPalDialogParameterDialog
{
public:
	struct FGuid                                  MapObjectInstanceId;                               // 0x0088(0x0010)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalDialogParameter_RequestMapObjectDismantle">();
	}
	static class UPalDialogParameter_RequestMapObjectDismantle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalDialogParameter_RequestMapObjectDismantle>();
	}
};
static_assert(alignof(UPalDialogParameter_RequestMapObjectDismantle) == 0x000008, "Wrong alignment on UPalDialogParameter_RequestMapObjectDismantle");
static_assert(sizeof(UPalDialogParameter_RequestMapObjectDismantle) == 0x000098, "Wrong size on UPalDialogParameter_RequestMapObjectDismantle");
static_assert(offsetof(UPalDialogParameter_RequestMapObjectDismantle, MapObjectInstanceId) == 0x000088, "Member 'UPalDialogParameter_RequestMapObjectDismantle::MapObjectInstanceId' has a wrong offset!");

// Class Pal.PalBossBattleManager
// 0x01A0 (0x0210 - 0x0070)
class UPalBossBattleManager : public UPalWorldSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnLocalBossBattleSuccessDelegate;                  // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCombatStartUIDelegate;                           // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCombatEndUIAction;                               // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         MAX_TIME_LIMIT;                                    // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PlayerRespawnTimeLimit;                            // 0x00A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BGMFadeDuration;                                   // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_297D[0x4];                                     // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, float>                            MultiPlayerBossHPMap;                              // 0x00B0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSubclassOf<class UPalBossBattleSequencer>    BossBattleSequencerClass;                          // 0x0100(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<EPalBossType, struct FPalBossBattleStaticInfo> BossInfoMap;                                       // 0x0108(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<EPalBossType, class UPalBossBattleInstanceModel*> InstanceModelMap;                                  // 0x0158(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<EPalBossType, class UPalBossBattleSequencer*> BossBattleSequencerMap;                            // 0x01A8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	struct FGuid                                  GroupGuid;                                         // 0x01F8(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPalBossType                                  DisableSkyBossType_LocalPlayer;                    // 0x0208(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_297E[0x7];                                     // 0x0209(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddGroupCharacter(class UPalIndividualCharacterHandle* AddIndividualHandle);
	void BossBattleEntry(EPalBossType BossType, class APalPlayerCharacter* EntryPlayer);
	void BossBattleEntryCancel(EPalBossType BossType, class APalPlayerCharacter* EntryPlayer);
	void BossBattleExit(EPalBossType BossType, class APalPlayerCharacter* ExitPlayer);
	bool CanStartBossBattle(EPalBossType BossType);
	void DisableSkyCreator(bool Disable);
	void EmptyInstanceCleanup();
	float GetBossHPMultiPlayerRate(int32 JoinedPlayerNum);
	bool GetIsServer();
	int32 GetMaxJoinablePlayerNum();
	struct FTransform GetPlayerSpawnTransformForMultiPlayer(int32 Param_Index, const struct FVector& Location, const struct FRotator& Rotate, float Offset);
	struct FPalBossBattleStaticInfo GetStaticInfo(EPalBossType BossType);
	void LoadAsyncBossBattle_ServerInternal(EPalBossType BossType);
	void OnBossBattleCombatStart(EPalBossType BossType);
	void OnCombatEndUIActionDelegate__DelegateSignature(EPalBossBattleCombatResult CombatResult);
	void OnCombatStartUIDelegate__DelegateSignature(class APalBossTower* BossTower);
	void OnLocalPlayerBossBattleSuccessDelegate__DelegateSignature(class APalPlayerCharacter* LocalJoinedPlayer, EPalBossType BossType);
	void UnloadBossBattle_ServerInternal(EPalBossType BossType);
	void UnlockAchievement(EPalBossType BossType);

	float GetBattleTimeLimit() const;
	int32 GetBossAchievementIndex(EPalBossType BossType) const;
	struct FTransform GetTopWarpPointTransform(EPalBossType BossType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBossBattleManager">();
	}
	static class UPalBossBattleManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBossBattleManager>();
	}
};
static_assert(alignof(UPalBossBattleManager) == 0x000008, "Wrong alignment on UPalBossBattleManager");
static_assert(sizeof(UPalBossBattleManager) == 0x000210, "Wrong size on UPalBossBattleManager");
static_assert(offsetof(UPalBossBattleManager, OnLocalBossBattleSuccessDelegate) == 0x000070, "Member 'UPalBossBattleManager::OnLocalBossBattleSuccessDelegate' has a wrong offset!");
static_assert(offsetof(UPalBossBattleManager, OnCombatStartUIDelegate) == 0x000080, "Member 'UPalBossBattleManager::OnCombatStartUIDelegate' has a wrong offset!");
static_assert(offsetof(UPalBossBattleManager, OnCombatEndUIAction) == 0x000090, "Member 'UPalBossBattleManager::OnCombatEndUIAction' has a wrong offset!");
static_assert(offsetof(UPalBossBattleManager, MAX_TIME_LIMIT) == 0x0000A0, "Member 'UPalBossBattleManager::MAX_TIME_LIMIT' has a wrong offset!");
static_assert(offsetof(UPalBossBattleManager, PlayerRespawnTimeLimit) == 0x0000A4, "Member 'UPalBossBattleManager::PlayerRespawnTimeLimit' has a wrong offset!");
static_assert(offsetof(UPalBossBattleManager, BGMFadeDuration) == 0x0000A8, "Member 'UPalBossBattleManager::BGMFadeDuration' has a wrong offset!");
static_assert(offsetof(UPalBossBattleManager, MultiPlayerBossHPMap) == 0x0000B0, "Member 'UPalBossBattleManager::MultiPlayerBossHPMap' has a wrong offset!");
static_assert(offsetof(UPalBossBattleManager, BossBattleSequencerClass) == 0x000100, "Member 'UPalBossBattleManager::BossBattleSequencerClass' has a wrong offset!");
static_assert(offsetof(UPalBossBattleManager, BossInfoMap) == 0x000108, "Member 'UPalBossBattleManager::BossInfoMap' has a wrong offset!");
static_assert(offsetof(UPalBossBattleManager, InstanceModelMap) == 0x000158, "Member 'UPalBossBattleManager::InstanceModelMap' has a wrong offset!");
static_assert(offsetof(UPalBossBattleManager, BossBattleSequencerMap) == 0x0001A8, "Member 'UPalBossBattleManager::BossBattleSequencerMap' has a wrong offset!");
static_assert(offsetof(UPalBossBattleManager, GroupGuid) == 0x0001F8, "Member 'UPalBossBattleManager::GroupGuid' has a wrong offset!");
static_assert(offsetof(UPalBossBattleManager, DisableSkyBossType_LocalPlayer) == 0x000208, "Member 'UPalBossBattleManager::DisableSkyBossType_LocalPlayer' has a wrong offset!");

// Class Pal.BossBattleLevelSequenceRootInterface
// 0x0000 (0x0028 - 0x0028)
class IBossBattleLevelSequenceRootInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BossBattleLevelSequenceRootInterface">();
	}
	static class IBossBattleLevelSequenceRootInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBossBattleLevelSequenceRootInterface>();
	}
};
static_assert(alignof(IBossBattleLevelSequenceRootInterface) == 0x000008, "Wrong alignment on IBossBattleLevelSequenceRootInterface");
static_assert(sizeof(IBossBattleLevelSequenceRootInterface) == 0x000028, "Wrong size on IBossBattleLevelSequenceRootInterface");

// Class Pal.PalBossBattleSequencer
// 0x0100 (0x0128 - 0x0028)
class UPalBossBattleSequencer : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnCombatStartDelegate;                             // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         RemainBattleTimer;                                 // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBattleTimerCountDown;                            // 0x003C(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPalBossBattleCombatResult                    CombatResult;                                      // 0x003D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2988[0x2];                                     // 0x003E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EPalBossBattleSequenceType, TSubclassOf<class UPalBossBattleSequenceBase>> SequenceClassMap;                                  // 0x0040(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<EPalBossBattleSequenceType, class UPalBossBattleSequenceBase*> SequenceMap;                                       // 0x0090(0x0050)(Transient, NativeAccessSpecifierPrivate)
	class UPalBossBattleSequenceBase*             CurrentSequence;                                   // 0x00E0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalBossBattleInstanceModel*            BossBattleInstanceModel;                           // 0x00E8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class APalPlayerCharacter*>            InRoomPlayers;                                     // 0x00F0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class APalPlayerCharacter*>            SequenceEndPlayers;                                // 0x0100(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2989[0x1];                                     // 0x0110(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	EPalBossType                                  SelfBossType;                                      // 0x0111(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_298A[0x6];                                     // 0x0112(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class APalCharacter*                          BossCharacter;                                     // 0x0118(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         PlayingBGMId;                                      // 0x0120(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsClientOnly;                                     // 0x0124(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_298B[0x3];                                     // 0x0125(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BossBattleCombatStart__DelegateSignature(EPalBossType BossType);
	class APalPlayerCharacter* FindFirstCombatTargetForBossAI();
	void ForceRespawnPlayer();
	void FullRecoveryHPAllPlayer();
	TArray<class APalPlayerCharacter*> GetAliveOrDyingPlayers();
	class APalCharacter* GetBossCharacter();
	EPalBossType GetBossType();
	TArray<class APalPlayerCharacter*> GetInRoomPlayers();
	class APalPlayerCharacter* GetJoinedAndServerLocalPlayer();
	class APalPlayerCharacter* GetJoinedLocalPlayer();
	float GetRemainTimeSecond();
	void KillAllPlayer();
	void NoticeClientCombatResult();
	void OnCombatEnd(bool Success);
	void OnCombatFinish(EPalBossBattleCombatResult InCombatResult);
	void OnCompletedEnd(bool Success);
	void OnDyingDeadEndDelegate(class APalPlayerCharacter* PlayerCharacter);
	void OnEndingEnd(bool Success);
	void OnOpeningEnd(bool Success);
	void OnPlayerDeadStopBGM(class APalPlayerCharacter* PlayerCharacter);
	void OnPlayerRespawn(class APalPlayerCharacter* Player);
	void PlayBGM(class UAkAudioEvent* BGMAudioEvent);
	void RemoveDyingStatus();
	void RemovePlayerFromInRoomList(class APalPlayerCharacter* Player);
	void SetAllPlayerMoveDisable(bool Disable);
	void SetBossCharacter(class APalCharacter* BossActor);
	void SetMutekiAllPlayer(bool bIsMuteki);
	void SetPlayerMoveDisable(class APalPlayerCharacter* Player, bool Disable);
	void StopBGM();
	void Tick_ForBP(float DeltaTime);

	class UPalBossBattleInstanceModel* GetBossBattleInstanceModel() const;
	TArray<class APalPlayerCharacter*> GetSequencePlayers() const;
	bool IsAllPlayerDead() const;
	bool IsClientOnly() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBossBattleSequencer">();
	}
	static class UPalBossBattleSequencer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBossBattleSequencer>();
	}
};
static_assert(alignof(UPalBossBattleSequencer) == 0x000008, "Wrong alignment on UPalBossBattleSequencer");
static_assert(sizeof(UPalBossBattleSequencer) == 0x000128, "Wrong size on UPalBossBattleSequencer");
static_assert(offsetof(UPalBossBattleSequencer, OnCombatStartDelegate) == 0x000028, "Member 'UPalBossBattleSequencer::OnCombatStartDelegate' has a wrong offset!");
static_assert(offsetof(UPalBossBattleSequencer, RemainBattleTimer) == 0x000038, "Member 'UPalBossBattleSequencer::RemainBattleTimer' has a wrong offset!");
static_assert(offsetof(UPalBossBattleSequencer, IsBattleTimerCountDown) == 0x00003C, "Member 'UPalBossBattleSequencer::IsBattleTimerCountDown' has a wrong offset!");
static_assert(offsetof(UPalBossBattleSequencer, CombatResult) == 0x00003D, "Member 'UPalBossBattleSequencer::CombatResult' has a wrong offset!");
static_assert(offsetof(UPalBossBattleSequencer, SequenceClassMap) == 0x000040, "Member 'UPalBossBattleSequencer::SequenceClassMap' has a wrong offset!");
static_assert(offsetof(UPalBossBattleSequencer, SequenceMap) == 0x000090, "Member 'UPalBossBattleSequencer::SequenceMap' has a wrong offset!");
static_assert(offsetof(UPalBossBattleSequencer, CurrentSequence) == 0x0000E0, "Member 'UPalBossBattleSequencer::CurrentSequence' has a wrong offset!");
static_assert(offsetof(UPalBossBattleSequencer, BossBattleInstanceModel) == 0x0000E8, "Member 'UPalBossBattleSequencer::BossBattleInstanceModel' has a wrong offset!");
static_assert(offsetof(UPalBossBattleSequencer, InRoomPlayers) == 0x0000F0, "Member 'UPalBossBattleSequencer::InRoomPlayers' has a wrong offset!");
static_assert(offsetof(UPalBossBattleSequencer, SequenceEndPlayers) == 0x000100, "Member 'UPalBossBattleSequencer::SequenceEndPlayers' has a wrong offset!");
static_assert(offsetof(UPalBossBattleSequencer, SelfBossType) == 0x000111, "Member 'UPalBossBattleSequencer::SelfBossType' has a wrong offset!");
static_assert(offsetof(UPalBossBattleSequencer, BossCharacter) == 0x000118, "Member 'UPalBossBattleSequencer::BossCharacter' has a wrong offset!");
static_assert(offsetof(UPalBossBattleSequencer, PlayingBGMId) == 0x000120, "Member 'UPalBossBattleSequencer::PlayingBGMId' has a wrong offset!");
static_assert(offsetof(UPalBossBattleSequencer, bIsClientOnly) == 0x000124, "Member 'UPalBossBattleSequencer::bIsClientOnly' has a wrong offset!");

// Class Pal.PalUIDisplayCharacter
// 0x0010 (0x02A0 - 0x0290)
class APalUIDisplayCharacter : public AActor
{
public:
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x0290(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalSkeletalMeshComponent*              PalSkeletalMeshComponent;                          // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ApplyCharacterMakeInfo(const struct FPalPlayerDataCharacterMakeInfo& MakeInfo);
	void ApplyCharacterMakeInfoFromPlayerData();
	void GetBodyBaseColor(class UPalSkeletalMeshComponent* TargetSkeletalMesh, struct FLinearColor* OutColor);
	void GetBrowBaseColor(class UPalSkeletalMeshComponent* TargetSkeletalMesh, struct FLinearColor* OutColor);
	void GetEyeBaseColor(class UPalSkeletalMeshComponent* TargetSkeletalMesh, struct FLinearColor* OutColor);
	void GetHairBaseColor(class UPalSkeletalMeshComponent* TargetSkeletalMesh, struct FLinearColor* OutColor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIDisplayCharacter">();
	}
	static class APalUIDisplayCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalUIDisplayCharacter>();
	}
};
static_assert(alignof(APalUIDisplayCharacter) == 0x000008, "Wrong alignment on APalUIDisplayCharacter");
static_assert(sizeof(APalUIDisplayCharacter) == 0x0002A0, "Wrong size on APalUIDisplayCharacter");
static_assert(offsetof(APalUIDisplayCharacter, DefaultSceneRoot) == 0x000290, "Member 'APalUIDisplayCharacter::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(APalUIDisplayCharacter, PalSkeletalMeshComponent) == 0x000298, "Member 'APalUIDisplayCharacter::PalSkeletalMeshComponent' has a wrong offset!");

// Class Pal.PalWaitInfoWorldHUDParameter
// 0x0010 (0x0048 - 0x0038)
class UPalWaitInfoWorldHUDParameter final : public UPalHUDDispatchParameterBase
{
public:
	class APalBossTower*                          BossTower;                                         // 0x0038(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsWaiting;                                         // 0x0040(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_298D[0x7];                                     // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWaitInfoWorldHUDParameter">();
	}
	static class UPalWaitInfoWorldHUDParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWaitInfoWorldHUDParameter>();
	}
};
static_assert(alignof(UPalWaitInfoWorldHUDParameter) == 0x000008, "Wrong alignment on UPalWaitInfoWorldHUDParameter");
static_assert(sizeof(UPalWaitInfoWorldHUDParameter) == 0x000048, "Wrong size on UPalWaitInfoWorldHUDParameter");
static_assert(offsetof(UPalWaitInfoWorldHUDParameter, BossTower) == 0x000038, "Member 'UPalWaitInfoWorldHUDParameter::BossTower' has a wrong offset!");
static_assert(offsetof(UPalWaitInfoWorldHUDParameter, IsWaiting) == 0x000040, "Member 'UPalWaitInfoWorldHUDParameter::IsWaiting' has a wrong offset!");

// Class Pal.PalBossTower
// 0x0068 (0x02F8 - 0x0290)
class APalBossTower final : public AActor
{
public:
	uint8                                         Pad_298E[0x8];                                     // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnChangeBossTowerEntryWaitUI;                      // 0x0298(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EPalBossType                                  BossType;                                          // 0x02A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_298F[0x3];                                     // 0x02A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  EntryWaitInfoHUDId;                                // 0x02AC(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2990[0x4];                                     // 0x02BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalBossBattleInstanceModel*            InstanceModel;                                     // 0x02C0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDateTime                              CombatTimeLimit;                                   // 0x02C8(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  LocationInstanceId;                                // 0x02D0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class APalPlayerCharacter*>            InDoorPlayerList;                                  // 0x02E0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           TimerHandle;                                       // 0x02F0(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AddInDoorPlayer(class APalPlayerCharacter* Player);
	void CloseWaitInfo();
	const class FName GetBossBattleRowName();
	TArray<class APalPlayerCharacter*> GetStartablePlayers();
	void OnChangeBossBattleState(EPalBossBattleState NewBossBattleState);
	void OnChangeBossBattleStateBP(EPalBossBattleState NewState);
	void OnChangeBossTowerEntryWaitUI__DelegateSignature(bool bIsCountDown, const struct FDateTime& TimeLimit);
	void OnChangeCombatTimeLimit(const struct FDateTime& NewCombatTimeLimit);
	void OnChangeEntryPlayer(const TArray<class APalPlayerCharacter*>& EntryPlayers);
	void OnRep_InstanceModel();
	void RemoveInDoorPlayer(class APalPlayerCharacter* Player);
	void RequestBossBattleEntry(class APalPlayerCharacter* Player);
	void RequestBossBattleStart(class APalPlayerCharacter* Player);
	void ShowWaitInfo(const struct FVector& TargetLocation, const struct FVector& DisplayOffset, bool IsWaiting);
	bool WriteBossDefeatRecord_ServerInternal(class APalPlayerCharacter* TargetPlayer);

	struct FTransform GetDeadItemDropPoint() const;
	TArray<class APalPlayerCharacter*> GetForceWarpTargets() const;
	struct FTransform GetFrontWarpPoint() const;
	struct FTransform GetTopWarpPoint() const;
	bool IsEntered(class APalPlayerCharacter* Player) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBossTower">();
	}
	static class APalBossTower* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalBossTower>();
	}
};
static_assert(alignof(APalBossTower) == 0x000008, "Wrong alignment on APalBossTower");
static_assert(sizeof(APalBossTower) == 0x0002F8, "Wrong size on APalBossTower");
static_assert(offsetof(APalBossTower, OnChangeBossTowerEntryWaitUI) == 0x000298, "Member 'APalBossTower::OnChangeBossTowerEntryWaitUI' has a wrong offset!");
static_assert(offsetof(APalBossTower, BossType) == 0x0002A8, "Member 'APalBossTower::BossType' has a wrong offset!");
static_assert(offsetof(APalBossTower, EntryWaitInfoHUDId) == 0x0002AC, "Member 'APalBossTower::EntryWaitInfoHUDId' has a wrong offset!");
static_assert(offsetof(APalBossTower, InstanceModel) == 0x0002C0, "Member 'APalBossTower::InstanceModel' has a wrong offset!");
static_assert(offsetof(APalBossTower, CombatTimeLimit) == 0x0002C8, "Member 'APalBossTower::CombatTimeLimit' has a wrong offset!");
static_assert(offsetof(APalBossTower, LocationInstanceId) == 0x0002D0, "Member 'APalBossTower::LocationInstanceId' has a wrong offset!");
static_assert(offsetof(APalBossTower, InDoorPlayerList) == 0x0002E0, "Member 'APalBossTower::InDoorPlayerList' has a wrong offset!");
static_assert(offsetof(APalBossTower, TimerHandle) == 0x0002F0, "Member 'APalBossTower::TimerHandle' has a wrong offset!");

// Class Pal.PalBotBuilderLocationBase
// 0x0008 (0x0298 - 0x0290)
class APalBotBuilderLocationBase final : public AActor
{
public:
	int32                                         BuilderIndex;                                      // 0x0290(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsBuilded;                                        // 0x0294(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2995[0x3];                                     // 0x0295(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBotBuilderLocationBase">();
	}
	static class APalBotBuilderLocationBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalBotBuilderLocationBase>();
	}
};
static_assert(alignof(APalBotBuilderLocationBase) == 0x000008, "Wrong alignment on APalBotBuilderLocationBase");
static_assert(sizeof(APalBotBuilderLocationBase) == 0x000298, "Wrong size on APalBotBuilderLocationBase");
static_assert(offsetof(APalBotBuilderLocationBase, BuilderIndex) == 0x000290, "Member 'APalBotBuilderLocationBase::BuilderIndex' has a wrong offset!");
static_assert(offsetof(APalBotBuilderLocationBase, bIsBuilded) == 0x000294, "Member 'APalBotBuilderLocationBase::bIsBuilded' has a wrong offset!");

// Class Pal.PalBoxSpawnerPlacementTool
// 0x0020 (0x02B0 - 0x0290)
class APalBoxSpawnerPlacementTool final : public AActor
{
public:
	struct FVector                                BoxExtent;                                         // 0x0290(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          BoxComp;                                           // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBoxSpawnerPlacementTool">();
	}
	static class APalBoxSpawnerPlacementTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalBoxSpawnerPlacementTool>();
	}
};
static_assert(alignof(APalBoxSpawnerPlacementTool) == 0x000008, "Wrong alignment on APalBoxSpawnerPlacementTool");
static_assert(sizeof(APalBoxSpawnerPlacementTool) == 0x0002B0, "Wrong size on APalBoxSpawnerPlacementTool");
static_assert(offsetof(APalBoxSpawnerPlacementTool, BoxExtent) == 0x000290, "Member 'APalBoxSpawnerPlacementTool::BoxExtent' has a wrong offset!");
static_assert(offsetof(APalBoxSpawnerPlacementTool, BoxComp) == 0x0002A8, "Member 'APalBoxSpawnerPlacementTool::BoxComp' has a wrong offset!");

// Class Pal.PalItemInventoryBase
// 0x0000 (0x0028 - 0x0028)
class UPalItemInventoryBase : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalItemInventoryBase">();
	}
	static class UPalItemInventoryBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalItemInventoryBase>();
	}
};
static_assert(alignof(UPalItemInventoryBase) == 0x000008, "Wrong alignment on UPalItemInventoryBase");
static_assert(sizeof(UPalItemInventoryBase) == 0x000028, "Wrong size on UPalItemInventoryBase");

// Class Pal.PalPlayerInventory
// 0x0000 (0x0028 - 0x0028)
class UPalPlayerInventory final : public UPalItemInventoryBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalPlayerInventory">();
	}
	static class UPalPlayerInventory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalPlayerInventory>();
	}
};
static_assert(alignof(UPalPlayerInventory) == 0x000008, "Wrong alignment on UPalPlayerInventory");
static_assert(sizeof(UPalPlayerInventory) == 0x000028, "Wrong size on UPalPlayerInventory");

// Class Pal.PalFunnelSkillModule
// 0x0008 (0x0030 - 0x0028)
class UPalFunnelSkillModule : public UObject
{
public:
	class APalFunnelCharacter*                    FunnelCharacter;                                   // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnNotifyFinishSkillAction();
	void OnTick(float DeltaTime);
	void SetCharacter(class APalCharacter* Character);

	class APalCharacter* GetCharacter() const;
	bool ShouldSetSkillAction() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalFunnelSkillModule">();
	}
	static class UPalFunnelSkillModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalFunnelSkillModule>();
	}
};
static_assert(alignof(UPalFunnelSkillModule) == 0x000008, "Wrong alignment on UPalFunnelSkillModule");
static_assert(sizeof(UPalFunnelSkillModule) == 0x000030, "Wrong size on UPalFunnelSkillModule");
static_assert(offsetof(UPalFunnelSkillModule, FunnelCharacter) == 0x000028, "Member 'UPalFunnelSkillModule::FunnelCharacter' has a wrong offset!");

// Class Pal.PalBuilderComponent
// 0x0060 (0x0100 - 0x00A0)
class UPalBuilderComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnUpdatePossessMaterials;                          // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStartBuildingMode_Local;                         // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEndBuildingMode_Local;                           // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         InstallDistanceNormalFromOwner;                    // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InstallableRange;                                  // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraComponent*                       OwnerCamera;                                       // 0x00D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APalBuildObjectInstallChecker*          InstallChecker;                                    // 0x00E0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APalDismantleObjectChecker*             DismantleChecker;                                  // 0x00E8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2996[0x10];                                    // 0x00F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class APalBuildObject* GetDismantleTargetObject();
	void MulticastReturnSelfDelegate__DelegateSignature(class UPalBuilderComponent* Self);
	void OnEnterBaseCamp(class UPalBaseCampModel* BaseCampModel);
	void OnExitBaseCamp(class UPalBaseCampModel* BaseCampModel);
	void ReceiveBuildResult_ToRequestClient(const EPalMapObjectOperationResult Result);
	void RequestBuild_ToServer(const class FName BuildObjectId, const struct FVector& Location, const struct FQuat& Rotation, const TArray<struct FPalNetArchive>& ExtraParameterArchives, const struct FPalBuildRequestDebugParameter& DebugParameter);

	EPalMapObjectOperationResult CanRequestDismantle() const;
	void CollectItemInfoEnableToUseMaterial(const TArray<class FName>& StaticItemIds, TArray<struct FPalStaticItemIdAndNum>* OutItemInfos) const;
	void GetSelectedBuildObjectId(class FName* OutSelectedBuildObjectId) const;
	EPalMapObjectOperationResult IsEnableBuild() const;
	bool IsEnableDismantle() const;
	bool IsExecuting() const;
	bool IsExistsMaterialForBuildObject(const struct FPalBuildObjectData& BuildObjectData) const;
	bool IsInstallAtReticle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBuilderComponent">();
	}
	static class UPalBuilderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBuilderComponent>();
	}
};
static_assert(alignof(UPalBuilderComponent) == 0x000008, "Wrong alignment on UPalBuilderComponent");
static_assert(sizeof(UPalBuilderComponent) == 0x000100, "Wrong size on UPalBuilderComponent");
static_assert(offsetof(UPalBuilderComponent, OnUpdatePossessMaterials) == 0x0000A0, "Member 'UPalBuilderComponent::OnUpdatePossessMaterials' has a wrong offset!");
static_assert(offsetof(UPalBuilderComponent, OnStartBuildingMode_Local) == 0x0000B0, "Member 'UPalBuilderComponent::OnStartBuildingMode_Local' has a wrong offset!");
static_assert(offsetof(UPalBuilderComponent, OnEndBuildingMode_Local) == 0x0000C0, "Member 'UPalBuilderComponent::OnEndBuildingMode_Local' has a wrong offset!");
static_assert(offsetof(UPalBuilderComponent, InstallDistanceNormalFromOwner) == 0x0000D0, "Member 'UPalBuilderComponent::InstallDistanceNormalFromOwner' has a wrong offset!");
static_assert(offsetof(UPalBuilderComponent, InstallableRange) == 0x0000D4, "Member 'UPalBuilderComponent::InstallableRange' has a wrong offset!");
static_assert(offsetof(UPalBuilderComponent, OwnerCamera) == 0x0000D8, "Member 'UPalBuilderComponent::OwnerCamera' has a wrong offset!");
static_assert(offsetof(UPalBuilderComponent, InstallChecker) == 0x0000E0, "Member 'UPalBuilderComponent::InstallChecker' has a wrong offset!");
static_assert(offsetof(UPalBuilderComponent, DismantleChecker) == 0x0000E8, "Member 'UPalBuilderComponent::DismantleChecker' has a wrong offset!");

// Class Pal.PalBuildObjectBaseCampPoint
// 0x0000 (0x0580 - 0x0580)
class APalBuildObjectBaseCampPoint final : public APalBuildObject
{
public:
	struct FTransform GetFastTravelLocalTransform() const;
	struct FTransform GetWorkerSpawnLocalTransform() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBuildObjectBaseCampPoint">();
	}
	static class APalBuildObjectBaseCampPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalBuildObjectBaseCampPoint>();
	}
};
static_assert(alignof(APalBuildObjectBaseCampPoint) == 0x000008, "Wrong alignment on APalBuildObjectBaseCampPoint");
static_assert(sizeof(APalBuildObjectBaseCampPoint) == 0x000580, "Wrong size on APalBuildObjectBaseCampPoint");

// Class Pal.PalPlayerMenuUIManager
// 0x0020 (0x0048 - 0x0028)
class UPalPlayerMenuUIManager final : public UObject
{
public:
	uint8                                         Pad_2999[0x18];                                    // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalPlayerMenuUI*                       PlayerMenuUI;                                      // 0x0040(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SelectItem(const struct FPalItemSlotId& SelectSlot);
	void Test_SetPlayerContainerID(const struct FPalContainerId& ContainerId);
	void ToggleInventoryWindow();

	const struct FPalContainerId Test_GetPlayerContainerID() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalPlayerMenuUIManager">();
	}
	static class UPalPlayerMenuUIManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalPlayerMenuUIManager>();
	}
};
static_assert(alignof(UPalPlayerMenuUIManager) == 0x000008, "Wrong alignment on UPalPlayerMenuUIManager");
static_assert(sizeof(UPalPlayerMenuUIManager) == 0x000048, "Wrong size on UPalPlayerMenuUIManager");
static_assert(offsetof(UPalPlayerMenuUIManager, PlayerMenuUI) == 0x000040, "Member 'UPalPlayerMenuUIManager::PlayerMenuUI' has a wrong offset!");

// Class Pal.PalBuildObjectDataMap
// 0x0068 (0x0090 - 0x0028)
class UPalBuildObjectDataMap final : public UObject
{
public:
	TMap<class FName, struct FPalBuildObjectData> BuildObjectDataIdMap;                              // 0x0028(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_299A[0x18];                                    // 0x0078(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetBuildObjectDataArrayForTypeAByTypeB(const EPalBuildObjectTypeA TypeA, TArray<struct FPalBuildObjectDataSetTypeB>* OutArray) const;
	void GetBuildObjectDataMapForType(const EPalBuildObjectTypeA TypeA, TArray<struct FPalBuildObjectData>* OutArray) const;
	const struct FPalBuildObjectData GetById(const class FName ID) const;
	const struct FPalBuildObjectData GetByMapObjectId(const class FName MapObjectId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBuildObjectDataMap">();
	}
	static class UPalBuildObjectDataMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBuildObjectDataMap>();
	}
};
static_assert(alignof(UPalBuildObjectDataMap) == 0x000008, "Wrong alignment on UPalBuildObjectDataMap");
static_assert(sizeof(UPalBuildObjectDataMap) == 0x000090, "Wrong size on UPalBuildObjectDataMap");
static_assert(offsetof(UPalBuildObjectDataMap, BuildObjectDataIdMap) == 0x000028, "Member 'UPalBuildObjectDataMap::BuildObjectDataIdMap' has a wrong offset!");

// Class Pal.PalCharacter
// 0x02F0 (0x0910 - 0x0620)
#pragma pack(push, 0x1)
class alignas(0x10) APalCharacter : public ACharacter
{
public:
	float                                         UpdateGroundInterval;                              // 0x0618(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_299D[0x4];                                     // 0x061C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalActionComponent*                    ActionComponent;                                   // 0x0620(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalCharacterParameterComponent*        CharacterParameterComponent;                       // 0x0628(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalStaticCharacterParameterComponent*  StaticCharacterParameterComponent;                 // 0x0630(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalDamageReactionComponent*            DamageReactionComponent;                           // 0x0638(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalStatusComponent*                    StatusComponent;                                   // 0x0640(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalShooterSpringArmComponent*          CameraBoom;                                        // 0x0648(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalCharacterCameraComponent*           FollowCamera;                                      // 0x0650(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalLookAtComponent*                    LookAtComponent;                                   // 0x0658(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalNavigationInvokerComponent*         NavInvokerComponent;                               // 0x0660(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalFootIKComponent*                    FootIKComponent;                                   // 0x0668(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalVisualEffectComponent*              VisualEffectComponent;                             // 0x0670(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalPassiveSkillComponent*              PassiveSkillComponent;                             // 0x0678(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalHeadUpDisplayComponent*             HUDComponent;                                      // 0x0680(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalAnimNotifyParameterComponent*       AnimNotifyComponent;                               // 0x0688(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalCharacterAroundInfoCollectorComponent* AroundInfoCollectorComponent;                      // 0x0690(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeActiveActorDelegate;                       // 0x0698(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRollingDelegate;                                 // 0x06A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRollingFinishDelegate;                           // 0x06B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCompleteSyncPlayerFromServer_InClient;           // 0x06C8(0x0010)(Edit, ZeroConstructor, Transient, EditConst, InstancedReference, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeBattleModeDelegate;                        // 0x06D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeImportanceDelegate;                        // 0x06E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCapturedDelegate;                                // 0x06F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsBattleMode;                                     // 0x0708(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsTalkMode;                                       // 0x0709(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsPalActiveActor;                                 // 0x070A(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsLocalInitialized;                               // 0x070B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsDisable_ChangeTickInterval_ByImportance;        // 0x070C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_299E[0x3];                                     // 0x070D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SpawnLocation_ForServer;                           // 0x0710(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFlagContainer                         IsDisableChangeTickInterval;                       // 0x0728(0x0050)(Edit, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPrivate)
	EPalCharacterImportanceType                   ImportanceType;                                    // 0x0778(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_299F[0x7];                                     // 0x0779(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           CheckIndividualParameterReplicateTimerHandle;      // 0x0780(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   RootCollisionProfileName;                          // 0x0788(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29A0[0x8];                                     // 0x0790(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EPalCharacterCompleteDelegatePriority, class UPalCharacterOnCompleteInitializeParameterWrapper*> OnCompleteInitializeParameterDelegateMap;          // 0x0798(0x0050)(Edit, Transient, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29A1[0x120];                                   // 0x07E8(0x0120)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindFonctionToOnCompleteInitializeParameter(EPalCharacterCompleteDelegatePriority Priority, TDelegate<void(class APalCharacter* InCharacter)> Callback);
	void BroadcastOnCompleteInitializeParameter();
	void ChangeBattleModeFlag(bool IsBattle);
	void ChangeBattleModeFlag_ToAll(bool IsBattle);
	void ChangeTalkModeFlag_ToAll(bool IsTalk);
	void ChangeWantFood_ToAll(bool IsWantFood, bool IsExistFood);
	class USkeletalMeshComponent* GetHandAttachMesh();
	class UPalCharacterOnCompleteInitializeParameterWrapper* GetOnCompleteInitializeParameterDelegate(EPalCharacterCompleteDelegatePriority Priority);
	class USkeletalMeshComponent* GetOverrideFaceMesh();
	void GetVisual_ExceptMainMesh_SyncAnyway(TArray<class USceneComponent*>* OutComponent);
	void LocalInitialized();
	void OnCaptured__DelegateSignature(class APalCharacter* SelfCharacter, class APalCharacter* Attacker);
	void OnChangeActiveActor__DelegateSignature(bool bIsActive);
	void OnChangeBattleMode__DelegateSignature(bool Param_bIsBattleMode);
	void OnChangeImportance__DelegateSignature(EPalCharacterImportanceType NextType);
	void OnChangeWetnessStatus(bool IsSwim);
	void OnCompleteInitializeParameter__DelegateSignature(class APalCharacter* InCharacter);
	void OnCompleteSyncPlayerFromServer_InClient__DelegateSignature();
	void OnOverlapBeginByAroundInfo(class AActor* OtherActor);
	void OnOverlapEndByAroundInfo(class AActor* OtherActor);
	void OnRep_IsPalActiveActor(bool PrevIsActiveActor);
	void OnRep_RootCollisionProfileName();
	void OnTeleport_ToClient(const struct FVector& Location, const struct FQuat& Rotation);
	void Play2Montage(class UAnimMontage* FirstMontage, class UAnimMontage* NextMontage);
	void Play2Montage_WithPlayRate(class UAnimMontage* FirstMontage, class UAnimMontage* NextMontage, float PlayRate);
	void RequestJump();
	void ResetTickInterval();
	void ReviveCharacter(const struct FFixedPoint& HP);
	void ReviveCharacter_ToServer(const struct FFixedPoint& HP);
	void RollingDelegate__DelegateSignature();
	void RPCDummy();
	void SetActiveActor(bool Active);
	void SetActiveActorStayVisible(bool Active);
	void SetActiveCollisionMovement(bool Active);
	void SetDisableChangeIntervalByImportance(class FName FlagName, bool IsDisable);
	void SetVisibleCharacterMesh(bool Active);
	void SetVisibleHandAttachMesh(bool Active);
	void UpdateGroundRayCast();

	class UPalActionComponent* GetActionComponent() const;
	bool GetActiveActorFlag() const;
	bool GetBattleMode() const;
	class UPalCharacterParameterComponent* GetCharacterParameterComponent() const;
	class UPalSkeletalMeshComponent* GetMainMesh() const;
	TSoftObjectPtr<class UNiagaraSystem> GetOverrideSleepFX() const;
	class UPalCharacterMovementComponent* GetPalCharacterMovementComponent() const;
	bool GetTalkMode() const;
	bool IsCooping() const;
	bool IsInitialized() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalCharacter">();
	}
	static class APalCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalCharacter>();
	}
};
#pragma pack(pop)
static_assert(alignof(APalCharacter) == 0x000010, "Wrong alignment on APalCharacter");
static_assert(sizeof(APalCharacter) == 0x000910, "Wrong size on APalCharacter");
static_assert(offsetof(APalCharacter, UpdateGroundInterval) == 0x000618, "Member 'APalCharacter::UpdateGroundInterval' has a wrong offset!");
static_assert(offsetof(APalCharacter, ActionComponent) == 0x000620, "Member 'APalCharacter::ActionComponent' has a wrong offset!");
static_assert(offsetof(APalCharacter, CharacterParameterComponent) == 0x000628, "Member 'APalCharacter::CharacterParameterComponent' has a wrong offset!");
static_assert(offsetof(APalCharacter, StaticCharacterParameterComponent) == 0x000630, "Member 'APalCharacter::StaticCharacterParameterComponent' has a wrong offset!");
static_assert(offsetof(APalCharacter, DamageReactionComponent) == 0x000638, "Member 'APalCharacter::DamageReactionComponent' has a wrong offset!");
static_assert(offsetof(APalCharacter, StatusComponent) == 0x000640, "Member 'APalCharacter::StatusComponent' has a wrong offset!");
static_assert(offsetof(APalCharacter, CameraBoom) == 0x000648, "Member 'APalCharacter::CameraBoom' has a wrong offset!");
static_assert(offsetof(APalCharacter, FollowCamera) == 0x000650, "Member 'APalCharacter::FollowCamera' has a wrong offset!");
static_assert(offsetof(APalCharacter, LookAtComponent) == 0x000658, "Member 'APalCharacter::LookAtComponent' has a wrong offset!");
static_assert(offsetof(APalCharacter, NavInvokerComponent) == 0x000660, "Member 'APalCharacter::NavInvokerComponent' has a wrong offset!");
static_assert(offsetof(APalCharacter, FootIKComponent) == 0x000668, "Member 'APalCharacter::FootIKComponent' has a wrong offset!");
static_assert(offsetof(APalCharacter, VisualEffectComponent) == 0x000670, "Member 'APalCharacter::VisualEffectComponent' has a wrong offset!");
static_assert(offsetof(APalCharacter, PassiveSkillComponent) == 0x000678, "Member 'APalCharacter::PassiveSkillComponent' has a wrong offset!");
static_assert(offsetof(APalCharacter, HUDComponent) == 0x000680, "Member 'APalCharacter::HUDComponent' has a wrong offset!");
static_assert(offsetof(APalCharacter, AnimNotifyComponent) == 0x000688, "Member 'APalCharacter::AnimNotifyComponent' has a wrong offset!");
static_assert(offsetof(APalCharacter, AroundInfoCollectorComponent) == 0x000690, "Member 'APalCharacter::AroundInfoCollectorComponent' has a wrong offset!");
static_assert(offsetof(APalCharacter, OnChangeActiveActorDelegate) == 0x000698, "Member 'APalCharacter::OnChangeActiveActorDelegate' has a wrong offset!");
static_assert(offsetof(APalCharacter, OnRollingDelegate) == 0x0006A8, "Member 'APalCharacter::OnRollingDelegate' has a wrong offset!");
static_assert(offsetof(APalCharacter, OnRollingFinishDelegate) == 0x0006B8, "Member 'APalCharacter::OnRollingFinishDelegate' has a wrong offset!");
static_assert(offsetof(APalCharacter, OnCompleteSyncPlayerFromServer_InClient) == 0x0006C8, "Member 'APalCharacter::OnCompleteSyncPlayerFromServer_InClient' has a wrong offset!");
static_assert(offsetof(APalCharacter, OnChangeBattleModeDelegate) == 0x0006D8, "Member 'APalCharacter::OnChangeBattleModeDelegate' has a wrong offset!");
static_assert(offsetof(APalCharacter, OnChangeImportanceDelegate) == 0x0006E8, "Member 'APalCharacter::OnChangeImportanceDelegate' has a wrong offset!");
static_assert(offsetof(APalCharacter, OnCapturedDelegate) == 0x0006F8, "Member 'APalCharacter::OnCapturedDelegate' has a wrong offset!");
static_assert(offsetof(APalCharacter, bIsBattleMode) == 0x000708, "Member 'APalCharacter::bIsBattleMode' has a wrong offset!");
static_assert(offsetof(APalCharacter, bIsTalkMode) == 0x000709, "Member 'APalCharacter::bIsTalkMode' has a wrong offset!");
static_assert(offsetof(APalCharacter, bIsPalActiveActor) == 0x00070A, "Member 'APalCharacter::bIsPalActiveActor' has a wrong offset!");
static_assert(offsetof(APalCharacter, bIsLocalInitialized) == 0x00070B, "Member 'APalCharacter::bIsLocalInitialized' has a wrong offset!");
static_assert(offsetof(APalCharacter, bIsDisable_ChangeTickInterval_ByImportance) == 0x00070C, "Member 'APalCharacter::bIsDisable_ChangeTickInterval_ByImportance' has a wrong offset!");
static_assert(offsetof(APalCharacter, SpawnLocation_ForServer) == 0x000710, "Member 'APalCharacter::SpawnLocation_ForServer' has a wrong offset!");
static_assert(offsetof(APalCharacter, IsDisableChangeTickInterval) == 0x000728, "Member 'APalCharacter::IsDisableChangeTickInterval' has a wrong offset!");
static_assert(offsetof(APalCharacter, ImportanceType) == 0x000778, "Member 'APalCharacter::ImportanceType' has a wrong offset!");
static_assert(offsetof(APalCharacter, CheckIndividualParameterReplicateTimerHandle) == 0x000780, "Member 'APalCharacter::CheckIndividualParameterReplicateTimerHandle' has a wrong offset!");
static_assert(offsetof(APalCharacter, RootCollisionProfileName) == 0x000788, "Member 'APalCharacter::RootCollisionProfileName' has a wrong offset!");
static_assert(offsetof(APalCharacter, OnCompleteInitializeParameterDelegateMap) == 0x000798, "Member 'APalCharacter::OnCompleteInitializeParameterDelegateMap' has a wrong offset!");

// Class Pal.PalFunnelCharacter
// 0x0040 (0x0950 - 0x0910)
class APalFunnelCharacter : public APalCharacter
{
public:
	TSubclassOf<class UPalAIActionFunnelSkillBase> FunnelSkillAIActionClass;                          // 0x0908(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalFunnelSkillModule>      FunnelSkillModuleClass;                            // 0x0910(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPalInstanceID                         OwnerCharacterId;                                  // 0x0918(0x0030)(Net, Transient, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29A7[0x8];                                     // 0x0948(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateSelf();
	void InactivateSelf();
	void OnActive();
	void OnInactive();
	void OnOwnerDead(const struct FPalDeadInfo& DeadInfo);
	void OnRep_OwnerCharacterId();
	void OnSpawned();
	void OnTrainerDead(const struct FPalDeadInfo& DeadInfo);
	void OnTrainerMoveToRespawnLocation(class APalPlayerCharacter* Player, const struct FVector& Location);
	void SetLocationNearTrainer();
	void SetOwnerCharacterId(const struct FPalInstanceID& Param_OwnerCharacterId);

	class FName GetCharacterID() const;
	class APalCharacter* GetOwnerPal() const;
	int32 GetRank() const;
	class APalCharacter* GetTrainer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalFunnelCharacter">();
	}
	static class APalFunnelCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalFunnelCharacter>();
	}
};
static_assert(alignof(APalFunnelCharacter) == 0x000010, "Wrong alignment on APalFunnelCharacter");
static_assert(sizeof(APalFunnelCharacter) == 0x000950, "Wrong size on APalFunnelCharacter");
static_assert(offsetof(APalFunnelCharacter, FunnelSkillAIActionClass) == 0x000908, "Member 'APalFunnelCharacter::FunnelSkillAIActionClass' has a wrong offset!");
static_assert(offsetof(APalFunnelCharacter, FunnelSkillModuleClass) == 0x000910, "Member 'APalFunnelCharacter::FunnelSkillModuleClass' has a wrong offset!");
static_assert(offsetof(APalFunnelCharacter, OwnerCharacterId) == 0x000918, "Member 'APalFunnelCharacter::OwnerCharacterId' has a wrong offset!");

// Class Pal.PalBuildObjectDefenseBase
// 0x0018 (0x0598 - 0x0580)
class APalBuildObjectDefenseBase final : public APalBuildObject
{
public:
	TSubclassOf<class UPalAIActionBaseCampDefenseBase> DefenseAIActionClass;                              // 0x0580(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPalDataTableRowName_ItemData          BulletItemId;                                      // 0x0588(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MagazineSize;                                      // 0x0590(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29A8[0x4];                                     // 0x0594(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBuildObjectDefenseBase">();
	}
	static class APalBuildObjectDefenseBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalBuildObjectDefenseBase>();
	}
};
static_assert(alignof(APalBuildObjectDefenseBase) == 0x000008, "Wrong alignment on APalBuildObjectDefenseBase");
static_assert(sizeof(APalBuildObjectDefenseBase) == 0x000598, "Wrong size on APalBuildObjectDefenseBase");
static_assert(offsetof(APalBuildObjectDefenseBase, DefenseAIActionClass) == 0x000580, "Member 'APalBuildObjectDefenseBase::DefenseAIActionClass' has a wrong offset!");
static_assert(offsetof(APalBuildObjectDefenseBase, BulletItemId) == 0x000588, "Member 'APalBuildObjectDefenseBase::BulletItemId' has a wrong offset!");
static_assert(offsetof(APalBuildObjectDefenseBase, MagazineSize) == 0x000590, "Member 'APalBuildObjectDefenseBase::MagazineSize' has a wrong offset!");

// Class Pal.PalBuildObjectDataUtility
// 0x0000 (0x0028 - 0x0028)
class UPalBuildObjectDataUtility final : public UBlueprintFunctionLibrary
{
public:
	static void MaterialInfos(const struct FPalBuildObjectData& BuildObjectData, TArray<struct FPalItemRecipeMaterialInfo>* Param_MaterialInfos);
	static const EPalBuildObjectTypeA ToBuildObjectTypeA(const int32 Value);
	static const int32 ToInt(const EPalBuildObjectTypeA TypeA);
	static const int32 ToSortPriorityTypeA(const EPalBuildObjectTypeA TypeA);
	static const int32 ToSortPriorityTypeB(const EPalBuildObjectTypeB TypeB);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBuildObjectDataUtility">();
	}
	static class UPalBuildObjectDataUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBuildObjectDataUtility>();
	}
};
static_assert(alignof(UPalBuildObjectDataUtility) == 0x000008, "Wrong alignment on UPalBuildObjectDataUtility");
static_assert(sizeof(UPalBuildObjectDataUtility) == 0x000028, "Wrong size on UPalBuildObjectDataUtility");

// Class Pal.PalPlayerRecordDataUtility
// 0x0000 (0x0028 - 0x0028)
class UPalPlayerRecordDataUtility final : public UBlueprintFunctionLibrary
{
public:
	static bool GetRecordData_Bool(const struct FPalPlayerRecordDataRepInfoArray_BoolVal& RecordData, const class FName Key);
	static int32 GetRecordData_BoolCount(const struct FPalPlayerRecordDataRepInfoArray_BoolVal& RecordData);
	static int32 GetRecordData_BossDefeat(const struct FPalPlayerRecordDataRepInfoArray_BoolVal& RecordData, const EPalBossType Key);
	static int32 GetRecordData_Int(const struct FPalPlayerRecordDataRepInfoArray_IntVal& RecordData, const class FName Key);
	static int32 GetRecordData_TribeIdCount(const struct FPalPlayerRecordDataRepInfoArray_IntVal& RecordData, const EPalTribeID Key);
	static bool GetRecordData_TribeIdFlag(const struct FPalPlayerRecordDataRepInfoArray_BoolVal& RecordData, const EPalTribeID Key);
	static void SetRecordData_Bool_ForServer(const class UObject* WorldContextObject, struct FPalPlayerRecordDataRepInfoArray_BoolVal* RecordData, const class FName Key, const bool bValue);
	static void SetRecordData_BossDefeat_ForServer(const class UObject* WorldContextObject, struct FPalPlayerRecordDataRepInfoArray_BoolVal* RecordData, const EPalBossType Key);
	static void SetRecordData_Int_ForServer(const class UObject* WorldContextObject, struct FPalPlayerRecordDataRepInfoArray_IntVal* RecordData, const class FName Key, const int32 Value);
	static void SetRecordData_TribeIdCount_ForServer(const class UObject* WorldContextObject, struct FPalPlayerRecordDataRepInfoArray_IntVal* RecordData, const EPalTribeID Key, const int32 Value);
	static void SetRecordData_TribeIdFlag_ForServer(const class UObject* WorldContextObject, struct FPalPlayerRecordDataRepInfoArray_BoolVal* RecordData, const EPalTribeID Key);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalPlayerRecordDataUtility">();
	}
	static class UPalPlayerRecordDataUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalPlayerRecordDataUtility>();
	}
};
static_assert(alignof(UPalPlayerRecordDataUtility) == 0x000008, "Wrong alignment on UPalPlayerRecordDataUtility");
static_assert(sizeof(UPalPlayerRecordDataUtility) == 0x000028, "Wrong size on UPalPlayerRecordDataUtility");

// Class Pal.PalDungeonItemSpawnerPoint
// 0x0050 (0x02F8 - 0x02A8)
class APalDungeonItemSpawnerPoint final : public APalLevelObjectActor
{
public:
	EPalDungeonItemSpawnerType                    ItemSpawnerType;                                   // 0x02A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29B8[0x7];                                     // 0x02A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   TreasureBoxSpawnerSoftClass;                       // 0x02B0(0x0030)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29B9[0x18];                                    // 0x02E0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalDungeonItemSpawnerPoint">();
	}
	static class APalDungeonItemSpawnerPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalDungeonItemSpawnerPoint>();
	}
};
static_assert(alignof(APalDungeonItemSpawnerPoint) == 0x000008, "Wrong alignment on APalDungeonItemSpawnerPoint");
static_assert(sizeof(APalDungeonItemSpawnerPoint) == 0x0002F8, "Wrong size on APalDungeonItemSpawnerPoint");
static_assert(offsetof(APalDungeonItemSpawnerPoint, ItemSpawnerType) == 0x0002A8, "Member 'APalDungeonItemSpawnerPoint::ItemSpawnerType' has a wrong offset!");
static_assert(offsetof(APalDungeonItemSpawnerPoint, TreasureBoxSpawnerSoftClass) == 0x0002B0, "Member 'APalDungeonItemSpawnerPoint::TreasureBoxSpawnerSoftClass' has a wrong offset!");

// Class Pal.PalBuildObjectFarmBlockV2
// 0x0028 (0x05A8 - 0x0580)
class APalBuildObjectFarmBlockV2 final : public APalBuildObject
{
public:
	struct FPalDataTableRowName_FarmCropData      CropDataId;                                        // 0x0580(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         GrowupFX;                                          // 0x0588(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APalMapObjectFarmCrop*                  CropActor;                                         // 0x0590(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29BA[0x10];                                    // 0x0598(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnUpdateState_ServerInternal(EPalFarmCropState LastCropState, EPalFarmCropState NextCropState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBuildObjectFarmBlockV2">();
	}
	static class APalBuildObjectFarmBlockV2* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalBuildObjectFarmBlockV2>();
	}
};
static_assert(alignof(APalBuildObjectFarmBlockV2) == 0x000008, "Wrong alignment on APalBuildObjectFarmBlockV2");
static_assert(sizeof(APalBuildObjectFarmBlockV2) == 0x0005A8, "Wrong size on APalBuildObjectFarmBlockV2");
static_assert(offsetof(APalBuildObjectFarmBlockV2, CropDataId) == 0x000580, "Member 'APalBuildObjectFarmBlockV2::CropDataId' has a wrong offset!");
static_assert(offsetof(APalBuildObjectFarmBlockV2, GrowupFX) == 0x000588, "Member 'APalBuildObjectFarmBlockV2::GrowupFX' has a wrong offset!");
static_assert(offsetof(APalBuildObjectFarmBlockV2, CropActor) == 0x000590, "Member 'APalBuildObjectFarmBlockV2::CropActor' has a wrong offset!");

// Class Pal.PalBuildObjectGenerateEnergy
// 0x0010 (0x0590 - 0x0580)
class APalBuildObjectGenerateEnergy final : public APalBuildObject
{
public:
	EPalEnergyType                                GenerateEnergyType;                                // 0x0580(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29BB[0x3];                                     // 0x0581(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GenerateEnergyRateByWorker;                        // 0x0584(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxEnergyStorage;                                  // 0x0588(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29BC[0x4];                                     // 0x058C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastEndGenerate();
	void BroadcastStartGenerate();
	void OnEndGenerate();
	void OnStartGenerate();
	void OnUpdateWorkAssigned_ServerInternal(class UPalWorkBase* Work);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBuildObjectGenerateEnergy">();
	}
	static class APalBuildObjectGenerateEnergy* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalBuildObjectGenerateEnergy>();
	}
};
static_assert(alignof(APalBuildObjectGenerateEnergy) == 0x000008, "Wrong alignment on APalBuildObjectGenerateEnergy");
static_assert(sizeof(APalBuildObjectGenerateEnergy) == 0x000590, "Wrong size on APalBuildObjectGenerateEnergy");
static_assert(offsetof(APalBuildObjectGenerateEnergy, GenerateEnergyType) == 0x000580, "Member 'APalBuildObjectGenerateEnergy::GenerateEnergyType' has a wrong offset!");
static_assert(offsetof(APalBuildObjectGenerateEnergy, GenerateEnergyRateByWorker) == 0x000584, "Member 'APalBuildObjectGenerateEnergy::GenerateEnergyRateByWorker' has a wrong offset!");
static_assert(offsetof(APalBuildObjectGenerateEnergy, MaxEnergyStorage) == 0x000588, "Member 'APalBuildObjectGenerateEnergy::MaxEnergyStorage' has a wrong offset!");

// Class Pal.PalDynamicItemDataBase
// 0x0040 (0x0068 - 0x0028)
class UPalDynamicItemDataBase : public UObject
{
public:
	uint8                                         Pad_29BD[0x18];                                    // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPalDynamicItemId                      ID;                                                // 0x0040(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   StaticId;                                          // 0x0060(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	struct FPalDynamicItemId GetId() const;
	class FName GetStaticId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalDynamicItemDataBase">();
	}
	static class UPalDynamicItemDataBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalDynamicItemDataBase>();
	}
};
static_assert(alignof(UPalDynamicItemDataBase) == 0x000008, "Wrong alignment on UPalDynamicItemDataBase");
static_assert(sizeof(UPalDynamicItemDataBase) == 0x000068, "Wrong size on UPalDynamicItemDataBase");
static_assert(offsetof(UPalDynamicItemDataBase, ID) == 0x000040, "Member 'UPalDynamicItemDataBase::ID' has a wrong offset!");
static_assert(offsetof(UPalDynamicItemDataBase, StaticId) == 0x000060, "Member 'UPalDynamicItemDataBase::StaticId' has a wrong offset!");

// Class Pal.PalDynamicWeaponItemDataBase
// 0x0040 (0x00A8 - 0x0068)
class UPalDynamicWeaponItemDataBase final : public UPalDynamicItemDataBase
{
public:
	uint8                                         Pad_29BE[0x8];                                     // 0x0068(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Durability;                                        // 0x0070(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxDurability;                                     // 0x0074(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OldDurability;                                     // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RemainingBullets;                                  // 0x007C(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           PassiveSkillList;                                  // 0x0080(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29BF[0x18];                                    // 0x0090(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AddPassiveSkill(class FName SkillName);
	bool ChangePassiveSkill(int32 PassiveIndex, class FName SkillName);
	void DeleteAllPassive();
	void OnRep_Durability();
	void SetBulletsNum(int32 bulletsNum);
	void SetDurability(float NewDurability);
	bool UseBullet();
	int32 UseBullets(int32 UseNum);

	float GetDurability() const;
	float GetMaxDurability() const;
	const TArray<class FName> GetPassiveSkillList() const;
	int32 GetRemainingBulletsNum() const;
	bool IsEmptyMagazine() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalDynamicWeaponItemDataBase">();
	}
	static class UPalDynamicWeaponItemDataBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalDynamicWeaponItemDataBase>();
	}
};
static_assert(alignof(UPalDynamicWeaponItemDataBase) == 0x000008, "Wrong alignment on UPalDynamicWeaponItemDataBase");
static_assert(sizeof(UPalDynamicWeaponItemDataBase) == 0x0000A8, "Wrong size on UPalDynamicWeaponItemDataBase");
static_assert(offsetof(UPalDynamicWeaponItemDataBase, Durability) == 0x000070, "Member 'UPalDynamicWeaponItemDataBase::Durability' has a wrong offset!");
static_assert(offsetof(UPalDynamicWeaponItemDataBase, MaxDurability) == 0x000074, "Member 'UPalDynamicWeaponItemDataBase::MaxDurability' has a wrong offset!");
static_assert(offsetof(UPalDynamicWeaponItemDataBase, OldDurability) == 0x000078, "Member 'UPalDynamicWeaponItemDataBase::OldDurability' has a wrong offset!");
static_assert(offsetof(UPalDynamicWeaponItemDataBase, RemainingBullets) == 0x00007C, "Member 'UPalDynamicWeaponItemDataBase::RemainingBullets' has a wrong offset!");
static_assert(offsetof(UPalDynamicWeaponItemDataBase, PassiveSkillList) == 0x000080, "Member 'UPalDynamicWeaponItemDataBase::PassiveSkillList' has a wrong offset!");

// Class Pal.PalBuildObjectInstallChecker
// 0x0028 (0x02B8 - 0x0290)
class APalBuildObjectInstallChecker final : public AActor
{
public:
	class APalBuildObject*                        TargetBuildObject;                                 // 0x0290(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UShapeComponent*                        OverlapCheckComponent;                             // 0x0298(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalBuildObjectOverlapChecker*          OverlapChecker;                                    // 0x02A0(0x0008)(Edit, ZeroConstructor, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalBuildObjectInstallStrategyBase*     InstallStrategy;                                   // 0x02A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29C2[0x8];                                     // 0x02B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBuildObjectInstallChecker">();
	}
	static class APalBuildObjectInstallChecker* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalBuildObjectInstallChecker>();
	}
};
static_assert(alignof(APalBuildObjectInstallChecker) == 0x000008, "Wrong alignment on APalBuildObjectInstallChecker");
static_assert(sizeof(APalBuildObjectInstallChecker) == 0x0002B8, "Wrong size on APalBuildObjectInstallChecker");
static_assert(offsetof(APalBuildObjectInstallChecker, TargetBuildObject) == 0x000290, "Member 'APalBuildObjectInstallChecker::TargetBuildObject' has a wrong offset!");
static_assert(offsetof(APalBuildObjectInstallChecker, OverlapCheckComponent) == 0x000298, "Member 'APalBuildObjectInstallChecker::OverlapCheckComponent' has a wrong offset!");
static_assert(offsetof(APalBuildObjectInstallChecker, OverlapChecker) == 0x0002A0, "Member 'APalBuildObjectInstallChecker::OverlapChecker' has a wrong offset!");
static_assert(offsetof(APalBuildObjectInstallChecker, InstallStrategy) == 0x0002A8, "Member 'APalBuildObjectInstallChecker::InstallStrategy' has a wrong offset!");

// Class Pal.PalPlayerState
// 0x0418 (0x07C0 - 0x03A8)
class APalPlayerState final : public APlayerState
{
public:
	struct FUniqueNetIdRepl                       WinGDKUniqueId;                                    // 0x03A8(0x0030)(Edit, Net, DisableEditOnTemplate, EditConst, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29C3[0x88];                                    // 0x03D8(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnReportCrimeIdsDelegate;                          // 0x0460(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnReleaseWantedDelegate;                           // 0x0470(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStartCrimeDelegate;                              // 0x0480(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEndCrimeDelegate;                                // 0x0490(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCompleteLoadInitWorldPartitionDelegate_InClient; // 0x04A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGuid                                  PlayerUId;                                         // 0x04B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPalInstanceID                         IndividualHandleId;                                // 0x04C0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnTemplate, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                CachedPlayerLocation;                              // 0x04F0(0x0018)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29C4[0x8];                                     // 0x0508(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  CachedPlayerRotation;                              // 0x0510(0x0020)(Edit, Net, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          CachedIsPlayerDead;                                // 0x0530(0x0001)(Edit, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          CachedIsPlayerDying;                               // 0x0531(0x0001)(Edit, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29C5[0x6];                                     // 0x0532(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalPlayerOtomoData*                    OtomoData;                                         // 0x0538(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalPlayerDataCharacterMake*            CharacterMakeData;                                 // 0x0540(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalPlayerInventoryData*                InventoryData;                                     // 0x0548(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalPlayerDataPalStorage*               PalStorage;                                        // 0x0550(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalTechnologyData*                     TechnologyData;                                    // 0x0558(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalPlayerRecordData*                   RecordData;                                        // 0x0560(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSelectedInitMapPoint;                           // 0x0568(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDetectedInValidPlayer;                            // 0x0569(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29C6[0x6];                                     // 0x056A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalPlayerLocalRecordData*              LocalRecordData;                                   // 0x0570(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalWorldMapUIData*                     WorldMapData;                                      // 0x0578(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalQuestManager*                       QuestManager;                                      // 0x0580(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalGroupGuildBase*                     GuildBelongTo;                                     // 0x0588(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29C7[0x20];                                    // 0x0590(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalNetworkPlayerStateComponent*        NetworkComp;                                       // 0x05B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalSyncTeleportComponent*              SyncTeleportComp;                                  // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDateTime                              StartPlayTime;                                     // 0x05C0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsNewCharacter;                                   // 0x05C8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29C8[0x7];                                     // 0x05C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalIndividualCharacterHandle*          TryCreateIndividualHandleTemporarily;              // 0x05D0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  LoginTryingPlayerUId_InServer;                     // 0x05D8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29C9[0x1A];                                    // 0x05E8(0x001A)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsCompleteSyncPlayerFromServer_InClient;          // 0x0602(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29CA[0x5];                                     // 0x0603(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPalPlayerAccountInitData              AcountInitData;                                    // 0x0608(0x00A8)(Transient, NativeAccessSpecifierPrivate)
	TArray<struct FPalLogInfo_DropPal>            DropPalInfo;                                       // 0x06B0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<struct FGuid, struct FTimerHandle>       WaitLoadingWorldPartitionTimerMap;                 // 0x06C0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29CB[0x50];                                    // 0x0710(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ChatCounter;                                       // 0x0760(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29CC[0x5C];                                    // 0x0764(0x005C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddMealLog(const TArray<struct FPalMealLogDisplayData>& DisplayDataArray);
	void CallOrRegisterOnCompleteLoadInitWorldPartition_InClient(TDelegate<void()> Delegate);
	void OnCompleteLoadWorldPartitionDelegate__DelegateSignature();
	void CallOrRegisterOnCompleteSyncPlayerFromServer_InClient(TDelegate<void(class APalPlayerState* PlayerState)> Delegate);
	void ReturnSelfSingleDelegate__DelegateSignature(class APalPlayerState* PlayerState);
	void CapturePalDelegate__DelegateSignature(const struct FPalUIPalCaptureInfo& CaptureInfo);
	void Debug_BotEnterDungeon_ToServer();
	void Debug_BuildDebugBaseCamp_ToServer(class FName CampMode, int32 WorkerCount);
	void Debug_CaptureNewMonster_ToServer(class FName CharacterID);
	void Debug_CaptureNewMonsterByDebugOtomoInfo_ToServer(const struct FPalDebugOtomoPalInfo& Info, bool bRandomPassiveSkill);
	void Debug_DeleteWorldAndShutdownRemoteServer();
	void Debug_DeleteWorldAndShutdownRemoteServer_ToServer();
	void Debug_OnCreatedIndividual(const struct FPalInstanceID& ID);
	void Debug_ReceiveDeletePlayerSelf_ToRequestClient(const bool bResult);
	void Debug_RepairEquipment_ToServer();
	void Debug_RequestAllowBroadcastAIInfoOfCharacter_ToServer(class APalCharacter* TargetCharacter);
	void Debug_RequestCauseServerCrash();
	void Debug_RequestCauseServerCrash_ToServer();
	void Debug_RequestDeletePlayerSelf();
	void Debug_RequestDeletePlayerSelf_ToServer();
	void Debug_RequestShutdownRemoteServer();
	void Debug_RequestShutdownRemoteServer_ToServer();
	void Debug_RequestStartAICheckOfCharacter_ToServer(class APalCharacter* TargetCharacter);
	void Debug_RequestStopAICheckOfCharacter_ToServer(class APalCharacter* TargetCharacter);
	void Debug_SetDestructionByCompleteBuiltFlag_ToServer();
	void Debug_ShutdownToClient();
	void DropOtomoSingle_ToServer(const struct FVector& DropLocation, const struct FPalInstanceID& DropID);
	void EndCrimeDelegate__DelegateSignature(const struct FGuid& CrimeInstanceId);
	bool EnterChat(const class FText& Msg, EPalChatCategory Category);
	void EnterChat_Receive(const struct FPalChatMessage& ChatMessage);
	void FixedCharacterMakeData(const struct FPalPlayerDataCharacterMakeInfo& MakeInfo);
	void FixedCharacterName(const class FString& CharacterName);
	TArray<struct FPalLogInfo_DropPal> GetAndClearLastDropPalInfo();
	struct FPalPlayerInfoForMap GetPlayerInfoForMap();
	void GrantExpForParty(const int32 ExpValue);
	bool IsCompleteLoadInitWorldPartition();
	bool IsSelectedInitMapPoint();
	void LoadTitleLevel(bool bIsSaveSuccess);
	void NotifyClientInitializedEssential_ToServer();
	void NotifyClientInitializeToServer(const struct FUniqueNetIdRepl& ReceiveUniqueId);
	void NotifyCompleteInitSelectMap_ToServer();
	void NotifyDropOtomoInfo(const TArray<struct FPalLogInfo_DropPal>& InDropPalInfo);
	void NotifyFailedJoin_ToClient(const EPalPlayerJoinResult Result);
	void NotifyForceUpdateInventory_ToServer(bool IsOpen);
	void NotifyInvalidPlayer_ToClient();
	void NotifyObtainComplete_ToServer(const struct FPalInstanceID& IndividualId);
	void NotifyOpenClosePalBox_ToServer(bool IsOpen);
	void NotifyRemovedCharacterFromPalBox_ToServer(const struct FPalInstanceID& IndividualId);
	void NotifyRunInitialize_ToClient();
	void NotifyStartInitSelectMap_ToServer();
	void OnCompleteLoadInitWorldPartition_InClient(class APalPlayerState* PlayerState);
	void OnCompleteLoadInitWorldPartitionDelegate__DelegateSignature();
	void OnCompleteSyncAll_InClient(class APalPlayerState* PlayerState);
	void OnCompleteSyncPlayer_InClient(class APalPlayerState* PlayerState);
	void OnCompleteSyncWorld_InClient(class APalPlayerState* PlayerState);
	void OnCreatedGrantedIndividualHandle_ServerInternal(const struct FPalInstanceID& IndividualId);
	void OnCreatePlayerIndividualHandle_InServer(const struct FPalInstanceID& ID);
	void OnNotifiedEnteredStage_ToClient();
	void OnNotifiedReturnToFieldFromStage_ToClient();
	void OnRelicNumAdded(int32 AddNum);
	void OnRep_GuildBelongTo(class UPalGroupGuildBase* OldValue);
	void OnRep_PlayerUId();
	void OnRep_WinGDKUniqueId();
	void OnUpdatePlayerInfoInGuildBelongTo(const class UPalGroupGuildBase* Guild, const struct FGuid& InPlayerUId, const struct FPalGuildPlayerInfo& InPlayerInfo);
	void ReceiveNotifyLoginComplete();
	void RegisterForPalDex_ServerInternal(const struct FPalInstanceID& IndividualId);
	void RegisterForPalDex_ToClient(const struct FPalUIPalCaptureInfo& CaptureInfo);
	void ReleaseWantedDelegate__DelegateSignature(class UPalIndividualCharacterHandle* CriminalHandle);
	void ReportCrimeIdsDelegate__DelegateSignature(class UPalIndividualCharacterHandle* CriminalHandle, const TArray<class FName>& CrimeIds);
	void RequestAccountInitData_ForClient();
	void RequestBotLocation();
	void RequestJoinPlayer_ToServer(const struct FGuid& JoinPlayerUId, const struct FPalPlayerInitializeParameter& InitPlayerParam);
	void RequestObtainLevelObject_ToServer(class APalLevelObjectObtainable* TargetObject);
	void RequestRespawn();
	void RequestSpawnMonsterForPlayer(const class FName& CharacterID, int32 Num, int32 Level);
	void RequestUnlockFastTravelPoint_ToServer(const class FName UnlockFlagKey);
	void ReturnSelfDelegate__DelegateSignature(class APalPlayerState* PlayerState);
	void SendAccountInitData_ForServer(const struct FPalPlayerAccountInitData& AccountInitData);
	void SendDamage_ToServer(class APalCharacter* Target, const struct FPalDamageInfo& Info);
	void SendDeath_ToServer(class APalCharacter* Target);
	void ShowBossDefeatRewardUI(int32 TechPoint);
	void ShowTowerBossDefeatRewardUI();
	void StartCrimeDelegate__DelegateSignature(const struct FGuid& CrimeInstanceId);
	void WaitWorldPartitionDelegate(struct FTimerHandle* OutTimerHandle, TDelegate<void()> Delegate);

	void AddFullInventoryLog_ToClient() const;
	void AddFullPalBoxLog_ToClient() const;
	void AddItemGetLog_ToClient(const struct FPalStaticItemIdAndNum& ItemAndNum) const;
	class UPalPlayerInventoryData* GetInventoryData() const;
	class UPalPlayerLocalRecordData* GetLocalRecordData() const;
	class UPalPlayerDataCharacterMake* GetPalPlayerCharacterMakeData() const;
	class UPalPlayerOtomoData* GetPalPlayerOtomoData() const;
	class UPalPlayerDataPalStorage* GetPalStorage() const;
	class UPalQuestManager* GetQuestManager() const;
	class UPalPlayerRecordData* GetRecordData() const;
	class UPalSyncTeleportComponent* GetSyncTeleportComp() const;
	class UPalTechnologyData* GetTechnologyData() const;
	class UPalWorldMapUIData* GetWorldMapData() const;
	bool IsInStage() const;
	bool IsPlayerCompletelyDead() const;
	bool IsPlayerDead() const;
	bool IsPlayerDying() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalPlayerState">();
	}
	static class APalPlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalPlayerState>();
	}
};
static_assert(alignof(APalPlayerState) == 0x000010, "Wrong alignment on APalPlayerState");
static_assert(sizeof(APalPlayerState) == 0x0007C0, "Wrong size on APalPlayerState");
static_assert(offsetof(APalPlayerState, WinGDKUniqueId) == 0x0003A8, "Member 'APalPlayerState::WinGDKUniqueId' has a wrong offset!");
static_assert(offsetof(APalPlayerState, OnReportCrimeIdsDelegate) == 0x000460, "Member 'APalPlayerState::OnReportCrimeIdsDelegate' has a wrong offset!");
static_assert(offsetof(APalPlayerState, OnReleaseWantedDelegate) == 0x000470, "Member 'APalPlayerState::OnReleaseWantedDelegate' has a wrong offset!");
static_assert(offsetof(APalPlayerState, OnStartCrimeDelegate) == 0x000480, "Member 'APalPlayerState::OnStartCrimeDelegate' has a wrong offset!");
static_assert(offsetof(APalPlayerState, OnEndCrimeDelegate) == 0x000490, "Member 'APalPlayerState::OnEndCrimeDelegate' has a wrong offset!");
static_assert(offsetof(APalPlayerState, OnCompleteLoadInitWorldPartitionDelegate_InClient) == 0x0004A0, "Member 'APalPlayerState::OnCompleteLoadInitWorldPartitionDelegate_InClient' has a wrong offset!");
static_assert(offsetof(APalPlayerState, PlayerUId) == 0x0004B0, "Member 'APalPlayerState::PlayerUId' has a wrong offset!");
static_assert(offsetof(APalPlayerState, IndividualHandleId) == 0x0004C0, "Member 'APalPlayerState::IndividualHandleId' has a wrong offset!");
static_assert(offsetof(APalPlayerState, CachedPlayerLocation) == 0x0004F0, "Member 'APalPlayerState::CachedPlayerLocation' has a wrong offset!");
static_assert(offsetof(APalPlayerState, CachedPlayerRotation) == 0x000510, "Member 'APalPlayerState::CachedPlayerRotation' has a wrong offset!");
static_assert(offsetof(APalPlayerState, CachedIsPlayerDead) == 0x000530, "Member 'APalPlayerState::CachedIsPlayerDead' has a wrong offset!");
static_assert(offsetof(APalPlayerState, CachedIsPlayerDying) == 0x000531, "Member 'APalPlayerState::CachedIsPlayerDying' has a wrong offset!");
static_assert(offsetof(APalPlayerState, OtomoData) == 0x000538, "Member 'APalPlayerState::OtomoData' has a wrong offset!");
static_assert(offsetof(APalPlayerState, CharacterMakeData) == 0x000540, "Member 'APalPlayerState::CharacterMakeData' has a wrong offset!");
static_assert(offsetof(APalPlayerState, InventoryData) == 0x000548, "Member 'APalPlayerState::InventoryData' has a wrong offset!");
static_assert(offsetof(APalPlayerState, PalStorage) == 0x000550, "Member 'APalPlayerState::PalStorage' has a wrong offset!");
static_assert(offsetof(APalPlayerState, TechnologyData) == 0x000558, "Member 'APalPlayerState::TechnologyData' has a wrong offset!");
static_assert(offsetof(APalPlayerState, RecordData) == 0x000560, "Member 'APalPlayerState::RecordData' has a wrong offset!");
static_assert(offsetof(APalPlayerState, bIsSelectedInitMapPoint) == 0x000568, "Member 'APalPlayerState::bIsSelectedInitMapPoint' has a wrong offset!");
static_assert(offsetof(APalPlayerState, bDetectedInValidPlayer) == 0x000569, "Member 'APalPlayerState::bDetectedInValidPlayer' has a wrong offset!");
static_assert(offsetof(APalPlayerState, LocalRecordData) == 0x000570, "Member 'APalPlayerState::LocalRecordData' has a wrong offset!");
static_assert(offsetof(APalPlayerState, WorldMapData) == 0x000578, "Member 'APalPlayerState::WorldMapData' has a wrong offset!");
static_assert(offsetof(APalPlayerState, QuestManager) == 0x000580, "Member 'APalPlayerState::QuestManager' has a wrong offset!");
static_assert(offsetof(APalPlayerState, GuildBelongTo) == 0x000588, "Member 'APalPlayerState::GuildBelongTo' has a wrong offset!");
static_assert(offsetof(APalPlayerState, NetworkComp) == 0x0005B0, "Member 'APalPlayerState::NetworkComp' has a wrong offset!");
static_assert(offsetof(APalPlayerState, SyncTeleportComp) == 0x0005B8, "Member 'APalPlayerState::SyncTeleportComp' has a wrong offset!");
static_assert(offsetof(APalPlayerState, StartPlayTime) == 0x0005C0, "Member 'APalPlayerState::StartPlayTime' has a wrong offset!");
static_assert(offsetof(APalPlayerState, bIsNewCharacter) == 0x0005C8, "Member 'APalPlayerState::bIsNewCharacter' has a wrong offset!");
static_assert(offsetof(APalPlayerState, TryCreateIndividualHandleTemporarily) == 0x0005D0, "Member 'APalPlayerState::TryCreateIndividualHandleTemporarily' has a wrong offset!");
static_assert(offsetof(APalPlayerState, LoginTryingPlayerUId_InServer) == 0x0005D8, "Member 'APalPlayerState::LoginTryingPlayerUId_InServer' has a wrong offset!");
static_assert(offsetof(APalPlayerState, bIsCompleteSyncPlayerFromServer_InClient) == 0x000602, "Member 'APalPlayerState::bIsCompleteSyncPlayerFromServer_InClient' has a wrong offset!");
static_assert(offsetof(APalPlayerState, AcountInitData) == 0x000608, "Member 'APalPlayerState::AcountInitData' has a wrong offset!");
static_assert(offsetof(APalPlayerState, DropPalInfo) == 0x0006B0, "Member 'APalPlayerState::DropPalInfo' has a wrong offset!");
static_assert(offsetof(APalPlayerState, WaitLoadingWorldPartitionTimerMap) == 0x0006C0, "Member 'APalPlayerState::WaitLoadingWorldPartitionTimerMap' has a wrong offset!");
static_assert(offsetof(APalPlayerState, ChatCounter) == 0x000760, "Member 'APalPlayerState::ChatCounter' has a wrong offset!");

// Class Pal.PalBuildObjectInstallStrategyAttachToObjectBase
// 0x0000 (0x0038 - 0x0038)
class UPalBuildObjectInstallStrategyAttachToObjectBase : public UPalBuildObjectInstallStrategyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBuildObjectInstallStrategyAttachToObjectBase">();
	}
	static class UPalBuildObjectInstallStrategyAttachToObjectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBuildObjectInstallStrategyAttachToObjectBase>();
	}
};
static_assert(alignof(UPalBuildObjectInstallStrategyAttachToObjectBase) == 0x000008, "Wrong alignment on UPalBuildObjectInstallStrategyAttachToObjectBase");
static_assert(sizeof(UPalBuildObjectInstallStrategyAttachToObjectBase) == 0x000038, "Wrong size on UPalBuildObjectInstallStrategyAttachToObjectBase");

// Class Pal.PalBuildObjectInstallStrategyAttachToCeil
// 0x0000 (0x0038 - 0x0038)
class UPalBuildObjectInstallStrategyAttachToCeil final : public UPalBuildObjectInstallStrategyAttachToObjectBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBuildObjectInstallStrategyAttachToCeil">();
	}
	static class UPalBuildObjectInstallStrategyAttachToCeil* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBuildObjectInstallStrategyAttachToCeil>();
	}
};
static_assert(alignof(UPalBuildObjectInstallStrategyAttachToCeil) == 0x000008, "Wrong alignment on UPalBuildObjectInstallStrategyAttachToCeil");
static_assert(sizeof(UPalBuildObjectInstallStrategyAttachToCeil) == 0x000038, "Wrong size on UPalBuildObjectInstallStrategyAttachToCeil");

// Class Pal.PalDungeonInstanceModel
// 0x0248 (0x0270 - 0x0028)
#pragma pack(push, 0x1)
class alignas(0x10) UPalDungeonInstanceModel : public UObject
{
public:
	uint8                                         Pad_29CF[0x38];                                    // 0x0028(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnChangeInstanceStatusDelegate;                    // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGuid                                  DungeonInstanceId;                                 // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  MarkerPointId;                                     // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DungeonSpawnAreaId;                                // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DungeonLevelName;                                  // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   OverrideDungeonNameTextId;                         // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector_NetQuantize                    RepFieldWarpPointLocation;                         // 0x00A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             FieldWarpPointTransform;                           // 0x00C0(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             StartPointTransform;                               // 0x0120(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             DeadItemDropTransform;                             // 0x0180(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPalDungeonInstanceBossState                  BossState;                                         // 0x01E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29D0[0x3];                                     // 0x01E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EnemySpawner_Boss_RowName;                         // 0x01E4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29D1[0x4];                                     // 0x01EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   EnemySpawnerClass_Boss;                            // 0x01F0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameDateTime                          DisappearTimeAt;                                   // 0x0220(0x0008)(Edit, Net, DisableEditOnTemplate, Transient, EditConst, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Level;                                             // 0x0228(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPalStageInstanceId                    StageInstanceId;                                   // 0x022C(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FPalMapObjectSaveData>          MapObjectSaveDataArray;                            // 0x0240(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	int32                                         ReservedDataLayerAssetIndex;                       // 0x0250(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29D2[0x4];                                     // 0x0254(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataLayerAsset*                        ReservedDataLayerAsset;                            // 0x0258(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29D3[0x8];                                     // 0x0260(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static float CalcDisappearRemainSeconds(const class UObject* WorldContextObject, const struct FGameDateTime& InDisappearTimeAt);
	static float CalcRemainSecondsBy(const class UObject* WorldContextObject, const struct FGameDateTime& TimeAt);

	void OnCapturedBoss_ServerInternal(class APalCharacter* Character, class APalCharacter* Attacker);
	void OnChangeInstanceStatus();
	void OnDeadBoss_ServerInternal(const struct FPalDeadInfo& DeadInfo);
	void OnRep_BossState();
	void OnRep_DisappearTimeAt();
	void OnSpawnedCharacter_ServerInternal(class UPalIndividualCharacterHandle* IndividualHandle);
	void OnUpdateBossState();
	void ReturnSelfDelegate__DelegateSignature(class UPalDungeonInstanceModel* Self);

	EPalDungeonInstanceBossState GetBossState() const;
	const struct FGameDateTime GetDisappearTimeAt() const;
	class FText GetDungeonNameText() const;
	class FName GetDungeonSpawnAreaId() const;
	int32 GetLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalDungeonInstanceModel">();
	}
	static class UPalDungeonInstanceModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalDungeonInstanceModel>();
	}
};
#pragma pack(pop)
static_assert(alignof(UPalDungeonInstanceModel) == 0x000010, "Wrong alignment on UPalDungeonInstanceModel");
static_assert(sizeof(UPalDungeonInstanceModel) == 0x000270, "Wrong size on UPalDungeonInstanceModel");
static_assert(offsetof(UPalDungeonInstanceModel, OnChangeInstanceStatusDelegate) == 0x000060, "Member 'UPalDungeonInstanceModel::OnChangeInstanceStatusDelegate' has a wrong offset!");
static_assert(offsetof(UPalDungeonInstanceModel, DungeonInstanceId) == 0x000070, "Member 'UPalDungeonInstanceModel::DungeonInstanceId' has a wrong offset!");
static_assert(offsetof(UPalDungeonInstanceModel, MarkerPointId) == 0x000080, "Member 'UPalDungeonInstanceModel::MarkerPointId' has a wrong offset!");
static_assert(offsetof(UPalDungeonInstanceModel, DungeonSpawnAreaId) == 0x000090, "Member 'UPalDungeonInstanceModel::DungeonSpawnAreaId' has a wrong offset!");
static_assert(offsetof(UPalDungeonInstanceModel, DungeonLevelName) == 0x000098, "Member 'UPalDungeonInstanceModel::DungeonLevelName' has a wrong offset!");
static_assert(offsetof(UPalDungeonInstanceModel, OverrideDungeonNameTextId) == 0x0000A0, "Member 'UPalDungeonInstanceModel::OverrideDungeonNameTextId' has a wrong offset!");
static_assert(offsetof(UPalDungeonInstanceModel, RepFieldWarpPointLocation) == 0x0000A8, "Member 'UPalDungeonInstanceModel::RepFieldWarpPointLocation' has a wrong offset!");
static_assert(offsetof(UPalDungeonInstanceModel, FieldWarpPointTransform) == 0x0000C0, "Member 'UPalDungeonInstanceModel::FieldWarpPointTransform' has a wrong offset!");
static_assert(offsetof(UPalDungeonInstanceModel, StartPointTransform) == 0x000120, "Member 'UPalDungeonInstanceModel::StartPointTransform' has a wrong offset!");
static_assert(offsetof(UPalDungeonInstanceModel, DeadItemDropTransform) == 0x000180, "Member 'UPalDungeonInstanceModel::DeadItemDropTransform' has a wrong offset!");
static_assert(offsetof(UPalDungeonInstanceModel, BossState) == 0x0001E0, "Member 'UPalDungeonInstanceModel::BossState' has a wrong offset!");
static_assert(offsetof(UPalDungeonInstanceModel, EnemySpawner_Boss_RowName) == 0x0001E4, "Member 'UPalDungeonInstanceModel::EnemySpawner_Boss_RowName' has a wrong offset!");
static_assert(offsetof(UPalDungeonInstanceModel, EnemySpawnerClass_Boss) == 0x0001F0, "Member 'UPalDungeonInstanceModel::EnemySpawnerClass_Boss' has a wrong offset!");
static_assert(offsetof(UPalDungeonInstanceModel, DisappearTimeAt) == 0x000220, "Member 'UPalDungeonInstanceModel::DisappearTimeAt' has a wrong offset!");
static_assert(offsetof(UPalDungeonInstanceModel, Level) == 0x000228, "Member 'UPalDungeonInstanceModel::Level' has a wrong offset!");
static_assert(offsetof(UPalDungeonInstanceModel, StageInstanceId) == 0x00022C, "Member 'UPalDungeonInstanceModel::StageInstanceId' has a wrong offset!");
static_assert(offsetof(UPalDungeonInstanceModel, MapObjectSaveDataArray) == 0x000240, "Member 'UPalDungeonInstanceModel::MapObjectSaveDataArray' has a wrong offset!");
static_assert(offsetof(UPalDungeonInstanceModel, ReservedDataLayerAssetIndex) == 0x000250, "Member 'UPalDungeonInstanceModel::ReservedDataLayerAssetIndex' has a wrong offset!");
static_assert(offsetof(UPalDungeonInstanceModel, ReservedDataLayerAsset) == 0x000258, "Member 'UPalDungeonInstanceModel::ReservedDataLayerAsset' has a wrong offset!");

// Class Pal.PalDungeonInstanceModelFixedDungeon
// 0x0000 (0x0270 - 0x0270)
class UPalDungeonInstanceModelFixedDungeon final : public UPalDungeonInstanceModel
{
public:
	struct FGameDateTime                          RespawnBossTimeAt;                                 // 0x0268(0x0008)(Edit, Net, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	const struct FGameDateTime GetRespawnBossTimeAt() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalDungeonInstanceModelFixedDungeon">();
	}
	static class UPalDungeonInstanceModelFixedDungeon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalDungeonInstanceModelFixedDungeon>();
	}
};
static_assert(alignof(UPalDungeonInstanceModelFixedDungeon) == 0x000010, "Wrong alignment on UPalDungeonInstanceModelFixedDungeon");
static_assert(sizeof(UPalDungeonInstanceModelFixedDungeon) == 0x000270, "Wrong size on UPalDungeonInstanceModelFixedDungeon");
static_assert(offsetof(UPalDungeonInstanceModelFixedDungeon, RespawnBossTimeAt) == 0x000268, "Member 'UPalDungeonInstanceModelFixedDungeon::RespawnBossTimeAt' has a wrong offset!");

// Class Pal.PalWorldSaveGame
// 0x0400 (0x0428 - 0x0028)
class UPalWorldSaveGame final : public USaveGame
{
public:
	int32                                         Version;                                           // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29D6[0x4];                                     // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              Timestamp;                                         // 0x0030(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPalWorldSaveData                      WorldSaveData;                                     // 0x0038(0x03F0)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorldSaveGame">();
	}
	static class UPalWorldSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWorldSaveGame>();
	}
};
static_assert(alignof(UPalWorldSaveGame) == 0x000008, "Wrong alignment on UPalWorldSaveGame");
static_assert(sizeof(UPalWorldSaveGame) == 0x000428, "Wrong size on UPalWorldSaveGame");
static_assert(offsetof(UPalWorldSaveGame, Version) == 0x000028, "Member 'UPalWorldSaveGame::Version' has a wrong offset!");
static_assert(offsetof(UPalWorldSaveGame, Timestamp) == 0x000030, "Member 'UPalWorldSaveGame::Timestamp' has a wrong offset!");
static_assert(offsetof(UPalWorldSaveGame, WorldSaveData) == 0x000038, "Member 'UPalWorldSaveGame::WorldSaveData' has a wrong offset!");

// Class Pal.PalDynamicObjectBase
// 0x0000 (0x0290 - 0x0290)
class APalDynamicObjectBase final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalDynamicObjectBase">();
	}
	static class APalDynamicObjectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalDynamicObjectBase>();
	}
};
static_assert(alignof(APalDynamicObjectBase) == 0x000008, "Wrong alignment on APalDynamicObjectBase");
static_assert(sizeof(APalDynamicObjectBase) == 0x000290, "Wrong size on APalDynamicObjectBase");

// Class Pal.PalMapObjectModelConnectorAttachToCeil
// 0x0000 (0x0048 - 0x0048)
class UPalMapObjectModelConnectorAttachToCeil final : public UPalMapObjectModelConnectorAttach
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectModelConnectorAttachToCeil">();
	}
	static class UPalMapObjectModelConnectorAttachToCeil* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectModelConnectorAttachToCeil>();
	}
};
static_assert(alignof(UPalMapObjectModelConnectorAttachToCeil) == 0x000008, "Wrong alignment on UPalMapObjectModelConnectorAttachToCeil");
static_assert(sizeof(UPalMapObjectModelConnectorAttachToCeil) == 0x000048, "Wrong size on UPalMapObjectModelConnectorAttachToCeil");

// Class Pal.PalBuildObjectInstallStrategyAttachToWall
// 0x0000 (0x0038 - 0x0038)
class UPalBuildObjectInstallStrategyAttachToWall final : public UPalBuildObjectInstallStrategyAttachToObjectBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBuildObjectInstallStrategyAttachToWall">();
	}
	static class UPalBuildObjectInstallStrategyAttachToWall* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBuildObjectInstallStrategyAttachToWall>();
	}
};
static_assert(alignof(UPalBuildObjectInstallStrategyAttachToWall) == 0x000008, "Wrong alignment on UPalBuildObjectInstallStrategyAttachToWall");
static_assert(sizeof(UPalBuildObjectInstallStrategyAttachToWall) == 0x000038, "Wrong size on UPalBuildObjectInstallStrategyAttachToWall");

// Class Pal.PalGamePlayerDataSaveInterface
// 0x0000 (0x0028 - 0x0028)
class IPalGamePlayerDataSaveInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGamePlayerDataSaveInterface">();
	}
	static class IPalGamePlayerDataSaveInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPalGamePlayerDataSaveInterface>();
	}
};
static_assert(alignof(IPalGamePlayerDataSaveInterface) == 0x000008, "Wrong alignment on IPalGamePlayerDataSaveInterface");
static_assert(sizeof(IPalGamePlayerDataSaveInterface) == 0x000028, "Wrong size on IPalGamePlayerDataSaveInterface");

// Class Pal.PalBuildObjectInstallStrategyFloor
// 0x0018 (0x0050 - 0x0038)
class UPalBuildObjectInstallStrategyFloor final : public UPalBuildObjectInstallStrategyBase
{
public:
	class AActor*                                 HitActorCache;                                     // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APalBuildObject*                        HitBuildObjectCache;                               // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29D7[0x8];                                     // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBuildObjectInstallStrategyFloor">();
	}
	static class UPalBuildObjectInstallStrategyFloor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBuildObjectInstallStrategyFloor>();
	}
};
static_assert(alignof(UPalBuildObjectInstallStrategyFloor) == 0x000008, "Wrong alignment on UPalBuildObjectInstallStrategyFloor");
static_assert(sizeof(UPalBuildObjectInstallStrategyFloor) == 0x000050, "Wrong size on UPalBuildObjectInstallStrategyFloor");
static_assert(offsetof(UPalBuildObjectInstallStrategyFloor, HitActorCache) == 0x000038, "Member 'UPalBuildObjectInstallStrategyFloor::HitActorCache' has a wrong offset!");
static_assert(offsetof(UPalBuildObjectInstallStrategyFloor, HitBuildObjectCache) == 0x000040, "Member 'UPalBuildObjectInstallStrategyFloor::HitBuildObjectCache' has a wrong offset!");

// Class Pal.PalDynamicItemDataManager
// 0x00E8 (0x0110 - 0x0028)
class alignas(0x10) UPalDynamicItemDataManager final : public UObject
{
public:
	uint8                                         Pad_29D8[0x10];                                    // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnCreateItemInServerDelegate;                      // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<struct FPalDynamicItemId, class UPalDynamicItemDataBase*> ItemDynamicDataMap;                                // 0x0048(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	float                                         DisposeReservedDynamicItemRemainingTime;           // 0x0098(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29D9[0x14];                                    // 0x009C(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DynamicItemDisposeReserveCount;                    // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29DA[0x4];                                     // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGuid, struct FPalDynamicItemDisposeWaitNotifyInfo> DisposeDynamicItemIdRequestWaitInfoMap_ServerInternal; // 0x00B8(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29DB[0x8];                                     // 0x0108(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalDynamicItemDataManager">();
	}
	static class UPalDynamicItemDataManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalDynamicItemDataManager>();
	}
};
static_assert(alignof(UPalDynamicItemDataManager) == 0x000010, "Wrong alignment on UPalDynamicItemDataManager");
static_assert(sizeof(UPalDynamicItemDataManager) == 0x000110, "Wrong size on UPalDynamicItemDataManager");
static_assert(offsetof(UPalDynamicItemDataManager, OnCreateItemInServerDelegate) == 0x000038, "Member 'UPalDynamicItemDataManager::OnCreateItemInServerDelegate' has a wrong offset!");
static_assert(offsetof(UPalDynamicItemDataManager, ItemDynamicDataMap) == 0x000048, "Member 'UPalDynamicItemDataManager::ItemDynamicDataMap' has a wrong offset!");
static_assert(offsetof(UPalDynamicItemDataManager, DisposeReservedDynamicItemRemainingTime) == 0x000098, "Member 'UPalDynamicItemDataManager::DisposeReservedDynamicItemRemainingTime' has a wrong offset!");
static_assert(offsetof(UPalDynamicItemDataManager, DynamicItemDisposeReserveCount) == 0x0000B0, "Member 'UPalDynamicItemDataManager::DynamicItemDisposeReserveCount' has a wrong offset!");
static_assert(offsetof(UPalDynamicItemDataManager, DisposeDynamicItemIdRequestWaitInfoMap_ServerInternal) == 0x0000B8, "Member 'UPalDynamicItemDataManager::DisposeDynamicItemIdRequestWaitInfoMap_ServerInternal' has a wrong offset!");

// Class Pal.PalBuildObjectInstallStrategyFoundation
// 0x0018 (0x0050 - 0x0038)
class UPalBuildObjectInstallStrategyFoundation final : public UPalBuildObjectInstallStrategyBase
{
public:
	class AActor*                                 HitActorCache;                                     // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APalBuildObject*                        HitBuildObjectCache;                               // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29DC[0x8];                                     // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBuildObjectInstallStrategyFoundation">();
	}
	static class UPalBuildObjectInstallStrategyFoundation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBuildObjectInstallStrategyFoundation>();
	}
};
static_assert(alignof(UPalBuildObjectInstallStrategyFoundation) == 0x000008, "Wrong alignment on UPalBuildObjectInstallStrategyFoundation");
static_assert(sizeof(UPalBuildObjectInstallStrategyFoundation) == 0x000050, "Wrong size on UPalBuildObjectInstallStrategyFoundation");
static_assert(offsetof(UPalBuildObjectInstallStrategyFoundation, HitActorCache) == 0x000038, "Member 'UPalBuildObjectInstallStrategyFoundation::HitActorCache' has a wrong offset!");
static_assert(offsetof(UPalBuildObjectInstallStrategyFoundation, HitBuildObjectCache) == 0x000040, "Member 'UPalBuildObjectInstallStrategyFoundation::HitBuildObjectCache' has a wrong offset!");

// Class Pal.PalMapObjectModelConnectorFoundation
// 0x0060 (0x00A8 - 0x0048)
class UPalMapObjectModelConnectorFoundation final : public UPalMapObjectModelConnectorBase
{
public:
	struct FPalMapObjectModelConnectInfo          FrontConnectInfo;                                  // 0x0048(0x0018)(Edit, Net, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	struct FPalMapObjectModelConnectInfo          BackConnectInfo;                                   // 0x0060(0x0018)(Edit, Net, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	struct FPalMapObjectModelConnectInfo          LeftConnectInfo;                                   // 0x0078(0x0018)(Edit, Net, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	struct FPalMapObjectModelConnectInfo          RightConnectInfo;                                  // 0x0090(0x0018)(Edit, Net, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectModelConnectorFoundation">();
	}
	static class UPalMapObjectModelConnectorFoundation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectModelConnectorFoundation>();
	}
};
static_assert(alignof(UPalMapObjectModelConnectorFoundation) == 0x000008, "Wrong alignment on UPalMapObjectModelConnectorFoundation");
static_assert(sizeof(UPalMapObjectModelConnectorFoundation) == 0x0000A8, "Wrong size on UPalMapObjectModelConnectorFoundation");
static_assert(offsetof(UPalMapObjectModelConnectorFoundation, FrontConnectInfo) == 0x000048, "Member 'UPalMapObjectModelConnectorFoundation::FrontConnectInfo' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModelConnectorFoundation, BackConnectInfo) == 0x000060, "Member 'UPalMapObjectModelConnectorFoundation::BackConnectInfo' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModelConnectorFoundation, LeftConnectInfo) == 0x000078, "Member 'UPalMapObjectModelConnectorFoundation::LeftConnectInfo' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModelConnectorFoundation, RightConnectInfo) == 0x000090, "Member 'UPalMapObjectModelConnectorFoundation::RightConnectInfo' has a wrong offset!");

// Class Pal.PalSetDefaultsCommandlet
// 0x0000 (0x0080 - 0x0080)
class UPalSetDefaultsCommandlet final : public UCommandlet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalSetDefaultsCommandlet">();
	}
	static class UPalSetDefaultsCommandlet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalSetDefaultsCommandlet>();
	}
};
static_assert(alignof(UPalSetDefaultsCommandlet) == 0x000008, "Wrong alignment on UPalSetDefaultsCommandlet");
static_assert(sizeof(UPalSetDefaultsCommandlet) == 0x000080, "Wrong size on UPalSetDefaultsCommandlet");

// Class Pal.PalEventNotifySystem
// 0x0060 (0x00D0 - 0x0070)
class UPalEventNotifySystem : public UPalWorldSubsystem
{
public:
	TArray<TSubclassOf<class UPalEventNotifyBase>> EventNotifyClassArray;                             // 0x0070(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<TSubclassOf<class UPalEventNotifyBase>, class UPalEventNotifyBase*> EventNotifyMap;                                    // 0x0080(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	class UPalEventNotifyBase* GetEventNotify(TSubclassOf<class UPalEventNotifyBase> Param_Class) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalEventNotifySystem">();
	}
	static class UPalEventNotifySystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalEventNotifySystem>();
	}
};
static_assert(alignof(UPalEventNotifySystem) == 0x000008, "Wrong alignment on UPalEventNotifySystem");
static_assert(sizeof(UPalEventNotifySystem) == 0x0000D0, "Wrong size on UPalEventNotifySystem");
static_assert(offsetof(UPalEventNotifySystem, EventNotifyClassArray) == 0x000070, "Member 'UPalEventNotifySystem::EventNotifyClassArray' has a wrong offset!");
static_assert(offsetof(UPalEventNotifySystem, EventNotifyMap) == 0x000080, "Member 'UPalEventNotifySystem::EventNotifyMap' has a wrong offset!");

// Class Pal.PalBuildObjectInstallStrategyGroundWall
// 0x0030 (0x0068 - 0x0038)
class UPalBuildObjectInstallStrategyGroundWall final : public UPalBuildObjectInstallStrategyBase
{
public:
	class AActor*                                 HitActorCache;                                     // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APalBuildObject*                        HitBuildObjectCache;                               // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29DD[0x20];                                    // 0x0048(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBuildObjectInstallStrategyGroundWall">();
	}
	static class UPalBuildObjectInstallStrategyGroundWall* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBuildObjectInstallStrategyGroundWall>();
	}
};
static_assert(alignof(UPalBuildObjectInstallStrategyGroundWall) == 0x000008, "Wrong alignment on UPalBuildObjectInstallStrategyGroundWall");
static_assert(sizeof(UPalBuildObjectInstallStrategyGroundWall) == 0x000068, "Wrong size on UPalBuildObjectInstallStrategyGroundWall");
static_assert(offsetof(UPalBuildObjectInstallStrategyGroundWall, HitActorCache) == 0x000038, "Member 'UPalBuildObjectInstallStrategyGroundWall::HitActorCache' has a wrong offset!");
static_assert(offsetof(UPalBuildObjectInstallStrategyGroundWall, HitBuildObjectCache) == 0x000040, "Member 'UPalBuildObjectInstallStrategyGroundWall::HitBuildObjectCache' has a wrong offset!");

// Class Pal.PalBuildObjectInstallStrategyNormal
// 0x0000 (0x0038 - 0x0038)
class UPalBuildObjectInstallStrategyNormal final : public UPalBuildObjectInstallStrategyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBuildObjectInstallStrategyNormal">();
	}
	static class UPalBuildObjectInstallStrategyNormal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBuildObjectInstallStrategyNormal>();
	}
};
static_assert(alignof(UPalBuildObjectInstallStrategyNormal) == 0x000008, "Wrong alignment on UPalBuildObjectInstallStrategyNormal");
static_assert(sizeof(UPalBuildObjectInstallStrategyNormal) == 0x000038, "Wrong size on UPalBuildObjectInstallStrategyNormal");

// Class Pal.PalFadeWidgetBase
// 0x0000 (0x0408 - 0x0408)
class UPalFadeWidgetBase : public UPalUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalFadeWidgetBase">();
	}
	static class UPalFadeWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalFadeWidgetBase>();
	}
};
static_assert(alignof(UPalFadeWidgetBase) == 0x000008, "Wrong alignment on UPalFadeWidgetBase");
static_assert(sizeof(UPalFadeWidgetBase) == 0x000408, "Wrong size on UPalFadeWidgetBase");

// Class Pal.PalBuildObjectInstallStrategyPalStorage
// 0x0008 (0x0040 - 0x0038)
class UPalBuildObjectInstallStrategyPalStorage final : public UPalBuildObjectInstallStrategySinkableNormal
{
public:
	class APalBuildObjectPalStorage*              TargetPalStorageCache;                             // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBuildObjectInstallStrategyPalStorage">();
	}
	static class UPalBuildObjectInstallStrategyPalStorage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBuildObjectInstallStrategyPalStorage>();
	}
};
static_assert(alignof(UPalBuildObjectInstallStrategyPalStorage) == 0x000008, "Wrong alignment on UPalBuildObjectInstallStrategyPalStorage");
static_assert(sizeof(UPalBuildObjectInstallStrategyPalStorage) == 0x000040, "Wrong size on UPalBuildObjectInstallStrategyPalStorage");
static_assert(offsetof(UPalBuildObjectInstallStrategyPalStorage, TargetPalStorageCache) == 0x000038, "Member 'UPalBuildObjectInstallStrategyPalStorage::TargetPalStorageCache' has a wrong offset!");

// Class Pal.PalBuildObjectInstallStrategyRoof
// 0x0018 (0x0050 - 0x0038)
class UPalBuildObjectInstallStrategyRoof final : public UPalBuildObjectInstallStrategyBase
{
public:
	class AActor*                                 HitActorCache;                                     // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APalBuildObject*                        HitBuildObjectCache;                               // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29DE[0x8];                                     // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBuildObjectInstallStrategyRoof">();
	}
	static class UPalBuildObjectInstallStrategyRoof* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBuildObjectInstallStrategyRoof>();
	}
};
static_assert(alignof(UPalBuildObjectInstallStrategyRoof) == 0x000008, "Wrong alignment on UPalBuildObjectInstallStrategyRoof");
static_assert(sizeof(UPalBuildObjectInstallStrategyRoof) == 0x000050, "Wrong size on UPalBuildObjectInstallStrategyRoof");
static_assert(offsetof(UPalBuildObjectInstallStrategyRoof, HitActorCache) == 0x000038, "Member 'UPalBuildObjectInstallStrategyRoof::HitActorCache' has a wrong offset!");
static_assert(offsetof(UPalBuildObjectInstallStrategyRoof, HitBuildObjectCache) == 0x000040, "Member 'UPalBuildObjectInstallStrategyRoof::HitBuildObjectCache' has a wrong offset!");

// Class Pal.PalEventNotify_Character
// 0x0020 (0x0048 - 0x0028)
class UPalEventNotify_Character final : public UPalEventNotifyBase
{
public:
	FMulticastInlineDelegateProperty_             OnNotifyEventDamagedInServer;                      // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNotifyEventDeadInServer;                         // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UPalEventNotify_Character* GetEventNotify_Character(const class UObject* WorldContextObject);

	void OnCharacterDamaged_ServerInternal(const struct FPalDamageResult& DamageResult);
	void OnCharacterDead_ServerInternal(const struct FPalDeadInfo& DeadInfo);
	void OnCharacterSpawned_ServerInternal(class UPalIndividualCharacterHandle* CharacterHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalEventNotify_Character">();
	}
	static class UPalEventNotify_Character* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalEventNotify_Character>();
	}
};
static_assert(alignof(UPalEventNotify_Character) == 0x000008, "Wrong alignment on UPalEventNotify_Character");
static_assert(sizeof(UPalEventNotify_Character) == 0x000048, "Wrong size on UPalEventNotify_Character");
static_assert(offsetof(UPalEventNotify_Character, OnNotifyEventDamagedInServer) == 0x000028, "Member 'UPalEventNotify_Character::OnNotifyEventDamagedInServer' has a wrong offset!");
static_assert(offsetof(UPalEventNotify_Character, OnNotifyEventDeadInServer) == 0x000038, "Member 'UPalEventNotify_Character::OnNotifyEventDeadInServer' has a wrong offset!");

// Class Pal.PalMapObjectModelConnectorRoof
// 0x0060 (0x00A8 - 0x0048)
class UPalMapObjectModelConnectorRoof final : public UPalMapObjectModelConnectorBase
{
public:
	struct FPalMapObjectModelConnectInfo          FrontConnectInfo;                                  // 0x0048(0x0018)(Edit, Net, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	struct FPalMapObjectModelConnectInfo          BackConnectInfo;                                   // 0x0060(0x0018)(Edit, Net, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	struct FPalMapObjectModelConnectInfo          LeftConnectInfo;                                   // 0x0078(0x0018)(Edit, Net, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	struct FPalMapObjectModelConnectInfo          RightConnectInfo;                                  // 0x0090(0x0018)(Edit, Net, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectModelConnectorRoof">();
	}
	static class UPalMapObjectModelConnectorRoof* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectModelConnectorRoof>();
	}
};
static_assert(alignof(UPalMapObjectModelConnectorRoof) == 0x000008, "Wrong alignment on UPalMapObjectModelConnectorRoof");
static_assert(sizeof(UPalMapObjectModelConnectorRoof) == 0x0000A8, "Wrong size on UPalMapObjectModelConnectorRoof");
static_assert(offsetof(UPalMapObjectModelConnectorRoof, FrontConnectInfo) == 0x000048, "Member 'UPalMapObjectModelConnectorRoof::FrontConnectInfo' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModelConnectorRoof, BackConnectInfo) == 0x000060, "Member 'UPalMapObjectModelConnectorRoof::BackConnectInfo' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModelConnectorRoof, LeftConnectInfo) == 0x000078, "Member 'UPalMapObjectModelConnectorRoof::LeftConnectInfo' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModelConnectorRoof, RightConnectInfo) == 0x000090, "Member 'UPalMapObjectModelConnectorRoof::RightConnectInfo' has a wrong offset!");

// Class Pal.PalBuildObjectInstallStrategyStairs
// 0x0018 (0x0050 - 0x0038)
class UPalBuildObjectInstallStrategyStairs final : public UPalBuildObjectInstallStrategyBase
{
public:
	class AActor*                                 HitActorCache;                                     // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APalBuildObject*                        HitBuildObjectCache;                               // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29DF[0x8];                                     // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBuildObjectInstallStrategyStairs">();
	}
	static class UPalBuildObjectInstallStrategyStairs* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBuildObjectInstallStrategyStairs>();
	}
};
static_assert(alignof(UPalBuildObjectInstallStrategyStairs) == 0x000008, "Wrong alignment on UPalBuildObjectInstallStrategyStairs");
static_assert(sizeof(UPalBuildObjectInstallStrategyStairs) == 0x000050, "Wrong size on UPalBuildObjectInstallStrategyStairs");
static_assert(offsetof(UPalBuildObjectInstallStrategyStairs, HitActorCache) == 0x000038, "Member 'UPalBuildObjectInstallStrategyStairs::HitActorCache' has a wrong offset!");
static_assert(offsetof(UPalBuildObjectInstallStrategyStairs, HitBuildObjectCache) == 0x000040, "Member 'UPalBuildObjectInstallStrategyStairs::HitBuildObjectCache' has a wrong offset!");

// Class Pal.PalEnemyVirtualCommander
// 0x0000 (0x0290 - 0x0290)
class APalEnemyVirtualCommander final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalEnemyVirtualCommander">();
	}
	static class APalEnemyVirtualCommander* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalEnemyVirtualCommander>();
	}
};
static_assert(alignof(APalEnemyVirtualCommander) == 0x000008, "Wrong alignment on APalEnemyVirtualCommander");
static_assert(sizeof(APalEnemyVirtualCommander) == 0x000290, "Wrong size on APalEnemyVirtualCommander");

// Class Pal.PalMapObjectModelConnectorStair
// 0x0030 (0x0078 - 0x0048)
class UPalMapObjectModelConnectorStair final : public UPalMapObjectModelConnectorBase
{
public:
	struct FPalMapObjectModelConnectInfo          UpConnectInfo;                                     // 0x0048(0x0018)(Edit, Net, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	struct FPalMapObjectModelConnectInfo          DownConnectInfo;                                   // 0x0060(0x0018)(Edit, Net, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectModelConnectorStair">();
	}
	static class UPalMapObjectModelConnectorStair* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectModelConnectorStair>();
	}
};
static_assert(alignof(UPalMapObjectModelConnectorStair) == 0x000008, "Wrong alignment on UPalMapObjectModelConnectorStair");
static_assert(sizeof(UPalMapObjectModelConnectorStair) == 0x000078, "Wrong size on UPalMapObjectModelConnectorStair");
static_assert(offsetof(UPalMapObjectModelConnectorStair, UpConnectInfo) == 0x000048, "Member 'UPalMapObjectModelConnectorStair::UpConnectInfo' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModelConnectorStair, DownConnectInfo) == 0x000060, "Member 'UPalMapObjectModelConnectorStair::DownConnectInfo' has a wrong offset!");

// Class Pal.PalBuildObjectInstallStrategyWall
// 0x0030 (0x0068 - 0x0038)
class UPalBuildObjectInstallStrategyWall final : public UPalBuildObjectInstallStrategyBase
{
public:
	class AActor*                                 HitActorCache;                                     // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APalBuildObject*                        HitBuildObjectCache;                               // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29E0[0x20];                                    // 0x0048(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBuildObjectInstallStrategyWall">();
	}
	static class UPalBuildObjectInstallStrategyWall* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBuildObjectInstallStrategyWall>();
	}
};
static_assert(alignof(UPalBuildObjectInstallStrategyWall) == 0x000008, "Wrong alignment on UPalBuildObjectInstallStrategyWall");
static_assert(sizeof(UPalBuildObjectInstallStrategyWall) == 0x000068, "Wrong size on UPalBuildObjectInstallStrategyWall");
static_assert(offsetof(UPalBuildObjectInstallStrategyWall, HitActorCache) == 0x000038, "Member 'UPalBuildObjectInstallStrategyWall::HitActorCache' has a wrong offset!");
static_assert(offsetof(UPalBuildObjectInstallStrategyWall, HitBuildObjectCache) == 0x000040, "Member 'UPalBuildObjectInstallStrategyWall::HitBuildObjectCache' has a wrong offset!");

// Class Pal.PalQuestBlock_CountWorker
// 0x0010 (0x0060 - 0x0050)
class UPalQuestBlock_CountWorker final : public UPalQuestBlock
{
public:
	int32                                         RequireWorkerCount;                                // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NowWorkerCount;                                    // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           CheckTimerHandle;                                  // 0x0058(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnTimer_CheckBaseCampWorker();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalQuestBlock_CountWorker">();
	}
	static class UPalQuestBlock_CountWorker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalQuestBlock_CountWorker>();
	}
};
static_assert(alignof(UPalQuestBlock_CountWorker) == 0x000008, "Wrong alignment on UPalQuestBlock_CountWorker");
static_assert(sizeof(UPalQuestBlock_CountWorker) == 0x000060, "Wrong size on UPalQuestBlock_CountWorker");
static_assert(offsetof(UPalQuestBlock_CountWorker, RequireWorkerCount) == 0x000050, "Member 'UPalQuestBlock_CountWorker::RequireWorkerCount' has a wrong offset!");
static_assert(offsetof(UPalQuestBlock_CountWorker, NowWorkerCount) == 0x000054, "Member 'UPalQuestBlock_CountWorker::NowWorkerCount' has a wrong offset!");
static_assert(offsetof(UPalQuestBlock_CountWorker, CheckTimerHandle) == 0x000058, "Member 'UPalQuestBlock_CountWorker::CheckTimerHandle' has a wrong offset!");

// Class Pal.PalUIBuildingModel
// 0x0008 (0x0030 - 0x0028)
class UPalUIBuildingModel final : public UObject
{
public:
	class FName                                   BuildObjectId;                                     // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BuildObject(const bool bContinuously);
	void ChangeMode(const bool bOn);
	void Dispose();
	void FinishBuilding();
	bool IsExistBaseCamp();
	void OnUpdateInventory(class UPalItemContainer* Container);
	void RotateTarget(const bool bRight);
	void Setup(const class FName InBuildObjectId);

	bool IsOutsideBaseCamp() const;
	bool ShouldDisplayChangeBuildingModeGuide() const;
	bool ShouldDisplayWarningForBuildObject() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIBuildingModel">();
	}
	static class UPalUIBuildingModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIBuildingModel>();
	}
};
static_assert(alignof(UPalUIBuildingModel) == 0x000008, "Wrong alignment on UPalUIBuildingModel");
static_assert(sizeof(UPalUIBuildingModel) == 0x000030, "Wrong size on UPalUIBuildingModel");
static_assert(offsetof(UPalUIBuildingModel, BuildObjectId) == 0x000028, "Member 'UPalUIBuildingModel::BuildObjectId' has a wrong offset!");

// Class Pal.PalBuildObjectInstallStrategyWallV2
// 0x0030 (0x0068 - 0x0038)
class UPalBuildObjectInstallStrategyWallV2 final : public UPalBuildObjectInstallStrategyBase
{
public:
	class AActor*                                 HitActorCache;                                     // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APalBuildObject*                        HitBuildObjectCache;                               // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29E1[0x20];                                    // 0x0048(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBuildObjectInstallStrategyWallV2">();
	}
	static class UPalBuildObjectInstallStrategyWallV2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBuildObjectInstallStrategyWallV2>();
	}
};
static_assert(alignof(UPalBuildObjectInstallStrategyWallV2) == 0x000008, "Wrong alignment on UPalBuildObjectInstallStrategyWallV2");
static_assert(sizeof(UPalBuildObjectInstallStrategyWallV2) == 0x000068, "Wrong size on UPalBuildObjectInstallStrategyWallV2");
static_assert(offsetof(UPalBuildObjectInstallStrategyWallV2, HitActorCache) == 0x000038, "Member 'UPalBuildObjectInstallStrategyWallV2::HitActorCache' has a wrong offset!");
static_assert(offsetof(UPalBuildObjectInstallStrategyWallV2, HitBuildObjectCache) == 0x000040, "Member 'UPalBuildObjectInstallStrategyWallV2::HitBuildObjectCache' has a wrong offset!");

// Class Pal.PalMapObjectModelConnectorWallV2
// 0x0030 (0x0078 - 0x0048)
class UPalMapObjectModelConnectorWallV2 final : public UPalMapObjectModelConnectorBase
{
public:
	struct FPalMapObjectModelConnectInfo          UpConnectInfo;                                     // 0x0048(0x0018)(Edit, Net, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	struct FPalMapObjectModelConnectInfo          DownConnectInfo;                                   // 0x0060(0x0018)(Edit, Net, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectModelConnectorWallV2">();
	}
	static class UPalMapObjectModelConnectorWallV2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectModelConnectorWallV2>();
	}
};
static_assert(alignof(UPalMapObjectModelConnectorWallV2) == 0x000008, "Wrong alignment on UPalMapObjectModelConnectorWallV2");
static_assert(sizeof(UPalMapObjectModelConnectorWallV2) == 0x000078, "Wrong size on UPalMapObjectModelConnectorWallV2");
static_assert(offsetof(UPalMapObjectModelConnectorWallV2, UpConnectInfo) == 0x000048, "Member 'UPalMapObjectModelConnectorWallV2::UpConnectInfo' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModelConnectorWallV2, DownConnectInfo) == 0x000060, "Member 'UPalMapObjectModelConnectorWallV2::DownConnectInfo' has a wrong offset!");

// Class Pal.PalBuildObjectOverlapChecker
// 0x0050 (0x0078 - 0x0028)
class UPalBuildObjectOverlapChecker final : public UObject
{
public:
	uint8                                         Pad_29E2[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UShapeComponent*                        Collision;                                         // 0x0030(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APalBuildObject*                        Owner;                                             // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class APalBuildObject*>                OverlapBuildObjects;                               // 0x0040(0x0010)(Edit, ZeroConstructor, Transient, EditConst, NativeAccessSpecifierPrivate)
	TArray<class UObject*>                        OverlapOtherObjects;                               // 0x0050(0x0010)(Edit, ZeroConstructor, Transient, EditConst, NativeAccessSpecifierPrivate)
	class AActor*                                 OverlappedActor;                                   // 0x0060(0x0008)(Edit, ZeroConstructor, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           AllowOverlapCollisionPresetNames;                  // 0x0068(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)

public:
	void OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnOverlapEnd(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBuildObjectOverlapChecker">();
	}
	static class UPalBuildObjectOverlapChecker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBuildObjectOverlapChecker>();
	}
};
static_assert(alignof(UPalBuildObjectOverlapChecker) == 0x000008, "Wrong alignment on UPalBuildObjectOverlapChecker");
static_assert(sizeof(UPalBuildObjectOverlapChecker) == 0x000078, "Wrong size on UPalBuildObjectOverlapChecker");
static_assert(offsetof(UPalBuildObjectOverlapChecker, Collision) == 0x000030, "Member 'UPalBuildObjectOverlapChecker::Collision' has a wrong offset!");
static_assert(offsetof(UPalBuildObjectOverlapChecker, Owner) == 0x000038, "Member 'UPalBuildObjectOverlapChecker::Owner' has a wrong offset!");
static_assert(offsetof(UPalBuildObjectOverlapChecker, OverlapBuildObjects) == 0x000040, "Member 'UPalBuildObjectOverlapChecker::OverlapBuildObjects' has a wrong offset!");
static_assert(offsetof(UPalBuildObjectOverlapChecker, OverlapOtherObjects) == 0x000050, "Member 'UPalBuildObjectOverlapChecker::OverlapOtherObjects' has a wrong offset!");
static_assert(offsetof(UPalBuildObjectOverlapChecker, OverlappedActor) == 0x000060, "Member 'UPalBuildObjectOverlapChecker::OverlappedActor' has a wrong offset!");
static_assert(offsetof(UPalBuildObjectOverlapChecker, AllowOverlapCollisionPresetNames) == 0x000068, "Member 'UPalBuildObjectOverlapChecker::AllowOverlapCollisionPresetNames' has a wrong offset!");

// Class Pal.PalQuestBlock_DetectMeal
// 0x0008 (0x0058 - 0x0050)
class UPalQuestBlock_DetectMeal final : public UPalQuestBlock
{
public:
	int32                                         RequireCount;                                      // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NowMealCount;                                      // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnTriedMeal();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalQuestBlock_DetectMeal">();
	}
	static class UPalQuestBlock_DetectMeal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalQuestBlock_DetectMeal>();
	}
};
static_assert(alignof(UPalQuestBlock_DetectMeal) == 0x000008, "Wrong alignment on UPalQuestBlock_DetectMeal");
static_assert(sizeof(UPalQuestBlock_DetectMeal) == 0x000058, "Wrong size on UPalQuestBlock_DetectMeal");
static_assert(offsetof(UPalQuestBlock_DetectMeal, RequireCount) == 0x000050, "Member 'UPalQuestBlock_DetectMeal::RequireCount' has a wrong offset!");
static_assert(offsetof(UPalQuestBlock_DetectMeal, NowMealCount) == 0x000054, "Member 'UPalQuestBlock_DetectMeal::NowMealCount' has a wrong offset!");

// Class Pal.PalUIBuildProgressWorldHUD
// 0x0008 (0x0410 - 0x0408)
class UPalUIBuildProgressWorldHUD final : public UPalUserWidgetWorldHUD
{
public:
	class UPalBuildProcess*                       BuildProcess;                                      // 0x0408(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BindUpdateAssingedCharacterDelegate();
	void CloseSelf();
	void OnRequestClose(class UPalBuildProcess* Process);
	void OnUpdatedAssignCharacter(class UPalWorkBase* TargetWork);
	void SetProgress(class UPalWorkProgress* Work);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIBuildProgressWorldHUD">();
	}
	static class UPalUIBuildProgressWorldHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIBuildProgressWorldHUD>();
	}
};
static_assert(alignof(UPalUIBuildProgressWorldHUD) == 0x000008, "Wrong alignment on UPalUIBuildProgressWorldHUD");
static_assert(sizeof(UPalUIBuildProgressWorldHUD) == 0x000410, "Wrong size on UPalUIBuildProgressWorldHUD");
static_assert(offsetof(UPalUIBuildProgressWorldHUD, BuildProcess) == 0x000408, "Member 'UPalUIBuildProgressWorldHUD::BuildProcess' has a wrong offset!");

// Class Pal.PalBuildObjectPalStorage
// 0x0148 (0x06C8 - 0x0580)
class APalBuildObjectPalStorage final : public APalBuildObject
{
public:
	FMulticastInlineDelegateProperty_             OnOverlapBeginCageArea;                            // 0x0580(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, InstancedReference, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnOverlapEndCageArea;                              // 0x0590(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, InstancedReference, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnOverlapBeginCageWalls;                           // 0x05A0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, InstancedReference, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnOverlapEndCageWalls;                             // 0x05B0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, InstancedReference, BlueprintCallable, NativeAccessSpecifierPublic)
	float                                         BaseCampAreaRange;                                 // 0x05C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29E5[0x4];                                     // 0x05C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FComponentReference                    AccessPointObjectRef;                              // 0x05C8(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FComponentReference                    AccessPointMovableRangeRef;                        // 0x05F0(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FComponentReference                    AccessPointInteractRef;                            // 0x0618(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FComponentReference                    ChestObjectRef;                                    // 0x0640(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FComponentReference                    ChestMovableRangeRef;                              // 0x0668(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FComponentReference                    ChestInteractRef;                                  // 0x0690(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FName                                   ChestWorkableBoundsName;                           // 0x06B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ChestSlotNum;                                      // 0x06C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29E6[0x4];                                     // 0x06C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UBoxComponent* GetAccessPointMovableRange();
	class UStaticMeshComponent* GetAccessPointObject();
	class UBoxComponent* GetChestMovableRange();
	class USceneComponent* GetChestObject();
	void OnSpawnCharacter(const struct FPalInstanceID& IndividualId, int32 PhantomId);
	void OverlapAreaDelegate__DelegateSignature(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp);

	class UShapeComponent* GetCageAreaShape() const;
	struct FTransform GetDisplayCharacterSpawnLocalTransform() const;
	struct FTransform GetFastTravelLocalTransform() const;
	struct FTransform GetWorkerSpawnLocalTransform() const;
	void PlaySpawnCharacterFX(class APalCharacter* TargetActor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBuildObjectPalStorage">();
	}
	static class APalBuildObjectPalStorage* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalBuildObjectPalStorage>();
	}
};
static_assert(alignof(APalBuildObjectPalStorage) == 0x000008, "Wrong alignment on APalBuildObjectPalStorage");
static_assert(sizeof(APalBuildObjectPalStorage) == 0x0006C8, "Wrong size on APalBuildObjectPalStorage");
static_assert(offsetof(APalBuildObjectPalStorage, OnOverlapBeginCageArea) == 0x000580, "Member 'APalBuildObjectPalStorage::OnOverlapBeginCageArea' has a wrong offset!");
static_assert(offsetof(APalBuildObjectPalStorage, OnOverlapEndCageArea) == 0x000590, "Member 'APalBuildObjectPalStorage::OnOverlapEndCageArea' has a wrong offset!");
static_assert(offsetof(APalBuildObjectPalStorage, OnOverlapBeginCageWalls) == 0x0005A0, "Member 'APalBuildObjectPalStorage::OnOverlapBeginCageWalls' has a wrong offset!");
static_assert(offsetof(APalBuildObjectPalStorage, OnOverlapEndCageWalls) == 0x0005B0, "Member 'APalBuildObjectPalStorage::OnOverlapEndCageWalls' has a wrong offset!");
static_assert(offsetof(APalBuildObjectPalStorage, BaseCampAreaRange) == 0x0005C0, "Member 'APalBuildObjectPalStorage::BaseCampAreaRange' has a wrong offset!");
static_assert(offsetof(APalBuildObjectPalStorage, AccessPointObjectRef) == 0x0005C8, "Member 'APalBuildObjectPalStorage::AccessPointObjectRef' has a wrong offset!");
static_assert(offsetof(APalBuildObjectPalStorage, AccessPointMovableRangeRef) == 0x0005F0, "Member 'APalBuildObjectPalStorage::AccessPointMovableRangeRef' has a wrong offset!");
static_assert(offsetof(APalBuildObjectPalStorage, AccessPointInteractRef) == 0x000618, "Member 'APalBuildObjectPalStorage::AccessPointInteractRef' has a wrong offset!");
static_assert(offsetof(APalBuildObjectPalStorage, ChestObjectRef) == 0x000640, "Member 'APalBuildObjectPalStorage::ChestObjectRef' has a wrong offset!");
static_assert(offsetof(APalBuildObjectPalStorage, ChestMovableRangeRef) == 0x000668, "Member 'APalBuildObjectPalStorage::ChestMovableRangeRef' has a wrong offset!");
static_assert(offsetof(APalBuildObjectPalStorage, ChestInteractRef) == 0x000690, "Member 'APalBuildObjectPalStorage::ChestInteractRef' has a wrong offset!");
static_assert(offsetof(APalBuildObjectPalStorage, ChestWorkableBoundsName) == 0x0006B8, "Member 'APalBuildObjectPalStorage::ChestWorkableBoundsName' has a wrong offset!");
static_assert(offsetof(APalBuildObjectPalStorage, ChestSlotNum) == 0x0006C0, "Member 'APalBuildObjectPalStorage::ChestSlotNum' has a wrong offset!");

// Class Pal.PalBuildObjectRaidBossSummon
// 0x0000 (0x0580 - 0x0580)
class APalBuildObjectRaidBossSummon final : public APalBuildObject
{
public:
	void BP_PlayPerform();
	void OnPerformComplete();
	void StartPerform();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBuildObjectRaidBossSummon">();
	}
	static class APalBuildObjectRaidBossSummon* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalBuildObjectRaidBossSummon>();
	}
};
static_assert(alignof(APalBuildObjectRaidBossSummon) == 0x000008, "Wrong alignment on APalBuildObjectRaidBossSummon");
static_assert(sizeof(APalBuildObjectRaidBossSummon) == 0x000580, "Wrong size on APalBuildObjectRaidBossSummon");

// Class Pal.PalBuildOperator
// 0x0060 (0x0088 - 0x0028)
class UPalBuildOperator final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnCompleteBuildInServerDelegate;                   // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FBuildingSurfaceMaterialSet            BuildingSurfaceMaterialSet;                        // 0x0038(0x0038)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UPalBuildObjectDataMap*                 DataMap;                                           // 0x0070(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class APalBuildObject*>                BuildObjects;                                      // 0x0078(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBuildOperator">();
	}
	static class UPalBuildOperator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBuildOperator>();
	}
};
static_assert(alignof(UPalBuildOperator) == 0x000008, "Wrong alignment on UPalBuildOperator");
static_assert(sizeof(UPalBuildOperator) == 0x000088, "Wrong size on UPalBuildOperator");
static_assert(offsetof(UPalBuildOperator, OnCompleteBuildInServerDelegate) == 0x000028, "Member 'UPalBuildOperator::OnCompleteBuildInServerDelegate' has a wrong offset!");
static_assert(offsetof(UPalBuildOperator, BuildingSurfaceMaterialSet) == 0x000038, "Member 'UPalBuildOperator::BuildingSurfaceMaterialSet' has a wrong offset!");
static_assert(offsetof(UPalBuildOperator, DataMap) == 0x000070, "Member 'UPalBuildOperator::DataMap' has a wrong offset!");
static_assert(offsetof(UPalBuildOperator, BuildObjects) == 0x000078, "Member 'UPalBuildOperator::BuildObjects' has a wrong offset!");

// Class Pal.PalQuestBlock_UseStatusPoint
// 0x0000 (0x0050 - 0x0050)
class UPalQuestBlock_UseStatusPoint final : public UPalQuestBlock
{
public:
	void OnUpdateStatusPoint();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalQuestBlock_UseStatusPoint">();
	}
	static class UPalQuestBlock_UseStatusPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalQuestBlock_UseStatusPoint>();
	}
};
static_assert(alignof(UPalQuestBlock_UseStatusPoint) == 0x000008, "Wrong alignment on UPalQuestBlock_UseStatusPoint");
static_assert(sizeof(UPalQuestBlock_UseStatusPoint) == 0x000050, "Wrong size on UPalQuestBlock_UseStatusPoint");

// Class Pal.PalBullet
// 0x00D8 (0x0368 - 0x0290)
class APalBullet : public AActor
{
public:
	FMulticastInlineDelegateProperty_             OnDestroyDelegate;                                 // 0x0290(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	class USphereComponent*                       CollisionComp;                                     // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProjectileMovementComponent*           ProjectileMovement;                                // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPalPlayerDamageCameraShakeCategory           PlayerDamageCameraShake;                           // 0x02B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsHitFriend;                                      // 0x02B1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29E8[0x2];                                     // 0x02B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         WeaponDamage;                                      // 0x02B4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           Handle;                                            // 0x02B8(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsDamageable;                                      // 0x02C0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          AISoundEmitable;                                   // 0x02C1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29E9[0x2];                                     // 0x02C2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SneakAttackRate;                                   // 0x02C4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DeleteTime;                                        // 0x02C8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DamageDecayStartRate;                              // 0x02CC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LifeTimer;                                         // 0x02D0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPalDamageAnimationReactionType               WeaponBulletDamageReactionType;                    // 0x02D4(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29EA[0x3];                                     // 0x02D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPalPassiveSkillEffect>         SkillEffectList;                                   // 0x02D8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<EPhysicalSurface, struct FBulletHoleDecalInfo> BulletHoleDecalsMap;                               // 0x02E8(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FBulletHoleDecalInfo                   DefaultBulletHoleDecals;                           // 0x0338(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	void DestroyBulletDelegate__DelegateSignature(class UPrimitiveComponent* HitComp, class AActor* OtherCharacter, class UPrimitiveComponent* OtherComp, const struct FHitResult& Hi);
	float GetDecayDamageRate();
	float GetSneakAttackRate();
	bool IsDestroy(class UPrimitiveComponent* HitComp, class AActor* OtherCharacter, class UPrimitiveComponent* OtherComp, const struct FHitResult& Hit);
	void OnBeginOverlap(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& Hit);
	void OnBlock(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnDestroy(class UPrimitiveComponent* HitComp, class AActor* OtherCharacter, class UPrimitiveComponent* OtherComp, const struct FHitResult& Hit);
	void OnHit(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FHitResult& Hit);
	void OnHitToActor(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FHitResult& Hit);
	void OnHitToPalCharacter(class UPrimitiveComponent* HitComp, class APalCharacter* OtherCharacter, class UPrimitiveComponent* OtherComp, const struct FHitResult& Hit);
	void OnHitToPalEnemy(class UPrimitiveComponent* HitComp, class APalCharacter* OtherCharacter, class UPrimitiveComponent* OtherComp, const struct FHitResult& Hit);
	bool SetBulletHoleDecal(const struct FHitResult& Hit, float LifeSpan, float FadeTime, float FadeScreenSize);
	void SetDamageable(bool Damageable);
	void SetDeleteTime(float DeleteSecound, float DecayStartRate);
	void SetSkillEffectList(const TArray<struct FPalPassiveSkillEffect>& InList);
	void SetSneakAttackRate(float Rate);
	void SetWeaponDamage(int32 Damage);

	float GetParameterWithPassiveSkillEffect(float OriginalValue, EPalPassiveSkillEffectType EffectType) const;
	int32 GetWeaponDamage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBullet">();
	}
	static class APalBullet* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalBullet>();
	}
};
static_assert(alignof(APalBullet) == 0x000008, "Wrong alignment on APalBullet");
static_assert(sizeof(APalBullet) == 0x000368, "Wrong size on APalBullet");
static_assert(offsetof(APalBullet, OnDestroyDelegate) == 0x000290, "Member 'APalBullet::OnDestroyDelegate' has a wrong offset!");
static_assert(offsetof(APalBullet, CollisionComp) == 0x0002A0, "Member 'APalBullet::CollisionComp' has a wrong offset!");
static_assert(offsetof(APalBullet, ProjectileMovement) == 0x0002A8, "Member 'APalBullet::ProjectileMovement' has a wrong offset!");
static_assert(offsetof(APalBullet, PlayerDamageCameraShake) == 0x0002B0, "Member 'APalBullet::PlayerDamageCameraShake' has a wrong offset!");
static_assert(offsetof(APalBullet, bIsHitFriend) == 0x0002B1, "Member 'APalBullet::bIsHitFriend' has a wrong offset!");
static_assert(offsetof(APalBullet, WeaponDamage) == 0x0002B4, "Member 'APalBullet::WeaponDamage' has a wrong offset!");
static_assert(offsetof(APalBullet, Handle) == 0x0002B8, "Member 'APalBullet::Handle' has a wrong offset!");
static_assert(offsetof(APalBullet, IsDamageable) == 0x0002C0, "Member 'APalBullet::IsDamageable' has a wrong offset!");
static_assert(offsetof(APalBullet, AISoundEmitable) == 0x0002C1, "Member 'APalBullet::AISoundEmitable' has a wrong offset!");
static_assert(offsetof(APalBullet, SneakAttackRate) == 0x0002C4, "Member 'APalBullet::SneakAttackRate' has a wrong offset!");
static_assert(offsetof(APalBullet, DeleteTime) == 0x0002C8, "Member 'APalBullet::DeleteTime' has a wrong offset!");
static_assert(offsetof(APalBullet, DamageDecayStartRate) == 0x0002CC, "Member 'APalBullet::DamageDecayStartRate' has a wrong offset!");
static_assert(offsetof(APalBullet, LifeTimer) == 0x0002D0, "Member 'APalBullet::LifeTimer' has a wrong offset!");
static_assert(offsetof(APalBullet, WeaponBulletDamageReactionType) == 0x0002D4, "Member 'APalBullet::WeaponBulletDamageReactionType' has a wrong offset!");
static_assert(offsetof(APalBullet, SkillEffectList) == 0x0002D8, "Member 'APalBullet::SkillEffectList' has a wrong offset!");
static_assert(offsetof(APalBullet, BulletHoleDecalsMap) == 0x0002E8, "Member 'APalBullet::BulletHoleDecalsMap' has a wrong offset!");
static_assert(offsetof(APalBullet, DefaultBulletHoleDecals) == 0x000338, "Member 'APalBullet::DefaultBulletHoleDecals' has a wrong offset!");

// Class Pal.PalBulletCreator
// 0x0000 (0x0028 - 0x0028)
class UPalBulletCreator : public UObject
{
public:
	class APalBullet* CreateBullet(const class UObject* WorldContextObject, class APalWeaponBase* Weapon, TSubclassOf<class APalBullet> bulletClass, const struct FTransform& SpawnTransform, ESpawnActorCollisionHandlingMethod CollisionHandlingOverride, class AActor* Owner, class APawn* Instigator);
	class APalBullet* SpawnBullet(const class UObject* WorldContextObject, TSubclassOf<class APalBullet> bulletClass, const struct FTransform& SpawnTransform, ESpawnActorCollisionHandlingMethod CollisionHandlingOverride, class AActor* Owner, class APawn* Instigato);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBulletCreator">();
	}
	static class UPalBulletCreator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBulletCreator>();
	}
};
static_assert(alignof(UPalBulletCreator) == 0x000008, "Wrong alignment on UPalBulletCreator");
static_assert(sizeof(UPalBulletCreator) == 0x000028, "Wrong size on UPalBulletCreator");

// Class Pal.PalBulletModifierComponent
// 0x0000 (0x00A0 - 0x00A0)
class UPalBulletModifierComponent : public UActorComponent
{
public:
	void Initialize(const class APalBullet* Bullet);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBulletModifierComponent">();
	}
	static class UPalBulletModifierComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBulletModifierComponent>();
	}
};
static_assert(alignof(UPalBulletModifierComponent) == 0x000008, "Wrong alignment on UPalBulletModifierComponent");
static_assert(sizeof(UPalBulletModifierComponent) == 0x0000A0, "Wrong size on UPalBulletModifierComponent");

// Class Pal.PalQuestRewardGiver
// 0x0000 (0x0028 - 0x0028)
class UPalQuestRewardGiver : public UObject
{
public:
	void TakeReward(class APalPlayerState* PlayerState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalQuestRewardGiver">();
	}
	static class UPalQuestRewardGiver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalQuestRewardGiver>();
	}
};
static_assert(alignof(UPalQuestRewardGiver) == 0x000008, "Wrong alignment on UPalQuestRewardGiver");
static_assert(sizeof(UPalQuestRewardGiver) == 0x000028, "Wrong size on UPalQuestRewardGiver");

// Class Pal.PalCommonQuestRewardGiver
// 0x0058 (0x0080 - 0x0028)
class UPalCommonQuestRewardGiver final : public UPalQuestRewardGiver
{
public:
	struct FPalCommonQuestRewardData              RewardData;                                        // 0x0028(0x0058)(NativeAccessSpecifierPrivate)

public:
	void SetCommonRewardData(const struct FPalCommonQuestRewardData& InRewardList);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalCommonQuestRewardGiver">();
	}
	static class UPalCommonQuestRewardGiver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalCommonQuestRewardGiver>();
	}
};
static_assert(alignof(UPalCommonQuestRewardGiver) == 0x000008, "Wrong alignment on UPalCommonQuestRewardGiver");
static_assert(sizeof(UPalCommonQuestRewardGiver) == 0x000080, "Wrong size on UPalCommonQuestRewardGiver");
static_assert(offsetof(UPalCommonQuestRewardGiver, RewardData) == 0x000028, "Member 'UPalCommonQuestRewardGiver::RewardData' has a wrong offset!");

// Class Pal.PalWorkFacingComponent
// 0x0000 (0x0550 - 0x0550)
class UPalWorkFacingComponent final : public UArrowComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorkFacingComponent">();
	}
	static class UPalWorkFacingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWorkFacingComponent>();
	}
};
static_assert(alignof(UPalWorkFacingComponent) == 0x000010, "Wrong alignment on UPalWorkFacingComponent");
static_assert(sizeof(UPalWorkFacingComponent) == 0x000550, "Wrong size on UPalWorkFacingComponent");

// Class Pal.PalFoliageInstallDataAsset
// 0x0050 (0x0080 - 0x0030)
class UPalFoliageInstallDataAsset final : public UDataAsset
{
public:
	TMap<class FName, TSoftObjectPtr<class UPalFoliageInstallDataAssetByIFA>> InstallDataSetMap;                                 // 0x0030(0x0050)(Edit, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalFoliageInstallDataAsset">();
	}
	static class UPalFoliageInstallDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalFoliageInstallDataAsset>();
	}
};
static_assert(alignof(UPalFoliageInstallDataAsset) == 0x000008, "Wrong alignment on UPalFoliageInstallDataAsset");
static_assert(sizeof(UPalFoliageInstallDataAsset) == 0x000080, "Wrong size on UPalFoliageInstallDataAsset");
static_assert(offsetof(UPalFoliageInstallDataAsset, InstallDataSetMap) == 0x000030, "Member 'UPalFoliageInstallDataAsset::InstallDataSetMap' has a wrong offset!");

// Class Pal.PalUIChat
// 0x0020 (0x0428 - 0x0408)
class UPalUIChat final : public UPalUserWidget
{
public:
	FMulticastInlineDelegateProperty_             OnRecievedFilteredMessageDelegate;                 // 0x0408(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UPalChatFilteringWaiter*>        FilteringWaiterArray;                              // 0x0418(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void OnFilteredChat(class UPalChatFilteringWaiter* Waiter, const struct FPalChatMessage& Message);
	void OnReceivedChat(const struct FPalChatMessage& Message);
	void OnRecievedFilteredMessageDelegate__DelegateSignature(const struct FPalChatMessage& Message);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIChat">();
	}
	static class UPalUIChat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIChat>();
	}
};
static_assert(alignof(UPalUIChat) == 0x000008, "Wrong alignment on UPalUIChat");
static_assert(sizeof(UPalUIChat) == 0x000428, "Wrong size on UPalUIChat");
static_assert(offsetof(UPalUIChat, OnRecievedFilteredMessageDelegate) == 0x000408, "Member 'UPalUIChat::OnRecievedFilteredMessageDelegate' has a wrong offset!");
static_assert(offsetof(UPalUIChat, FilteringWaiterArray) == 0x000418, "Member 'UPalUIChat::FilteringWaiterArray' has a wrong offset!");

// Class Pal.PalBurnBoxComponent
// 0x0000 (0x0580 - 0x0580)
class UPalBurnBoxComponent final : public UBoxComponent
{
public:
	void BeginOverlapEvent(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void EndOverlapEvent(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBurnBoxComponent">();
	}
	static class UPalBurnBoxComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBurnBoxComponent>();
	}
};
static_assert(alignof(UPalBurnBoxComponent) == 0x000010, "Wrong alignment on UPalBurnBoxComponent");
static_assert(sizeof(UPalBurnBoxComponent) == 0x000580, "Wrong size on UPalBurnBoxComponent");

// Class Pal.PalCameraShakeBase
// 0x00E0 (0x01D0 - 0x00F0)
class UPalCameraShakeBase : public UCameraShakeBase
{
public:
	class UCurveFloat*                            CurveAsset;                                        // 0x00E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OscillationDuration;                               // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OscillationBlendInTime;                            // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OscillationBlendOutTime;                           // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FROscillator                           RotOscillation;                                    // 0x00FC(0x0024)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FVOscillator                           LocOscillation;                                    // 0x0120(0x0024)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FFOscillator                           FOVOscillation;                                    // 0x0144(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         OscillatorTimeRemaining;                           // 0x0150(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29F4[0x7C];                                    // 0x0154(0x007C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalCameraShakeBase">();
	}
	static class UPalCameraShakeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalCameraShakeBase>();
	}
};
static_assert(alignof(UPalCameraShakeBase) == 0x000010, "Wrong alignment on UPalCameraShakeBase");
static_assert(sizeof(UPalCameraShakeBase) == 0x0001D0, "Wrong size on UPalCameraShakeBase");
static_assert(offsetof(UPalCameraShakeBase, CurveAsset) == 0x0000E8, "Member 'UPalCameraShakeBase::CurveAsset' has a wrong offset!");
static_assert(offsetof(UPalCameraShakeBase, OscillationDuration) == 0x0000F0, "Member 'UPalCameraShakeBase::OscillationDuration' has a wrong offset!");
static_assert(offsetof(UPalCameraShakeBase, OscillationBlendInTime) == 0x0000F4, "Member 'UPalCameraShakeBase::OscillationBlendInTime' has a wrong offset!");
static_assert(offsetof(UPalCameraShakeBase, OscillationBlendOutTime) == 0x0000F8, "Member 'UPalCameraShakeBase::OscillationBlendOutTime' has a wrong offset!");
static_assert(offsetof(UPalCameraShakeBase, RotOscillation) == 0x0000FC, "Member 'UPalCameraShakeBase::RotOscillation' has a wrong offset!");
static_assert(offsetof(UPalCameraShakeBase, LocOscillation) == 0x000120, "Member 'UPalCameraShakeBase::LocOscillation' has a wrong offset!");
static_assert(offsetof(UPalCameraShakeBase, FOVOscillation) == 0x000144, "Member 'UPalCameraShakeBase::FOVOscillation' has a wrong offset!");
static_assert(offsetof(UPalCameraShakeBase, OscillatorTimeRemaining) == 0x000150, "Member 'UPalCameraShakeBase::OscillatorTimeRemaining' has a wrong offset!");

// Class Pal.PalCameraShakePattern
// 0x0000 (0x0028 - 0x0028)
class UPalCameraShakePattern final : public UCameraShakePattern
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalCameraShakePattern">();
	}
	static class UPalCameraShakePattern* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalCameraShakePattern>();
	}
};
static_assert(alignof(UPalCameraShakePattern) == 0x000008, "Wrong alignment on UPalCameraShakePattern");
static_assert(sizeof(UPalCameraShakePattern) == 0x000028, "Wrong size on UPalCameraShakePattern");

// Class Pal.PalCaptureBallEffectSettingDataAsset
// 0x0050 (0x0080 - 0x0030)
class UPalCaptureBallEffectSettingDataAsset final : public UDataAsset
{
public:
	TMap<EPalSizeType, struct FPalCaptureBallEffectSettingData> EffectSettingDataArray;                            // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	const struct FPalCaptureBallEffectSettingData GetEffectSettingData(const EPalSizeType PalSizeType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalCaptureBallEffectSettingDataAsset">();
	}
	static class UPalCaptureBallEffectSettingDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalCaptureBallEffectSettingDataAsset>();
	}
};
static_assert(alignof(UPalCaptureBallEffectSettingDataAsset) == 0x000008, "Wrong alignment on UPalCaptureBallEffectSettingDataAsset");
static_assert(sizeof(UPalCaptureBallEffectSettingDataAsset) == 0x000080, "Wrong size on UPalCaptureBallEffectSettingDataAsset");
static_assert(offsetof(UPalCaptureBallEffectSettingDataAsset, EffectSettingDataArray) == 0x000030, "Member 'UPalCaptureBallEffectSettingDataAsset::EffectSettingDataArray' has a wrong offset!");

// Class Pal.PalPettingPresset
// 0x0030 (0x0058 - 0x0028)
class UPalPettingPresset : public UObject
{
public:
	struct FPalPettingParameter                   SmallPreset;                                       // 0x0028(0x000C)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FPalPettingParameter                   SmallMiddlePreset;                                 // 0x0034(0x000C)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FPalPettingParameter                   MediumPreset;                                      // 0x0040(0x000C)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FPalPettingParameter                   LargePreset;                                       // 0x004C(0x000C)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)

public:
	float GetCameraArmLength(class AActor* Pal);
	float GetCameraCenterDistance(class AActor* Pal);
	float GetCameraHeight(class AActor* Pal);
	float GetDistance(class AActor* Pal);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalPettingPresset">();
	}
	static class UPalPettingPresset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalPettingPresset>();
	}
};
static_assert(alignof(UPalPettingPresset) == 0x000008, "Wrong alignment on UPalPettingPresset");
static_assert(sizeof(UPalPettingPresset) == 0x000058, "Wrong size on UPalPettingPresset");
static_assert(offsetof(UPalPettingPresset, SmallPreset) == 0x000028, "Member 'UPalPettingPresset::SmallPreset' has a wrong offset!");
static_assert(offsetof(UPalPettingPresset, SmallMiddlePreset) == 0x000034, "Member 'UPalPettingPresset::SmallMiddlePreset' has a wrong offset!");
static_assert(offsetof(UPalPettingPresset, MediumPreset) == 0x000040, "Member 'UPalPettingPresset::MediumPreset' has a wrong offset!");
static_assert(offsetof(UPalPettingPresset, LargePreset) == 0x00004C, "Member 'UPalPettingPresset::LargePreset' has a wrong offset!");

// Class Pal.PalCapturedCage
// 0x0038 (0x02C8 - 0x0290)
class APalCapturedCage final : public AActor
{
public:
	uint8                                         Pad_29FA[0x8];                                     // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FieldKeyName;                                      // 0x0298(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class APalAIController>           ControllerClass;                                   // 0x02A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpawnRange;                                        // 0x02A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DespawnRange;                                      // 0x02AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SpawnedPalId;                                      // 0x02B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SpawnedPalLevel;                                   // 0x02B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsRequestedInteract;                               // 0x02BC(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsDisableInteractive;                              // 0x02BD(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsInSpawnedRange;                                  // 0x02BE(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29FB[0x1];                                     // 0x02BF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalIndividualCharacterHandle*          SpawnedPalHandle;                                  // 0x02C0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class APalCharacter* GetSpawnedPal();
	void LotteryAndSpawnPal();
	void OnCreateHandle(const struct FPalInstanceID& ID);
	void RequestInteract(class APalPlayerCharacter* Attacker);
	void SetDisableInteractive();
	void SetOverrideKeyName(class FName Key);
	void SpawnPal(class FName InPalID, int32 InPalLevel);

	class FName GetCampSpawnerName() const;
	EPalInteractiveObjectIndicatorType GetIndicatorType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalCapturedCage">();
	}
	static class APalCapturedCage* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalCapturedCage>();
	}
};
static_assert(alignof(APalCapturedCage) == 0x000008, "Wrong alignment on APalCapturedCage");
static_assert(sizeof(APalCapturedCage) == 0x0002C8, "Wrong size on APalCapturedCage");
static_assert(offsetof(APalCapturedCage, FieldKeyName) == 0x000298, "Member 'APalCapturedCage::FieldKeyName' has a wrong offset!");
static_assert(offsetof(APalCapturedCage, ControllerClass) == 0x0002A0, "Member 'APalCapturedCage::ControllerClass' has a wrong offset!");
static_assert(offsetof(APalCapturedCage, SpawnRange) == 0x0002A8, "Member 'APalCapturedCage::SpawnRange' has a wrong offset!");
static_assert(offsetof(APalCapturedCage, DespawnRange) == 0x0002AC, "Member 'APalCapturedCage::DespawnRange' has a wrong offset!");
static_assert(offsetof(APalCapturedCage, SpawnedPalId) == 0x0002B0, "Member 'APalCapturedCage::SpawnedPalId' has a wrong offset!");
static_assert(offsetof(APalCapturedCage, SpawnedPalLevel) == 0x0002B8, "Member 'APalCapturedCage::SpawnedPalLevel' has a wrong offset!");
static_assert(offsetof(APalCapturedCage, IsRequestedInteract) == 0x0002BC, "Member 'APalCapturedCage::IsRequestedInteract' has a wrong offset!");
static_assert(offsetof(APalCapturedCage, IsDisableInteractive) == 0x0002BD, "Member 'APalCapturedCage::IsDisableInteractive' has a wrong offset!");
static_assert(offsetof(APalCapturedCage, IsInSpawnedRange) == 0x0002BE, "Member 'APalCapturedCage::IsInSpawnedRange' has a wrong offset!");
static_assert(offsetof(APalCapturedCage, SpawnedPalHandle) == 0x0002C0, "Member 'APalCapturedCage::SpawnedPalHandle' has a wrong offset!");

// Class Pal.PalCaptureJudgeObject
// 0x0028 (0x02B8 - 0x0290)
class APalCaptureJudgeObject : public AActor
{
public:
	uint8                                         Pad_29FC[0x28];                                    // 0x0290(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CaptureResult_ToALL(class APalCharacter* Character, const struct FCaptureResult& Result);
	void ChallengeCapture(class APalCharacter* Character, float CapturePower);
	void ChallengeCapture_ToServer(class APalCharacter* Character, float CapturePower);
	void OnCaptureSuccess(const class APalCharacter* Character, const struct FCaptureResult& Result);
	void OnFailedByMP(const class APalCharacter* Character, const struct FCaptureResult& Result);
	void OnFailedByTest(const class APalCharacter* Character, const struct FCaptureResult& Result);
	void OnFailedFinish();
	void OnSuccessFinish();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalCaptureJudgeObject">();
	}
	static class APalCaptureJudgeObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalCaptureJudgeObject>();
	}
};
static_assert(alignof(APalCaptureJudgeObject) == 0x000008, "Wrong alignment on APalCaptureJudgeObject");
static_assert(sizeof(APalCaptureJudgeObject) == 0x0002B8, "Wrong size on APalCaptureJudgeObject");

// Class Pal.PalPlayerBattleSituation
// 0x0090 (0x00B8 - 0x0028)
class UPalPlayerBattleSituation final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnBattleRankDownDelegate;                          // 0x0028(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEnemyAddRemoveDelegate;                          // 0x0038(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeNearEnemyDelegate;                         // 0x0048(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TMap<struct FPalInstanceID, struct FPalPlayerBattleEnemyInfo> BattleEnemyList;                                   // 0x0058(0x0050)(Transient, NativeAccessSpecifierPrivate)
	bool                                          IsNearCommonEnemy;                                 // 0x00A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A03[0x3];                                     // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NearDistanceSqr;                                   // 0x00AC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           DistanceUpdateTimerHandle;                         // 0x00B0(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalPlayerBattleSituation">();
	}
	static class UPalPlayerBattleSituation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalPlayerBattleSituation>();
	}
};
static_assert(alignof(UPalPlayerBattleSituation) == 0x000008, "Wrong alignment on UPalPlayerBattleSituation");
static_assert(sizeof(UPalPlayerBattleSituation) == 0x0000B8, "Wrong size on UPalPlayerBattleSituation");
static_assert(offsetof(UPalPlayerBattleSituation, OnBattleRankDownDelegate) == 0x000028, "Member 'UPalPlayerBattleSituation::OnBattleRankDownDelegate' has a wrong offset!");
static_assert(offsetof(UPalPlayerBattleSituation, OnEnemyAddRemoveDelegate) == 0x000038, "Member 'UPalPlayerBattleSituation::OnEnemyAddRemoveDelegate' has a wrong offset!");
static_assert(offsetof(UPalPlayerBattleSituation, OnChangeNearEnemyDelegate) == 0x000048, "Member 'UPalPlayerBattleSituation::OnChangeNearEnemyDelegate' has a wrong offset!");
static_assert(offsetof(UPalPlayerBattleSituation, BattleEnemyList) == 0x000058, "Member 'UPalPlayerBattleSituation::BattleEnemyList' has a wrong offset!");
static_assert(offsetof(UPalPlayerBattleSituation, IsNearCommonEnemy) == 0x0000A8, "Member 'UPalPlayerBattleSituation::IsNearCommonEnemy' has a wrong offset!");
static_assert(offsetof(UPalPlayerBattleSituation, NearDistanceSqr) == 0x0000AC, "Member 'UPalPlayerBattleSituation::NearDistanceSqr' has a wrong offset!");
static_assert(offsetof(UPalPlayerBattleSituation, DistanceUpdateTimerHandle) == 0x0000B0, "Member 'UPalPlayerBattleSituation::DistanceUpdateTimerHandle' has a wrong offset!");

// Class Pal.PalCharacterAroundInfoCollectorComponent
// 0x0030 (0x0590 - 0x0560)
class UPalCharacterAroundInfoCollectorComponent final : public USphereComponent
{
public:
	FMulticastInlineDelegateProperty_             OnOverlapBeginDelegate;                            // 0x0560(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnOverlapEndDelegate;                              // 0x0570(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FGuid>                          MapObjectModelIds;                                 // 0x0580(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)

public:
	void OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnOverlapEnd(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OverlapDelegate__DelegateSignature(class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalCharacterAroundInfoCollectorComponent">();
	}
	static class UPalCharacterAroundInfoCollectorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalCharacterAroundInfoCollectorComponent>();
	}
};
static_assert(alignof(UPalCharacterAroundInfoCollectorComponent) == 0x000010, "Wrong alignment on UPalCharacterAroundInfoCollectorComponent");
static_assert(sizeof(UPalCharacterAroundInfoCollectorComponent) == 0x000590, "Wrong size on UPalCharacterAroundInfoCollectorComponent");
static_assert(offsetof(UPalCharacterAroundInfoCollectorComponent, OnOverlapBeginDelegate) == 0x000560, "Member 'UPalCharacterAroundInfoCollectorComponent::OnOverlapBeginDelegate' has a wrong offset!");
static_assert(offsetof(UPalCharacterAroundInfoCollectorComponent, OnOverlapEndDelegate) == 0x000570, "Member 'UPalCharacterAroundInfoCollectorComponent::OnOverlapEndDelegate' has a wrong offset!");
static_assert(offsetof(UPalCharacterAroundInfoCollectorComponent, MapObjectModelIds) == 0x000580, "Member 'UPalCharacterAroundInfoCollectorComponent::MapObjectModelIds' has a wrong offset!");

// Class Pal.PalCharacterCameraComponent
// 0x01A0 (0x0BD0 - 0x0A30)
class UPalCharacterCameraComponent final : public UCameraComponent
{
public:
	float                                         WalkFOV;                                           // 0x0A30(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintFOV;                                         // 0x0A34(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintFOVInterpSpeed;                              // 0x0A38(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PostProcessInterpTime;                             // 0x0A3C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldFocalDistance_NoAim;                   // 0x0A40(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldDepthBlurAmount_NoAim;                 // 0x0A44(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldDepthBlurRadius_NoAim;                 // 0x0A48(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldFstop_NoAim;                           // 0x0A4C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldFocalDistance_Aim;                     // 0x0A50(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldDepthBlurAmount_Aim;                   // 0x0A54(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldDepthBlurRadius_Aim;                   // 0x0A58(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldFstop_Aim;                             // 0x0A5C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EPalWeaponType, struct FPalCameraDOFSetting> DefaultWeaponDOFSetting;                           // 0x0A60(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<TSoftClassPtr<class UClass>, struct FPalCameraDOFSetting> UniqueWeaponDOFSetting;                            // 0x0AB0(0x0050)(Edit, NativeAccessSpecifierPublic)
	bool                                          bIsDynamicDOFFocalDistance;                        // 0x0B00(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A06[0x3];                                     // 0x0B01(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DynamicDOFFocalDistanceSpeed;                      // 0x0B04(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DynamicDOFFocalDistanceMAX;                        // 0x0B08(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEnableSpeedBlur;                                // 0x0B0C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A07[0x3];                                     // 0x0B0D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     DynamicSpeedBlurMaterial;                          // 0x0B10(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedBlurInterpSpeed;                              // 0x0B18(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSpeedBlurSpeed;                                 // 0x0B1C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeedBlurSpeed;                                 // 0x0B20(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeedBlurAlpha;                                 // 0x0B24(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEnableAimBlur;                                  // 0x0B28(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A08[0x7];                                     // 0x0B29(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     DynamicAimBlurMaterial;                            // 0x0B30(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInAimBlurInterpTime;                          // 0x0B38(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutAimBlurInterpTime;                         // 0x0B3C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimFOVInterpTime;                                  // 0x0B40(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimFOV;                                            // 0x0B44(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateSpeedRate;                                   // 0x0B48(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A09[0x6C];                                    // 0x0B4C(0x006C)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               DynamicSpeedBlurMaterialDynamic;                   // 0x0BB8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               DynamicAimBlurMaterialDynamic;                     // 0x0BC0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A0A[0x8];                                     // 0x0BC8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEndAim();
	void OnStartAim();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalCharacterCameraComponent">();
	}
	static class UPalCharacterCameraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalCharacterCameraComponent>();
	}
};
static_assert(alignof(UPalCharacterCameraComponent) == 0x000010, "Wrong alignment on UPalCharacterCameraComponent");
static_assert(sizeof(UPalCharacterCameraComponent) == 0x000BD0, "Wrong size on UPalCharacterCameraComponent");
static_assert(offsetof(UPalCharacterCameraComponent, WalkFOV) == 0x000A30, "Member 'UPalCharacterCameraComponent::WalkFOV' has a wrong offset!");
static_assert(offsetof(UPalCharacterCameraComponent, SprintFOV) == 0x000A34, "Member 'UPalCharacterCameraComponent::SprintFOV' has a wrong offset!");
static_assert(offsetof(UPalCharacterCameraComponent, SprintFOVInterpSpeed) == 0x000A38, "Member 'UPalCharacterCameraComponent::SprintFOVInterpSpeed' has a wrong offset!");
static_assert(offsetof(UPalCharacterCameraComponent, PostProcessInterpTime) == 0x000A3C, "Member 'UPalCharacterCameraComponent::PostProcessInterpTime' has a wrong offset!");
static_assert(offsetof(UPalCharacterCameraComponent, DepthOfFieldFocalDistance_NoAim) == 0x000A40, "Member 'UPalCharacterCameraComponent::DepthOfFieldFocalDistance_NoAim' has a wrong offset!");
static_assert(offsetof(UPalCharacterCameraComponent, DepthOfFieldDepthBlurAmount_NoAim) == 0x000A44, "Member 'UPalCharacterCameraComponent::DepthOfFieldDepthBlurAmount_NoAim' has a wrong offset!");
static_assert(offsetof(UPalCharacterCameraComponent, DepthOfFieldDepthBlurRadius_NoAim) == 0x000A48, "Member 'UPalCharacterCameraComponent::DepthOfFieldDepthBlurRadius_NoAim' has a wrong offset!");
static_assert(offsetof(UPalCharacterCameraComponent, DepthOfFieldFstop_NoAim) == 0x000A4C, "Member 'UPalCharacterCameraComponent::DepthOfFieldFstop_NoAim' has a wrong offset!");
static_assert(offsetof(UPalCharacterCameraComponent, DepthOfFieldFocalDistance_Aim) == 0x000A50, "Member 'UPalCharacterCameraComponent::DepthOfFieldFocalDistance_Aim' has a wrong offset!");
static_assert(offsetof(UPalCharacterCameraComponent, DepthOfFieldDepthBlurAmount_Aim) == 0x000A54, "Member 'UPalCharacterCameraComponent::DepthOfFieldDepthBlurAmount_Aim' has a wrong offset!");
static_assert(offsetof(UPalCharacterCameraComponent, DepthOfFieldDepthBlurRadius_Aim) == 0x000A58, "Member 'UPalCharacterCameraComponent::DepthOfFieldDepthBlurRadius_Aim' has a wrong offset!");
static_assert(offsetof(UPalCharacterCameraComponent, DepthOfFieldFstop_Aim) == 0x000A5C, "Member 'UPalCharacterCameraComponent::DepthOfFieldFstop_Aim' has a wrong offset!");
static_assert(offsetof(UPalCharacterCameraComponent, DefaultWeaponDOFSetting) == 0x000A60, "Member 'UPalCharacterCameraComponent::DefaultWeaponDOFSetting' has a wrong offset!");
static_assert(offsetof(UPalCharacterCameraComponent, UniqueWeaponDOFSetting) == 0x000AB0, "Member 'UPalCharacterCameraComponent::UniqueWeaponDOFSetting' has a wrong offset!");
static_assert(offsetof(UPalCharacterCameraComponent, bIsDynamicDOFFocalDistance) == 0x000B00, "Member 'UPalCharacterCameraComponent::bIsDynamicDOFFocalDistance' has a wrong offset!");
static_assert(offsetof(UPalCharacterCameraComponent, DynamicDOFFocalDistanceSpeed) == 0x000B04, "Member 'UPalCharacterCameraComponent::DynamicDOFFocalDistanceSpeed' has a wrong offset!");
static_assert(offsetof(UPalCharacterCameraComponent, DynamicDOFFocalDistanceMAX) == 0x000B08, "Member 'UPalCharacterCameraComponent::DynamicDOFFocalDistanceMAX' has a wrong offset!");
static_assert(offsetof(UPalCharacterCameraComponent, bIsEnableSpeedBlur) == 0x000B0C, "Member 'UPalCharacterCameraComponent::bIsEnableSpeedBlur' has a wrong offset!");
static_assert(offsetof(UPalCharacterCameraComponent, DynamicSpeedBlurMaterial) == 0x000B10, "Member 'UPalCharacterCameraComponent::DynamicSpeedBlurMaterial' has a wrong offset!");
static_assert(offsetof(UPalCharacterCameraComponent, SpeedBlurInterpSpeed) == 0x000B18, "Member 'UPalCharacterCameraComponent::SpeedBlurInterpSpeed' has a wrong offset!");
static_assert(offsetof(UPalCharacterCameraComponent, MinSpeedBlurSpeed) == 0x000B1C, "Member 'UPalCharacterCameraComponent::MinSpeedBlurSpeed' has a wrong offset!");
static_assert(offsetof(UPalCharacterCameraComponent, MaxSpeedBlurSpeed) == 0x000B20, "Member 'UPalCharacterCameraComponent::MaxSpeedBlurSpeed' has a wrong offset!");
static_assert(offsetof(UPalCharacterCameraComponent, MaxSpeedBlurAlpha) == 0x000B24, "Member 'UPalCharacterCameraComponent::MaxSpeedBlurAlpha' has a wrong offset!");
static_assert(offsetof(UPalCharacterCameraComponent, bIsEnableAimBlur) == 0x000B28, "Member 'UPalCharacterCameraComponent::bIsEnableAimBlur' has a wrong offset!");
static_assert(offsetof(UPalCharacterCameraComponent, DynamicAimBlurMaterial) == 0x000B30, "Member 'UPalCharacterCameraComponent::DynamicAimBlurMaterial' has a wrong offset!");
static_assert(offsetof(UPalCharacterCameraComponent, BlendInAimBlurInterpTime) == 0x000B38, "Member 'UPalCharacterCameraComponent::BlendInAimBlurInterpTime' has a wrong offset!");
static_assert(offsetof(UPalCharacterCameraComponent, BlendOutAimBlurInterpTime) == 0x000B3C, "Member 'UPalCharacterCameraComponent::BlendOutAimBlurInterpTime' has a wrong offset!");
static_assert(offsetof(UPalCharacterCameraComponent, AimFOVInterpTime) == 0x000B40, "Member 'UPalCharacterCameraComponent::AimFOVInterpTime' has a wrong offset!");
static_assert(offsetof(UPalCharacterCameraComponent, AimFOV) == 0x000B44, "Member 'UPalCharacterCameraComponent::AimFOV' has a wrong offset!");
static_assert(offsetof(UPalCharacterCameraComponent, RotateSpeedRate) == 0x000B48, "Member 'UPalCharacterCameraComponent::RotateSpeedRate' has a wrong offset!");
static_assert(offsetof(UPalCharacterCameraComponent, DynamicSpeedBlurMaterialDynamic) == 0x000BB8, "Member 'UPalCharacterCameraComponent::DynamicSpeedBlurMaterialDynamic' has a wrong offset!");
static_assert(offsetof(UPalCharacterCameraComponent, DynamicAimBlurMaterialDynamic) == 0x000BC0, "Member 'UPalCharacterCameraComponent::DynamicAimBlurMaterialDynamic' has a wrong offset!");

// Class Pal.PalPlayerDataCharacterMake
// 0x0098 (0x00C0 - 0x0028)
class UPalPlayerDataCharacterMake : public UObject
{
public:
	uint8                                         Pad_2A0B[0x98];                                    // 0x0028(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetPresetMakeInfo(class UObject* WorldContextObject, const class FName& PresetName, struct FPalPlayerDataCharacterMakeInfo* OutMakeInfo);

	const struct FPalPlayerDataCharacterMakeInfo GetMakeData() const;
	class FName GetRandomBodyMeshName() const;
	class FName GetRandomHairMeshName() const;
	class FName GetRandomHeadMeshName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalPlayerDataCharacterMake">();
	}
	static class UPalPlayerDataCharacterMake* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalPlayerDataCharacterMake>();
	}
};
static_assert(alignof(UPalPlayerDataCharacterMake) == 0x000008, "Wrong alignment on UPalPlayerDataCharacterMake");
static_assert(sizeof(UPalPlayerDataCharacterMake) == 0x0000C0, "Wrong size on UPalPlayerDataCharacterMake");

// Class Pal.PalCharacterContainerManager
// 0x0150 (0x01C0 - 0x0070)
class UPalCharacterContainerManager : public UPalWorldSubsystem
{
public:
	uint8                                         Pad_2A0D[0x10];                                    // 0x0070(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FPalContainerId, class UPalIndividualCharacterContainer*> ContainerMap_InServer;                             // 0x0080(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A0E[0x50];                                    // 0x00D0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FPalContainerId, class UPalIndividualCharacterContainer*> LocalContainerMap;                                 // 0x0120(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	TSet<struct FPalContainerId>                  LoadedContainerIDs;                                // 0x0170(0x0050)(NativeAccessSpecifierPrivate)

public:
	class UPalIndividualCharacterContainer* GetContainer(const struct FPalContainerId& ContainerId) const;
	class UPalIndividualCharacterContainer* GetLocalContainer(const struct FPalContainerId& ContainerId) const;
	class UPalIndividualCharacterSlot* GetLocalSlot(const struct FPalContainerId& ContainerId, const int32 SlotIndex) const;
	bool TryGetContainer(const struct FPalContainerId& ContainerId, class UPalIndividualCharacterContainer** Container) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalCharacterContainerManager">();
	}
	static class UPalCharacterContainerManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalCharacterContainerManager>();
	}
};
static_assert(alignof(UPalCharacterContainerManager) == 0x000008, "Wrong alignment on UPalCharacterContainerManager");
static_assert(sizeof(UPalCharacterContainerManager) == 0x0001C0, "Wrong size on UPalCharacterContainerManager");
static_assert(offsetof(UPalCharacterContainerManager, ContainerMap_InServer) == 0x000080, "Member 'UPalCharacterContainerManager::ContainerMap_InServer' has a wrong offset!");
static_assert(offsetof(UPalCharacterContainerManager, LocalContainerMap) == 0x000120, "Member 'UPalCharacterContainerManager::LocalContainerMap' has a wrong offset!");
static_assert(offsetof(UPalCharacterContainerManager, LoadedContainerIDs) == 0x000170, "Member 'UPalCharacterContainerManager::LoadedContainerIDs' has a wrong offset!");

// Class Pal.PalFunnelSkillModuleReticleTargetAttack
// 0x0018 (0x0048 - 0x0030)
class UPalFunnelSkillModuleReticleTargetAttack final : public UPalFunnelSkillModule
{
public:
	bool                                          bShouldSetSkillAction;                             // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A11[0x3];                                     // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SearchRange;                                       // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A12[0x4];                                     // 0x0038(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CoolTime;                                          // 0x003C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class APalCharacter>           ReticleTarget;                                     // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Reset();

	class APalCharacter* GetTarget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalFunnelSkillModuleReticleTargetAttack">();
	}
	static class UPalFunnelSkillModuleReticleTargetAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalFunnelSkillModuleReticleTargetAttack>();
	}
};
static_assert(alignof(UPalFunnelSkillModuleReticleTargetAttack) == 0x000008, "Wrong alignment on UPalFunnelSkillModuleReticleTargetAttack");
static_assert(sizeof(UPalFunnelSkillModuleReticleTargetAttack) == 0x000048, "Wrong size on UPalFunnelSkillModuleReticleTargetAttack");
static_assert(offsetof(UPalFunnelSkillModuleReticleTargetAttack, bShouldSetSkillAction) == 0x000030, "Member 'UPalFunnelSkillModuleReticleTargetAttack::bShouldSetSkillAction' has a wrong offset!");
static_assert(offsetof(UPalFunnelSkillModuleReticleTargetAttack, SearchRange) == 0x000034, "Member 'UPalFunnelSkillModuleReticleTargetAttack::SearchRange' has a wrong offset!");
static_assert(offsetof(UPalFunnelSkillModuleReticleTargetAttack, CoolTime) == 0x00003C, "Member 'UPalFunnelSkillModuleReticleTargetAttack::CoolTime' has a wrong offset!");
static_assert(offsetof(UPalFunnelSkillModuleReticleTargetAttack, ReticleTarget) == 0x000040, "Member 'UPalFunnelSkillModuleReticleTargetAttack::ReticleTarget' has a wrong offset!");

// Class Pal.PalCharacterImportanceManager
// 0x00A8 (0x00D0 - 0x0028)
class UPalCharacterImportanceManager : public UObject
{
public:
	uint8                                         Pad_2A13[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APalPlayerCharacter*>            PlayerList;                                        // 0x0030(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class APalPlayerCharacter*>            PlayerList_ForOutsideGet;                          // 0x0040(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<EPalCharacterImportanceType, struct FCharacterListForImportanceManager> CharacterMap;                                      // 0x0050(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TArray<class APalNPCSpawnerBase*>             SpawnerList;                                       // 0x00A0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A14[0x20];                                    // 0x00B0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetAllNPC(TArray<class APalCharacter*>* OutArray);
	void GetAllPalCharacter(TArray<class APalCharacter*>* OutArray);
	void GetAllPlayer(TArray<class APalCharacter*>* OutArray);
	void GetImportantNPC(TArray<class APalCharacter*>* OutArray);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalCharacterImportanceManager">();
	}
	static class UPalCharacterImportanceManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalCharacterImportanceManager>();
	}
};
static_assert(alignof(UPalCharacterImportanceManager) == 0x000008, "Wrong alignment on UPalCharacterImportanceManager");
static_assert(sizeof(UPalCharacterImportanceManager) == 0x0000D0, "Wrong size on UPalCharacterImportanceManager");
static_assert(offsetof(UPalCharacterImportanceManager, PlayerList) == 0x000030, "Member 'UPalCharacterImportanceManager::PlayerList' has a wrong offset!");
static_assert(offsetof(UPalCharacterImportanceManager, PlayerList_ForOutsideGet) == 0x000040, "Member 'UPalCharacterImportanceManager::PlayerList_ForOutsideGet' has a wrong offset!");
static_assert(offsetof(UPalCharacterImportanceManager, CharacterMap) == 0x000050, "Member 'UPalCharacterImportanceManager::CharacterMap' has a wrong offset!");
static_assert(offsetof(UPalCharacterImportanceManager, SpawnerList) == 0x0000A0, "Member 'UPalCharacterImportanceManager::SpawnerList' has a wrong offset!");

// Class Pal.PalCharacterLiftupObjectComponent
// 0x0068 (0x0108 - 0x00A0)
class UPalCharacterLiftupObjectComponent final : public UActorComponent
{
public:
	uint8                                         Pad_2A15[0xA];                                     // 0x00A0(0x000A)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsLifting;                                        // 0x00AA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A16[0x9];                                     // 0x00AB(0x0009)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnableLiftup;                                     // 0x00B4(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A17[0x53];                                    // 0x00B5(0x0053)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastSetBeingThrown(const bool bInBeingThrown);
	void OnHitOwnerMainMesh(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnOverlapEndCageAreaWalls();
	void SetEnable(const bool bInEnable);

	struct FGuid GetLastLiftRequestedPlayerUId() const;
	bool IsLifting() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalCharacterLiftupObjectComponent">();
	}
	static class UPalCharacterLiftupObjectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalCharacterLiftupObjectComponent>();
	}
};
static_assert(alignof(UPalCharacterLiftupObjectComponent) == 0x000008, "Wrong alignment on UPalCharacterLiftupObjectComponent");
static_assert(sizeof(UPalCharacterLiftupObjectComponent) == 0x000108, "Wrong size on UPalCharacterLiftupObjectComponent");
static_assert(offsetof(UPalCharacterLiftupObjectComponent, bIsLifting) == 0x0000AA, "Member 'UPalCharacterLiftupObjectComponent::bIsLifting' has a wrong offset!");
static_assert(offsetof(UPalCharacterLiftupObjectComponent, bEnableLiftup) == 0x0000B4, "Member 'UPalCharacterLiftupObjectComponent::bEnableLiftup' has a wrong offset!");

// Class Pal.PalPlayerHeadAnimInstance
// 0x0030 (0x0380 - 0x0350)
class UPalPlayerHeadAnimInstance : public UAnimInstance
{
public:
	struct FVector                                PlayerEyeLocationRight;                            // 0x0348(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                PlayerEyeLocationLeft;                             // 0x0360(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A18[0x8];                                     // 0x0378(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetPlayerEyeLocation(class USkeletalMesh* HeadMesh);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalPlayerHeadAnimInstance">();
	}
	static class UPalPlayerHeadAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalPlayerHeadAnimInstance>();
	}
};
static_assert(alignof(UPalPlayerHeadAnimInstance) == 0x000010, "Wrong alignment on UPalPlayerHeadAnimInstance");
static_assert(sizeof(UPalPlayerHeadAnimInstance) == 0x000380, "Wrong size on UPalPlayerHeadAnimInstance");
static_assert(offsetof(UPalPlayerHeadAnimInstance, PlayerEyeLocationRight) == 0x000348, "Member 'UPalPlayerHeadAnimInstance::PlayerEyeLocationRight' has a wrong offset!");
static_assert(offsetof(UPalPlayerHeadAnimInstance, PlayerEyeLocationLeft) == 0x000360, "Member 'UPalPlayerHeadAnimInstance::PlayerEyeLocationLeft' has a wrong offset!");

// Class Pal.PalFootIKComponent
// 0x0108 (0x01A8 - 0x00A0)
class UPalFootIKComponent final : public UActorComponent
{
public:
	bool                                          bIsEnableFootIK;                                   // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A19[0x3];                                     // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinMeshOffset;                                     // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootIKInterpTime;                                  // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A1A[0x4];                                     // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EPalFootType, struct FFootIKSetting>     FootIKSettings;                                    // 0x00B0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         FootIKMeshOffset;                                  // 0x0100(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A1B[0x4];                                     // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EPalFootType, struct FHitResult>         FootGroundResult;                                  // 0x0108(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A1C[0x50];                                    // 0x0158(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetFootIKDisable(class FName FlagName, bool bIsDisable);

	bool IsEnableFootIK() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalFootIKComponent">();
	}
	static class UPalFootIKComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalFootIKComponent>();
	}
};
static_assert(alignof(UPalFootIKComponent) == 0x000008, "Wrong alignment on UPalFootIKComponent");
static_assert(sizeof(UPalFootIKComponent) == 0x0001A8, "Wrong size on UPalFootIKComponent");
static_assert(offsetof(UPalFootIKComponent, bIsEnableFootIK) == 0x0000A0, "Member 'UPalFootIKComponent::bIsEnableFootIK' has a wrong offset!");
static_assert(offsetof(UPalFootIKComponent, MinMeshOffset) == 0x0000A4, "Member 'UPalFootIKComponent::MinMeshOffset' has a wrong offset!");
static_assert(offsetof(UPalFootIKComponent, FootIKInterpTime) == 0x0000A8, "Member 'UPalFootIKComponent::FootIKInterpTime' has a wrong offset!");
static_assert(offsetof(UPalFootIKComponent, FootIKSettings) == 0x0000B0, "Member 'UPalFootIKComponent::FootIKSettings' has a wrong offset!");
static_assert(offsetof(UPalFootIKComponent, FootIKMeshOffset) == 0x000100, "Member 'UPalFootIKComponent::FootIKMeshOffset' has a wrong offset!");
static_assert(offsetof(UPalFootIKComponent, FootGroundResult) == 0x000108, "Member 'UPalFootIKComponent::FootGroundResult' has a wrong offset!");

// Class Pal.PalCharacterManager
// 0x01E0 (0x0250 - 0x0070)
class UPalCharacterManager : public UPalWorldSubsystem
{
public:
	uint8                                         Pad_2A1E[0x58];                                    // 0x0070(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnIndividualParameterSynced;                       // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A1F[0x10];                                    // 0x00D8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UPalActionBase>             AttackNearBaseClass;                               // 0x00E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalActionBase>             AttackFarBaseClass;                                // 0x00F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FPalInstanceID, class UPalIndividualCharacterParameter*> IndividualParameterMap;                            // 0x00F8(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	TMap<struct FPalInstanceID, TWeakObjectPtr<class UPalIndividualCharacterHandle>> WeakIndividualHandleMap;                           // 0x0148(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class UPalIndividualCharacterHandle*>  InitializeWaitingHandles;                          // 0x0198(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UPalIndividualCharacterHandle*>  NoHoldHandles;                                     // 0x01A8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<struct FPalInstanceID, class UPalIndividualCharacterHandleReference*> CachedRefenrenceOnlyHandles;                       // 0x01B8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A20[0x8];                                     // 0x0208(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UPalIndividualCharacterHandle*>  CreatingHandles;                                   // 0x0210(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UPalIndividualCharacterHandle*>  SpawningActorHandles;                              // 0x0220(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UPalIndividualCharacterHandle*>  ReserveDestroyActorHandles;                        // 0x0230(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UPalIndividualCharacterParameter*> CachedIndividualParameterList;                     // 0x0240(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void CharacterHandleDelegate__DelegateSignature(class UPalIndividualCharacterHandle* CharacterHandle);
	void CharacterParameterAddedDelegate__DelegateSignature(const struct FPalInstanceID& InstanceId);
	class UPalIndividualCharacterHandle* CreateIndividual(const struct FPalIndividualCharacterSaveParameter& InitParameter, TDelegate<void(const struct FPalInstanceID& ID)> SpawnCallback);
	void IndividualIDCallback__DelegateSignature(const struct FPalInstanceID& ID);
	class UPalIndividualCharacterHandle* CreateIndividualByFixedID(const struct FPalInstanceID& ID, const struct FPalIndividualCharacterSaveParameter& InitParameter, TDelegate<void(const struct FPalInstanceID& ID)> SpawnCallback);
	void DespawnCharacterByHandle(class UPalIndividualCharacterHandle* Handle, TDelegate<void(const struct FPalInstanceID& ID)> SpawnCallback);
	void DespawnPhantomByHandle(class UPalIndividualCharacterHandle* Handle, int32 PhantomId, TDelegate<void(const struct FPalInstanceID& ID, int32 PhantomId)> SpawnCallback);
	void IndividualPhantomIDCallback__DelegateSignature(const struct FPalInstanceID& ID, int32 PhantomId);
	class UPalIndividualCharacterHandle* GetIndividualHandle(const struct FPalInstanceID& ID);
	class UPalIndividualCharacterHandle* GetIndividualHandleFromCharacterParameter(class UPalIndividualCharacterParameter* Parameter);
	class UPalIndividualCharacterHandleReference* GetIndividualHandleReference(const struct FPalInstanceID& ID);
	void OnCreateIndividualID(const struct FPalInstanceID& ID);
	void RaiseToMainActor(class UPalIndividualCharacterHandle* Handle, int32 PhantomId, TDelegate<void(const struct FPalInstanceID& ID, int32 PhantomId)> Callback);
	void SpawnCharacterByHandle(class UPalIndividualCharacterHandle* Handle, const struct FNetworkActorSpawnParameters& SpawnParameter, TDelegate<void(const struct FPalInstanceID& ID)> SpawnCallback);
	void SpawnCharacterByHandleWithInitializeParameterCallback(class UPalIndividualCharacterHandle* Handle, const struct FNetworkActorSpawnParameters& SpawnParameter, EPalCharacterCompleteDelegatePriority InitializeParameterCallbackPriority, TDelegate<void(class APalCharacter* InCharacter)> InitializeParameterCallback, TDelegate<void(const struct FPalInstanceID& ID)> SpawnCallback);
	class UPalIndividualCharacterHandle* SpawnNewCharacter(const struct FPalIndividualCharacterSaveParameter& InitParameter, const struct FNetworkActorSpawnParameters& SpawnParameter, TDelegate<void(const struct FPalInstanceID& ID)> SpawnCallback);
	class UPalIndividualCharacterHandle* SpawnNewCharacterWithInitializeParameterCallback(const struct FPalIndividualCharacterSaveParameter& InitParameter, const struct FNetworkActorSpawnParameters& SpawnParameter, EPalCharacterCompleteDelegatePriority InitializeParameterCallbackPriority, TDelegate<void(class APalCharacter* InCharacter)> InitializeParameterCallback, TDelegate<void(const struct FPalInstanceID& ID)> SpawnCallback);
	void SpawnPhantomByHandle(class UPalIndividualCharacterHandle* Handle, const struct FNetworkActorSpawnParameters& SpawnParameter, TDelegate<void(const struct FPalInstanceID& ID, int32 PhantomId)> SpawnCallback);

	class UPalIndividualCharacterParameter* GetIndividualCharacterParameter(const struct FPalInstanceID& IndividualId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalCharacterManager">();
	}
	static class UPalCharacterManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalCharacterManager>();
	}
};
static_assert(alignof(UPalCharacterManager) == 0x000008, "Wrong alignment on UPalCharacterManager");
static_assert(sizeof(UPalCharacterManager) == 0x000250, "Wrong size on UPalCharacterManager");
static_assert(offsetof(UPalCharacterManager, OnIndividualParameterSynced) == 0x0000C8, "Member 'UPalCharacterManager::OnIndividualParameterSynced' has a wrong offset!");
static_assert(offsetof(UPalCharacterManager, AttackNearBaseClass) == 0x0000E8, "Member 'UPalCharacterManager::AttackNearBaseClass' has a wrong offset!");
static_assert(offsetof(UPalCharacterManager, AttackFarBaseClass) == 0x0000F0, "Member 'UPalCharacterManager::AttackFarBaseClass' has a wrong offset!");
static_assert(offsetof(UPalCharacterManager, IndividualParameterMap) == 0x0000F8, "Member 'UPalCharacterManager::IndividualParameterMap' has a wrong offset!");
static_assert(offsetof(UPalCharacterManager, WeakIndividualHandleMap) == 0x000148, "Member 'UPalCharacterManager::WeakIndividualHandleMap' has a wrong offset!");
static_assert(offsetof(UPalCharacterManager, InitializeWaitingHandles) == 0x000198, "Member 'UPalCharacterManager::InitializeWaitingHandles' has a wrong offset!");
static_assert(offsetof(UPalCharacterManager, NoHoldHandles) == 0x0001A8, "Member 'UPalCharacterManager::NoHoldHandles' has a wrong offset!");
static_assert(offsetof(UPalCharacterManager, CachedRefenrenceOnlyHandles) == 0x0001B8, "Member 'UPalCharacterManager::CachedRefenrenceOnlyHandles' has a wrong offset!");
static_assert(offsetof(UPalCharacterManager, CreatingHandles) == 0x000210, "Member 'UPalCharacterManager::CreatingHandles' has a wrong offset!");
static_assert(offsetof(UPalCharacterManager, SpawningActorHandles) == 0x000220, "Member 'UPalCharacterManager::SpawningActorHandles' has a wrong offset!");
static_assert(offsetof(UPalCharacterManager, ReserveDestroyActorHandles) == 0x000230, "Member 'UPalCharacterManager::ReserveDestroyActorHandles' has a wrong offset!");
static_assert(offsetof(UPalCharacterManager, CachedIndividualParameterList) == 0x000240, "Member 'UPalCharacterManager::CachedIndividualParameterList' has a wrong offset!");

// Class Pal.PalCharacterManagerReplicator
// 0x0148 (0x0170 - 0x0028)
class UPalCharacterManagerReplicator final : public UPalGameStateReplicatorBase
{
public:
	struct FFastCharacterParameterRepInfoArray    CharacterParameterInfosFast;                       // 0x0028(0x0148)(Net, RepNotify, NativeAccessSpecifierPrivate)

public:
	void OnPep_CharacterParameterInfos();
	void OnPostReplicatedAddItem(const struct FCharacterParameterRepInfo& Item);
	void OnPostReplicatedChangeItem(const struct FCharacterParameterRepInfo& Item);
	void OnPreReplicatedRemoveItem(const struct FCharacterParameterRepInfo& Item);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalCharacterManagerReplicator">();
	}
	static class UPalCharacterManagerReplicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalCharacterManagerReplicator>();
	}
};
static_assert(alignof(UPalCharacterManagerReplicator) == 0x000008, "Wrong alignment on UPalCharacterManagerReplicator");
static_assert(sizeof(UPalCharacterManagerReplicator) == 0x000170, "Wrong size on UPalCharacterManagerReplicator");
static_assert(offsetof(UPalCharacterManagerReplicator, CharacterParameterInfosFast) == 0x000028, "Member 'UPalCharacterManagerReplicator::CharacterParameterInfosFast' has a wrong offset!");

// Class Pal.PalFoliagePresetDataSet
// 0x0050 (0x0080 - 0x0030)
class UPalFoliagePresetDataSet final : public UDataAsset
{
public:
	TMap<EPalFoliagePresetType, struct FPalFoliagePresetData> Presets;                                           // 0x0030(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalFoliagePresetDataSet">();
	}
	static class UPalFoliagePresetDataSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalFoliagePresetDataSet>();
	}
};
static_assert(alignof(UPalFoliagePresetDataSet) == 0x000008, "Wrong alignment on UPalFoliagePresetDataSet");
static_assert(sizeof(UPalFoliagePresetDataSet) == 0x000080, "Wrong size on UPalFoliagePresetDataSet");
static_assert(offsetof(UPalFoliagePresetDataSet, Presets) == 0x000030, "Member 'UPalFoliagePresetDataSet::Presets' has a wrong offset!");

// Class Pal.PalCharacterMovementComponent
// 0x07D0 (0x16D0 - 0x0F00)
class UPalCharacterMovementComponent final : public UCharacterMovementComponent
{
public:
	FMulticastInlineDelegateProperty_             OnMovementModeChangedDelegate;                     // 0x0EF8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnJumpDelegate;                                    // 0x0F08(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFlyDelegate;                                     // 0x0F18(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLandedDelegate;                                  // 0x0F28(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeCrouchDelegate;                            // 0x0F38(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeSprintDelegate;                            // 0x0F48(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeSlidingDelegate;                           // 0x0F58(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeSwimmingDelegate;                          // 0x0F68(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEnterWaterDelegate;                              // 0x0F78(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnExitWaterDelegate;                               // 0x0F88(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnJumpDisableDelegate;                             // 0x0F98(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         DyingMaxSpeed;                                     // 0x0FA8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FatigueMaxSpeed;                                   // 0x0FAC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintMaxSpeed;                                    // 0x0FB0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintMaxAcceleration;                             // 0x0FB4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintYawRate;                                     // 0x0FB8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GliderMaxSpeed;                                    // 0x0FBC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GliderAirControl;                                  // 0x0FC0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GliderGravityScale;                                // 0x0FC4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlidingStartSpeed;                                 // 0x0FC8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlidingMaxSpeed;                                   // 0x0FCC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlidingAddRate;                                    // 0x0FD0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlidingSubRate;                                    // 0x0FD4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlidingYawRate;                                    // 0x0FD8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEnableSkySliding;                               // 0x0FDC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A28[0x3];                                     // 0x0FDD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClimbMaxSpeed;                                     // 0x0FE0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RollingMaxSpeed;                                   // 0x0FE4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastLandedTransformCacheNum;                       // 0x0FE8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUseLastLandedCache;                             // 0x0FEC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A29[0x3];                                     // 0x0FED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, float>                            OverrideJumpZVelocityMap;                          // 0x0FF0(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      MaxAccelerationMultiplierMap;                      // 0x1040(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	TMap<class FName, float>                      WalkSpeedMultiplierMap;                            // 0x1090(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	TMap<class FName, float>                      YawRotatorMultiplierMap;                           // 0x10E0(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	TMap<class FName, float>                      GravityZMultiplierMap;                             // 0x1130(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	TMap<class FName, float>                      AirControlXYMultiplierMap;                         // 0x1180(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	TMap<class FName, float>                      SlideAlphaMultiplierMap;                           // 0x11D0(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	struct FFlagContainer                         MoveDisableFlag;                                   // 0x1220(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	struct FFlagContainer                         InputDisableFlag;                                  // 0x1270(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	struct FFlagContainer                         JumpDisableFlag;                                   // 0x12C0(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	struct FFlagContainer                         DriveMoveFlag;                                     // 0x1310(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	struct FFlagContainer                         PysicsAccelerationFlag;                            // 0x1360(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	struct FVector                                ClientLocation;                                    // 0x13B0(0x0018)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A2A[0x8];                                     // 0x13C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFlagContainer                         CrouchDisableFlag;                                 // 0x13D0(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	struct FFlagContainer                         SlidingDisableFlag;                                // 0x1420(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	struct FFlagContainer                         GliderDisableFlag;                                 // 0x1470(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	struct FFlagContainer                         SplintDisableFlag;                                 // 0x14C0(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	bool                                          bRequestCrouch;                                    // 0x1510(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRequestSprint;                                    // 0x1511(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A2B[0x6];                                     // 0x1512(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LastLandingInputVelocity;                          // 0x1518(0x0018)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FVector>                        LastLandingLocationCache;                          // 0x1530(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	struct FFlagContainer                         StepDisableFlag;                                   // 0x1540(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	struct FFlagContainer                         NavWalkDisableFlag;                                // 0x1590(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	TMap<EPalWalkableFloorAnglePriority, float>   WalkableFloorAngleOverridesMap;                    // 0x15E0(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	float                                         SlowWalkSpeed_Default;                             // 0x1630(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WalkSpeed_Default;                                 // 0x1634(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RunSpeed_Default;                                  // 0x1638(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RideSprintSpeed_Default;                           // 0x163C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TransportSpeed_Default;                            // 0x1640(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TemporaryAccelerationTimeCount;                    // 0x1644(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsFlyDashMode;                                     // 0x1648(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsGrapplingMoving;                                // 0x1649(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A2C[0x2];                                     // 0x164A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultMaxStepHeight;                              // 0x164C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPalCharacterMovementCustomMode               CustomMovementMode_ForReplicate;                   // 0x1650(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A2D[0x3];                                     // 0x1651(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InWaterRate;                                       // 0x1654(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DashSwimMaxSpeed;                                  // 0x1658(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpableInWaterDepth;                              // 0x165C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEnterWaterFlag                               EnteredWaterFlag;                                  // 0x1660(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A2E[0x3];                                     // 0x1661(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WaterPlaneZ;                                       // 0x1664(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WaterPlaneZPrev;                                   // 0x1668(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WaitTimeToSwimInFalling;                           // 0x166C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsDashSwim;                                       // 0x1670(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A2F[0x5F];                                    // 0x1671(0x005F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckReturnToNavWakl();
	float GetDefaultRunSpeed();
	void Jump();
	void MergeLastLandingLocationCache(const class UPalCharacterMovementComponent* MovementComponent);
	void OnChangeActiveCharacter(bool bInIsActive);
	void OnChangeCrouch(class UPalCharacterMovementComponent* Component, bool IsInCrouch);
	void OnChangeCrouch__DelegateSignature(class UPalCharacterMovementComponent* Component, bool IsInCrouch);
	void OnChangeSliding__DelegateSignature(class UPalCharacterMovementComponent* Component, bool IsInSliding);
	void OnChangeSprint__DelegateSignature(class UPalCharacterMovementComponent* Component, bool IsInSprint);
	void OnChangeSwimming__DelegateSignature(bool IsInSwimming);
	void OnDeactivated(class UActorComponent* Component);
	void OnEnterWater();
	void OnEnterWater__DelegateSignature();
	void OnExitWater();
	void OnExitWater__DelegateSignature();
	void OnFlyDelegate__DelegateSignature(class UPalCharacterMovementComponent* Component);
	void OnJumpDelegate__DelegateSignature(class UPalCharacterMovementComponent* Component);
	void OnJumpDisable__DelegateSignature();
	void OnLandedDelegate__DelegateSignature(class UPalCharacterMovementComponent* Component, const struct FHitResult& Hit);
	void OnMovementModeChangedDelegate__DelegateSignature(class UPalCharacterMovementComponent* Component, EMovementMode PrevMode, EMovementMode NewMode, EPalCharacterMovementCustomMode PrevCustomMode, EPalCharacterMovementCustomMode NewCustomMode);
	void OnRep_CustomMovementMode_ForReplicate();
	void RemoveWalkableFloorAngleOverrides(EPalWalkableFloorAnglePriority Priority);
	void RequestTemporaryAcceleration();
	void ResetLastLandingLocationCache();
	void SetAirControlXYMultiplier(class FName FlagName, float Rate);
	void SetCrouchDisbleFlag(class FName FlagName, bool Disable);
	void SetCustomMovementMode(EPalCharacterMovementCustomMode NewCustomMode);
	void SetDashSwimming(bool _isDash);
	void SetDashSwimming_ToServer(bool _isDash);
	void SetDisableLeftHandAttachFlag(bool IsDisable);
	void SetDriveMoveFlag(class FName FlagName, bool IsEnable);
	void SetFlyDashMode_ToServer(bool IsDash);
	void SetForceMaxAccel(bool bIsEnable);
	void SetGliderDisbleFlag(class FName FlagName, bool Disable);
	void SetGrapplingMoving(bool IsMoving);
	void SetGravityZMultiplier(class FName FlagName, float Rate);
	void SetInputDisableFlag(class FName FlagName, bool IsDisable);
	void SetJumpDisableFlag(class FName FlagName, bool IsDisable);
	void SetMaxAccelerationMultiplier(class FName FlagName, float Speed);
	void SetMoveDisableFlag(class FName FlagName, bool IsDisable);
	void SetNavWalkDisableFlag(class FName FlagName, bool IsDisable);
	void SetPysicsAccelerationFlag(class FName FlagName, bool IsEnable);
	void SetSlideAlphaMultiplier(class FName FlagName, float Rate);
	void SetSlidingDisbleFlag(class FName FlagName, bool Disable);
	void SetSplintDisbleFlag(class FName FlagName, bool Disable);
	void SetStepDisableFlag(class FName FlagName, bool IsDisable);
	void SetupDatabaseSpeed(class APalCharacter* InCharacter);
	void SetupDatabaseSpeedByCharacterId(class APalCharacter* InCharacter, class FName CharaID);
	void SetWalkableFloorAngleOverrides(EPalWalkableFloorAnglePriority Priority, float Angle);
	void SetWalkSpeedByType(class FName FlagName, EPalMovementSpeedType MoveSpeedType);
	void SetWalkSpeedMultiplier(class FName FlagName, float Speed);
	void SetYawRotatorMultiplier(class FName FlagName, float Rate);

	bool CanDashSwimming() const;
	bool CanGainSP() const;
	bool CanSliding() const;
	float GetAirControlXYMultiplier() const;
	EPalCharacterMovementCustomMode GetCustomMovementMode() const;
	float GetGravityZMultiplier() const;
	float GetInWaterRate() const;
	struct FVector GetLastLandingLocation() const;
	struct FVector GetLastLandingLocationFromLastOfCache() const;
	float GetMaxAccelerationMultiplier() const;
	float GetSlideAlphaMultiplier() const;
	struct FVector GetVelocity() const;
	float GetWalkableFloorAngleByPriority() const;
	float GetWalkSpeedMultiplier() const;
	struct FVector GetWaterPlaneLocation() const;
	struct FVector GetWaterPlaneNormal() const;
	float GetYawRotatorMultiplier() const;
	bool IsClimbing() const;
	bool IsDashSwimming() const;
	bool IsDriveMove() const;
	bool IsEnableSkySliding() const;
	bool IsEnteredWater() const;
	bool IsFallingFromSwimming() const;
	bool IsGliding() const;
	bool IsGrapplingMoving() const;
	bool IsInputDisabled() const;
	bool IsJumpDisabled() const;
	bool IsMoveDisabled() const;
	bool IsNavWalkDisabled() const;
	bool IsPysicsAcceleration() const;
	bool IsRequestSliding() const;
	bool IsSliding() const;
	bool IsSprint() const;
	bool IsStepDisabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalCharacterMovementComponent">();
	}
	static class UPalCharacterMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalCharacterMovementComponent>();
	}
};
static_assert(alignof(UPalCharacterMovementComponent) == 0x000010, "Wrong alignment on UPalCharacterMovementComponent");
static_assert(sizeof(UPalCharacterMovementComponent) == 0x0016D0, "Wrong size on UPalCharacterMovementComponent");
static_assert(offsetof(UPalCharacterMovementComponent, OnMovementModeChangedDelegate) == 0x000EF8, "Member 'UPalCharacterMovementComponent::OnMovementModeChangedDelegate' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, OnJumpDelegate) == 0x000F08, "Member 'UPalCharacterMovementComponent::OnJumpDelegate' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, OnFlyDelegate) == 0x000F18, "Member 'UPalCharacterMovementComponent::OnFlyDelegate' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, OnLandedDelegate) == 0x000F28, "Member 'UPalCharacterMovementComponent::OnLandedDelegate' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, OnChangeCrouchDelegate) == 0x000F38, "Member 'UPalCharacterMovementComponent::OnChangeCrouchDelegate' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, OnChangeSprintDelegate) == 0x000F48, "Member 'UPalCharacterMovementComponent::OnChangeSprintDelegate' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, OnChangeSlidingDelegate) == 0x000F58, "Member 'UPalCharacterMovementComponent::OnChangeSlidingDelegate' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, OnChangeSwimmingDelegate) == 0x000F68, "Member 'UPalCharacterMovementComponent::OnChangeSwimmingDelegate' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, OnEnterWaterDelegate) == 0x000F78, "Member 'UPalCharacterMovementComponent::OnEnterWaterDelegate' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, OnExitWaterDelegate) == 0x000F88, "Member 'UPalCharacterMovementComponent::OnExitWaterDelegate' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, OnJumpDisableDelegate) == 0x000F98, "Member 'UPalCharacterMovementComponent::OnJumpDisableDelegate' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, DyingMaxSpeed) == 0x000FA8, "Member 'UPalCharacterMovementComponent::DyingMaxSpeed' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, FatigueMaxSpeed) == 0x000FAC, "Member 'UPalCharacterMovementComponent::FatigueMaxSpeed' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, SprintMaxSpeed) == 0x000FB0, "Member 'UPalCharacterMovementComponent::SprintMaxSpeed' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, SprintMaxAcceleration) == 0x000FB4, "Member 'UPalCharacterMovementComponent::SprintMaxAcceleration' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, SprintYawRate) == 0x000FB8, "Member 'UPalCharacterMovementComponent::SprintYawRate' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, GliderMaxSpeed) == 0x000FBC, "Member 'UPalCharacterMovementComponent::GliderMaxSpeed' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, GliderAirControl) == 0x000FC0, "Member 'UPalCharacterMovementComponent::GliderAirControl' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, GliderGravityScale) == 0x000FC4, "Member 'UPalCharacterMovementComponent::GliderGravityScale' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, SlidingStartSpeed) == 0x000FC8, "Member 'UPalCharacterMovementComponent::SlidingStartSpeed' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, SlidingMaxSpeed) == 0x000FCC, "Member 'UPalCharacterMovementComponent::SlidingMaxSpeed' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, SlidingAddRate) == 0x000FD0, "Member 'UPalCharacterMovementComponent::SlidingAddRate' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, SlidingSubRate) == 0x000FD4, "Member 'UPalCharacterMovementComponent::SlidingSubRate' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, SlidingYawRate) == 0x000FD8, "Member 'UPalCharacterMovementComponent::SlidingYawRate' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, bIsEnableSkySliding) == 0x000FDC, "Member 'UPalCharacterMovementComponent::bIsEnableSkySliding' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, ClimbMaxSpeed) == 0x000FE0, "Member 'UPalCharacterMovementComponent::ClimbMaxSpeed' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, RollingMaxSpeed) == 0x000FE4, "Member 'UPalCharacterMovementComponent::RollingMaxSpeed' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, LastLandedTransformCacheNum) == 0x000FE8, "Member 'UPalCharacterMovementComponent::LastLandedTransformCacheNum' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, bIsUseLastLandedCache) == 0x000FEC, "Member 'UPalCharacterMovementComponent::bIsUseLastLandedCache' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, OverrideJumpZVelocityMap) == 0x000FF0, "Member 'UPalCharacterMovementComponent::OverrideJumpZVelocityMap' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, MaxAccelerationMultiplierMap) == 0x001040, "Member 'UPalCharacterMovementComponent::MaxAccelerationMultiplierMap' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, WalkSpeedMultiplierMap) == 0x001090, "Member 'UPalCharacterMovementComponent::WalkSpeedMultiplierMap' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, YawRotatorMultiplierMap) == 0x0010E0, "Member 'UPalCharacterMovementComponent::YawRotatorMultiplierMap' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, GravityZMultiplierMap) == 0x001130, "Member 'UPalCharacterMovementComponent::GravityZMultiplierMap' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, AirControlXYMultiplierMap) == 0x001180, "Member 'UPalCharacterMovementComponent::AirControlXYMultiplierMap' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, SlideAlphaMultiplierMap) == 0x0011D0, "Member 'UPalCharacterMovementComponent::SlideAlphaMultiplierMap' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, MoveDisableFlag) == 0x001220, "Member 'UPalCharacterMovementComponent::MoveDisableFlag' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, InputDisableFlag) == 0x001270, "Member 'UPalCharacterMovementComponent::InputDisableFlag' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, JumpDisableFlag) == 0x0012C0, "Member 'UPalCharacterMovementComponent::JumpDisableFlag' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, DriveMoveFlag) == 0x001310, "Member 'UPalCharacterMovementComponent::DriveMoveFlag' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, PysicsAccelerationFlag) == 0x001360, "Member 'UPalCharacterMovementComponent::PysicsAccelerationFlag' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, ClientLocation) == 0x0013B0, "Member 'UPalCharacterMovementComponent::ClientLocation' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, CrouchDisableFlag) == 0x0013D0, "Member 'UPalCharacterMovementComponent::CrouchDisableFlag' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, SlidingDisableFlag) == 0x001420, "Member 'UPalCharacterMovementComponent::SlidingDisableFlag' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, GliderDisableFlag) == 0x001470, "Member 'UPalCharacterMovementComponent::GliderDisableFlag' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, SplintDisableFlag) == 0x0014C0, "Member 'UPalCharacterMovementComponent::SplintDisableFlag' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, bRequestCrouch) == 0x001510, "Member 'UPalCharacterMovementComponent::bRequestCrouch' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, bRequestSprint) == 0x001511, "Member 'UPalCharacterMovementComponent::bRequestSprint' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, LastLandingInputVelocity) == 0x001518, "Member 'UPalCharacterMovementComponent::LastLandingInputVelocity' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, LastLandingLocationCache) == 0x001530, "Member 'UPalCharacterMovementComponent::LastLandingLocationCache' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, StepDisableFlag) == 0x001540, "Member 'UPalCharacterMovementComponent::StepDisableFlag' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, NavWalkDisableFlag) == 0x001590, "Member 'UPalCharacterMovementComponent::NavWalkDisableFlag' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, WalkableFloorAngleOverridesMap) == 0x0015E0, "Member 'UPalCharacterMovementComponent::WalkableFloorAngleOverridesMap' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, SlowWalkSpeed_Default) == 0x001630, "Member 'UPalCharacterMovementComponent::SlowWalkSpeed_Default' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, WalkSpeed_Default) == 0x001634, "Member 'UPalCharacterMovementComponent::WalkSpeed_Default' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, RunSpeed_Default) == 0x001638, "Member 'UPalCharacterMovementComponent::RunSpeed_Default' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, RideSprintSpeed_Default) == 0x00163C, "Member 'UPalCharacterMovementComponent::RideSprintSpeed_Default' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, TransportSpeed_Default) == 0x001640, "Member 'UPalCharacterMovementComponent::TransportSpeed_Default' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, TemporaryAccelerationTimeCount) == 0x001644, "Member 'UPalCharacterMovementComponent::TemporaryAccelerationTimeCount' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, IsFlyDashMode) == 0x001648, "Member 'UPalCharacterMovementComponent::IsFlyDashMode' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, bIsGrapplingMoving) == 0x001649, "Member 'UPalCharacterMovementComponent::bIsGrapplingMoving' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, DefaultMaxStepHeight) == 0x00164C, "Member 'UPalCharacterMovementComponent::DefaultMaxStepHeight' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, CustomMovementMode_ForReplicate) == 0x001650, "Member 'UPalCharacterMovementComponent::CustomMovementMode_ForReplicate' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, InWaterRate) == 0x001654, "Member 'UPalCharacterMovementComponent::InWaterRate' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, DashSwimMaxSpeed) == 0x001658, "Member 'UPalCharacterMovementComponent::DashSwimMaxSpeed' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, JumpableInWaterDepth) == 0x00165C, "Member 'UPalCharacterMovementComponent::JumpableInWaterDepth' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, EnteredWaterFlag) == 0x001660, "Member 'UPalCharacterMovementComponent::EnteredWaterFlag' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, WaterPlaneZ) == 0x001664, "Member 'UPalCharacterMovementComponent::WaterPlaneZ' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, WaterPlaneZPrev) == 0x001668, "Member 'UPalCharacterMovementComponent::WaterPlaneZPrev' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, WaitTimeToSwimInFalling) == 0x00166C, "Member 'UPalCharacterMovementComponent::WaitTimeToSwimInFalling' has a wrong offset!");
static_assert(offsetof(UPalCharacterMovementComponent, bIsDashSwim) == 0x001670, "Member 'UPalCharacterMovementComponent::bIsDashSwim' has a wrong offset!");

// Class Pal.PalCharacterParameterComponent
// 0x05D0 (0x0670 - 0x00A0)
class UPalCharacterParameterComponent final : public UActorComponent
{
public:
	bool                                          bIsCooping;                                        // 0x00A0(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEnableSendReticleTarget;                        // 0x00A1(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEnableMuteki;                                   // 0x00A2(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A42[0x5];                                     // 0x00A3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFixedPoint64                          LeanBackPoint;                                     // 0x00A8(0x0008)(Edit, BlueprintVisible, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FFixedPoint64                          LeanBackMaxPoint;                                  // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FFixedPoint64                          StunPoint;                                         // 0x00B8(0x0008)(Edit, BlueprintVisible, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FFixedPoint64                          StunMaxPoint;                                      // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          IsSPOverheat;                                      // 0x00C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHyperArmor;                                     // 0x00C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDebugMuteki;                                    // 0x00CA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPalElementType                               ElementType1;                                      // 0x00CB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPalElementType                               ElementType2;                                      // 0x00CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOverrideTarget;                                  // 0x00CD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A43[0x2];                                     // 0x00CE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OverrideTargetLocation;                            // 0x00D0(0x0018)(Edit, BlueprintVisible, Net, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APalCharacter*                          Trainer;                                           // 0x00E8(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APalCharacter*                          OtomoPal;                                          // 0x00F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  ReticleTargetActor;                                // 0x00F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalIndividualCharacterHandle*          IndividualHandle;                                  // 0x0100(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalIndividualCharacterParameter*       IndividualParameter;                               // 0x0108(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, InstancedReference, RepNotify, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsStun;                                            // 0x0110(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEnableSpeedCollision;                            // 0x0111(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCanSneakAttacked;                                // 0x0112(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFriendBulletIgnore;                              // 0x0113(0x0001)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BiologicalGrade;                                   // 0x0114(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPredator;                                        // 0x0118(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEdible;                                          // 0x0119(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A44[0x2];                                     // 0x011A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HiddenCollisionOverlapCount;                       // 0x011C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BurnCollisionOverlapCount;                         // 0x0120(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LavaCollisionOverlapCount;                         // 0x0124(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A45[0x1];                                     // 0x0128(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	EPalElementType                               DamageUpElement_ByElementStatus;                   // 0x0129(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPalElementType                               DamageDownElement_ByElementStatus;                 // 0x012A(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDarknessRandomAttack;                            // 0x012B(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AttackUp;                                          // 0x012C(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefenseUp;                                         // 0x0130(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A46[0x4];                                     // 0x0134(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EPalAdditionalEffectType, struct FPalStatusAccumulate> StatusAccumulateMap;                               // 0x0138(0x0050)(Transient, NativeAccessSpecifierPublic)
	bool                                          IsSleepAction;                                     // 0x0188(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A47[0x7];                                     // 0x0189(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                WildPalDrinkWaterPoint;                            // 0x0190(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDisableOtomoReturnEffect;                        // 0x01A8(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A48[0x3];                                     // 0x01A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxHPRate_ForTowerBoss;                            // 0x01AC(0x0004)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             GroundHitResult;                                   // 0x01B0(0x00E8)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A49[0x4];                                     // 0x0298(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsUseGroundRayCast;                               // 0x029C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A4A[0x3];                                     // 0x029D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFlagContainer                         DisableGroundRayCast;                              // 0x02A0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	struct FFixedPoint64                          SP;                                                // 0x02F0(0x0008)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGuid                                  BaseCampDefenseModelId;                            // 0x02F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPalMapBaseCampWorkerOrderType                BaseCampWorkerOrderType;                           // 0x0308(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBaseCampWorkerAttackableFriend;                   // 0x0309(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A4B[0x6];                                     // 0x030A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGuid, struct FPalMapObjectAppearanceData> UnreachableMapObjectInfos;                         // 0x0310(0x0050)(Transient, NativeAccessSpecifierPublic)
	struct FPalCharacterParameter_Work            Work;                                              // 0x0360(0x0078)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPublic)
	struct FPalWorkAssignHandleId                 WorkAssignId;                                      // 0x03D8(0x0018)(Edit, Net, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPalWorkType                                  WorkType;                                          // 0x03F0(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A4C[0x3];                                     // 0x03F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  BaseCampWalkAroundExcludeMapObjectInstanceId;      // 0x03F4(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PossessStaticItemId;                               // 0x0404(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBeingRescued;                                     // 0x040C(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A4D[0x3];                                     // 0x040D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DyingHP;                                           // 0x0410(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DyingMaxHP;                                        // 0x0414(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalItemContainer*                      ItemContainer;                                     // 0x0418(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsCapturedProcessing;                              // 0x0420(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A4E[0x7];                                     // 0x0421(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnUpdatePossessItemDelegate;                       // 0x0428(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateWorkAssignIdDelegate;                      // 0x0438(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSPOverheatDelegate;                              // 0x0448(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeTrapLegHoldDelegate;                       // 0x0458(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeTrapMovingPanelDelegate;                   // 0x0468(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FVector                                TrapDirection;                                     // 0x0478(0x0018)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FPalInstanceID, int32>            DamageMap;                                         // 0x0490(0x0050)(Transient, NativeAccessSpecifierPublic)
	bool                                          CanDropItem;                                       // 0x04E0(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A4F[0x7];                                     // 0x04E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFlagContainer                         DisableNaturalHealing_Component;                   // 0x04E8(0x0050)(Transient, NativeAccessSpecifierPublic)
	bool                                          IsImmortality;                                     // 0x0538(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A50[0xFF];                                    // 0x0539(0x00FF)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class AActor>>          TrapLegHoldList;                                   // 0x0638(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class AActor>>          TrapMovingPanelList;                               // 0x0648(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UPalOtomoAttackStopJudgeByBallList*     OtomoAttackStopJudge;                              // 0x0658(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FPalMapObjectAppearanceDataWithId> UnreachableMapObjectRepInfoArray;                  // 0x0660(0x0010)(Net, ZeroConstructor, Transient, NativeAccessSpecifierPublic)

public:
	void AddDyingHP(float AddHP);
	void AddTrapLegHold(class AActor* TrapActor);
	void AddTrapMovingPanel(class AActor* TrapActor);
	int32 GetCraftSpeed();
	int32 GetCraftSpeed_WorkSuitability(const EPalWorkSuitability WorkSuitability);
	int32 GetDefense();
	float GetFullStomach();
	float GetHPRate();
	bool GetIsCapturedProcessing();
	int32 GetLegHoldResistLevel();
	int32 GetLevel();
	float GetMaxFullStomach();
	struct FFixedPoint64 GetMaxHP();
	struct FFixedPoint64 GetMaxMP();
	float GetMaxSanity();
	struct FFixedPoint64 GetMaxSP();
	int32 GetMeleeAttack();
	struct FFixedPoint64 GetMP();
	void GetNickname(class FString* OutName);
	class UPalOtomoAttackStopJudgeByBallList* GetOtomoAttackStopJudge();
	struct FVector GetOverrideTargetLocation_ConsiderRide();
	float GetSanity();
	int32 GetShotAttack();
	struct FFixedPoint64 GetSP();
	bool IsInHiddenCollision();
	bool IsMuteki();
	void OnChangeTrapDelegate__DelegateSignature(bool IsExist);
	void OnDamage(const struct FPalDamageResult& DamageResult);
	void OnInitialize_AfterSetIndividualParameter(class APalCharacter* Character);
	void OnInitializedCharacter(class APalCharacter* OwnerCharacter);
	void OnRep_IndividualParameter();
	void OnRep_ItemContainer();
	void OnRep_PossessStaticItemId();
	void OnRep_Trainer();
	void OnSlipDamage(int32 Damage);
	void RemoveTrapLegHold(class AActor* TrapActor);
	void RemoveTrapMovingPanel(class AActor* TrapActor);
	void ResetDyingHP();
	void ResetSP();
	void ReviveFromDying();
	void SetCoopingFlag(bool IsEnable);
	void SetDisableCreateUNKO(class FName FlagName, bool IsDisable);
	void SetDisableNaturalHealing_Component(class FName Key, bool Disable);
	void SetElementTypeFromDatabase(class APalCharacter* InCharacter);
	void SetEnableSendReticleTarget(class FName FlagName, bool IsEnable);
	void SetHP(const struct FFixedPoint64& NewHP);
	void SetIsCapturedProcessing(bool IsCaptureProcess);
	void SetIsOverrideTarget(bool IsOverride);
	void SetIsOverrideTarget_Innner(bool IsOverride);
	void SetIsOverrideTarget_ToALL(int32 ID, bool IsOverride);
	void SetIsOverrideTarget_ToServer(int32 ID, bool IsOverride);
	void SetMaxMP(const struct FFixedPoint64& NewMaxMP);
	void SetMaxSP(const struct FFixedPoint64& NewMaxSP);
	void SetMP(const struct FFixedPoint64& NewMP);
	void SetMuteki(class FName FlagName, bool IsEnable);
	void SetOverrideTargetLocation(const struct FVector& TargetLocation);
	void SetOverrideTargetLocation_ToServer(const struct FVector& TargetLocation);
	void SetReticleTarget_ToServer(class AActor* Actor);
	void SetSP(const struct FFixedPoint64& NewSP);
	void SetTrainer(class APalCharacter* InTrainer);
	void SetupBiologicalGradeFromDatabase();
	void SPOverheatDelegate__DelegateSignature();
	void SubDyingHP(float SubHP);
	void UpdateParameterDelegate__DelegateSignature(class UPalCharacterParameterComponent* Parameter);
	void UpdateWorkAssignIdDelegate__DelegateSignature(class UPalCharacterParameterComponent* Parameter);
	void ZeroDyingHP();
	void ZeroDyingHP_ToServer();

	const struct FGuid GetBaseCampId() const;
	struct FVector GetFloorLocation() const;
	EPhysicalSurface GetFloorPhisicalSurface() const;
	const struct FHitResult GetHitGroundResult() const;
	struct FFixedPoint64 GetHP() const;
	class UPalIndividualCharacterParameter* GetIndividualParameter() const;
	const struct FGuid GetMapObjectInstanceIdApproachTo() const;
	float GetRadius() const;
	class UPalWorkBase* GetWork() const;
	class UPalWorkAssign* GetWorkAssign() const;
	const struct FGuid GetWorkId() const;
	bool HasElementType(const EPalElementType ElementType) const;
	bool HasFloorPhysMaterial() const;
	bool IsAssignedFixed() const;
	bool IsAssignedToAnyWork() const;
	bool IsCooping() const;
	bool IsDead() const;
	bool IsDying() const;
	bool IsDyingHPMax() const;
	bool IsDyingHPZero() const;
	bool IsHittingLava() const;
	bool IsHyperArmor() const;
	bool IsLive() const;
	bool IsOtomo() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalCharacterParameterComponent">();
	}
	static class UPalCharacterParameterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalCharacterParameterComponent>();
	}
};
static_assert(alignof(UPalCharacterParameterComponent) == 0x000008, "Wrong alignment on UPalCharacterParameterComponent");
static_assert(sizeof(UPalCharacterParameterComponent) == 0x000670, "Wrong size on UPalCharacterParameterComponent");
static_assert(offsetof(UPalCharacterParameterComponent, bIsCooping) == 0x0000A0, "Member 'UPalCharacterParameterComponent::bIsCooping' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, bIsEnableSendReticleTarget) == 0x0000A1, "Member 'UPalCharacterParameterComponent::bIsEnableSendReticleTarget' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, bIsEnableMuteki) == 0x0000A2, "Member 'UPalCharacterParameterComponent::bIsEnableMuteki' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, LeanBackPoint) == 0x0000A8, "Member 'UPalCharacterParameterComponent::LeanBackPoint' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, LeanBackMaxPoint) == 0x0000B0, "Member 'UPalCharacterParameterComponent::LeanBackMaxPoint' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, StunPoint) == 0x0000B8, "Member 'UPalCharacterParameterComponent::StunPoint' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, StunMaxPoint) == 0x0000C0, "Member 'UPalCharacterParameterComponent::StunMaxPoint' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, IsSPOverheat) == 0x0000C8, "Member 'UPalCharacterParameterComponent::IsSPOverheat' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, bIsHyperArmor) == 0x0000C9, "Member 'UPalCharacterParameterComponent::bIsHyperArmor' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, bIsDebugMuteki) == 0x0000CA, "Member 'UPalCharacterParameterComponent::bIsDebugMuteki' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, ElementType1) == 0x0000CB, "Member 'UPalCharacterParameterComponent::ElementType1' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, ElementType2) == 0x0000CC, "Member 'UPalCharacterParameterComponent::ElementType2' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, IsOverrideTarget) == 0x0000CD, "Member 'UPalCharacterParameterComponent::IsOverrideTarget' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, OverrideTargetLocation) == 0x0000D0, "Member 'UPalCharacterParameterComponent::OverrideTargetLocation' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, Trainer) == 0x0000E8, "Member 'UPalCharacterParameterComponent::Trainer' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, OtomoPal) == 0x0000F0, "Member 'UPalCharacterParameterComponent::OtomoPal' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, ReticleTargetActor) == 0x0000F8, "Member 'UPalCharacterParameterComponent::ReticleTargetActor' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, IndividualHandle) == 0x000100, "Member 'UPalCharacterParameterComponent::IndividualHandle' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, IndividualParameter) == 0x000108, "Member 'UPalCharacterParameterComponent::IndividualParameter' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, IsStun) == 0x000110, "Member 'UPalCharacterParameterComponent::IsStun' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, IsEnableSpeedCollision) == 0x000111, "Member 'UPalCharacterParameterComponent::IsEnableSpeedCollision' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, IsCanSneakAttacked) == 0x000112, "Member 'UPalCharacterParameterComponent::IsCanSneakAttacked' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, IsFriendBulletIgnore) == 0x000113, "Member 'UPalCharacterParameterComponent::IsFriendBulletIgnore' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, BiologicalGrade) == 0x000114, "Member 'UPalCharacterParameterComponent::BiologicalGrade' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, IsPredator) == 0x000118, "Member 'UPalCharacterParameterComponent::IsPredator' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, IsEdible) == 0x000119, "Member 'UPalCharacterParameterComponent::IsEdible' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, HiddenCollisionOverlapCount) == 0x00011C, "Member 'UPalCharacterParameterComponent::HiddenCollisionOverlapCount' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, BurnCollisionOverlapCount) == 0x000120, "Member 'UPalCharacterParameterComponent::BurnCollisionOverlapCount' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, LavaCollisionOverlapCount) == 0x000124, "Member 'UPalCharacterParameterComponent::LavaCollisionOverlapCount' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, DamageUpElement_ByElementStatus) == 0x000129, "Member 'UPalCharacterParameterComponent::DamageUpElement_ByElementStatus' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, DamageDownElement_ByElementStatus) == 0x00012A, "Member 'UPalCharacterParameterComponent::DamageDownElement_ByElementStatus' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, IsDarknessRandomAttack) == 0x00012B, "Member 'UPalCharacterParameterComponent::IsDarknessRandomAttack' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, AttackUp) == 0x00012C, "Member 'UPalCharacterParameterComponent::AttackUp' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, DefenseUp) == 0x000130, "Member 'UPalCharacterParameterComponent::DefenseUp' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, StatusAccumulateMap) == 0x000138, "Member 'UPalCharacterParameterComponent::StatusAccumulateMap' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, IsSleepAction) == 0x000188, "Member 'UPalCharacterParameterComponent::IsSleepAction' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, WildPalDrinkWaterPoint) == 0x000190, "Member 'UPalCharacterParameterComponent::WildPalDrinkWaterPoint' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, IsDisableOtomoReturnEffect) == 0x0001A8, "Member 'UPalCharacterParameterComponent::IsDisableOtomoReturnEffect' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, MaxHPRate_ForTowerBoss) == 0x0001AC, "Member 'UPalCharacterParameterComponent::MaxHPRate_ForTowerBoss' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, GroundHitResult) == 0x0001B0, "Member 'UPalCharacterParameterComponent::GroundHitResult' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, bIsUseGroundRayCast) == 0x00029C, "Member 'UPalCharacterParameterComponent::bIsUseGroundRayCast' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, DisableGroundRayCast) == 0x0002A0, "Member 'UPalCharacterParameterComponent::DisableGroundRayCast' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, SP) == 0x0002F0, "Member 'UPalCharacterParameterComponent::SP' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, BaseCampDefenseModelId) == 0x0002F8, "Member 'UPalCharacterParameterComponent::BaseCampDefenseModelId' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, BaseCampWorkerOrderType) == 0x000308, "Member 'UPalCharacterParameterComponent::BaseCampWorkerOrderType' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, bBaseCampWorkerAttackableFriend) == 0x000309, "Member 'UPalCharacterParameterComponent::bBaseCampWorkerAttackableFriend' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, UnreachableMapObjectInfos) == 0x000310, "Member 'UPalCharacterParameterComponent::UnreachableMapObjectInfos' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, Work) == 0x000360, "Member 'UPalCharacterParameterComponent::Work' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, WorkAssignId) == 0x0003D8, "Member 'UPalCharacterParameterComponent::WorkAssignId' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, WorkType) == 0x0003F0, "Member 'UPalCharacterParameterComponent::WorkType' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, BaseCampWalkAroundExcludeMapObjectInstanceId) == 0x0003F4, "Member 'UPalCharacterParameterComponent::BaseCampWalkAroundExcludeMapObjectInstanceId' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, PossessStaticItemId) == 0x000404, "Member 'UPalCharacterParameterComponent::PossessStaticItemId' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, bBeingRescued) == 0x00040C, "Member 'UPalCharacterParameterComponent::bBeingRescued' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, DyingHP) == 0x000410, "Member 'UPalCharacterParameterComponent::DyingHP' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, DyingMaxHP) == 0x000414, "Member 'UPalCharacterParameterComponent::DyingMaxHP' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, ItemContainer) == 0x000418, "Member 'UPalCharacterParameterComponent::ItemContainer' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, IsCapturedProcessing) == 0x000420, "Member 'UPalCharacterParameterComponent::IsCapturedProcessing' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, OnUpdatePossessItemDelegate) == 0x000428, "Member 'UPalCharacterParameterComponent::OnUpdatePossessItemDelegate' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, OnUpdateWorkAssignIdDelegate) == 0x000438, "Member 'UPalCharacterParameterComponent::OnUpdateWorkAssignIdDelegate' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, OnSPOverheatDelegate) == 0x000448, "Member 'UPalCharacterParameterComponent::OnSPOverheatDelegate' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, OnChangeTrapLegHoldDelegate) == 0x000458, "Member 'UPalCharacterParameterComponent::OnChangeTrapLegHoldDelegate' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, OnChangeTrapMovingPanelDelegate) == 0x000468, "Member 'UPalCharacterParameterComponent::OnChangeTrapMovingPanelDelegate' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, TrapDirection) == 0x000478, "Member 'UPalCharacterParameterComponent::TrapDirection' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, DamageMap) == 0x000490, "Member 'UPalCharacterParameterComponent::DamageMap' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, CanDropItem) == 0x0004E0, "Member 'UPalCharacterParameterComponent::CanDropItem' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, DisableNaturalHealing_Component) == 0x0004E8, "Member 'UPalCharacterParameterComponent::DisableNaturalHealing_Component' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, IsImmortality) == 0x000538, "Member 'UPalCharacterParameterComponent::IsImmortality' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, TrapLegHoldList) == 0x000638, "Member 'UPalCharacterParameterComponent::TrapLegHoldList' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, TrapMovingPanelList) == 0x000648, "Member 'UPalCharacterParameterComponent::TrapMovingPanelList' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, OtomoAttackStopJudge) == 0x000658, "Member 'UPalCharacterParameterComponent::OtomoAttackStopJudge' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterComponent, UnreachableMapObjectRepInfoArray) == 0x000660, "Member 'UPalCharacterParameterComponent::UnreachableMapObjectRepInfoArray' has a wrong offset!");

// Class Pal.LambdaWrapper
// 0x0048 (0x0070 - 0x0028)
class ULambdaWrapper final : public UObject
{
public:
	uint8                                         Pad_2A58[0x48];                                    // 0x0028(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Dispatch(bool IsSuccess);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LambdaWrapper">();
	}
	static class ULambdaWrapper* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULambdaWrapper>();
	}
};
static_assert(alignof(ULambdaWrapper) == 0x000008, "Wrong alignment on ULambdaWrapper");
static_assert(sizeof(ULambdaWrapper) == 0x000070, "Wrong size on ULambdaWrapper");

// Class Pal.SequentialProcessSequenceBase
// 0x0018 (0x0040 - 0x0028)
class USequentialProcessSequenceBase : public UObject
{
public:
	uint8                                         Pad_2A59[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USequentialProcessHandle*>       ProcessHandles;                                    // 0x0030(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SequentialProcessSequenceBase">();
	}
	static class USequentialProcessSequenceBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<USequentialProcessSequenceBase>();
	}
};
static_assert(alignof(USequentialProcessSequenceBase) == 0x000008, "Wrong alignment on USequentialProcessSequenceBase");
static_assert(sizeof(USequentialProcessSequenceBase) == 0x000040, "Wrong size on USequentialProcessSequenceBase");
static_assert(offsetof(USequentialProcessSequenceBase, ProcessHandles) == 0x000030, "Member 'USequentialProcessSequenceBase::ProcessHandles' has a wrong offset!");

// Class Pal.PalGuildEnterRequestSequence_ExitGuildMainProcess
// 0x0000 (0x0040 - 0x0040)
class UPalGuildEnterRequestSequence_ExitGuildMainProcess final : public USequentialProcessSequenceBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGuildEnterRequestSequence_ExitGuildMainProcess">();
	}
	static class UPalGuildEnterRequestSequence_ExitGuildMainProcess* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalGuildEnterRequestSequence_ExitGuildMainProcess>();
	}
};
static_assert(alignof(UPalGuildEnterRequestSequence_ExitGuildMainProcess) == 0x000008, "Wrong alignment on UPalGuildEnterRequestSequence_ExitGuildMainProcess");
static_assert(sizeof(UPalGuildEnterRequestSequence_ExitGuildMainProcess) == 0x000040, "Wrong size on UPalGuildEnterRequestSequence_ExitGuildMainProcess");

// Class Pal.PalCharacterParameterStorageSubsystem
// 0x0078 (0x00E8 - 0x0070)
class UPalCharacterParameterStorageSubsystem : public UPalWorldSubsystem
{
public:
	uint8                                         Pad_2A5A[0x8];                                     // 0x0070(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnStoredParameterDelegate_ForServer;               // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRemovedParameterDelegate_ForServer;              // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<struct FPalCharacterStoredParameterId, struct FPalCharacterStoredParameterInfo> StoredParameterInfoMap;                            // 0x0098(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalCharacterParameterStorageSubsystem">();
	}
	static class UPalCharacterParameterStorageSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalCharacterParameterStorageSubsystem>();
	}
};
static_assert(alignof(UPalCharacterParameterStorageSubsystem) == 0x000008, "Wrong alignment on UPalCharacterParameterStorageSubsystem");
static_assert(sizeof(UPalCharacterParameterStorageSubsystem) == 0x0000E8, "Wrong size on UPalCharacterParameterStorageSubsystem");
static_assert(offsetof(UPalCharacterParameterStorageSubsystem, OnStoredParameterDelegate_ForServer) == 0x000078, "Member 'UPalCharacterParameterStorageSubsystem::OnStoredParameterDelegate_ForServer' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterStorageSubsystem, OnRemovedParameterDelegate_ForServer) == 0x000088, "Member 'UPalCharacterParameterStorageSubsystem::OnRemovedParameterDelegate_ForServer' has a wrong offset!");
static_assert(offsetof(UPalCharacterParameterStorageSubsystem, StoredParameterInfoMap) == 0x000098, "Member 'UPalCharacterParameterStorageSubsystem::StoredParameterInfoMap' has a wrong offset!");

// Class Pal.PalCharacterRankUpUtility
// 0x0000 (0x0028 - 0x0028)
class UPalCharacterRankUpUtility final : public UBlueprintFunctionLibrary
{
public:
	static int32 GetRequiredInitRankCharacterNum(const class UObject* WorldContextObject, const int32 Rank);
	static void SimulateRankUpCharacter(const class UObject* WorldContextObject, const struct FPalInstanceID& TargetId, const TArray<struct FPalInstanceID>& ResourceIds, int32* OutToRank, int32* OutToRankUpExp);
	static void SimulateRankUpCharacterByHandle(const class UObject* WorldContextObject, const class UPalIndividualCharacterHandle* Target, const TArray<class UPalIndividualCharacterHandle*>& Resources, int32* OutToRank, int32* OutToRankUpExp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalCharacterRankUpUtility">();
	}
	static class UPalCharacterRankUpUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalCharacterRankUpUtility>();
	}
};
static_assert(alignof(UPalCharacterRankUpUtility) == 0x000008, "Wrong alignment on UPalCharacterRankUpUtility");
static_assert(sizeof(UPalCharacterRankUpUtility) == 0x000028, "Wrong size on UPalCharacterRankUpUtility");

// Class Pal.PalGameModeBase
// 0x0008 (0x0338 - 0x0330)
class APalGameModeBase : public AGameModeBase
{
public:
	EPalGameModeType                              GameModeType;                                      // 0x0330(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A5B[0x7];                                     // 0x0331(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGameModeBase">();
	}
	static class APalGameModeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalGameModeBase>();
	}
};
static_assert(alignof(APalGameModeBase) == 0x000008, "Wrong alignment on APalGameModeBase");
static_assert(sizeof(APalGameModeBase) == 0x000338, "Wrong size on APalGameModeBase");
static_assert(offsetof(APalGameModeBase, GameModeType) == 0x000330, "Member 'APalGameModeBase::GameModeType' has a wrong offset!");

// Class Pal.PalGameModeTitle
// 0x0000 (0x0338 - 0x0338)
class APalGameModeTitle : public APalGameModeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGameModeTitle">();
	}
	static class APalGameModeTitle* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalGameModeTitle>();
	}
};
static_assert(alignof(APalGameModeTitle) == 0x000008, "Wrong alignment on APalGameModeTitle");
static_assert(sizeof(APalGameModeTitle) == 0x000338, "Wrong size on APalGameModeTitle");

// Class Pal.PalShopBase
// 0x0090 (0x00B8 - 0x0028)
class UPalShopBase : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnUpdateAnyProduct;                                // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGuid                                  MyShopID;                                          // 0x0038(0x0010)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   MyShopName;                                        // 0x0048(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UPalShopProductBase*>            ProductArray;                                      // 0x0050(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	TMap<struct FGuid, class UPalShopProductBase*> ProductMap_ForServer;                              // 0x0060(0x0050)(Transient, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           RestockTimerHandle_ForServer;                      // 0x00B0(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_MyShopName();
	void OnRep_ProductArray();
	void OnTimerTrigger_Restock();
	void OnUpdateAnyProductMaxStock(int32 MaxStock);
	void OnUpdateAnyProductStock(int32 NowStock);
	void UpdateAnyProductDelegate__DelegateSignature();

	void GetAllProduct(TArray<class UPalShopProductBase*>* OutProductArray) const;
	void GetId(struct FGuid* OutID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalShopBase">();
	}
	static class UPalShopBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalShopBase>();
	}
};
static_assert(alignof(UPalShopBase) == 0x000008, "Wrong alignment on UPalShopBase");
static_assert(sizeof(UPalShopBase) == 0x0000B8, "Wrong size on UPalShopBase");
static_assert(offsetof(UPalShopBase, OnUpdateAnyProduct) == 0x000028, "Member 'UPalShopBase::OnUpdateAnyProduct' has a wrong offset!");
static_assert(offsetof(UPalShopBase, MyShopID) == 0x000038, "Member 'UPalShopBase::MyShopID' has a wrong offset!");
static_assert(offsetof(UPalShopBase, MyShopName) == 0x000048, "Member 'UPalShopBase::MyShopName' has a wrong offset!");
static_assert(offsetof(UPalShopBase, ProductArray) == 0x000050, "Member 'UPalShopBase::ProductArray' has a wrong offset!");
static_assert(offsetof(UPalShopBase, ProductMap_ForServer) == 0x000060, "Member 'UPalShopBase::ProductMap_ForServer' has a wrong offset!");
static_assert(offsetof(UPalShopBase, RestockTimerHandle_ForServer) == 0x0000B0, "Member 'UPalShopBase::RestockTimerHandle_ForServer' has a wrong offset!");

// Class Pal.PalCharacterShop
// 0x0010 (0x00C8 - 0x00B8)
class UPalCharacterShop final : public UPalShopBase
{
public:
	TArray<class UPalShopProduct_LostPal*>        LocalLostPalProductArray;                          // 0x00B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalCharacterShop">();
	}
	static class UPalCharacterShop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalCharacterShop>();
	}
};
static_assert(alignof(UPalCharacterShop) == 0x000008, "Wrong alignment on UPalCharacterShop");
static_assert(sizeof(UPalCharacterShop) == 0x0000C8, "Wrong size on UPalCharacterShop");
static_assert(offsetof(UPalCharacterShop, LocalLostPalProductArray) == 0x0000B8, "Member 'UPalCharacterShop::LocalLostPalProductArray' has a wrong offset!");

// Class Pal.PalReticleTargetableInterface
// 0x0000 (0x0028 - 0x0028)
class IPalReticleTargetableInterface final : public IInterface
{
public:
	bool IsShowOutlineInReticleTargetting() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalReticleTargetableInterface">();
	}
	static class IPalReticleTargetableInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPalReticleTargetableInterface>();
	}
};
static_assert(alignof(IPalReticleTargetableInterface) == 0x000008, "Wrong alignment on IPalReticleTargetableInterface");
static_assert(sizeof(IPalReticleTargetableInterface) == 0x000028, "Wrong size on IPalReticleTargetableInterface");

// Class Pal.PalHeatSourceModule
// 0x0038 (0x0060 - 0x0028)
class UPalHeatSourceModule final : public UObject
{
public:
	TArray<TWeakObjectPtr<class AActor>>          PlayerList;                                        // 0x0028(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class AActor>>          ActorList;                                         // 0x0038(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	bool                                          IsActive;                                          // 0x0048(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A5C[0x3];                                     // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   UnieqName;                                         // 0x004C(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPalHeatSourceInfo                     HeatSourceInfo;                                    // 0x0054(0x0008)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A5D[0x4];                                     // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddActor(class AActor* Actor);
	void AddPlayer(class AActor* Player);
	void InitializeHeatSource(class FName SourceName, const struct FPalHeatSourceInfo& Info, bool DefaultActive);
	void RemoveActor(class AActor* Actor);
	void RemovePlayer(class AActor* Player);
	void SetActivate(bool Active);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalHeatSourceModule">();
	}
	static class UPalHeatSourceModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalHeatSourceModule>();
	}
};
static_assert(alignof(UPalHeatSourceModule) == 0x000008, "Wrong alignment on UPalHeatSourceModule");
static_assert(sizeof(UPalHeatSourceModule) == 0x000060, "Wrong size on UPalHeatSourceModule");
static_assert(offsetof(UPalHeatSourceModule, PlayerList) == 0x000028, "Member 'UPalHeatSourceModule::PlayerList' has a wrong offset!");
static_assert(offsetof(UPalHeatSourceModule, ActorList) == 0x000038, "Member 'UPalHeatSourceModule::ActorList' has a wrong offset!");
static_assert(offsetof(UPalHeatSourceModule, IsActive) == 0x000048, "Member 'UPalHeatSourceModule::IsActive' has a wrong offset!");
static_assert(offsetof(UPalHeatSourceModule, UnieqName) == 0x00004C, "Member 'UPalHeatSourceModule::UnieqName' has a wrong offset!");
static_assert(offsetof(UPalHeatSourceModule, HeatSourceInfo) == 0x000054, "Member 'UPalHeatSourceModule::HeatSourceInfo' has a wrong offset!");

// Class Pal.PalCharacterStatusOperation
// 0x0000 (0x0028 - 0x0028)
class UPalCharacterStatusOperation final : public UObject
{
public:
	static int32 GetCurrentLocalPlayerTotalStatusPoint(const class UObject* WorldContextObject, const class FName StatusName);
	static int32 GetCurrentStatusRank(const class UPalIndividualCharacterParameter* TargetIndividualParameter, const EPalCharacterStatusOperationName StatusName);
	static void GetRequiredItemCountForCharacterStatus(const class UObject* WorldContextObject, class UPalIndividualCharacterHandle* TargetHandle, const EPalCharacterStatusOperationName StatusName, class FName* OutStaticItemId, int32* OutItemNum);
	static int32 GetRequiredMoneyCountForResetCharacterStatus(const class UObject* WorldContextObject, class UPalIndividualCharacterHandle* TargetHandle, const EPalCharacterStatusOperationName StatusName);
	static int32 GetRequiredMoneyCountForResetCharacterStatusAll(const class UObject* WorldContextObject, class UPalIndividualCharacterHandle* TargetHandle);
	static int32 GetRequiredMoneyCountForResetLocalPlayer(const class UObject* WorldContextObject);
	static int32 GetRequiredRelicCountForLocalPlayer(const class UObject* WorldContextObject);
	static TMap<class FName, int32> GetReturnItemsForResetCharacterStatusAll(const class UObject* WorldContextObject, const class UPalIndividualCharacterParameter* TargetIndividualParameter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalCharacterStatusOperation">();
	}
	static class UPalCharacterStatusOperation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalCharacterStatusOperation>();
	}
};
static_assert(alignof(UPalCharacterStatusOperation) == 0x000008, "Wrong alignment on UPalCharacterStatusOperation");
static_assert(sizeof(UPalCharacterStatusOperation) == 0x000028, "Wrong size on UPalCharacterStatusOperation");

// Class Pal.PalHUDDispatchParameter_CharacterStatusOperator
// 0x0000 (0x0038 - 0x0038)
class UPalHUDDispatchParameter_CharacterStatusOperator final : public UPalHUDDispatchParameterBase
{
public:
	static void GetCharacterStatusOperationResultText(const class UObject* WorldContextObject, const EPalCharacterStatusOperationResult Type, class FText* OutText);

	void BindReceiveRequestResultDelegate(const class UObject* WorldContextObject, TDelegate<void(EPalCharacterStatusOperationResult Result)> Delegate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalHUDDispatchParameter_CharacterStatusOperator">();
	}
	static class UPalHUDDispatchParameter_CharacterStatusOperator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalHUDDispatchParameter_CharacterStatusOperator>();
	}
};
static_assert(alignof(UPalHUDDispatchParameter_CharacterStatusOperator) == 0x000008, "Wrong alignment on UPalHUDDispatchParameter_CharacterStatusOperator");
static_assert(sizeof(UPalHUDDispatchParameter_CharacterStatusOperator) == 0x000038, "Wrong size on UPalHUDDispatchParameter_CharacterStatusOperator");

// Class Pal.PalCheatManager
// 0x0040 (0x00C8 - 0x0088)
class UPalCheatManager : public UCheatManager
{
public:
	uint8                                         Pad_2A67[0x8];                                     // 0x0088(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalDebugWindowSetting*                 DebugWindowSetting;                                // 0x0090(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             DebugProgressPresetDataTable;                      // 0x0098(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class APalDebug_SpawnInfoReporter> SpawnerInfoReporterClass;                          // 0x00A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APalImGui*                              PalImGui;                                          // 0x00A8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalStatPalCount*                       PalCountSystem;                                    // 0x00B0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APalDebug_SpawnInfoReporter*            SpawnInfoReporter;                                 // 0x00B8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A68[0x8];                                     // 0x00C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddBaseCampEnergyAmount(const EPalEnergyType EnergyType, const float Amount);
	void AddBossTechnologyPoints(int32 AddPoints);
	void AddExpForALLPlayer(int32 AddExp);
	void AddExStatusPoint(int32 Point);
	void AddGameTime_Hours(const int32 Hours);
	void AddGameTime_Minutes(const int32 Minutes);
	void AddMapObjectEffectVisualAround(const float Range, const EPalMapObjectVisualEffectType EffectType);
	void AddMapObjectEffectVisualAround_Burn(const float Range);
	void AddMoney(int64 AddValue);
	void AddOneStatusEnemy();
	void AddOneStatusOtomo();
	void AddOneStatusPlayer();
	void AddPartyExp(int32 AddExp);
	void AddPlayerExp(int32 AddExp);
	void AddTechnologyPoints(int32 AddPoints);
	void ApplyDebugGameProgress(class FName PresetName);
	void BanPlayerFromGuildLocalPlayerBelongTo(const struct FGuid& TargetPlayerUId);
	void BotOff();
	void BotOn();
	void BuildDebugBaseCamp(class FName Mode);
	void BuildNotConsumeMaterials();
	void CaptureAllEnemy();
	void CaptureAllMonsters();
	void CaptureFailAlways();
	void CaptureNewMonster(const class FName CharacterID);
	void CaptureSuccessAlways();
	void CauseCrash();
	void CauseEnsure();
	void CauseServerCrash();
	void ChangeHUDScale(float Scale);
	void ChangeMaxPlayers(int32 Players);
	void ChangePassive_PlayerWeapon(int32 Param_Index, class FName SkillName);
	void CheckFoliageChunkStatus(const bool bShowInstanceDetail, const bool bShowGridDetail);
	void CleatDebugInfoText();
	void CommandToServer(const class FString& Command);
	void CopyPlayerLocation();
	void CopyPlayerUId();
	void CopyWorldDirectoryName();
	void CountPalCharacter();
	void CreateGuild(const class FString& GuildName);
	void CreateGuildAndEnterLocalPlayer(const class FString& GuildName);
	void CreateGuildWithAdmin(const class FString& GuildName, const struct FGuid& AdminPlayerUId);
	void DebugAutoRun();
	void DebugAutoSave();
	void DebugChangeAutoSaveTimespan(float SaveSpan);
	void DebugDeleteEnemyCampSaveData();
	void DebugSaveFullWorldData(const class FString& WorldName);
	void DebugSaveLocalWorldData(const class FString& SaveName);
	void DebugSaveWorldData(const class FString& SaveName);
	void DebugSaveWorldOptionData(const class FString& WorldName);
	void DebugWindow();
	void DeletePlayerAndQuitGame();
	void DeleteWorldAndShutdownRemoteServer();
	void DisableEnemyEyeSight();
	void DisableScreenMessage();
	void DismantleBaseCampByBaseCampId(const struct FGuid& BaseCampId);
	void DismantleBaseCampFirst();
	void DisposeGuild(const class FString& GuildName);
	void DrawDebugLimitVolume(const EPalLimitVolumeFlag Flag, const float Range, const float Duration);
	void DrawDebugRangeBaseCamp(const float LifeTime);
	void DropItem(const class FName StaticItemId, const int32 Num);
	void DropItemByTimer(const class FName StaticItemId, const int32 Num, const float Interval);
	void DropItems(const class FName StaticItemId, const int32 Num, const int32 DropCount);
	void EasyGamePreset();
	void EnableCollectServerPalCount();
	void EnableCommandToServer();
	void EnableStatPalnet();
	void EnableStatPlayerInfo();
	void EnableStatUnit();
	void EnterGroup(const class FString& GroupName, const struct FPalInstanceID& IndividualId);
	void EnterGuildLocalPlayer(const class FString& GuildName);
	void EnterGuildOtherPlayerBelongTo(const struct FGuid& TargetPlayerUId);
	void EnterGuildPlayer(const class FString& GuildName, class APalPlayerCharacter* Player);
	void ExitGuildLocalPlayer(const class FString& GuildName);
	void ExitGuildPlayer(const class FString& GuildName, class APalPlayerCharacter* Player);
	void FixedActionRandomSeed();
	void FixedSP();
	void FixedUseEagleForGlider();
	void FootIKDisable();
	void FootIKEnable();
	void ForceDisablePalMeshCollision();
	void ForceDisableTimerLight();
	void ForceExitStage();
	void ForceExitStageAllPlayer();
	void ForceLowerSpecSetting();
	void ForceReleaseWanted();
	void ForceReloadPlayerParameter();
	void ForceReportCriminal();
	void ForceSpawnRarePal();
	void ForceUpdateBaseCampWorkerEvent();
	void FullPowerForPlayer();
	void GenerateCombiMonster();
	void GetItem(class FName StaticItemId, int32 Count);
	void GetItemToLoadout(class FName StaticItemId, int32 Count);
	void GetItemToLoadoutWithPassive(class FName StaticItemId, int32 Count);
	void GetItemWithPassive(class FName StaticItemId, int32 Count);
	void GetItemWithPassiveSkill(class FName StaticItemId, int32 Count, class FName PassiveSkillId);
	void GetPalEgg(const class FName CharacterID);
	void GetPlanerPal();
	void GetRelic(int32 Count);
	void HideDebugInfo();
	void HideTutorialQuest();
	void HideTutorialQuest_BP();
	void HPOneAllCharacter();
	void IgnoreBuildRestrictionBaseCamp();
	void IgnoreDamageCheckByServer();
	void IgnoreRestrictedByItemsForPartnerSkill();
	void InitInventory(const class FName StaticItemId, const int32 Count);
	void InsightsTraceStartForLocal();
	void InsightsTraceStartForServer();
	void InsightsTraceStopForLocal();
	void InsightsTraceStopForServer();
	void InstallVirtualBaseCamp();
	void InvaderMarch();
	void InvaderMarchRandom();
	void IsAllStreamingCompleted();
	void JoinClientPlayerToServerGuild();
	void JumpToClientStartLocation();
	void KickPlayer(const class FString& UserId, const class FText& KickReason);
	void KillAllEnemy();
	void KillAllFriend();
	void KillBaseCampWorker();
	void KillBaseCampWorkerSingle();
	void KillGuildFriend();
	void KillPlayer();
	void LogBaseCampInfo();
	void LoginEOS();
	void LoginNative();
	void ManyUNKO();
	void MutekiALL();
	void MutekiForFriend();
	void MutekiForPlayer();
	void NotConsumeMaterialsInBuild();
	void NotConsumeMaterialsInCraft();
	void NotDecreaseWeaponItem();
	void OnPingComplete(class UPingIP* PingIP, const class FString& Address, int32 TimeMS);
	void OpenDefaultMap();
	void OpenMultiBattleMap();
	void OpenMultiBattleMapForBP();
	void OpenPrivateServer();
	void OpenPrivateServerForBP();
	void OpenTitle();
	void OpenTitleForBP();
	void OrderBaseCampWorker(const EPalMapBaseCampWorkerOrderType OrderType);
	void PalmiTargetEnemny();
	void ParallelForUpdateActiveTiles();
	void Ping(const class FString& Address);
	void PrintGameTime();
	void PrintInventoryDynamicItemLog();
	void PrintRealTime();
	void RandomizePassive_PlayerWeapon();
	void RepairEquipment();
	void RequestFillSlotChestFromInventory();
	void RequestFillSlotChestToInventory();
	void RequestLogServerThreadNum();
	void RequestLogTreasureBoxLocalPlayerAround();
	void RerollCharacterMake();
	void RespawnPlayer();
	void RideIKDisable();
	void RideIKEnable();
	void SaikyoGamePreset();
	void SendChatToBroadcast(const class FString& Text);
	void SetActivity(const class FString& ConnStr, int32 MaxPlayer, int32 CurrentPlayer);
	void SetAllowBaseCampBattle(const bool bAllowBaseCampBattle);
	void SetAlwaysGrantPassiveSkillMode(bool Flag);
	void SetBaseCampWorkerHp(const float Percentage);
	void SetBaseCampWorkerHpSingle(const float Percentage);
	void SetCharacterMakeAllBlue();
	void SetCharacterMakeAllGreen();
	void SetCharacterMakeAllMax();
	void SetCharacterMakeAllMin();
	void SetCharacterMakeAllNormal();
	void SetCharacterMakeAllRed();
	void SetCharacterMakeColor(const struct FColor& Color);
	void SetCharacterName(const class FString& Param_Name);
	void SetDamageTextMaxNum(int32 Num);
	void SetDebugFullStomachDecreaseRate(const float Rate);
	void SetDebugRespawnPointForPlayer(class APalPlayerCharacter* Character, const struct FVector& Location);
	void SetDisableInteractReticleTarget(bool bIsEnable);
	void SetForceLocationTeleport(bool bForceLocationTeleport);
	void SetFPSForServer(float Fps);
	void SetGameTime_NextDay();
	void SetGameTime_NextDay_SecondsAgo(const int32 SecondsAgo);
	void SetGameTime_NextNight();
	void SetGameTime_NextNight_SecondsAgo(const int32 SecondsAgo);
	void SetInventoryItemDurability(const float Percent);
	void SetLoadingSceneVisible(bool IsVisible);
	void SetMapObjectStatusRange(const float Range);
	void SetMultiplayRestriction(bool bRestriction);
	void SetOtomoPalAttackRank(int32 Rank);
	void SetOtomoPalDefenceRank(int32 Rank);
	void SetOtomoPalHPRank(int32 Rank);
	void SetOtomoPalRank(int32 Rank);
	void SetOtomoPalWorkSpeedRank(int32 Rank);
	void SetPaldexComplete(bool IsComplete);
	void SetPalEggStatusRange(const float Range);
	void SetPalWorldTime(int32 Hour);
	void SetPalWorldTimeScale(float Rate);
	void SetPassive_PlayerWeapon(class FName FirstPassive, class FName SecondPassive, class FName ThirdPassive);
	void SetPlayerCameraBoomLengthRate(const float Rate);
	void SetPlayerHP(int32 NewHP);
	void SetPlayerSP(int32 NewSP);
	void SetSanityToBaseCampPal(const float Sanity);
	void SetSunLightShadowDistance(const float InDistance);
	void SetVoiceID(int32 VoiceID);
	void ShowActionAndStatus();
	void ShowActionAndStatus_ToServer();
	void ShowActionName();
	void ShowAISound();
	void ShowAlert(const class FText& Msg);
	void ShowBuildObjectInstallCheck();
	void ShowCharacterStatus();
	void ShowDebugCrime();
	void ShowDebugWanted();
	void ShowDebugWorkAssign();
	void ShowDebugWorkAssignTarget();
	void ShowDefenseAttackableRange();
	void ShowDefenseAttackTarget();
	void ShowDialog(const class FText& Msg);
	void ShowFloorLocation();
	void ShowHateArrow();
	void ShowLocalSaveData();
	void ShowMapObjectConnector();
	void ShowMapObjectFoliageStatus();
	void ShowMapObjectStatus();
	void ShowMaxPlayers();
	void ShowMovementMode();
	void ShowObjectNameForward();
	void ShowObjectNameGround();
	void ShowPalCount();
	void ShowPalEggStatus();
	void ShowPlayerMoveSpeed();
	void ShowPlayers();
	void ShowSpawnerInfo();
	void ShowStreamingLevel();
	void ShowTargetLocalPlayerEnemyList();
	void ShutdownRemoteServer();
	void SkipCutscene();
	void SleepAllEnemy();
	void SpawnMonster(const class FName CharacterID, int32 Level);
	void SpawnMonsterForPlayer(const class FName& CharacterID, int32 Num, int32 Level);
	void SpawnPalEggBreedFarm(const class FName MonsterId, const float Range);
	void SpectatorOff();
	void SpectatorOffForBP();
	void SpectatorOn();
	void SpectatorOnForBP();
	void StartBuildMode(const class FName BuildObjectId);
	void StartDismantlingMode();
	void StartTraceAllOption();
	void StartWildPalCombat();
	void StopTimerDropItem();
	void StringToPlayerUID(const class FString& Str);
	void TeleportToBossTower(EPalBossType BossType);
	void TeleportToBotCamp(int32 botIndex);
	void TeleportToBotLocation(int32 botIndex);
	void TeleportToCurrentDungeonGoal();
	void TeleportToCurrentDungeonTreasureBox();
	void TeleportToDungeonEntranceByDataLayer(const class FName DataLayerName);
	void TeleportToDungeonEntranceByIndex(const int32 Param_Index);
	void TeleportToDungeonEntranceByRandomScattered();
	void TeleportToDungeonEntranceRandom();
	void TeleportToLastLandingLocation();
	void TeleportToLocation(float X, float Y, float Z);
	void TeleportToLocationByClipboard();
	void TeleportToNearestCamp();
	void TeleportToNearestPlayer();
	void TeleportToSafePoint();
	void TimeStopForBP();
	void ToggleBaseCampWorkerSanityDetail();
	void ToggleBuildInstallCheckLookToCamera();
	void ToggleHUD();
	void ToggleLoadingScreen();
	void TogglePartnerSkillNoDecrease();
	void ToggleRevision();
	void ToggleRevision_BP();
	void ToggleShowDropItemHitEventLog();
	void ToggleShowReticleLocation();
	void ToggleVisibleFoliageChunk();
	void TraceReticleDirectionAllObjectType(const float Length);
	void TriggerBaseCampWorkerEvent(const EPalBaseCampWorkerEventType EventType);
	void UNKO();
	void UnlockAchievement(const class FString& AchievementId, int32 Progress);
	void UnlockAllCategoryTechnology();
	void UnlockAllRecipeTechnology();
	void UnlockMap(class FName RegionId);
	void UnlockOneTechnology(class FName TechnologyName);
	void UnlockTechnologyByLvCap(int32 Lv);
	void UpdateBaseCampLevelMax();
	void UpdateBaseCampTickInvokeMaxNumInOneTick(const int32 Value);
	void UpdateBaseCampWorkerSlotNum(const int32 SlotNum);
	void VisitorTravel();
	void WazaCoolTimeFastMode();
	void WildPalCombatStart();
	void WorkerEventInterval(const float Interval);
	void WorkerEventLog();

	bool IsActionName() const;
	bool IsCaptureFailAlways() const;
	bool IsCaptureSuccessAlways() const;
	bool IsDisableEnemyEyeSight() const;
	bool IsFixedSP() const;
	bool IsIgnoreBuildRestrictionBaseCamp() const;
	bool IsMutekiALL() const;
	bool IsMutekiForFriend() const;
	bool IsMutekiForPlayer() const;
	bool IsNotConsumeMaterialsInBuild() const;
	bool IsNotDecreaseWeaponItem() const;
	bool IsShowCharacterStatus() const;
	void JoinInviteCode(const class FString& InviteCode) const;
	void ShowInvaderDebugLog() const;
	void ShowInviteCode() const;
	void ShowLaunchArguments() const;
	void StopOtomoAI() const;
	void StopOtomoMovement() const;
	void TeleportNearestPlayerToMe() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalCheatManager">();
	}
	static class UPalCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalCheatManager>();
	}
};
static_assert(alignof(UPalCheatManager) == 0x000008, "Wrong alignment on UPalCheatManager");
static_assert(sizeof(UPalCheatManager) == 0x0000C8, "Wrong size on UPalCheatManager");
static_assert(offsetof(UPalCheatManager, DebugWindowSetting) == 0x000090, "Member 'UPalCheatManager::DebugWindowSetting' has a wrong offset!");
static_assert(offsetof(UPalCheatManager, DebugProgressPresetDataTable) == 0x000098, "Member 'UPalCheatManager::DebugProgressPresetDataTable' has a wrong offset!");
static_assert(offsetof(UPalCheatManager, SpawnerInfoReporterClass) == 0x0000A0, "Member 'UPalCheatManager::SpawnerInfoReporterClass' has a wrong offset!");
static_assert(offsetof(UPalCheatManager, PalImGui) == 0x0000A8, "Member 'UPalCheatManager::PalImGui' has a wrong offset!");
static_assert(offsetof(UPalCheatManager, PalCountSystem) == 0x0000B0, "Member 'UPalCheatManager::PalCountSystem' has a wrong offset!");
static_assert(offsetof(UPalCheatManager, SpawnInfoReporter) == 0x0000B8, "Member 'UPalCheatManager::SpawnInfoReporter' has a wrong offset!");

// Class Pal.PalRichTextDecorator_TagText
// 0x0000 (0x0028 - 0x0028)
class UPalRichTextDecorator_TagText : public URichTextBlockDecorator
{
public:
	class FString GetTagName();
	class FString GetTextStringInternal(const class UObject* WorldContextObject, class FName ID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalRichTextDecorator_TagText">();
	}
	static class UPalRichTextDecorator_TagText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalRichTextDecorator_TagText>();
	}
};
static_assert(alignof(UPalRichTextDecorator_TagText) == 0x000008, "Wrong alignment on UPalRichTextDecorator_TagText");
static_assert(sizeof(UPalRichTextDecorator_TagText) == 0x000028, "Wrong size on UPalRichTextDecorator_TagText");

// Class Pal.PalCheckBox
// 0x0000 (0x0C80 - 0x0C80)
class UPalCheckBox final : public UCheckBox
{
public:
	void ToggleCheck();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalCheckBox">();
	}
	static class UPalCheckBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalCheckBox>();
	}
};
static_assert(alignof(UPalCheckBox) == 0x000010, "Wrong alignment on UPalCheckBox");
static_assert(sizeof(UPalCheckBox) == 0x000C80, "Wrong size on UPalCheckBox");

// Class Pal.PalGameSystemInitSequenceBase
// 0x0010 (0x0038 - 0x0028)
class UPalGameSystemInitSequenceBase : public UObject
{
public:
	TArray<class UPalGameSystemInitProcessHandle*> ProcessHandles;                                    // 0x0028(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGameSystemInitSequenceBase">();
	}
	static class UPalGameSystemInitSequenceBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalGameSystemInitSequenceBase>();
	}
};
static_assert(alignof(UPalGameSystemInitSequenceBase) == 0x000008, "Wrong alignment on UPalGameSystemInitSequenceBase");
static_assert(sizeof(UPalGameSystemInitSequenceBase) == 0x000038, "Wrong size on UPalGameSystemInitSequenceBase");
static_assert(offsetof(UPalGameSystemInitSequenceBase, ProcessHandles) == 0x000028, "Member 'UPalGameSystemInitSequenceBase::ProcessHandles' has a wrong offset!");

// Class Pal.PalGameSystemInitSequence_WaitForLocalNetworkTransmitter
// 0x0000 (0x0038 - 0x0038)
class UPalGameSystemInitSequence_WaitForLocalNetworkTransmitter final : public UPalGameSystemInitSequenceBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGameSystemInitSequence_WaitForLocalNetworkTransmitter">();
	}
	static class UPalGameSystemInitSequence_WaitForLocalNetworkTransmitter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalGameSystemInitSequence_WaitForLocalNetworkTransmitter>();
	}
};
static_assert(alignof(UPalGameSystemInitSequence_WaitForLocalNetworkTransmitter) == 0x000008, "Wrong alignment on UPalGameSystemInitSequence_WaitForLocalNetworkTransmitter");
static_assert(sizeof(UPalGameSystemInitSequence_WaitForLocalNetworkTransmitter) == 0x000038, "Wrong size on UPalGameSystemInitSequence_WaitForLocalNetworkTransmitter");

// Class Pal.PalClimbingComponent
// 0x0000 (0x00A0 - 0x00A0)
class UPalClimbingComponent : public UActorComponent
{
public:
	void ForceCancelClimb();
	void StartClimb(const struct FHitResult& Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalClimbingComponent">();
	}
	static class UPalClimbingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalClimbingComponent>();
	}
};
static_assert(alignof(UPalClimbingComponent) == 0x000008, "Wrong alignment on UPalClimbingComponent");
static_assert(sizeof(UPalClimbingComponent) == 0x0000A0, "Wrong size on UPalClimbingComponent");

// Class Pal.PalGameState
// 0x0000 (0x02E0 - 0x02E0)
class APalGameState : public AGameStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGameState">();
	}
	static class APalGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalGameState>();
	}
};
static_assert(alignof(APalGameState) == 0x000008, "Wrong alignment on APalGameState");
static_assert(sizeof(APalGameState) == 0x0002E0, "Wrong size on APalGameState");

// Class Pal.PalComboBoxString
// 0x14F0 (0x1640 - 0x0150)
class UPalComboBoxString final : public UWidget
{
public:
	TArray<class FString>                         DefaultOptions;                                    // 0x0150(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	class FString                                 SelectedOption;                                    // 0x0160(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FComboBoxStyle                         WidgetStyle;                                       // 0x0170(0x0660)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FTableRowStyle                         ItemStyle;                                         // 0x07D0(0x0D50)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FMargin                                ContentPadding;                                    // 0x1520(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MaxListHeight;                                     // 0x1530(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasDownArrow;                                      // 0x1534(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableGamepadNavigationMode;                       // 0x1535(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A6D[0x2];                                     // 0x1536(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateFontInfo                         Font;                                              // 0x1538(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateColor                            ForegroundColor;                                   // 0x1598(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bIsFocusable;                                      // 0x15AC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A6E[0x3];                                     // 0x15AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(const class FString& Item)>    OnGenerateWidgetEvent;                             // 0x15B0(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(const class FString& Item)>    OnGenerateTopWidgetEvent;                          // 0x15C0(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSelectionChanged;                                // 0x15D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnOpening;                                         // 0x15E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A6F[0x50];                                    // 0x15F0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddOption(const class FString& Option);
	void ClearOptions();
	void ClearSelection();
	void OnOpeningEvent__DelegateSignature();
	void OnSelectionChangedEvent__DelegateSignature(const class FString& SelectedItem, ESelectInfo SelectionType);
	void RefreshOptions();
	bool RemoveOption(const class FString& Option);
	void SetSelectedIndex(const int32 Param_Index);
	void SetSelectedOption(const class FString& Option);

	int32 FindOptionIndex(const class FString& Option) const;
	class FString GetOptionAtIndex(int32 Param_Index) const;
	int32 GetOptionCount() const;
	int32 GetSelectedIndex() const;
	class FString GetSelectedOption() const;
	bool IsOpen() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalComboBoxString">();
	}
	static class UPalComboBoxString* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalComboBoxString>();
	}
};
static_assert(alignof(UPalComboBoxString) == 0x000010, "Wrong alignment on UPalComboBoxString");
static_assert(sizeof(UPalComboBoxString) == 0x001640, "Wrong size on UPalComboBoxString");
static_assert(offsetof(UPalComboBoxString, DefaultOptions) == 0x000150, "Member 'UPalComboBoxString::DefaultOptions' has a wrong offset!");
static_assert(offsetof(UPalComboBoxString, SelectedOption) == 0x000160, "Member 'UPalComboBoxString::SelectedOption' has a wrong offset!");
static_assert(offsetof(UPalComboBoxString, WidgetStyle) == 0x000170, "Member 'UPalComboBoxString::WidgetStyle' has a wrong offset!");
static_assert(offsetof(UPalComboBoxString, ItemStyle) == 0x0007D0, "Member 'UPalComboBoxString::ItemStyle' has a wrong offset!");
static_assert(offsetof(UPalComboBoxString, ContentPadding) == 0x001520, "Member 'UPalComboBoxString::ContentPadding' has a wrong offset!");
static_assert(offsetof(UPalComboBoxString, MaxListHeight) == 0x001530, "Member 'UPalComboBoxString::MaxListHeight' has a wrong offset!");
static_assert(offsetof(UPalComboBoxString, HasDownArrow) == 0x001534, "Member 'UPalComboBoxString::HasDownArrow' has a wrong offset!");
static_assert(offsetof(UPalComboBoxString, EnableGamepadNavigationMode) == 0x001535, "Member 'UPalComboBoxString::EnableGamepadNavigationMode' has a wrong offset!");
static_assert(offsetof(UPalComboBoxString, Font) == 0x001538, "Member 'UPalComboBoxString::Font' has a wrong offset!");
static_assert(offsetof(UPalComboBoxString, ForegroundColor) == 0x001598, "Member 'UPalComboBoxString::ForegroundColor' has a wrong offset!");
static_assert(offsetof(UPalComboBoxString, bIsFocusable) == 0x0015AC, "Member 'UPalComboBoxString::bIsFocusable' has a wrong offset!");
static_assert(offsetof(UPalComboBoxString, OnGenerateWidgetEvent) == 0x0015B0, "Member 'UPalComboBoxString::OnGenerateWidgetEvent' has a wrong offset!");
static_assert(offsetof(UPalComboBoxString, OnGenerateTopWidgetEvent) == 0x0015C0, "Member 'UPalComboBoxString::OnGenerateTopWidgetEvent' has a wrong offset!");
static_assert(offsetof(UPalComboBoxString, OnSelectionChanged) == 0x0015D0, "Member 'UPalComboBoxString::OnSelectionChanged' has a wrong offset!");
static_assert(offsetof(UPalComboBoxString, OnOpening) == 0x0015E0, "Member 'UPalComboBoxString::OnOpening' has a wrong offset!");

// Class Pal.PalCommonBoundActionButton
// 0x0000 (0x1510 - 0x1510)
class UPalCommonBoundActionButton : public UCommonBoundActionButton
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalCommonBoundActionButton">();
	}
	static class UPalCommonBoundActionButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalCommonBoundActionButton>();
	}
};
static_assert(alignof(UPalCommonBoundActionButton) == 0x000010, "Wrong alignment on UPalCommonBoundActionButton");
static_assert(sizeof(UPalCommonBoundActionButton) == 0x001510, "Wrong size on UPalCommonBoundActionButton");

// Class Pal.PalCommonScrollListBase
// 0x0000 (0x0408 - 0x0408)
class UPalCommonScrollListBase : public UPalUserWidget
{
public:
	void MoveItem(const int32 Num, class UPalItemSlot* MoveItemSlot, const struct FPalContainerId& TargetContainerId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalCommonScrollListBase">();
	}
	static class UPalCommonScrollListBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalCommonScrollListBase>();
	}
};
static_assert(alignof(UPalCommonScrollListBase) == 0x000008, "Wrong alignment on UPalCommonScrollListBase");
static_assert(sizeof(UPalCommonScrollListBase) == 0x000408, "Wrong size on UPalCommonScrollListBase");

// Class Pal.PalGameSystemInitManagerComponent
// 0x0058 (0x00F8 - 0x00A0)
class UPalGameSystemInitManagerComponent final : public UGameStateComponent
{
public:
	uint8                                         Pad_2A75[0x40];                                    // 0x00A0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPalGameSystemInitSequenceSet>  InitSequences;                                     // 0x00E0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	int32                                         CurrentSequenceIndex;                              // 0x00F0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A76[0x4];                                     // 0x00F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChangeProcessProgressRate(class UPalGameSystemInitProcessHandle* ChangedProcessHandle);
	void OnChangeProcessState(class UPalGameSystemInitProcessHandle* ChangedProcessHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGameSystemInitManagerComponent">();
	}
	static class UPalGameSystemInitManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalGameSystemInitManagerComponent>();
	}
};
static_assert(alignof(UPalGameSystemInitManagerComponent) == 0x000008, "Wrong alignment on UPalGameSystemInitManagerComponent");
static_assert(sizeof(UPalGameSystemInitManagerComponent) == 0x0000F8, "Wrong size on UPalGameSystemInitManagerComponent");
static_assert(offsetof(UPalGameSystemInitManagerComponent, InitSequences) == 0x0000E0, "Member 'UPalGameSystemInitManagerComponent::InitSequences' has a wrong offset!");
static_assert(offsetof(UPalGameSystemInitManagerComponent, CurrentSequenceIndex) == 0x0000F0, "Member 'UPalGameSystemInitManagerComponent::CurrentSequenceIndex' has a wrong offset!");

// Class Pal.PalContainerBase
// 0x0028 (0x0050 - 0x0028)
class UPalContainerBase : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnDisposeContainerDelegate;                        // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FPalContainerId                        ID;                                                // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnTemplate, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPalContainerOperationRestrictType            OperationRestrictType;                             // 0x0048(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnoreOnSave;                                     // 0x0049(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A77[0x6];                                     // 0x004A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisposeContainerDelegate__DelegateSignature();

	const struct FPalContainerId GetId() const;
	bool IsEmpty() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalContainerBase">();
	}
	static class UPalContainerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalContainerBase>();
	}
};
static_assert(alignof(UPalContainerBase) == 0x000008, "Wrong alignment on UPalContainerBase");
static_assert(sizeof(UPalContainerBase) == 0x000050, "Wrong size on UPalContainerBase");
static_assert(offsetof(UPalContainerBase, OnDisposeContainerDelegate) == 0x000028, "Member 'UPalContainerBase::OnDisposeContainerDelegate' has a wrong offset!");
static_assert(offsetof(UPalContainerBase, ID) == 0x000038, "Member 'UPalContainerBase::ID' has a wrong offset!");
static_assert(offsetof(UPalContainerBase, OperationRestrictType) == 0x000048, "Member 'UPalContainerBase::OperationRestrictType' has a wrong offset!");
static_assert(offsetof(UPalContainerBase, bIgnoreOnSave) == 0x000049, "Member 'UPalContainerBase::bIgnoreOnSave' has a wrong offset!");

// Class Pal.PalContainerUtility
// 0x0000 (0x0028 - 0x0028)
class UPalContainerUtility final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalContainerUtility">();
	}
	static class UPalContainerUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalContainerUtility>();
	}
};
static_assert(alignof(UPalContainerUtility) == 0x000008, "Wrong alignment on UPalContainerUtility");
static_assert(sizeof(UPalContainerUtility) == 0x000028, "Wrong size on UPalContainerUtility");

// Class Pal.PalGameSystemInitSequence_StartAutoSave_WorldAndLocal
// 0x0000 (0x0038 - 0x0038)
class UPalGameSystemInitSequence_StartAutoSave_WorldAndLocal final : public UPalGameSystemInitSequenceBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGameSystemInitSequence_StartAutoSave_WorldAndLocal">();
	}
	static class UPalGameSystemInitSequence_StartAutoSave_WorldAndLocal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalGameSystemInitSequence_StartAutoSave_WorldAndLocal>();
	}
};
static_assert(alignof(UPalGameSystemInitSequence_StartAutoSave_WorldAndLocal) == 0x000008, "Wrong alignment on UPalGameSystemInitSequence_StartAutoSave_WorldAndLocal");
static_assert(sizeof(UPalGameSystemInitSequence_StartAutoSave_WorldAndLocal) == 0x000038, "Wrong size on UPalGameSystemInitSequence_StartAutoSave_WorldAndLocal");

// Class Pal.PalMapObjectDoorModel
// 0x0000 (0x0218 - 0x0218)
class UPalMapObjectDoorModel final : public UPalMapObjectConcreteModelBase
{
public:
	void RequestTrigger_ServerInternal(const int32 RequestPlayerId, const int32 ToStateInt);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectDoorModel">();
	}
	static class UPalMapObjectDoorModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectDoorModel>();
	}
};
static_assert(alignof(UPalMapObjectDoorModel) == 0x000008, "Wrong alignment on UPalMapObjectDoorModel");
static_assert(sizeof(UPalMapObjectDoorModel) == 0x000218, "Wrong size on UPalMapObjectDoorModel");

// Class Pal.PalCoopClimbPlayer
// 0x00A8 (0x00D0 - 0x0028)
class UPalCoopClimbPlayer final : public UObject
{
public:
	class APalCharacter*                          Player;                                            // 0x0028(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalAnimInstance*                       PlayerAnime;                                       // 0x0030(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<EHumanBone>                            BoneChain;                                         // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	int32                                         CurrentIndex;                                      // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A78[0x4];                                     // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             TargetWorldTf;                                     // 0x0050(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Progress;                                          // 0x00B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          Complete;                                          // 0x00B4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A79[0x3];                                     // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             StartStandAnimeDelegate;                           // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A7A[0x8];                                     // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeNode(EHumanBone EntryBone, class APalCharacter* PlayerCharacter, const struct FTransform& Climber);
	void StartStandAnimeDelegate__DelegateSignature();
	struct FTransform UpdateTransform(const struct FTransform& Climber, float ProgressSpeed, float LeapPosSpeed, float LeapRotateSpeed, float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalCoopClimbPlayer">();
	}
	static class UPalCoopClimbPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalCoopClimbPlayer>();
	}
};
static_assert(alignof(UPalCoopClimbPlayer) == 0x000010, "Wrong alignment on UPalCoopClimbPlayer");
static_assert(sizeof(UPalCoopClimbPlayer) == 0x0000D0, "Wrong size on UPalCoopClimbPlayer");
static_assert(offsetof(UPalCoopClimbPlayer, Player) == 0x000028, "Member 'UPalCoopClimbPlayer::Player' has a wrong offset!");
static_assert(offsetof(UPalCoopClimbPlayer, PlayerAnime) == 0x000030, "Member 'UPalCoopClimbPlayer::PlayerAnime' has a wrong offset!");
static_assert(offsetof(UPalCoopClimbPlayer, BoneChain) == 0x000038, "Member 'UPalCoopClimbPlayer::BoneChain' has a wrong offset!");
static_assert(offsetof(UPalCoopClimbPlayer, CurrentIndex) == 0x000048, "Member 'UPalCoopClimbPlayer::CurrentIndex' has a wrong offset!");
static_assert(offsetof(UPalCoopClimbPlayer, TargetWorldTf) == 0x000050, "Member 'UPalCoopClimbPlayer::TargetWorldTf' has a wrong offset!");
static_assert(offsetof(UPalCoopClimbPlayer, Progress) == 0x0000B0, "Member 'UPalCoopClimbPlayer::Progress' has a wrong offset!");
static_assert(offsetof(UPalCoopClimbPlayer, Complete) == 0x0000B4, "Member 'UPalCoopClimbPlayer::Complete' has a wrong offset!");
static_assert(offsetof(UPalCoopClimbPlayer, StartStandAnimeDelegate) == 0x0000B8, "Member 'UPalCoopClimbPlayer::StartStandAnimeDelegate' has a wrong offset!");

// Class Pal.PalCoopSkillModuleBase
// 0x0010 (0x0038 - 0x0028)
class UPalCoopSkillModuleBase : public UObject
{
public:
	EPalLogType                                   ExecuteLog;                                        // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A7C[0x7];                                     // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class APalCharacter*                          OwnerCharacter;                                    // 0x0030(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Abort();
	void AddSkillLog();
	void Initialize(class UPalPartnerSkillParameterComponent* PartnerSkillComponent);
	void OnInitialized();
	void OnSkillOverheat();
	void OnStartSkill();
	void OnTick(float DeltaTime);
	void SetTrainerCoopFlag(bool IsCoop);
	void Start();

	class APalCharacter* GetOwner() const;
	int32 GetOwnerRank() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalCoopSkillModuleBase">();
	}
	static class UPalCoopSkillModuleBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalCoopSkillModuleBase>();
	}
};
static_assert(alignof(UPalCoopSkillModuleBase) == 0x000008, "Wrong alignment on UPalCoopSkillModuleBase");
static_assert(sizeof(UPalCoopSkillModuleBase) == 0x000038, "Wrong size on UPalCoopSkillModuleBase");
static_assert(offsetof(UPalCoopSkillModuleBase, ExecuteLog) == 0x000028, "Member 'UPalCoopSkillModuleBase::ExecuteLog' has a wrong offset!");
static_assert(offsetof(UPalCoopSkillModuleBase, OwnerCharacter) == 0x000030, "Member 'UPalCoopSkillModuleBase::OwnerCharacter' has a wrong offset!");

// Class Pal.PalSyncTeleportComponent
// 0x00B0 (0x0150 - 0x00A0)
class alignas(0x10) UPalSyncTeleportComponent final : public UActorComponent
{
public:
	uint8                                         Pad_2A7D[0x18];                                    // 0x00A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnPlayerMovedClientDelegate;                       // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerMoveCompleteClientDelegate;                // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          DefaultStartSE;                                    // 0x00D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalHUDDispatchParameter_FadeWidget*    FadeParameter;                                     // 0x00E0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A7E[0x68];                                    // 0x00E8(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEndSyncTeleportFadeIn();
	void OnEndSyncTeleportFadeOut();
	void ReceiveSyncTeleportEnd_ToClient(bool bIsSuccess);
	void ReceiveSyncTeleportMoveResult_ToClient(bool bIsSuccess);
	void ReceiveSyncTeleportStartResult_ToClient(bool bIsSuccess);
	void RequestSyncTeleportEnd_ToServer();
	void RequestSyncTeleportMove_ToServer();
	void RequestSyncTeleportStart_ToServer(const struct FPalSyncTeleportRequestParameter& Parameter);
	void SyncTeleport(const struct FPalSyncTeleportRequestParameter& Parameter);
	void SyncTeleport_ToClient(const struct FPalSyncTeleportRequestParameter& Parameter);
	void SyncTeleportPlayerMovedDynamicDelegate__DelegateSignature();

	struct FVector GetTeleportLocation() const;
	struct FQuat GetTeleportRotation() const;
	bool IsTeleporting() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalSyncTeleportComponent">();
	}
	static class UPalSyncTeleportComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalSyncTeleportComponent>();
	}
};
static_assert(alignof(UPalSyncTeleportComponent) == 0x000010, "Wrong alignment on UPalSyncTeleportComponent");
static_assert(sizeof(UPalSyncTeleportComponent) == 0x000150, "Wrong size on UPalSyncTeleportComponent");
static_assert(offsetof(UPalSyncTeleportComponent, OnPlayerMovedClientDelegate) == 0x0000B8, "Member 'UPalSyncTeleportComponent::OnPlayerMovedClientDelegate' has a wrong offset!");
static_assert(offsetof(UPalSyncTeleportComponent, OnPlayerMoveCompleteClientDelegate) == 0x0000C8, "Member 'UPalSyncTeleportComponent::OnPlayerMoveCompleteClientDelegate' has a wrong offset!");
static_assert(offsetof(UPalSyncTeleportComponent, DefaultStartSE) == 0x0000D8, "Member 'UPalSyncTeleportComponent::DefaultStartSE' has a wrong offset!");
static_assert(offsetof(UPalSyncTeleportComponent, FadeParameter) == 0x0000E0, "Member 'UPalSyncTeleportComponent::FadeParameter' has a wrong offset!");

// Class Pal.PalGameSystemInitSequence_CreateSystemForDedicatedServer
// 0x0000 (0x0038 - 0x0038)
class UPalGameSystemInitSequence_CreateSystemForDedicatedServer final : public UPalGameSystemInitSequenceBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGameSystemInitSequence_CreateSystemForDedicatedServer">();
	}
	static class UPalGameSystemInitSequence_CreateSystemForDedicatedServer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalGameSystemInitSequence_CreateSystemForDedicatedServer>();
	}
};
static_assert(alignof(UPalGameSystemInitSequence_CreateSystemForDedicatedServer) == 0x000008, "Wrong alignment on UPalGameSystemInitSequence_CreateSystemForDedicatedServer");
static_assert(sizeof(UPalGameSystemInitSequence_CreateSystemForDedicatedServer) == 0x000038, "Wrong size on UPalGameSystemInitSequence_CreateSystemForDedicatedServer");

// Class Pal.PalCoopSkillModuleAssignPassiveSkill
// 0x0018 (0x0050 - 0x0038)
class UPalCoopSkillModuleAssignPassiveSkill final : public UPalCoopSkillModuleBase
{
public:
	TArray<struct FPalCoopSkillModuleAssignPassiveSkillNames> AssignSkillNamesPerRank;                           // 0x0038(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   PassiveSkillAssignFlagName;                        // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AssignPassiveSkill(const class FName& SkillName);
	void AssignPassiveSkills(const TArray<struct FPalDataTableRowName_PassiveSkillData>& AssignSkillName);
	void RemovePassiveSkills();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalCoopSkillModuleAssignPassiveSkill">();
	}
	static class UPalCoopSkillModuleAssignPassiveSkill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalCoopSkillModuleAssignPassiveSkill>();
	}
};
static_assert(alignof(UPalCoopSkillModuleAssignPassiveSkill) == 0x000008, "Wrong alignment on UPalCoopSkillModuleAssignPassiveSkill");
static_assert(sizeof(UPalCoopSkillModuleAssignPassiveSkill) == 0x000050, "Wrong size on UPalCoopSkillModuleAssignPassiveSkill");
static_assert(offsetof(UPalCoopSkillModuleAssignPassiveSkill, AssignSkillNamesPerRank) == 0x000038, "Member 'UPalCoopSkillModuleAssignPassiveSkill::AssignSkillNamesPerRank' has a wrong offset!");
static_assert(offsetof(UPalCoopSkillModuleAssignPassiveSkill, PassiveSkillAssignFlagName) == 0x000048, "Member 'UPalCoopSkillModuleAssignPassiveSkill::PassiveSkillAssignFlagName' has a wrong offset!");

// Class Pal.PalGameSystemInitProcessHandle
// 0x0040 (0x0068 - 0x0028)
class UPalGameSystemInitProcessHandle final : public UObject
{
public:
	uint8                                         Pad_2A7F[0x28];                                    // 0x0028(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UPalGameSystemInitProcessHandle*> ChildProcessHandles;                               // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A80[0x8];                                     // 0x0060(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGameSystemInitProcessHandle">();
	}
	static class UPalGameSystemInitProcessHandle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalGameSystemInitProcessHandle>();
	}
};
static_assert(alignof(UPalGameSystemInitProcessHandle) == 0x000008, "Wrong alignment on UPalGameSystemInitProcessHandle");
static_assert(sizeof(UPalGameSystemInitProcessHandle) == 0x000068, "Wrong size on UPalGameSystemInitProcessHandle");
static_assert(offsetof(UPalGameSystemInitProcessHandle, ChildProcessHandles) == 0x000050, "Member 'UPalGameSystemInitProcessHandle::ChildProcessHandles' has a wrong offset!");

// Class Pal.PalCoopSkillSearchCharacter
// 0x0000 (0x0098 - 0x0098)
class UPalCoopSkillSearchCharacter final : public UPalCoopSkillSearchBase
{
public:
	void SearchMonsters(const struct FVector& Origin, float SearchRadius, const struct FGuid& RequestPlayerUId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalCoopSkillSearchCharacter">();
	}
	static class UPalCoopSkillSearchCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalCoopSkillSearchCharacter>();
	}
};
static_assert(alignof(UPalCoopSkillSearchCharacter) == 0x000008, "Wrong alignment on UPalCoopSkillSearchCharacter");
static_assert(sizeof(UPalCoopSkillSearchCharacter) == 0x000098, "Wrong size on UPalCoopSkillSearchCharacter");

// Class Pal.PalCoopSkillSearchDungeonPortal
// 0x0000 (0x0098 - 0x0098)
class UPalCoopSkillSearchDungeonPortal final : public UPalCoopSkillSearchBase
{
public:
	void SearchDungeonPortal(const struct FVector& Origin, float SearchRadius, const struct FGuid& RequestPlayerUId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalCoopSkillSearchDungeonPortal">();
	}
	static class UPalCoopSkillSearchDungeonPortal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalCoopSkillSearchDungeonPortal>();
	}
};
static_assert(alignof(UPalCoopSkillSearchDungeonPortal) == 0x000008, "Wrong alignment on UPalCoopSkillSearchDungeonPortal");
static_assert(sizeof(UPalCoopSkillSearchDungeonPortal) == 0x000098, "Wrong size on UPalCoopSkillSearchDungeonPortal");

// Class Pal.PalEditorNpcMultiTalkDataUtility
// 0x0000 (0x0028 - 0x0028)
class UPalEditorNpcMultiTalkDataUtility final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalEditorNpcMultiTalkDataUtility">();
	}
	static class UPalEditorNpcMultiTalkDataUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalEditorNpcMultiTalkDataUtility>();
	}
};
static_assert(alignof(UPalEditorNpcMultiTalkDataUtility) == 0x000008, "Wrong alignment on UPalEditorNpcMultiTalkDataUtility");
static_assert(sizeof(UPalEditorNpcMultiTalkDataUtility) == 0x000028, "Wrong size on UPalEditorNpcMultiTalkDataUtility");

// Class Pal.PalGameSystemInitSequence_InitializeWorldAfterAppliedSaveData
// 0x0000 (0x0038 - 0x0038)
class UPalGameSystemInitSequence_InitializeWorldAfterAppliedSaveData final : public UPalGameSystemInitSequenceBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGameSystemInitSequence_InitializeWorldAfterAppliedSaveData">();
	}
	static class UPalGameSystemInitSequence_InitializeWorldAfterAppliedSaveData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalGameSystemInitSequence_InitializeWorldAfterAppliedSaveData>();
	}
};
static_assert(alignof(UPalGameSystemInitSequence_InitializeWorldAfterAppliedSaveData) == 0x000008, "Wrong alignment on UPalGameSystemInitSequence_InitializeWorldAfterAppliedSaveData");
static_assert(sizeof(UPalGameSystemInitSequence_InitializeWorldAfterAppliedSaveData) == 0x000038, "Wrong size on UPalGameSystemInitSequence_InitializeWorldAfterAppliedSaveData");

// Class Pal.PalCoopSkillSearchEffectController
// 0x0000 (0x0028 - 0x0028)
class UPalCoopSkillSearchEffectController : public UObject
{
public:
	void End();
	void Start(const struct FVector& Origin, float RadiusFrom, float RadiusTo, float ExtRadiusPerSec);
	void Tick(float DeltaTime);

	bool IsFinished() const;
	bool IsRunning() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalCoopSkillSearchEffectController">();
	}
	static class UPalCoopSkillSearchEffectController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalCoopSkillSearchEffectController>();
	}
};
static_assert(alignof(UPalCoopSkillSearchEffectController) == 0x000008, "Wrong alignment on UPalCoopSkillSearchEffectController");
static_assert(sizeof(UPalCoopSkillSearchEffectController) == 0x000028, "Wrong size on UPalCoopSkillSearchEffectController");

// Class Pal.PalCoopSkillSearchLocationRegister
// 0x00B8 (0x00E0 - 0x0028)
class UPalCoopSkillSearchLocationRegister final : public UObject
{
public:
	TArray<struct FGuid>                          RegisteredLocationIds;                             // 0x0028(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	TMap<struct FGuid, float>                     RegisteredLocationElapsedSec;                      // 0x0038(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	float                                         LocationDisplayTimeSec;                            // 0x0088(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A84[0x54];                                    // 0x008C(0x0054)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RegisterMapObjectLocationsToCompass(const struct FPalCoopSkillSearchResultParameter& ResultParameter);
	void UnregisterMapObjectLocationsFromCompass(const struct FGuid& Guiid);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalCoopSkillSearchLocationRegister">();
	}
	static class UPalCoopSkillSearchLocationRegister* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalCoopSkillSearchLocationRegister>();
	}
};
static_assert(alignof(UPalCoopSkillSearchLocationRegister) == 0x000008, "Wrong alignment on UPalCoopSkillSearchLocationRegister");
static_assert(sizeof(UPalCoopSkillSearchLocationRegister) == 0x0000E0, "Wrong size on UPalCoopSkillSearchLocationRegister");
static_assert(offsetof(UPalCoopSkillSearchLocationRegister, RegisteredLocationIds) == 0x000028, "Member 'UPalCoopSkillSearchLocationRegister::RegisteredLocationIds' has a wrong offset!");
static_assert(offsetof(UPalCoopSkillSearchLocationRegister, RegisteredLocationElapsedSec) == 0x000038, "Member 'UPalCoopSkillSearchLocationRegister::RegisteredLocationElapsedSec' has a wrong offset!");
static_assert(offsetof(UPalCoopSkillSearchLocationRegister, LocationDisplayTimeSec) == 0x000088, "Member 'UPalCoopSkillSearchLocationRegister::LocationDisplayTimeSec' has a wrong offset!");

// Class Pal.PalGroupOperationResultUtility
// 0x0000 (0x0028 - 0x0028)
class UPalGroupOperationResultUtility final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGroupOperationResultUtility">();
	}
	static class UPalGroupOperationResultUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalGroupOperationResultUtility>();
	}
};
static_assert(alignof(UPalGroupOperationResultUtility) == 0x000008, "Wrong alignment on UPalGroupOperationResultUtility");
static_assert(sizeof(UPalGroupOperationResultUtility) == 0x000028, "Wrong size on UPalGroupOperationResultUtility");

// Class Pal.PalStateMachine
// 0x0060 (0x0088 - 0x0028)
class UPalStateMachine : public UObject
{
public:
	TMap<class UClass*, class UPalStateMachineStateBase*> StateMap;                                          // 0x0028(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	class UPalStateMachineStateBase*              CurrentState;                                      // 0x0078(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A85[0x8];                                     // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddState(class UPalStateMachineStateBase* State);
	void ChangeState(class UClass* ToStateClass);
	void Dispose();
	void Start(class UClass* StartClass);
	void Tick(float DeltaTime);

	class UPalStateMachineStateBase* GetCurrentState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalStateMachine">();
	}
	static class UPalStateMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalStateMachine>();
	}
};
static_assert(alignof(UPalStateMachine) == 0x000008, "Wrong alignment on UPalStateMachine");
static_assert(sizeof(UPalStateMachine) == 0x000088, "Wrong size on UPalStateMachine");
static_assert(offsetof(UPalStateMachine, StateMap) == 0x000028, "Member 'UPalStateMachine::StateMap' has a wrong offset!");
static_assert(offsetof(UPalStateMachine, CurrentState) == 0x000078, "Member 'UPalStateMachine::CurrentState' has a wrong offset!");

// Class Pal.PalMapObjectFarmBlockV2ModelStateBehaviourMachine
// 0x0010 (0x0098 - 0x0088)
class UPalMapObjectFarmBlockV2ModelStateBehaviourMachine final : public UPalStateMachine
{
public:
	class UPalMapObjectFarmBlockV2ModelStateBehaviourBase* CurrentStateBehaviourCache;                        // 0x0088(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A86[0x8];                                     // 0x0090(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectFarmBlockV2ModelStateBehaviourMachine">();
	}
	static class UPalMapObjectFarmBlockV2ModelStateBehaviourMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectFarmBlockV2ModelStateBehaviourMachine>();
	}
};
static_assert(alignof(UPalMapObjectFarmBlockV2ModelStateBehaviourMachine) == 0x000008, "Wrong alignment on UPalMapObjectFarmBlockV2ModelStateBehaviourMachine");
static_assert(sizeof(UPalMapObjectFarmBlockV2ModelStateBehaviourMachine) == 0x000098, "Wrong size on UPalMapObjectFarmBlockV2ModelStateBehaviourMachine");
static_assert(offsetof(UPalMapObjectFarmBlockV2ModelStateBehaviourMachine, CurrentStateBehaviourCache) == 0x000088, "Member 'UPalMapObjectFarmBlockV2ModelStateBehaviourMachine::CurrentStateBehaviourCache' has a wrong offset!");

// Class Pal.PalCoopSkillSearchMapObject
// 0x0000 (0x0098 - 0x0098)
class UPalCoopSkillSearchMapObject final : public UPalCoopSkillSearchBase
{
public:
	void SearchMapObjects(const TArray<class FName>& SearchMapObjIds, const struct FVector& Origin, float SearchRadius, const struct FGuid& RequestPlayerUId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalCoopSkillSearchMapObject">();
	}
	static class UPalCoopSkillSearchMapObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalCoopSkillSearchMapObject>();
	}
};
static_assert(alignof(UPalCoopSkillSearchMapObject) == 0x000008, "Wrong alignment on UPalCoopSkillSearchMapObject");
static_assert(sizeof(UPalCoopSkillSearchMapObject) == 0x000098, "Wrong size on UPalCoopSkillSearchMapObject");

// Class Pal.PalGameViewportClient
// 0x0000 (0x03E0 - 0x03E0)
class UPalGameViewportClient final : public UCommonGameViewportClient
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGameViewportClient">();
	}
	static class UPalGameViewportClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalGameViewportClient>();
	}
};
static_assert(alignof(UPalGameViewportClient) == 0x000008, "Wrong alignment on UPalGameViewportClient");
static_assert(sizeof(UPalGameViewportClient) == 0x0003E0, "Wrong size on UPalGameViewportClient");

// Class Pal.PalCopyMeshVisualEffect
// 0x0010 (0x02A0 - 0x0290)
class APalCopyMeshVisualEffect : public AActor
{
public:
	class UCapsuleComponent*                      RootCapsule;                                       // 0x0290(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalPoseableMeshComponent*              PoseableSkeletalMeshComponent;                     // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Setup(class USkeletalMeshComponent* MeshComponent);

	void GetAllMesh(TArray<class USceneComponent*>* OutComponent) const;
	class USkinnedMeshComponent* GetMainMesh() const;
	TArray<class UMaterialInstanceDynamic*> GetMainMeshMaterials() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalCopyMeshVisualEffect">();
	}
	static class APalCopyMeshVisualEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalCopyMeshVisualEffect>();
	}
};
static_assert(alignof(APalCopyMeshVisualEffect) == 0x000008, "Wrong alignment on APalCopyMeshVisualEffect");
static_assert(sizeof(APalCopyMeshVisualEffect) == 0x0002A0, "Wrong size on APalCopyMeshVisualEffect");
static_assert(offsetof(APalCopyMeshVisualEffect, RootCapsule) == 0x000290, "Member 'APalCopyMeshVisualEffect::RootCapsule' has a wrong offset!");
static_assert(offsetof(APalCopyMeshVisualEffect, PoseableSkeletalMeshComponent) == 0x000298, "Member 'APalCopyMeshVisualEffect::PoseableSkeletalMeshComponent' has a wrong offset!");

// Class Pal.PalCryComponentBase
// 0x0000 (0x00A0 - 0x00A0)
class UPalCryComponentBase : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalCryComponentBase">();
	}
	static class UPalCryComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalCryComponentBase>();
	}
};
static_assert(alignof(UPalCryComponentBase) == 0x000008, "Wrong alignment on UPalCryComponentBase");
static_assert(sizeof(UPalCryComponentBase) == 0x0000A0, "Wrong size on UPalCryComponentBase");

// Class Pal.PalGameSystemInitSequence_InitializeWorld
// 0x0000 (0x0038 - 0x0038)
class UPalGameSystemInitSequence_InitializeWorld final : public UPalGameSystemInitSequenceBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGameSystemInitSequence_InitializeWorld">();
	}
	static class UPalGameSystemInitSequence_InitializeWorld* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalGameSystemInitSequence_InitializeWorld>();
	}
};
static_assert(alignof(UPalGameSystemInitSequence_InitializeWorld) == 0x000008, "Wrong alignment on UPalGameSystemInitSequence_InitializeWorld");
static_assert(sizeof(UPalGameSystemInitSequence_InitializeWorld) == 0x000038, "Wrong size on UPalGameSystemInitSequence_InitializeWorld");

// Class Pal.PalMapObjectItemCollectableInterface
// 0x0000 (0x0028 - 0x0028)
class IPalMapObjectItemCollectableInterface final : public IInterface
{
public:
	void GetCollectableStaticItemIds(TArray<class FName>* OutStaticItemIds);

	EPalMapObjectItemCollectableType GetItemCollectableType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectItemCollectableInterface">();
	}
	static class IPalMapObjectItemCollectableInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPalMapObjectItemCollectableInterface>();
	}
};
static_assert(alignof(IPalMapObjectItemCollectableInterface) == 0x000008, "Wrong alignment on IPalMapObjectItemCollectableInterface");
static_assert(sizeof(IPalMapObjectItemCollectableInterface) == 0x000028, "Wrong size on IPalMapObjectItemCollectableInterface");

// Class Pal.PalCustomPrimitiveWidget
// 0x0028 (0x0430 - 0x0408)
class UPalCustomPrimitiveWidget : public UPalUserWidget
{
public:
	class USlateBrushAsset*                       SlateBrush;                                        // 0x0408(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FPalUMGCustomVertexData>        VertexData;                                        // 0x0410(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 VertexIndexes;                                     // 0x0420(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void PushVertexData(const struct FPalUMGCustomVertexData& InVertexData);
	void UpdateVertexData(int32 Param_Index, const struct FPalUMGCustomVertexData& InVertexData);

	void DrawVertexData(struct FPaintContext& Context) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalCustomPrimitiveWidget">();
	}
	static class UPalCustomPrimitiveWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalCustomPrimitiveWidget>();
	}
};
static_assert(alignof(UPalCustomPrimitiveWidget) == 0x000008, "Wrong alignment on UPalCustomPrimitiveWidget");
static_assert(sizeof(UPalCustomPrimitiveWidget) == 0x000430, "Wrong size on UPalCustomPrimitiveWidget");
static_assert(offsetof(UPalCustomPrimitiveWidget, SlateBrush) == 0x000408, "Member 'UPalCustomPrimitiveWidget::SlateBrush' has a wrong offset!");
static_assert(offsetof(UPalCustomPrimitiveWidget, VertexData) == 0x000410, "Member 'UPalCustomPrimitiveWidget::VertexData' has a wrong offset!");
static_assert(offsetof(UPalCustomPrimitiveWidget, VertexIndexes) == 0x000420, "Member 'UPalCustomPrimitiveWidget::VertexIndexes' has a wrong offset!");

// Class Pal.PalFacialComponent
// 0x0028 (0x00C8 - 0x00A0)
class UPalFacialComponent final : public UActorComponent
{
public:
	bool                                          bIsEnableEyeBlink;                                 // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A89[0x7];                                     // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalFacial_MainModule*                  MainModule;                                        // 0x00A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A8A[0x18];                                    // 0x00B0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Blink();
	void ChangeDefaultFacial();
	void ChangeEye_ForMontageNotify(EPalFacialEyeType Eye);
	void ChangeEyeAndMouthMesh(EPalFacialEyeType Eye);
	void ChangeMouth_ForMontageNotify(EPalFacialMouthType Mouth);
	bool ExistEyeNotifyInMontage(class UAnimMontage* Montage);
	bool ExistFacialNotifyInMontage(class UAnimMontage* Montage);
	void SetDefaultLayer(EPalFacialEyeType Eye);
	void SetDisableNotify(bool Disable);
	void SetUpTestMesh(class USkeletalMeshComponent* SkeletalMeshComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalFacialComponent">();
	}
	static class UPalFacialComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalFacialComponent>();
	}
};
static_assert(alignof(UPalFacialComponent) == 0x000008, "Wrong alignment on UPalFacialComponent");
static_assert(sizeof(UPalFacialComponent) == 0x0000C8, "Wrong size on UPalFacialComponent");
static_assert(offsetof(UPalFacialComponent, bIsEnableEyeBlink) == 0x0000A0, "Member 'UPalFacialComponent::bIsEnableEyeBlink' has a wrong offset!");
static_assert(offsetof(UPalFacialComponent, MainModule) == 0x0000A8, "Member 'UPalFacialComponent::MainModule' has a wrong offset!");

// Class Pal.PalCutsceneActor
// 0x0008 (0x0310 - 0x0308)
class APalCutsceneActor final : public ALevelSequenceActor
{
public:
	float                                         OpeningFadeOutDelay;                               // 0x0308(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OpeningFadeOutTime;                                // 0x030C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnFinishedCutscene();
	void OnPrePlayCutscene();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalCutsceneActor">();
	}
	static class APalCutsceneActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalCutsceneActor>();
	}
};
static_assert(alignof(APalCutsceneActor) == 0x000008, "Wrong alignment on APalCutsceneActor");
static_assert(sizeof(APalCutsceneActor) == 0x000310, "Wrong size on APalCutsceneActor");
static_assert(offsetof(APalCutsceneActor, OpeningFadeOutDelay) == 0x000308, "Member 'APalCutsceneActor::OpeningFadeOutDelay' has a wrong offset!");
static_assert(offsetof(APalCutsceneActor, OpeningFadeOutTime) == 0x00030C, "Member 'APalCutsceneActor::OpeningFadeOutTime' has a wrong offset!");

// Class Pal.PalCutsceneComponent
// 0x0048 (0x00E8 - 0x00A0)
class UPalCutsceneComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnPlayCutsceneDelegate;                            // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFinishCutsceneDelegate;                          // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class APalCutsceneActor*                      CutsceneActor;                                     // 0x00C0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A8D[0x8];                                     // 0x00C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalHUDDispatchParameter_FadeWidget*    FadeParam;                                         // 0x00D0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A8E[0x10];                                    // 0x00D8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CutsceneDelegate__DelegateSignature();
	void CutsceneFinishDelegate__DelegateSignature(bool bIsSkipped);
	void OnEndFadeOut();
	void OnFinished();
	void PlayCutscene(class APalCutsceneActor* InCutsceneActor, bool IsAutoDestroy);
	void PlayCutsceneToServer();
	class APalCutsceneActor* SpawnCutsceneActor(TSubclassOf<class APalCutsceneActor> CutsceneActorClass, const struct FVector& Location, const struct FRotator& Rotation, class AActor* Owner);
	void StartFadeOut();
	void StopCutscene();
	void StopCutsceneToServer();

	bool IsPlayingCutscene() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalCutsceneComponent">();
	}
	static class UPalCutsceneComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalCutsceneComponent>();
	}
};
static_assert(alignof(UPalCutsceneComponent) == 0x000008, "Wrong alignment on UPalCutsceneComponent");
static_assert(sizeof(UPalCutsceneComponent) == 0x0000E8, "Wrong size on UPalCutsceneComponent");
static_assert(offsetof(UPalCutsceneComponent, OnPlayCutsceneDelegate) == 0x0000A0, "Member 'UPalCutsceneComponent::OnPlayCutsceneDelegate' has a wrong offset!");
static_assert(offsetof(UPalCutsceneComponent, OnFinishCutsceneDelegate) == 0x0000B0, "Member 'UPalCutsceneComponent::OnFinishCutsceneDelegate' has a wrong offset!");
static_assert(offsetof(UPalCutsceneComponent, CutsceneActor) == 0x0000C0, "Member 'UPalCutsceneComponent::CutsceneActor' has a wrong offset!");
static_assert(offsetof(UPalCutsceneComponent, FadeParam) == 0x0000D0, "Member 'UPalCutsceneComponent::FadeParam' has a wrong offset!");

// Class Pal.PalGroupBase
// 0x0178 (0x01A0 - 0x0028)
class UPalGroupBase : public UObject
{
public:
	uint8                                         Pad_2A90[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnChangedGroupName;                                // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEnterCharacterDelegate;                          // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnExitCharacterDelegate;                           // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGuid                                  ID;                                                // 0x0060(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 GroupName;                                         // 0x0070(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, RepNotify, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFastPalIndividualCharacterHandleIdArray IndividualCharacterHandleIds;                      // 0x0080(0x0118)(Edit, Net, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A91[0x8];                                     // 0x0198(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangedGroupNameDelegate__DelegateSignature(const class FString& NewGroupName);
	void IndividualHandleDelegate__DelegateSignature(class UPalIndividualCharacterHandle* IndividualHandle);
	void OnRep_GroupName();
	void OnUpdateIndividualActor(class UPalIndividualCharacterHandle* CharacterHandle);

	class FString GetGroupName() const;
	const struct FGuid GetId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGroupBase">();
	}
	static class UPalGroupBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalGroupBase>();
	}
};
static_assert(alignof(UPalGroupBase) == 0x000008, "Wrong alignment on UPalGroupBase");
static_assert(sizeof(UPalGroupBase) == 0x0001A0, "Wrong size on UPalGroupBase");
static_assert(offsetof(UPalGroupBase, OnChangedGroupName) == 0x000030, "Member 'UPalGroupBase::OnChangedGroupName' has a wrong offset!");
static_assert(offsetof(UPalGroupBase, OnEnterCharacterDelegate) == 0x000040, "Member 'UPalGroupBase::OnEnterCharacterDelegate' has a wrong offset!");
static_assert(offsetof(UPalGroupBase, OnExitCharacterDelegate) == 0x000050, "Member 'UPalGroupBase::OnExitCharacterDelegate' has a wrong offset!");
static_assert(offsetof(UPalGroupBase, ID) == 0x000060, "Member 'UPalGroupBase::ID' has a wrong offset!");
static_assert(offsetof(UPalGroupBase, GroupName) == 0x000070, "Member 'UPalGroupBase::GroupName' has a wrong offset!");
static_assert(offsetof(UPalGroupBase, IndividualCharacterHandleIds) == 0x000080, "Member 'UPalGroupBase::IndividualCharacterHandleIds' has a wrong offset!");

// Class Pal.PalGroupOrganization
// 0x0020 (0x01C0 - 0x01A0)
class UPalGroupOrganization : public UPalGroupBase
{
public:
	uint8                                         Pad_2A92[0x8];                                     // 0x01A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EPalOrganizationType                          OrganizationType;                                  // 0x01A8(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A93[0x7];                                     // 0x01A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGuid>                          BaseCampIds;                                       // 0x01B0(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	void OnDamage(const struct FPalDamageResult& DamageResult);
	void OnDead(const struct FPalDeadInfo& DeadInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGroupOrganization">();
	}
	static class UPalGroupOrganization* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalGroupOrganization>();
	}
};
static_assert(alignof(UPalGroupOrganization) == 0x000008, "Wrong alignment on UPalGroupOrganization");
static_assert(sizeof(UPalGroupOrganization) == 0x0001C0, "Wrong size on UPalGroupOrganization");
static_assert(offsetof(UPalGroupOrganization, OrganizationType) == 0x0001A8, "Member 'UPalGroupOrganization::OrganizationType' has a wrong offset!");
static_assert(offsetof(UPalGroupOrganization, BaseCampIds) == 0x0001B0, "Member 'UPalGroupOrganization::BaseCampIds' has a wrong offset!");

// Class Pal.PalGroupGuildBase
// 0x0088 (0x0248 - 0x01C0)
class UPalGroupGuildBase : public UPalGroupOrganization
{
public:
	uint8                                         Pad_2A94[0x38];                                    // 0x01C0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalGuildPalStorage*                    PalStorage;                                        // 0x01F8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FGuid>                          MapObjectInstanceIds_BaseCampPoint;                // 0x0200(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	int32                                         BaseCampLevel;                                     // 0x0210(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class APalGuildInfo>           WeakGuildInfo;                                     // 0x0214(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A95[0x4];                                     // 0x021C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 GuildName;                                         // 0x0220(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, RepNotify, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 OldGuildName;                                      // 0x0230(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllPlayerNotOnlineAndAlreadyReset;                // 0x0240(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A96[0x7];                                     // 0x0241(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NotifyPlayerInfoDelegate__DelegateSignature(const class UPalGroupGuildBase* Self, const struct FGuid& PlayerUId, const struct FPalGuildPlayerInfo& PlayerInfo);
	void OnDeletePlayerAccount_ServerInternal(class UPalPlayerAccount* DeleteAccount);
	void OnReceivedWordFilteringResult(const class FString& ResponseBody, bool bResponseOK, int32 ResponseCode);
	void OnRep_BaseCampLevel(int32 OldValue);
	void OnRep_Guildname();
	void ReturnSelfDelegate__DelegateSignature(class UPalGroupGuildBase* Self);
	void UpdatedGuildNameDelegate__DelegateSignature(const class FString& NewGuildName);

	int32 GetBaseCampLevel() const;
	int32 GetBaseCampMaxNumInGuild() const;
	class FString GetGuildName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGroupGuildBase">();
	}
	static class UPalGroupGuildBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalGroupGuildBase>();
	}
};
static_assert(alignof(UPalGroupGuildBase) == 0x000008, "Wrong alignment on UPalGroupGuildBase");
static_assert(sizeof(UPalGroupGuildBase) == 0x000248, "Wrong size on UPalGroupGuildBase");
static_assert(offsetof(UPalGroupGuildBase, PalStorage) == 0x0001F8, "Member 'UPalGroupGuildBase::PalStorage' has a wrong offset!");
static_assert(offsetof(UPalGroupGuildBase, MapObjectInstanceIds_BaseCampPoint) == 0x000200, "Member 'UPalGroupGuildBase::MapObjectInstanceIds_BaseCampPoint' has a wrong offset!");
static_assert(offsetof(UPalGroupGuildBase, BaseCampLevel) == 0x000210, "Member 'UPalGroupGuildBase::BaseCampLevel' has a wrong offset!");
static_assert(offsetof(UPalGroupGuildBase, WeakGuildInfo) == 0x000214, "Member 'UPalGroupGuildBase::WeakGuildInfo' has a wrong offset!");
static_assert(offsetof(UPalGroupGuildBase, GuildName) == 0x000220, "Member 'UPalGroupGuildBase::GuildName' has a wrong offset!");
static_assert(offsetof(UPalGroupGuildBase, OldGuildName) == 0x000230, "Member 'UPalGroupGuildBase::OldGuildName' has a wrong offset!");
static_assert(offsetof(UPalGroupGuildBase, bAllPlayerNotOnlineAndAlreadyReset) == 0x000240, "Member 'UPalGroupGuildBase::bAllPlayerNotOnlineAndAlreadyReset' has a wrong offset!");

// Class Pal.PalGroupIndependentGuild
// 0x0030 (0x0278 - 0x0248)
class UPalGroupIndependentGuild final : public UPalGroupGuildBase
{
public:
	struct FGuid                                  PlayerUId;                                         // 0x0248(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPalGuildPlayerInfo                    PlayerInfo;                                        // 0x0258(0x0020)(Edit, Net, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGroupIndependentGuild">();
	}
	static class UPalGroupIndependentGuild* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalGroupIndependentGuild>();
	}
};
static_assert(alignof(UPalGroupIndependentGuild) == 0x000008, "Wrong alignment on UPalGroupIndependentGuild");
static_assert(sizeof(UPalGroupIndependentGuild) == 0x000278, "Wrong size on UPalGroupIndependentGuild");
static_assert(offsetof(UPalGroupIndependentGuild, PlayerUId) == 0x000248, "Member 'UPalGroupIndependentGuild::PlayerUId' has a wrong offset!");
static_assert(offsetof(UPalGroupIndependentGuild, PlayerInfo) == 0x000258, "Member 'UPalGroupIndependentGuild::PlayerInfo' has a wrong offset!");

// Class Pal.PalDamageDisplayCanvas
// 0x0000 (0x0408 - 0x0408)
class UPalDamageDisplayCanvas : public UPalUserWidget
{
public:
	int32 CalcDisplayDamage(const struct FPalDamageInfo& DamageInfo, class AActor* Defender, float* OutSpecialDamageRate, int32* WeakCount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalDamageDisplayCanvas">();
	}
	static class UPalDamageDisplayCanvas* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalDamageDisplayCanvas>();
	}
};
static_assert(alignof(UPalDamageDisplayCanvas) == 0x000008, "Wrong alignment on UPalDamageDisplayCanvas");
static_assert(sizeof(UPalDamageDisplayCanvas) == 0x000408, "Wrong size on UPalDamageDisplayCanvas");

// Class Pal.PalHitEffectSlot
// 0x0000 (0x0028 - 0x0028)
class UPalHitEffectSlot : public UObject
{
public:
	void Initialize();
	void PlayHitEffect(const struct FPalDamageInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalHitEffectSlot">();
	}
	static class UPalHitEffectSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalHitEffectSlot>();
	}
};
static_assert(alignof(UPalHitEffectSlot) == 0x000008, "Wrong alignment on UPalHitEffectSlot");
static_assert(sizeof(UPalHitEffectSlot) == 0x000028, "Wrong size on UPalHitEffectSlot");

// Class Pal.PalShopUtility
// 0x0000 (0x0028 - 0x0028)
class UPalShopUtility final : public UBlueprintFunctionLibrary
{
public:
	static int32 CalcItemSellPrice(const class UObject* WorldContextObject, const struct FPalStaticItemIdAndNum& StaticItemIDAndNum, float SellRate);
	static int32 CalcPalSellPrice(const class UObject* WorldContextObject, const struct FPalIndividualCharacterSaveParameter& SaveParameter, float SellRate);
	static bool CanSellFromSlotIdAndNum(const class UObject* WorldContextObject, const struct FPalItemSlotIdAndNum& SlotIdAndNum, float SellRate);
	static bool CanSellFromStaticItemIDAndNum(const class UObject* WorldContextObject, const struct FPalStaticItemIdAndNum& StaticItemIDAndNum, float SellRate);
	static bool CreateNewItemShop(const class UObject* WorldContextObject, const struct FPalItemShopCreateDataRow& CreateShopData, const class FName& SharedShopKeyName, class UPalShopBase** OutCreatedShop);
	static bool CreateNewPalShop(const class UObject* WorldContextObject, const struct FPalPalShopCreateDataRow& CreateShopData, const class FName& SharedShopKeyName, class UPalShopBase** OutCreatedShop);
	static bool GetItemShopCreateData(const class UObject* WorldContextObject, const class FName& ShopName, struct FPalItemShopCreateDataRow* OutData);
	static bool GetPalShopCreateData(const class UObject* WorldContextObject, const class FName& ShopName, struct FPalPalShopCreateDataRow* OutData);
	static void LotteryItemShop(const class UObject* WorldContextObject, const class FName& ItemShopLotteryName, class FName* OutShopName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalShopUtility">();
	}
	static class UPalShopUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalShopUtility>();
	}
};
static_assert(alignof(UPalShopUtility) == 0x000008, "Wrong alignment on UPalShopUtility");
static_assert(sizeof(UPalShopUtility) == 0x000028, "Wrong size on UPalShopUtility");

// Class Pal.PalDamageInfoUtility
// 0x0000 (0x0028 - 0x0028)
class UPalDamageInfoUtility final : public UObject
{
public:
	static float GetSpecialAttackRate(const struct FPalDamageInfo& DamageInfo, const EPalSpecialAttackRateType Type);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalDamageInfoUtility">();
	}
	static class UPalDamageInfoUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalDamageInfoUtility>();
	}
};
static_assert(alignof(UPalDamageInfoUtility) == 0x000008, "Wrong alignment on UPalDamageInfoUtility");
static_assert(sizeof(UPalDamageInfoUtility) == 0x000028, "Wrong size on UPalDamageInfoUtility");

// Class Pal.PalExpDatabase
// 0x0010 (0x0038 - 0x0028)
class UPalExpDatabase : public UObject
{
public:
	class UDataTable*                             ExpDataTable;                                      // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             PaldexBonusExpDataTable;                           // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddExp_EnemyDeath(const struct FPalDeadInfo& DeadInfo);
	void AddExp_forBaseCamp(class UPalIndividualCharacterHandle* DeadEnemyHandle, class UPalBaseCampModel* CampModel);
	void AddExp_forPlayerParty_TowerBoss(class UPalIndividualCharacterHandle* DeadEnemyHandle, const TArray<class APalPlayerCharacter*>& GiftPlayerList, bool IsCallDelegate);
	void AddExpValue_forPlayerParty_Server(int32 ExpValue, const TArray<class APalPlayerCharacter*>& GiftPlayerList, bool IsCallDelegate);
	int32 CalcLevelFromTotalExp(int32 TotalEXP, bool IsPlayer);
	int32 CalcNeedLevelUpExp(int32 TotalEXP, bool IsPlayer);
	int32 CalcPaldexBonusExp(const class FName CharacterID, int32 CaptureCount, class APalPlayerState* CaptureOwnerState);
	void DistributionExpValue_forPlayerParty_Server(int32 ExpValue, const TArray<class APalPlayerCharacter*>& GiftPlayerList, bool IsCallDelegate);
	int32 GetDropExp(int32 Level, class FName RowName);
	int32 GetNextExp(int32 Level, bool IsPlayer);
	int32 GetTotalExp(int32 Level, bool IsPlayer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalExpDatabase">();
	}
	static class UPalExpDatabase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalExpDatabase>();
	}
};
static_assert(alignof(UPalExpDatabase) == 0x000008, "Wrong alignment on UPalExpDatabase");
static_assert(sizeof(UPalExpDatabase) == 0x000038, "Wrong size on UPalExpDatabase");
static_assert(offsetof(UPalExpDatabase, ExpDataTable) == 0x000028, "Member 'UPalExpDatabase::ExpDataTable' has a wrong offset!");
static_assert(offsetof(UPalExpDatabase, PaldexBonusExpDataTable) == 0x000030, "Member 'UPalExpDatabase::PaldexBonusExpDataTable' has a wrong offset!");

// Class Pal.PalDamagePopUpManager
// 0x0010 (0x0038 - 0x0028)
class UPalDamagePopUpManager : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnAddDamagePopupDelegate;                          // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void AddDamagePopUp(const struct FPalDamageInfo& DamageInfo, class AActor* Defender);
	void AddDamagePopupDelegate__DelegateSignature(const struct FPalDamageInfo& DamageInfo, class AActor* Defender);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalDamagePopUpManager">();
	}
	static class UPalDamagePopUpManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalDamagePopUpManager>();
	}
};
static_assert(alignof(UPalDamagePopUpManager) == 0x000008, "Wrong alignment on UPalDamagePopUpManager");
static_assert(sizeof(UPalDamagePopUpManager) == 0x000038, "Wrong size on UPalDamagePopUpManager");
static_assert(offsetof(UPalDamagePopUpManager, OnAddDamagePopupDelegate) == 0x000028, "Member 'UPalDamagePopUpManager::OnAddDamagePopupDelegate' has a wrong offset!");

// Class Pal.PalDamageReactionComponent
// 0x00F0 (0x0190 - 0x00A0)
class UPalDamageReactionComponent final : public UActorComponent
{
public:
	uint8                                         Pad_2AAC[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnDamageDelegate;                                  // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDamageDelegate_Always;                           // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDeadDelegate;                                    // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDyingDeadEndDelegate;                            // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMentalDamageDelegate;                            // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSleepDelegate;                                   // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDamageReactionDelegate;                          // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEachDamageReactionDelegate;                      // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSlipDamageDelegate;                              // 0x0128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCaptureStartDelegate;                            // 0x0138(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNooseTrapDelegate;                               // 0x0148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalHitEffectSlot>          DamageEffectSlotClass;                             // 0x0158(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalHitEffectSlot*                      EffectSlot;                                        // 0x0160(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<float>                                 RateList;                                          // 0x0168(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<float>                                 LargeDownAbleHPRate;                               // 0x0178(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	bool                                          DisableLargeDown;                                  // 0x0188(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2AAD[0x7];                                     // 0x0189(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddDeadImplus(const struct FPalDamageResult& DamageResult);
	void ApplyDamageForDyingHP(const struct FPalDamageResult& DamageResult);
	void ApplyDamageForHP(const struct FPalDamageResult& DamageResult);
	void ApplyDamageForMP(const struct FPalDamageResult& DamageResult);
	void CallDeadDelegate_ToALL(const struct FPalDeadInfo& DeadInfo);
	void CallOnDamageDelegateAlways(const struct FPalDamageResult& DamageResult);
	void DeathDamage_ForSelfDestruct(const struct FVector& Velocity, EPalWazaID WazaID);
	void ForceDamageDelegateForCaptureBall(class AActor* Attacker);
	bool IsIgnoreElementStatus(EPalAdditionalEffectType Effect);
	void OnCaptureStartDelegate__DelegateSignature();
	void OnDamageDelegate__DelegateSignature(const struct FPalDamageResult& DamageResult);
	void OnDamageReactionDelegate__DelegateSignature(const struct FPalDamageRactionInfo& ReactionInfo);
	void OnDeadDelegate__DelegateSignature(const struct FPalDeadInfo& DeadInfo);
	void OnDyingDeadEnd__DelegateSignature(class APalPlayerCharacter* PlayerCharacter);
	void OnDyingDeadEndDelegate_ToALL();
	void OnEachDamageReactionDelegate__DelegateSignature(const struct FPalEachDamageRactionInfo& EachReactionInfo);
	void OnEndDamageMotion(class UAnimMontage* Montage, bool bInterrupted);
	void OnHitNooseTrap(class AActor* TrapActor, const struct FVector& FixLocation);
	void OnMentalDamageDelegate__DelegateSignature(const struct FPalDamageResult& DamageResult);
	void OnNooseTrapDelegate__DelegateSignature(class AActor* TrapActor, const struct FVector& FixLocation);
	void OnSleepDelegate__DelegateSignature(int32 LastDamage);
	void OnSlipDamageDelegate__DelegateSignature(int32 Damage);
	void PlayAddDamageMotion(EPalDamageAnimationReactionType ReactionType);
	void PlayDamageReaction(const struct FPalDamageRactionInfo& ReactionInfo);
	void PlayEachDamageReaction(const struct FPalEachDamageRactionInfo& EachReactionInfo);
	void PopupDamageBySlipDamage_ToALL(int32 Damage);
	void ProcessDamage_ToServer(const struct FPalDamageInfo& Info);
	void ProcessDeath_ToServer();
	void SetDisableLargeDown();
	void ShowDeadDebugLog(const struct FPalDeadInfo& DeadInfo);
	void SlipDamage(int32 Damage, bool ShieldIgnore, EPalDeadType DeadType);
	void SlipDamageAndBlowWhenDead(int32 Damage, const struct FVector& Velocity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalDamageReactionComponent">();
	}
	static class UPalDamageReactionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalDamageReactionComponent>();
	}
};
static_assert(alignof(UPalDamageReactionComponent) == 0x000008, "Wrong alignment on UPalDamageReactionComponent");
static_assert(sizeof(UPalDamageReactionComponent) == 0x000190, "Wrong size on UPalDamageReactionComponent");
static_assert(offsetof(UPalDamageReactionComponent, OnDamageDelegate) == 0x0000A8, "Member 'UPalDamageReactionComponent::OnDamageDelegate' has a wrong offset!");
static_assert(offsetof(UPalDamageReactionComponent, OnDamageDelegate_Always) == 0x0000B8, "Member 'UPalDamageReactionComponent::OnDamageDelegate_Always' has a wrong offset!");
static_assert(offsetof(UPalDamageReactionComponent, OnDeadDelegate) == 0x0000C8, "Member 'UPalDamageReactionComponent::OnDeadDelegate' has a wrong offset!");
static_assert(offsetof(UPalDamageReactionComponent, OnDyingDeadEndDelegate) == 0x0000D8, "Member 'UPalDamageReactionComponent::OnDyingDeadEndDelegate' has a wrong offset!");
static_assert(offsetof(UPalDamageReactionComponent, OnMentalDamageDelegate) == 0x0000E8, "Member 'UPalDamageReactionComponent::OnMentalDamageDelegate' has a wrong offset!");
static_assert(offsetof(UPalDamageReactionComponent, OnSleepDelegate) == 0x0000F8, "Member 'UPalDamageReactionComponent::OnSleepDelegate' has a wrong offset!");
static_assert(offsetof(UPalDamageReactionComponent, OnDamageReactionDelegate) == 0x000108, "Member 'UPalDamageReactionComponent::OnDamageReactionDelegate' has a wrong offset!");
static_assert(offsetof(UPalDamageReactionComponent, OnEachDamageReactionDelegate) == 0x000118, "Member 'UPalDamageReactionComponent::OnEachDamageReactionDelegate' has a wrong offset!");
static_assert(offsetof(UPalDamageReactionComponent, OnSlipDamageDelegate) == 0x000128, "Member 'UPalDamageReactionComponent::OnSlipDamageDelegate' has a wrong offset!");
static_assert(offsetof(UPalDamageReactionComponent, OnCaptureStartDelegate) == 0x000138, "Member 'UPalDamageReactionComponent::OnCaptureStartDelegate' has a wrong offset!");
static_assert(offsetof(UPalDamageReactionComponent, OnNooseTrapDelegate) == 0x000148, "Member 'UPalDamageReactionComponent::OnNooseTrapDelegate' has a wrong offset!");
static_assert(offsetof(UPalDamageReactionComponent, DamageEffectSlotClass) == 0x000158, "Member 'UPalDamageReactionComponent::DamageEffectSlotClass' has a wrong offset!");
static_assert(offsetof(UPalDamageReactionComponent, EffectSlot) == 0x000160, "Member 'UPalDamageReactionComponent::EffectSlot' has a wrong offset!");
static_assert(offsetof(UPalDamageReactionComponent, RateList) == 0x000168, "Member 'UPalDamageReactionComponent::RateList' has a wrong offset!");
static_assert(offsetof(UPalDamageReactionComponent, LargeDownAbleHPRate) == 0x000178, "Member 'UPalDamageReactionComponent::LargeDownAbleHPRate' has a wrong offset!");
static_assert(offsetof(UPalDamageReactionComponent, DisableLargeDown) == 0x000188, "Member 'UPalDamageReactionComponent::DisableLargeDown' has a wrong offset!");

// Class Pal.PalSkillEffectBase
// 0x00A0 (0x0330 - 0x0290)
class APalSkillEffectBase : public AActor
{
public:
	uint8                                         Pad_2AB2[0x58];                                    // 0x0290(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EffectSize;                                        // 0x02E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSize;                                           // 0x02EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSize;                                           // 0x02F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeTime;                                          // 0x02F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalAttackFilter*                       AttackFilter;                                      // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalHitFilter*                          HitFilterGround;                                   // 0x0300(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalHitFilter*                          HitFilterCustomRange;                              // 0x0308(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 AttackTarget;                                      // 0x0310(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           LifeTimeHandler;                                   // 0x0318(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalSoundPlayer*                        SoundPlayer;                                       // 0x0320(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRandomStream                          RandomStream;                                      // 0x0328(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

public:
	static struct FTimerHandle SetTimeCallbackBySkillEffectSpawnParameter(const class UObject* WorldContextObject, const struct FSkillEffectSpawnParameter& Parameter, class UObject* CallObject, TDelegate<void(struct FSkillEffectSpawnParameter& Parameter)> TimeDelegate);

	class APalSkillEffectBase* CreateChildSkillEffect(TSubclassOf<class APalSkillEffectBase> EffectClass, const struct FTransform& SpawnTransform, const struct FRandomStream& Param_RandomStream, ESpawnActorCollisionHandlingMethod CollisionMethod, class AActor* OwnerActor);
	void Initialize(const class AActor* SkillOwner, const struct FVector& MyOffset, class AActor* Target, const struct FRandomStream& Param_RandomStream);
	bool IsRidden();
	bool IsSelfOwnerCharacterOrRaider(class AActor* HitTarget);
	void LifeTimeCallback();
	void OnInitialize();
	void PlayAkSound(class UAkAudioEvent* AudioEvent);
	void SetActionTargetActor(class AActor* Target);
	void SetActorTransformByOwner(const class AActor* SkillOwner, const struct FVector& MyOffset);
	void StopAkSound();
	void StopAllNiagaraSound();

	class AActor* GetActionTargetActor() const;
	struct FVector GetActionTargetLocation() const;
	class APalCharacter* GetOwnerCharacter() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalSkillEffectBase">();
	}
	static class APalSkillEffectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalSkillEffectBase>();
	}
};
static_assert(alignof(APalSkillEffectBase) == 0x000008, "Wrong alignment on APalSkillEffectBase");
static_assert(sizeof(APalSkillEffectBase) == 0x000330, "Wrong size on APalSkillEffectBase");
static_assert(offsetof(APalSkillEffectBase, EffectSize) == 0x0002E8, "Member 'APalSkillEffectBase::EffectSize' has a wrong offset!");
static_assert(offsetof(APalSkillEffectBase, MinSize) == 0x0002EC, "Member 'APalSkillEffectBase::MinSize' has a wrong offset!");
static_assert(offsetof(APalSkillEffectBase, MaxSize) == 0x0002F0, "Member 'APalSkillEffectBase::MaxSize' has a wrong offset!");
static_assert(offsetof(APalSkillEffectBase, LifeTime) == 0x0002F4, "Member 'APalSkillEffectBase::LifeTime' has a wrong offset!");
static_assert(offsetof(APalSkillEffectBase, AttackFilter) == 0x0002F8, "Member 'APalSkillEffectBase::AttackFilter' has a wrong offset!");
static_assert(offsetof(APalSkillEffectBase, HitFilterGround) == 0x000300, "Member 'APalSkillEffectBase::HitFilterGround' has a wrong offset!");
static_assert(offsetof(APalSkillEffectBase, HitFilterCustomRange) == 0x000308, "Member 'APalSkillEffectBase::HitFilterCustomRange' has a wrong offset!");
static_assert(offsetof(APalSkillEffectBase, AttackTarget) == 0x000310, "Member 'APalSkillEffectBase::AttackTarget' has a wrong offset!");
static_assert(offsetof(APalSkillEffectBase, LifeTimeHandler) == 0x000318, "Member 'APalSkillEffectBase::LifeTimeHandler' has a wrong offset!");
static_assert(offsetof(APalSkillEffectBase, SoundPlayer) == 0x000320, "Member 'APalSkillEffectBase::SoundPlayer' has a wrong offset!");
static_assert(offsetof(APalSkillEffectBase, RandomStream) == 0x000328, "Member 'APalSkillEffectBase::RandomStream' has a wrong offset!");

// Class Pal.PalGuildPlayerInfoUtility
// 0x0000 (0x0028 - 0x0028)
class UPalGuildPlayerInfoUtility final : public UBlueprintFunctionLibrary
{
public:
	static bool IsValid(const struct FPalGuildPlayerInfo& PlayerInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGuildPlayerInfoUtility">();
	}
	static class UPalGuildPlayerInfoUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalGuildPlayerInfoUtility>();
	}
};
static_assert(alignof(UPalGuildPlayerInfoUtility) == 0x000008, "Wrong alignment on UPalGuildPlayerInfoUtility");
static_assert(sizeof(UPalGuildPlayerInfoUtility) == 0x000028, "Wrong size on UPalGuildPlayerInfoUtility");

// Class Pal.PalDamageText
// 0x0020 (0x0428 - 0x0408)
class UPalDamageText final : public UPalUserWidget
{
public:
	struct FVector2D                              RandomPositionMin;                                 // 0x0408(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RandomPositionMax;                                 // 0x0418(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalDamageText">();
	}
	static class UPalDamageText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalDamageText>();
	}
};
static_assert(alignof(UPalDamageText) == 0x000008, "Wrong alignment on UPalDamageText");
static_assert(sizeof(UPalDamageText) == 0x000428, "Wrong size on UPalDamageText");
static_assert(offsetof(UPalDamageText, RandomPositionMin) == 0x000408, "Member 'UPalDamageText::RandomPositionMin' has a wrong offset!");
static_assert(offsetof(UPalDamageText, RandomPositionMax) == 0x000418, "Member 'UPalDamageText::RandomPositionMax' has a wrong offset!");

// Class Pal.PalDatabaseCharacterParameter
// 0x0148 (0x0170 - 0x0028)
class UPalDatabaseCharacterParameter : public UObject
{
public:
	TMap<class FName, TSubclassOf<class UPalAIResponsePreset>> AIResponsePresetMap;                               // 0x0028(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<class FName, TSubclassOf<class UPalAISightResponsePreset>> AISightResponsePresetMap;                          // 0x0078(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSubclassOf<class UPalPettingPresset>         PettingPressetClass;                               // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             PlayerParameterDataTable;                          // 0x00D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             MonsterParameterDataTable;                         // 0x00D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             HumanParameterDataTable;                           // 0x00E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             DropItemDataTable;                                 // 0x00E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             MonsterNameDataTable;                              // 0x00F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             HumanNameDataTable;                                // 0x00F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             CharacterIconDataTable;                            // 0x0100(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             BPClassDataTable;                                  // 0x0108(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             PartnerSkillDataTable;                             // 0x0110(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             PalSizeParameterDataTable;                         // 0x0118(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             PalCapturedCageDataTable;                          // 0x0120(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             PalStatusEffectFoodDataTable;                      // 0x0128(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             PalGainStatusPointsItemDataTable;                  // 0x0130(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             PalCombiUniqueDataTable;                           // 0x0138(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             PalTalentUpItemDataTable;                          // 0x0140(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2AB7[0x8];                                     // 0x0148(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 TalentMagnificationList;                           // 0x0150(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UPalPettingPresset*                     PettingPressetInstance;                            // 0x0160(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalCombiMonsterParameter*              CombiMonsterParameter;                             // 0x0168(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	EPalBattleBGMType GetBattleBGM(class FName RowName);
	TSoftClassPtr<class UClass> GetBPClass(class FName RowName);
	class FName GetBPClassName(class FName RowName);
	float GetCaptureRateCorrect(class FName RowName);
	int32 GetCraftSpeed(class UPalIndividualCharacterParameter* IndividualParameter);
	int32 GetCraftSpeedBySaveParameter(const struct FPalIndividualCharacterSaveParameter& SaveParameter);
	TArray<struct FPalWorkSuitabilityInfo> GetCraftSpeeds(class UPalIndividualCharacterParameter* IndividualParameter);
	int32 GetDefense(const class UPalIndividualCharacterParameter* IndividualParameter);
	int32 GetDefenseBySaveParameter(const struct FPalIndividualCharacterSaveParameter& SaveParameter);
	bool GetDropItemData(const class FName& CharacterID, const int32 Level, struct FPalDropItemDatabaseRow* OutData);
	void GetElementType(class FName RowName, EPalElementType* Element1, EPalElementType* Element2);
	float GetExpRatio(class FName RowName);
	int32 GetFoodAmount(class FName RowName);
	EPalGenusCategoryType GetGenusCategory(class FName RowName);
	float GetHearingRate(class FName RowName);
	bool GetIsBoss(class FName RowName);
	bool GetIsPal(class FName RowName);
	bool GetIsRaidBoss(class FName RowName);
	bool GetIsTowerBoss(class FName RowName);
	void GetLocalizedCharacterName(const class FName& CharacterID, class FText* OutText);
	int32 GetMeleeAttack(class UPalIndividualCharacterParameter* IndividualParameter);
	int32 GetMeleeAttackBySaveParameter(const struct FPalIndividualCharacterSaveParameter& SaveParameter);
	bool GetNocturnal(class FName RowName);
	EPalOrganizationType GetOrganizationType(class FName RowName);
	void GetPartnerSkillMsgID(const class FName& CharacterID, class FName* OutMsgID);
	void GetPassiveSkill(class FName RowName, TArray<class FName>* PassiveSkill);
	class UPalPettingPresset* GetPettingPreset();
	void GetPrefixNameMsgID(const class FName& CharacterID, class FName* OutMsgID);
	float GetPriceRate(class FName RowName);
	int32 GetRarity(class FName RowName);
	int32 GetShotAttackBySaveParameter(const struct FPalIndividualCharacterSaveParameter& SaveParameter);
	EPalSizeType GetSize(class FName RowName);
	int32 GetSupport(class UPalIndividualCharacterParameter* IndividualParameter);
	int32 GetSupportBySaveParameter(const struct FPalIndividualCharacterSaveParameter& SaveParameter);
	EPalTribeID GetTribe(class FName RowName);
	int32 GetViewingAngle_Degree(class FName RowName);
	int32 GetViewingDistance_cm(class FName RowName);
	bool GetWeaponEquip(class FName RowName);
	EPalWeaponType GetWeaponType(class FName RowName);
	void GetWorkSuitability(class FName RowName, TArray<EPalWorkSuitability>* WorkSuitabilities);
	void GetWorkSuitabilityMaterialSubTypes(class FName RowName, TArray<EPalMapObjectMaterialSubType>* MaterialSubTypes);
	void GetWorkSuitabilityRank(class FName RowName, TMap<EPalWorkSuitability, int32>* WorkSuitabilities);
	bool SetupSaveParameter(const class FName CharacterID, const int32 Level, const struct FGuid& OwnerPlayerUId, struct FPalIndividualCharacterSaveParameter* OutParameter);
	void UpdateApplyDatabaseToIndividualParameter(class UPalIndividualCharacterParameter* IndividualParameter);

	int32 CalcCorrectedLevel(const int32 TrainerLevel, const int32 TargetCharacterLevel, const class UObject* WorldContextObject) const;
	bool FindPalSizeParameter(EPalSizeType CharacterSize, struct FPalSizeParameterDataRow* RowData) const;
	bool FindTalentUpItem(class FName ItemName, struct FPalTalentUpItemDataRow* OutData) const;
	TSoftObjectPtr<class UTexture2D> GetCharacterIconTexture(const class FName CharacterID) const;
	TSoftObjectPtr<class UTexture2D> GetCharacterIconTextureByTribeID(const EPalTribeID TribeID) const;
	struct FSoftObjectPath GetCharacterIconTexturePath(const class FName CharacterID) const;
	int32 GetHP(const class UPalIndividualCharacterParameter* IndividualParameter) const;
	int32 GetHPBySaveParameter(const struct FPalIndividualCharacterSaveParameter& SaveParameter) const;
	int32 GetShotAttack(const class UPalIndividualCharacterParameter* IndividualParameter) const;
	int32 HigherLevelOtomoFromTrainer(const class UPalIndividualCharacterParameter* IndividualCharacterParameter) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalDatabaseCharacterParameter">();
	}
	static class UPalDatabaseCharacterParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalDatabaseCharacterParameter>();
	}
};
static_assert(alignof(UPalDatabaseCharacterParameter) == 0x000008, "Wrong alignment on UPalDatabaseCharacterParameter");
static_assert(sizeof(UPalDatabaseCharacterParameter) == 0x000170, "Wrong size on UPalDatabaseCharacterParameter");
static_assert(offsetof(UPalDatabaseCharacterParameter, AIResponsePresetMap) == 0x000028, "Member 'UPalDatabaseCharacterParameter::AIResponsePresetMap' has a wrong offset!");
static_assert(offsetof(UPalDatabaseCharacterParameter, AISightResponsePresetMap) == 0x000078, "Member 'UPalDatabaseCharacterParameter::AISightResponsePresetMap' has a wrong offset!");
static_assert(offsetof(UPalDatabaseCharacterParameter, PettingPressetClass) == 0x0000C8, "Member 'UPalDatabaseCharacterParameter::PettingPressetClass' has a wrong offset!");
static_assert(offsetof(UPalDatabaseCharacterParameter, PlayerParameterDataTable) == 0x0000D0, "Member 'UPalDatabaseCharacterParameter::PlayerParameterDataTable' has a wrong offset!");
static_assert(offsetof(UPalDatabaseCharacterParameter, MonsterParameterDataTable) == 0x0000D8, "Member 'UPalDatabaseCharacterParameter::MonsterParameterDataTable' has a wrong offset!");
static_assert(offsetof(UPalDatabaseCharacterParameter, HumanParameterDataTable) == 0x0000E0, "Member 'UPalDatabaseCharacterParameter::HumanParameterDataTable' has a wrong offset!");
static_assert(offsetof(UPalDatabaseCharacterParameter, DropItemDataTable) == 0x0000E8, "Member 'UPalDatabaseCharacterParameter::DropItemDataTable' has a wrong offset!");
static_assert(offsetof(UPalDatabaseCharacterParameter, MonsterNameDataTable) == 0x0000F0, "Member 'UPalDatabaseCharacterParameter::MonsterNameDataTable' has a wrong offset!");
static_assert(offsetof(UPalDatabaseCharacterParameter, HumanNameDataTable) == 0x0000F8, "Member 'UPalDatabaseCharacterParameter::HumanNameDataTable' has a wrong offset!");
static_assert(offsetof(UPalDatabaseCharacterParameter, CharacterIconDataTable) == 0x000100, "Member 'UPalDatabaseCharacterParameter::CharacterIconDataTable' has a wrong offset!");
static_assert(offsetof(UPalDatabaseCharacterParameter, BPClassDataTable) == 0x000108, "Member 'UPalDatabaseCharacterParameter::BPClassDataTable' has a wrong offset!");
static_assert(offsetof(UPalDatabaseCharacterParameter, PartnerSkillDataTable) == 0x000110, "Member 'UPalDatabaseCharacterParameter::PartnerSkillDataTable' has a wrong offset!");
static_assert(offsetof(UPalDatabaseCharacterParameter, PalSizeParameterDataTable) == 0x000118, "Member 'UPalDatabaseCharacterParameter::PalSizeParameterDataTable' has a wrong offset!");
static_assert(offsetof(UPalDatabaseCharacterParameter, PalCapturedCageDataTable) == 0x000120, "Member 'UPalDatabaseCharacterParameter::PalCapturedCageDataTable' has a wrong offset!");
static_assert(offsetof(UPalDatabaseCharacterParameter, PalStatusEffectFoodDataTable) == 0x000128, "Member 'UPalDatabaseCharacterParameter::PalStatusEffectFoodDataTable' has a wrong offset!");
static_assert(offsetof(UPalDatabaseCharacterParameter, PalGainStatusPointsItemDataTable) == 0x000130, "Member 'UPalDatabaseCharacterParameter::PalGainStatusPointsItemDataTable' has a wrong offset!");
static_assert(offsetof(UPalDatabaseCharacterParameter, PalCombiUniqueDataTable) == 0x000138, "Member 'UPalDatabaseCharacterParameter::PalCombiUniqueDataTable' has a wrong offset!");
static_assert(offsetof(UPalDatabaseCharacterParameter, PalTalentUpItemDataTable) == 0x000140, "Member 'UPalDatabaseCharacterParameter::PalTalentUpItemDataTable' has a wrong offset!");
static_assert(offsetof(UPalDatabaseCharacterParameter, TalentMagnificationList) == 0x000150, "Member 'UPalDatabaseCharacterParameter::TalentMagnificationList' has a wrong offset!");
static_assert(offsetof(UPalDatabaseCharacterParameter, PettingPressetInstance) == 0x000160, "Member 'UPalDatabaseCharacterParameter::PettingPressetInstance' has a wrong offset!");
static_assert(offsetof(UPalDatabaseCharacterParameter, CombiMonsterParameter) == 0x000168, "Member 'UPalDatabaseCharacterParameter::CombiMonsterParameter' has a wrong offset!");

// Class Pal.SequentialProcessSequenceBase_WaitOneProcess
// 0x0008 (0x0048 - 0x0040)
class USequentialProcessSequenceBase_WaitOneProcess : public USequentialProcessSequenceBase
{
public:
	class USequentialProcessHandle*               SelfManagedProcessHandle;                          // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SequentialProcessSequenceBase_WaitOneProcess">();
	}
	static class USequentialProcessSequenceBase_WaitOneProcess* GetDefaultObj()
	{
		return GetDefaultObjImpl<USequentialProcessSequenceBase_WaitOneProcess>();
	}
};
static_assert(alignof(USequentialProcessSequenceBase_WaitOneProcess) == 0x000008, "Wrong alignment on USequentialProcessSequenceBase_WaitOneProcess");
static_assert(sizeof(USequentialProcessSequenceBase_WaitOneProcess) == 0x000048, "Wrong size on USequentialProcessSequenceBase_WaitOneProcess");
static_assert(offsetof(USequentialProcessSequenceBase_WaitOneProcess, SelfManagedProcessHandle) == 0x000040, "Member 'USequentialProcessSequenceBase_WaitOneProcess::SelfManagedProcessHandle' has a wrong offset!");

// Class Pal.PalGuildRequestFlowSequenceWaitForConfirmPlayer
// 0x0020 (0x0068 - 0x0048)
class UPalGuildRequestFlowSequenceWaitForConfirmPlayer : public USequentialProcessSequenceBase_WaitOneProcess
{
public:
	struct FGuid                                  PlayerUIdWaitFor;                                  // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USequentialProcessSequenceBase*         NextSequenceIfConfirmYes;                          // 0x0058(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ProgressTime;                                      // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2ADB[0x4];                                     // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGuildRequestFlowSequenceWaitForConfirmPlayer">();
	}
	static class UPalGuildRequestFlowSequenceWaitForConfirmPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalGuildRequestFlowSequenceWaitForConfirmPlayer>();
	}
};
static_assert(alignof(UPalGuildRequestFlowSequenceWaitForConfirmPlayer) == 0x000008, "Wrong alignment on UPalGuildRequestFlowSequenceWaitForConfirmPlayer");
static_assert(sizeof(UPalGuildRequestFlowSequenceWaitForConfirmPlayer) == 0x000068, "Wrong size on UPalGuildRequestFlowSequenceWaitForConfirmPlayer");
static_assert(offsetof(UPalGuildRequestFlowSequenceWaitForConfirmPlayer, PlayerUIdWaitFor) == 0x000048, "Member 'UPalGuildRequestFlowSequenceWaitForConfirmPlayer::PlayerUIdWaitFor' has a wrong offset!");
static_assert(offsetof(UPalGuildRequestFlowSequenceWaitForConfirmPlayer, NextSequenceIfConfirmYes) == 0x000058, "Member 'UPalGuildRequestFlowSequenceWaitForConfirmPlayer::NextSequenceIfConfirmYes' has a wrong offset!");
static_assert(offsetof(UPalGuildRequestFlowSequenceWaitForConfirmPlayer, ProgressTime) == 0x000060, "Member 'UPalGuildRequestFlowSequenceWaitForConfirmPlayer::ProgressTime' has a wrong offset!");

// Class Pal.PalDataTableRowIdMapper
// 0x0060 (0x0088 - 0x0028)
class UPalDataTableRowIdMapper : public UObject
{
public:
	TArray<class UDataTable*>                     DataTables;                                        // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, int32>                      RowNameHashMap;                                    // 0x0038(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalDataTableRowIdMapper">();
	}
	static class UPalDataTableRowIdMapper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalDataTableRowIdMapper>();
	}
};
static_assert(alignof(UPalDataTableRowIdMapper) == 0x000008, "Wrong alignment on UPalDataTableRowIdMapper");
static_assert(sizeof(UPalDataTableRowIdMapper) == 0x000088, "Wrong size on UPalDataTableRowIdMapper");
static_assert(offsetof(UPalDataTableRowIdMapper, DataTables) == 0x000028, "Member 'UPalDataTableRowIdMapper::DataTables' has a wrong offset!");
static_assert(offsetof(UPalDataTableRowIdMapper, RowNameHashMap) == 0x000038, "Member 'UPalDataTableRowIdMapper::RowNameHashMap' has a wrong offset!");

// Class Pal.PalDeadBodyManager
// 0x0010 (0x0038 - 0x0028)
class UPalDeadBodyManager : public UObject
{
public:
	TArray<class UPalIndividualCharacterHandle*>  DeadPalList;                                       // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPrivate)

public:
	void GetDeadPalList(TArray<class UPalIndividualCharacterHandle*>* OutArray);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalDeadBodyManager">();
	}
	static class UPalDeadBodyManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalDeadBodyManager>();
	}
};
static_assert(alignof(UPalDeadBodyManager) == 0x000008, "Wrong alignment on UPalDeadBodyManager");
static_assert(sizeof(UPalDeadBodyManager) == 0x000038, "Wrong size on UPalDeadBodyManager");
static_assert(offsetof(UPalDeadBodyManager, DeadPalList) == 0x000028, "Member 'UPalDeadBodyManager::DeadPalList' has a wrong offset!");

// Class Pal.PalSoundEmitterComponent
// 0x0000 (0x00A0 - 0x00A0)
class UPalSoundEmitterComponent : public UActorComponent
{
public:
	void EmitSound(class FName SoundFName, class AActor* EmitterCharacter, const struct FVector& EmitLocation, float VolumeRate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalSoundEmitterComponent">();
	}
	static class UPalSoundEmitterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalSoundEmitterComponent>();
	}
};
static_assert(alignof(UPalSoundEmitterComponent) == 0x000008, "Wrong alignment on UPalSoundEmitterComponent");
static_assert(sizeof(UPalSoundEmitterComponent) == 0x0000A0, "Wrong size on UPalSoundEmitterComponent");

// Class Pal.PalGroupNeutral
// 0x0000 (0x01A0 - 0x01A0)
class UPalGroupNeutral final : public UPalGroupBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGroupNeutral">();
	}
	static class UPalGroupNeutral* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalGroupNeutral>();
	}
};
static_assert(alignof(UPalGroupNeutral) == 0x000008, "Wrong alignment on UPalGroupNeutral");
static_assert(sizeof(UPalGroupNeutral) == 0x0001A0, "Wrong size on UPalGroupNeutral");

// Class Pal.PalDeathPenaltyManager
// 0x0060 (0x0088 - 0x0028)
class UPalDeathPenaltyManager : public UObject
{
public:
	float                                         StageDeathPenaltyRayStartHeight;                   // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StageDeathPenaltyChestRadius;                      // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StageDeathPenaltySpaceWidth;                       // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StageDeathPenaltySpaceDepth;                       // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<struct FGuid, struct FPalDeathPenaltyList> DeathPenaMap;                                      // 0x0038(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	void DropDeathPenaltyChest(class APalPlayerCharacter* Player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalDeathPenaltyManager">();
	}
	static class UPalDeathPenaltyManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalDeathPenaltyManager>();
	}
};
static_assert(alignof(UPalDeathPenaltyManager) == 0x000008, "Wrong alignment on UPalDeathPenaltyManager");
static_assert(sizeof(UPalDeathPenaltyManager) == 0x000088, "Wrong size on UPalDeathPenaltyManager");
static_assert(offsetof(UPalDeathPenaltyManager, StageDeathPenaltyRayStartHeight) == 0x000028, "Member 'UPalDeathPenaltyManager::StageDeathPenaltyRayStartHeight' has a wrong offset!");
static_assert(offsetof(UPalDeathPenaltyManager, StageDeathPenaltyChestRadius) == 0x00002C, "Member 'UPalDeathPenaltyManager::StageDeathPenaltyChestRadius' has a wrong offset!");
static_assert(offsetof(UPalDeathPenaltyManager, StageDeathPenaltySpaceWidth) == 0x000030, "Member 'UPalDeathPenaltyManager::StageDeathPenaltySpaceWidth' has a wrong offset!");
static_assert(offsetof(UPalDeathPenaltyManager, StageDeathPenaltySpaceDepth) == 0x000034, "Member 'UPalDeathPenaltyManager::StageDeathPenaltySpaceDepth' has a wrong offset!");
static_assert(offsetof(UPalDeathPenaltyManager, DeathPenaMap) == 0x000038, "Member 'UPalDeathPenaltyManager::DeathPenaMap' has a wrong offset!");

// Class Pal.PalDebugInfoGameInstanceSubsystem
// 0x0010 (0x0040 - 0x0030)
class UPalDebugInfoGameInstanceSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_2ADD[0x8];                                     // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UFont*                                  FontObject;                                        // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalDebugInfoGameInstanceSubsystem">();
	}
	static class UPalDebugInfoGameInstanceSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalDebugInfoGameInstanceSubsystem>();
	}
};
static_assert(alignof(UPalDebugInfoGameInstanceSubsystem) == 0x000008, "Wrong alignment on UPalDebugInfoGameInstanceSubsystem");
static_assert(sizeof(UPalDebugInfoGameInstanceSubsystem) == 0x000040, "Wrong size on UPalDebugInfoGameInstanceSubsystem");
static_assert(offsetof(UPalDebugInfoGameInstanceSubsystem, FontObject) == 0x000038, "Member 'UPalDebugInfoGameInstanceSubsystem::FontObject' has a wrong offset!");

// Class Pal.PalGroupGuild
// 0x0168 (0x03B0 - 0x0248)
class UPalGroupGuild final : public UPalGroupGuildBase
{
public:
	struct FPalFastGuildPlayerInfoRepInfoArray    PlayerInfoRepInfoArray;                            // 0x0248(0x0148)(Edit, Net, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	struct FGuid                                  AdminPlayerUId;                                    // 0x0390(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2ADE[0x10];                                    // 0x03A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChangedGuildMemberNickName(class UPalIndividualCharacterParameter* Parameter, const class FString& NickName);
	void OnFilteredPlayerInfo(class UPlGuildPlayerInfoFilteringWaiter* Waiter, const struct FPalGuildPlayerInfo& FilteredInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGroupGuild">();
	}
	static class UPalGroupGuild* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalGroupGuild>();
	}
};
static_assert(alignof(UPalGroupGuild) == 0x000008, "Wrong alignment on UPalGroupGuild");
static_assert(sizeof(UPalGroupGuild) == 0x0003B0, "Wrong size on UPalGroupGuild");
static_assert(offsetof(UPalGroupGuild, PlayerInfoRepInfoArray) == 0x000248, "Member 'UPalGroupGuild::PlayerInfoRepInfoArray' has a wrong offset!");
static_assert(offsetof(UPalGroupGuild, AdminPlayerUId) == 0x000390, "Member 'UPalGroupGuild::AdminPlayerUId' has a wrong offset!");

// Class Pal.PalDebugSetting
// 0x0460 (0x0488 - 0x0028)
class UPalDebugSetting final : public UObject
{
public:
	bool                                          bEnableCommandToServer;                            // 0x0028(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPalLanguageType                              EditorPlayTextLanguageType;                        // 0x0029(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRequiredLoadPlayerSaveData;                      // 0x002A(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2ADF[0x5];                                     // 0x002B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DefaultLoadPlayerSaveDataName;                     // 0x0030(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRequiredLoadWorldSaveData;                       // 0x0040(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AE0[0x7];                                     // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DefaultLoadWorldSaveDataName;                      // 0x0048(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRequiredLoadLocalWorldSaveData;                 // 0x0058(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2AE1[0x3];                                     // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  EditorServerPlayerUIdOverwrite;                    // 0x005C(0x0010)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AE2[0x4];                                     // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FGuid>                     EditorPlayerSaveDataOverwriteMap;                  // 0x0070(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	class FString                                 PlayerAutoSaveDataName;                            // 0x00C0(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WorldAutoSaveDataName;                             // 0x00D0(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDontAutoSaveInMulti;                              // 0x00E0(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AE3[0x3];                                     // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EditorSaveDirectoryName;                           // 0x00E4(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoSaveSpan;                                      // 0x00EC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoSaveEnable;                                    // 0x00F0(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoSetTruePalMainStats;                          // 0x00F1(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AE4[0x2];                                     // 0x00F2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPalDataTableRowName_GameProgressPreset PlayerDefaultPreset;                               // 0x00F4(0x0008)(Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerLevel;                                       // 0x00FC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ForceFixLevelForWildPal;                           // 0x0100(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ForceFixTalent;                                    // 0x0104(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPalDebugOtomoPalInfo>          DefaultOtomoPal;                                   // 0x0108(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FPalDebugPalCaptureInfo>        DefaultCapturePalInfos;                            // 0x0118(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	int32                                         DefaultCapturePalRandomNum;                        // 0x0128(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AE5[0x4];                                     // 0x012C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPalDebugItemCreateInfo>        DefaultItem;                                       // 0x0130(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FPalDebugItemCreateInfo>        DefaultLoadoutItem;                                // 0x0140(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	int32                                         PlayStart_PalWorldTime;                            // 0x0150(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DebugRate_PalWorldTime;                            // 0x0154(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreOverWeightMove;                             // 0x0158(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDisableReticleShoot;                            // 0x0159(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEquipDefaultWeapon;                               // 0x015A(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGetAllBulletItems;                                // 0x015B(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreItemDurabilityDecrease;                     // 0x015C(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNotConsumeMaterialsInRepair;                      // 0x015D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreDamageCheckByServer;                        // 0x015E(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMutekiALL;                                      // 0x015F(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMutekiForPlayer;                                // 0x0160(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMutekiForFriend;                                // 0x0161(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableDeathPenalty;                              // 0x0162(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreRespawnTimer;                               // 0x0163(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDisableDyingCountdown;                          // 0x0164(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFixedSP;                                        // 0x0165(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisiablePlayerShield;                             // 0x0166(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFullPowerForPlayer;                             // 0x0167(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCaptureSuccessAlways;                           // 0x0168(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCaptureFailAlways_BounceBall;                   // 0x0169(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsShowActionName;                                 // 0x016A(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsShowCharacterStatus;                            // 0x016B(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsShowCharacterTickInfo;                          // 0x016C(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsWazaCoolTimeFast;                               // 0x016D(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsShowUseRootMotion;                              // 0x016E(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEnableClimbing;                                 // 0x016F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDisableFallDamage;                              // 0x0170(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsShowPlayerFallHeight;                           // 0x0171(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsShowGroundObjectName;                           // 0x0172(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsShowForwardObjectName;                          // 0x0173(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableStatus_Darkness;                           // 0x0174(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsIgnoreBuildRestrictionBaseCamp;                 // 0x0175(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPalMovementSpeedType                         ConfirmTransportItemBaseSpeedType;                 // 0x0176(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AE6[0x1];                                     // 0x0177(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConfirmTransportItemSpeedMultipleRate;             // 0x0178(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNotConsumeMaterialsInBuild;                       // 0x017C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AE7[0x3];                                     // 0x017D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BuildRequiredWorkAmount;                           // 0x0180(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDisableEnemyEyeSight;                           // 0x0184(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEnableNPCDrawRaycastDebug;                      // 0x0185(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHideScreenMessage;                              // 0x0186(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHungerDisable;                                  // 0x0187(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAllRecipeUnlock;                                // 0x0188(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNotDecreaseWeaponItem;                            // 0x0189(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNotRequiredBulletWhenReload;                      // 0x018A(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowReticleLocation;                              // 0x018B(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowAutoAimInfo;                                  // 0x018C(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEnableMouseAutoAim;                             // 0x018D(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AE8[0x2];                                     // 0x018E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MouseSensitivityRate;                              // 0x0190(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CaptureFPS;                                        // 0x0194(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDisableDropItem;                                // 0x0198(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowDropItemHitEvent;                             // 0x0199(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPrintLogGroupsWhenGroupOperated;                  // 0x019A(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSoundRangeVisual;                               // 0x019B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsToggleHUDWhenEject;                             // 0x019C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLookAtDisable;                                  // 0x019D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPalBoxInLevelBelongingToServerPlayer;             // 0x019E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCreateGameInstanceViewActor;                      // 0x019F(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFixedLightingControllerTime;                    // 0x01A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AE9[0x3];                                     // 0x01A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LightingControllerTimeIfFixed;                     // 0x01A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsShowFloorLocation;                              // 0x01A8(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsShowGroundTilt;                                 // 0x01A9(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDisableShiftKey;                                // 0x01AA(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSpawnAlwaysFromSpawner;                          // 0x01AB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDisableSpawner;                                  // 0x01AC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEnableRandomizeSpawner;                         // 0x01AD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AEA[0x2];                                     // 0x01AE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverrideSpawnRadius;                               // 0x01B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideDespawnRadius;                             // 0x01B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPlayerCompleteSTEALTH;                          // 0x01B8(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsShowEnemyHate;                                  // 0x01B9(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsShowEnemyHateArrow;                             // 0x01BA(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsShowTargetLocalPlayerList;                      // 0x01BB(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsShowMovementMode;                               // 0x01BC(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsShowOrganization;                               // 0x01BD(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanAccessToOtherGuildMapObject;                   // 0x01BE(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AEB[0x1];                                     // 0x01BF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ExpireGuildEnterRequestLogInfoMinutes;             // 0x01C0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFirstBuildPalBox;                                 // 0x01C4(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AEC[0x3];                                     // 0x01C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WorkExtraRate;                                     // 0x01C8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDisableFootIK;                                  // 0x01CC(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBuildInstallCheckLookToCamera;                    // 0x01CD(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBuildFXDebugLog;                                  // 0x01CE(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDamageTextStack;                                  // 0x01CF(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFootStepNotify_DebugDisplay;                      // 0x01D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipBossCutscene;                                 // 0x01D1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowRangeDistributeExpAround;                     // 0x01D2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNotDropOtomoAtPlayerDeath;                        // 0x01D3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNotDropItemsAtPlayerDeath;                        // 0x01D4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableDebugMoveSpeed;                             // 0x01D5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceToggleDash;                                  // 0x01D6(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugAutoRun;                                     // 0x01D7(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawPlayerInDoor;                                 // 0x01D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AED[0x3];                                     // 0x01D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlayerPalStoragePage;                              // 0x01DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowPlayerMoveSpeed;                               // 0x01E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSwimming_DebugDisplay;                            // 0x01E1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSwimming_NoDecreaseSP;                            // 0x01E2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPartnerSkill_DebugDisplay;                        // 0x01E3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPartnerSkill_NoDecrease;                          // 0x01E4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AEE[0x3];                                     // 0x01E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PartnerSkill_CooldownSpeedRate;                    // 0x01E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PartnerSkill_IgnoreRestrictedByItems;              // 0x01EC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNotConsumeMaterialsInCraft;                       // 0x01ED(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSelectableRecipeWhenNothingMaterials;             // 0x01EE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreWorkableElementType;                        // 0x01EF(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreWorkableGenusCategories;                    // 0x01F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowDebugWorkAssign;                              // 0x01F1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowDebugWorkAssignTarget;                        // 0x01F2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceRunInWork;                                   // 0x01F3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bContinueSpeedInTransportWork;                     // 0x01F4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNotInterruptTransportingWork;                     // 0x01F5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPrintLogWorkerEventDetail;                        // 0x01F6(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AEF[0x1];                                     // 0x01F7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BaseCampWorkerEventTriggerInterval;                // 0x01F8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreBaseCampTask;                                // 0x01FC(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBaseCampSpawnLevelMax;                            // 0x01FD(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBaseCampWorkerSanityDetail;                       // 0x01FE(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AF0[0x1];                                     // 0x01FF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BaseCampWorkerEatTime;                             // 0x0200(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBaseCampShowCannotTransportTarget;                // 0x0204(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AF1[0x3];                                     // 0x0205(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPalArrowSettings                      BaseCampCannotTransportTargetArrowSettings;        // 0x0208(0x000C)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bBaseCampMoveModeTeleportForce;                    // 0x0214(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowBaseCampSquaredDistanceFromPlayer;            // 0x0215(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVisibleSpawnPointFromPalBox;                      // 0x0216(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AF2[0x1];                                     // 0x0217(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FallBackDefense;                                   // 0x0218(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugLogWorldSecurity;                            // 0x021C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugLogEnableCriminal;                           // 0x021D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugLogEnableWanted;                             // 0x021E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugLogEnableCriminalPlayer;                     // 0x021F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowDebugWantedSpawnerSphere;                     // 0x0220(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransportGrantedMonsterToPalBox;                  // 0x0221(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvaderDisable;                                   // 0x0222(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AF3[0x1];                                     // 0x0223(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DebugSpawnWildPal_DistanceFromPlayer;              // 0x0224(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPalStatusID                                  DebugAddStatus;                                    // 0x0228(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDisplayDebug_PassiveSkill;                      // 0x0229(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowPassiveSkillStatus;                           // 0x022A(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AF4[0x1];                                     // 0x022B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShowPassiveSkillStatusRange;                       // 0x022C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnorePalPassiveSkill;                            // 0x0230(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AF5[0x7];                                     // 0x0231(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPalDataTableRowName_PassiveSkillData> PalPassiveSkillOverride;                           // 0x0238(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	bool                                          bGrantPassiveSkillAlways;                          // 0x0248(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AF6[0x7];                                     // 0x0249(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FPalDataTableRowName_PalMonsterData, struct FPalDebugAttachPassiveSkillInfo> PassiveSkill_AttachSkill;                          // 0x0250(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	bool                                          bPassiveSkill_CollectItem_10Sec;                   // 0x02A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPassiveSkill_LifeSteal_DisplayRecoverHp;          // 0x02A1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLogMapObjectFailedSpawn;                          // 0x02A2(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowMapObjectStatus;                              // 0x02A3(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowMapObjectFoliageStatus;                       // 0x02A4(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AF7[0x3];                                     // 0x02A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShowMapObjectStatusRange;                          // 0x02A8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisablePalFoliageComponentBeginPlay;              // 0x02AC(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowMapObjectSpawnerStatus;                       // 0x02AD(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableMapObjectEffect;                           // 0x02AE(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawDetectMapObjectInDoor;                        // 0x02AF(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanDamageToMapObjectFromSameGroup;                // 0x02B0(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AF8[0x3];                                     // 0x02B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MapObjectHpOverride;                               // 0x02B4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FoliageRespawnIntervalOverrideSeconds;             // 0x02B8(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVisibleFoliageChunk;                              // 0x02BC(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowPalEggStatus;                                 // 0x02BD(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AF9[0x2];                                     // 0x02BE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShowPalEggStatusRange;                             // 0x02C0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHideAllHUD;                                     // 0x02C4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNowHUDHide;                                     // 0x02C5(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceCreateDispatchParameterByHUDService;         // 0x02C6(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowDebugMapIcon;                                 // 0x02C7(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHideUIForPV;                                    // 0x02C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCompletePaldex;                                 // 0x02C9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseFixedPositionPlayerUI;                         // 0x02CA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceShowHPGauge;                                 // 0x02CB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceWordFilter_ACE;                              // 0x02CC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPalACEWordFilterAPIType                      ForceWordFilterAPIType_ACE;                        // 0x02CD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFixedRandomSeed;                                // 0x02CE(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AFA[0x1];                                     // 0x02CF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ActionRandomSeed;                                  // 0x02D0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAvailableBuildObjectInDevelop;                    // 0x02D4(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowBuildObjectInstallCheck;                      // 0x02D5(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AFB[0x2];                                     // 0x02D6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EPalMapObjectOperationResult>          IgnoreInstallErrors;                               // 0x02D8(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	bool                                          bDrawDebugInstallConnection;                       // 0x02E8(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseEagleForGlider;                                // 0x02E9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEquipDefaultGlider;                               // 0x02EA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AFC[0x1];                                     // 0x02EB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExtraHpRegenRateInSleepingBed;                     // 0x02EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceDisableLamp;                                 // 0x02F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceDisableTimerLight;                           // 0x02F1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceDisableTickOptimization;                     // 0x02F2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceDisableDamagePopup;                          // 0x02F3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsShowTickOptimizationType;                       // 0x02F4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreFastTravelLock;                             // 0x02F5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AFD[0x2];                                     // 0x02F6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EPalAudioBus, float>                     AudioBusVolumes;                                   // 0x02F8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	TMap<EPalAudioBus, bool>                      AudioBusMute;                                      // 0x0348(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	bool                                          bIsShowPostAkEvent;                                // 0x0398(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AFE[0x7];                                     // 0x0399(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class APalSoundDebugModel>        SoundDebugModelClass;                              // 0x03A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMuteForPlayerSoundOnly;                         // 0x03A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayPlaySoundId;                               // 0x03A9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayFootStepSound;                                // 0x03AA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AFF[0x5];                                     // 0x03AB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           IgnoreSoundIds;                                    // 0x03B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	bool                                          bIsSpawnFootStepEffect;                            // 0x03C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDisableCameraPitchLimit;                        // 0x03C1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsIgnoreNetworkVersionCompatible;                 // 0x03C2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUseClientOtomoSetting;                          // 0x03C3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B00[0x4];                                     // 0x03C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPalDebugOtomoPalInfo>          DefaultOtomoPalForClient;                          // 0x03C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	bool                                          bIsForcedSynchronizedMapObject;                    // 0x03D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCharacterCountInServer;                     // 0x03D9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDedicatedServerOptimizeInListenServer;         // 0x03DA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDisableInitRandomCharacterMake;                 // 0x03DB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceSpawnTreasureBox;                            // 0x03DC(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceSpawnEnemyCamp;                              // 0x03DD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceSpawnPalEgg;                                 // 0x03DE(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceSpawnRarePal;                                // 0x03DF(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreAudio;                                       // 0x03E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsShowAudioSoundPlayer;                           // 0x03E1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceSpawnRandomIncident;                         // 0x03E2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceDisableSpawnRandomIncident;                  // 0x03E3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B01[0x4];                                     // 0x03E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ForceSpawnRandomIncidentName;                      // 0x03E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowRandomIncidentSpawnArea;                      // 0x03F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowRandomIncidentEndArea;                        // 0x03F9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowRandomIncidentExcludeArea;                    // 0x03FA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvadeSetting_Override;                           // 0x03FB(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InvadeProbability_Override;                        // 0x03FC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InvadeOccurablePlayerLevel_Override;               // 0x0400(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B02[0x4];                                     // 0x0404(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ForceOccurInvaderName;                             // 0x0408(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPalBiomeType                                 Biome_Override;                                    // 0x0418(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B03[0x3];                                     // 0x0419(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InvadeJudgmentInterval_Minutes_Override;           // 0x041C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InvadeCollTime_Max_Minutes_Override;               // 0x0420(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InvadeCollTime_Min_Minutes_Override;               // 0x0424(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InvadeReturnTime_Minutes_Override;                 // 0x0428(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InvadeStartPoint_BaseCampRadius_Min_cm_Override;   // 0x042C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InvadeStartPoint_BaseCampRadius_Max_cm_Override;   // 0x0430(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VisitorNPCProbability_Override;                    // 0x0434(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ForceOccurVisitorNPCName;                          // 0x0438(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VisitorNPCReturnTime_Minutes_Override;             // 0x0448(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDisableCrossKeyQuickSwitch;                     // 0x044C(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEnableAirRolling;                               // 0x044D(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEnablePalWarp;                                  // 0x044E(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDungeonDevelopFlag;                               // 0x044F(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDisableOptionWorldLoadConfig;                   // 0x0450(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsShowNightSkipLog;                               // 0x0451(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsApplyOptionWorldModePreset;                     // 0x0452(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowAnimRateScale;                                // 0x0453(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShowAnimRateScaleRange;                            // 0x0454(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsParallelForUpdateActiveTiles;                   // 0x0458(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDisablePlayerTeleportTimeout;                   // 0x0459(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseMalePlayer;                                    // 0x045A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableLoadingScreen;                              // 0x045B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B04[0x4];                                     // 0x045C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnLoadingScreenVisibilityChanged;                  // 0x0460(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsSkipCharacterMake;                              // 0x0470(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawHitCollision;                                 // 0x0471(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableGrapplingCoolDown;                         // 0x0472(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawGrapplingLine;                                // 0x0473(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawGrapplingHitPoint;                            // 0x0474(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawAmbientSoundLinePlayLocation;                 // 0x0475(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawAmbientSoundActivateTrigger;                  // 0x0476(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawDefenseAttackableRange;                       // 0x0477(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowDefenseAttackTarget;                          // 0x0478(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B05[0x3];                                     // 0x0479(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShowDefenseRange;                                  // 0x047C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableInteractRecicleTarget;                     // 0x0480(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowStageDeathPenaltyLocation;                    // 0x0481(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceLocationTeleport;                            // 0x0482(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowInvaderDebugLog;                              // 0x0483(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowStreamingLevel;                               // 0x0484(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowInteractPoints;                               // 0x0485(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableArenaTest;                                  // 0x0486(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B06[0x1];                                     // 0x0487(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalDebugSetting">();
	}
	static class UPalDebugSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalDebugSetting>();
	}
};
static_assert(alignof(UPalDebugSetting) == 0x000008, "Wrong alignment on UPalDebugSetting");
static_assert(sizeof(UPalDebugSetting) == 0x000488, "Wrong size on UPalDebugSetting");
static_assert(offsetof(UPalDebugSetting, bEnableCommandToServer) == 0x000028, "Member 'UPalDebugSetting::bEnableCommandToServer' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, EditorPlayTextLanguageType) == 0x000029, "Member 'UPalDebugSetting::EditorPlayTextLanguageType' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, IsRequiredLoadPlayerSaveData) == 0x00002A, "Member 'UPalDebugSetting::IsRequiredLoadPlayerSaveData' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, DefaultLoadPlayerSaveDataName) == 0x000030, "Member 'UPalDebugSetting::DefaultLoadPlayerSaveDataName' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, IsRequiredLoadWorldSaveData) == 0x000040, "Member 'UPalDebugSetting::IsRequiredLoadWorldSaveData' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, DefaultLoadWorldSaveDataName) == 0x000048, "Member 'UPalDebugSetting::DefaultLoadWorldSaveDataName' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsRequiredLoadLocalWorldSaveData) == 0x000058, "Member 'UPalDebugSetting::bIsRequiredLoadLocalWorldSaveData' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, EditorServerPlayerUIdOverwrite) == 0x00005C, "Member 'UPalDebugSetting::EditorServerPlayerUIdOverwrite' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, EditorPlayerSaveDataOverwriteMap) == 0x000070, "Member 'UPalDebugSetting::EditorPlayerSaveDataOverwriteMap' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, PlayerAutoSaveDataName) == 0x0000C0, "Member 'UPalDebugSetting::PlayerAutoSaveDataName' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, WorldAutoSaveDataName) == 0x0000D0, "Member 'UPalDebugSetting::WorldAutoSaveDataName' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bDontAutoSaveInMulti) == 0x0000E0, "Member 'UPalDebugSetting::bDontAutoSaveInMulti' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, EditorSaveDirectoryName) == 0x0000E4, "Member 'UPalDebugSetting::EditorSaveDirectoryName' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, AutoSaveSpan) == 0x0000EC, "Member 'UPalDebugSetting::AutoSaveSpan' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, AutoSaveEnable) == 0x0000F0, "Member 'UPalDebugSetting::AutoSaveEnable' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bAutoSetTruePalMainStats) == 0x0000F1, "Member 'UPalDebugSetting::bAutoSetTruePalMainStats' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, PlayerDefaultPreset) == 0x0000F4, "Member 'UPalDebugSetting::PlayerDefaultPreset' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, PlayerLevel) == 0x0000FC, "Member 'UPalDebugSetting::PlayerLevel' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, ForceFixLevelForWildPal) == 0x000100, "Member 'UPalDebugSetting::ForceFixLevelForWildPal' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, ForceFixTalent) == 0x000104, "Member 'UPalDebugSetting::ForceFixTalent' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, DefaultOtomoPal) == 0x000108, "Member 'UPalDebugSetting::DefaultOtomoPal' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, DefaultCapturePalInfos) == 0x000118, "Member 'UPalDebugSetting::DefaultCapturePalInfos' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, DefaultCapturePalRandomNum) == 0x000128, "Member 'UPalDebugSetting::DefaultCapturePalRandomNum' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, DefaultItem) == 0x000130, "Member 'UPalDebugSetting::DefaultItem' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, DefaultLoadoutItem) == 0x000140, "Member 'UPalDebugSetting::DefaultLoadoutItem' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, PlayStart_PalWorldTime) == 0x000150, "Member 'UPalDebugSetting::PlayStart_PalWorldTime' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, DebugRate_PalWorldTime) == 0x000154, "Member 'UPalDebugSetting::DebugRate_PalWorldTime' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIgnoreOverWeightMove) == 0x000158, "Member 'UPalDebugSetting::bIgnoreOverWeightMove' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsDisableReticleShoot) == 0x000159, "Member 'UPalDebugSetting::bIsDisableReticleShoot' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bEquipDefaultWeapon) == 0x00015A, "Member 'UPalDebugSetting::bEquipDefaultWeapon' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bGetAllBulletItems) == 0x00015B, "Member 'UPalDebugSetting::bGetAllBulletItems' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIgnoreItemDurabilityDecrease) == 0x00015C, "Member 'UPalDebugSetting::bIgnoreItemDurabilityDecrease' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bNotConsumeMaterialsInRepair) == 0x00015D, "Member 'UPalDebugSetting::bNotConsumeMaterialsInRepair' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIgnoreDamageCheckByServer) == 0x00015E, "Member 'UPalDebugSetting::bIgnoreDamageCheckByServer' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsMutekiALL) == 0x00015F, "Member 'UPalDebugSetting::bIsMutekiALL' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsMutekiForPlayer) == 0x000160, "Member 'UPalDebugSetting::bIsMutekiForPlayer' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsMutekiForFriend) == 0x000161, "Member 'UPalDebugSetting::bIsMutekiForFriend' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bDisableDeathPenalty) == 0x000162, "Member 'UPalDebugSetting::bDisableDeathPenalty' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIgnoreRespawnTimer) == 0x000163, "Member 'UPalDebugSetting::bIgnoreRespawnTimer' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsDisableDyingCountdown) == 0x000164, "Member 'UPalDebugSetting::bIsDisableDyingCountdown' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsFixedSP) == 0x000165, "Member 'UPalDebugSetting::bIsFixedSP' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bDisiablePlayerShield) == 0x000166, "Member 'UPalDebugSetting::bDisiablePlayerShield' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsFullPowerForPlayer) == 0x000167, "Member 'UPalDebugSetting::bIsFullPowerForPlayer' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsCaptureSuccessAlways) == 0x000168, "Member 'UPalDebugSetting::bIsCaptureSuccessAlways' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsCaptureFailAlways_BounceBall) == 0x000169, "Member 'UPalDebugSetting::bIsCaptureFailAlways_BounceBall' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsShowActionName) == 0x00016A, "Member 'UPalDebugSetting::bIsShowActionName' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsShowCharacterStatus) == 0x00016B, "Member 'UPalDebugSetting::bIsShowCharacterStatus' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsShowCharacterTickInfo) == 0x00016C, "Member 'UPalDebugSetting::bIsShowCharacterTickInfo' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsWazaCoolTimeFast) == 0x00016D, "Member 'UPalDebugSetting::bIsWazaCoolTimeFast' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsShowUseRootMotion) == 0x00016E, "Member 'UPalDebugSetting::bIsShowUseRootMotion' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsEnableClimbing) == 0x00016F, "Member 'UPalDebugSetting::bIsEnableClimbing' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsDisableFallDamage) == 0x000170, "Member 'UPalDebugSetting::bIsDisableFallDamage' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsShowPlayerFallHeight) == 0x000171, "Member 'UPalDebugSetting::bIsShowPlayerFallHeight' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsShowGroundObjectName) == 0x000172, "Member 'UPalDebugSetting::bIsShowGroundObjectName' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsShowForwardObjectName) == 0x000173, "Member 'UPalDebugSetting::bIsShowForwardObjectName' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bDisableStatus_Darkness) == 0x000174, "Member 'UPalDebugSetting::bDisableStatus_Darkness' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsIgnoreBuildRestrictionBaseCamp) == 0x000175, "Member 'UPalDebugSetting::bIsIgnoreBuildRestrictionBaseCamp' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, ConfirmTransportItemBaseSpeedType) == 0x000176, "Member 'UPalDebugSetting::ConfirmTransportItemBaseSpeedType' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, ConfirmTransportItemSpeedMultipleRate) == 0x000178, "Member 'UPalDebugSetting::ConfirmTransportItemSpeedMultipleRate' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bNotConsumeMaterialsInBuild) == 0x00017C, "Member 'UPalDebugSetting::bNotConsumeMaterialsInBuild' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, BuildRequiredWorkAmount) == 0x000180, "Member 'UPalDebugSetting::BuildRequiredWorkAmount' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsDisableEnemyEyeSight) == 0x000184, "Member 'UPalDebugSetting::bIsDisableEnemyEyeSight' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsEnableNPCDrawRaycastDebug) == 0x000185, "Member 'UPalDebugSetting::bIsEnableNPCDrawRaycastDebug' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsHideScreenMessage) == 0x000186, "Member 'UPalDebugSetting::bIsHideScreenMessage' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsHungerDisable) == 0x000187, "Member 'UPalDebugSetting::bIsHungerDisable' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsAllRecipeUnlock) == 0x000188, "Member 'UPalDebugSetting::bIsAllRecipeUnlock' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bNotDecreaseWeaponItem) == 0x000189, "Member 'UPalDebugSetting::bNotDecreaseWeaponItem' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bNotRequiredBulletWhenReload) == 0x00018A, "Member 'UPalDebugSetting::bNotRequiredBulletWhenReload' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bShowReticleLocation) == 0x00018B, "Member 'UPalDebugSetting::bShowReticleLocation' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bShowAutoAimInfo) == 0x00018C, "Member 'UPalDebugSetting::bShowAutoAimInfo' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsEnableMouseAutoAim) == 0x00018D, "Member 'UPalDebugSetting::bIsEnableMouseAutoAim' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, MouseSensitivityRate) == 0x000190, "Member 'UPalDebugSetting::MouseSensitivityRate' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, CaptureFPS) == 0x000194, "Member 'UPalDebugSetting::CaptureFPS' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsDisableDropItem) == 0x000198, "Member 'UPalDebugSetting::bIsDisableDropItem' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bShowDropItemHitEvent) == 0x000199, "Member 'UPalDebugSetting::bShowDropItemHitEvent' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bPrintLogGroupsWhenGroupOperated) == 0x00019A, "Member 'UPalDebugSetting::bPrintLogGroupsWhenGroupOperated' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsSoundRangeVisual) == 0x00019B, "Member 'UPalDebugSetting::bIsSoundRangeVisual' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsToggleHUDWhenEject) == 0x00019C, "Member 'UPalDebugSetting::bIsToggleHUDWhenEject' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsLookAtDisable) == 0x00019D, "Member 'UPalDebugSetting::bIsLookAtDisable' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bPalBoxInLevelBelongingToServerPlayer) == 0x00019E, "Member 'UPalDebugSetting::bPalBoxInLevelBelongingToServerPlayer' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bCreateGameInstanceViewActor) == 0x00019F, "Member 'UPalDebugSetting::bCreateGameInstanceViewActor' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsFixedLightingControllerTime) == 0x0001A0, "Member 'UPalDebugSetting::bIsFixedLightingControllerTime' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, LightingControllerTimeIfFixed) == 0x0001A4, "Member 'UPalDebugSetting::LightingControllerTimeIfFixed' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsShowFloorLocation) == 0x0001A8, "Member 'UPalDebugSetting::bIsShowFloorLocation' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsShowGroundTilt) == 0x0001A9, "Member 'UPalDebugSetting::bIsShowGroundTilt' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsDisableShiftKey) == 0x0001AA, "Member 'UPalDebugSetting::bIsDisableShiftKey' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, IsSpawnAlwaysFromSpawner) == 0x0001AB, "Member 'UPalDebugSetting::IsSpawnAlwaysFromSpawner' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, IsDisableSpawner) == 0x0001AC, "Member 'UPalDebugSetting::IsDisableSpawner' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsEnableRandomizeSpawner) == 0x0001AD, "Member 'UPalDebugSetting::bIsEnableRandomizeSpawner' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, OverrideSpawnRadius) == 0x0001B0, "Member 'UPalDebugSetting::OverrideSpawnRadius' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, OverrideDespawnRadius) == 0x0001B4, "Member 'UPalDebugSetting::OverrideDespawnRadius' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsPlayerCompleteSTEALTH) == 0x0001B8, "Member 'UPalDebugSetting::bIsPlayerCompleteSTEALTH' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsShowEnemyHate) == 0x0001B9, "Member 'UPalDebugSetting::bIsShowEnemyHate' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsShowEnemyHateArrow) == 0x0001BA, "Member 'UPalDebugSetting::bIsShowEnemyHateArrow' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsShowTargetLocalPlayerList) == 0x0001BB, "Member 'UPalDebugSetting::bIsShowTargetLocalPlayerList' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsShowMovementMode) == 0x0001BC, "Member 'UPalDebugSetting::bIsShowMovementMode' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsShowOrganization) == 0x0001BD, "Member 'UPalDebugSetting::bIsShowOrganization' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bCanAccessToOtherGuildMapObject) == 0x0001BE, "Member 'UPalDebugSetting::bCanAccessToOtherGuildMapObject' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, ExpireGuildEnterRequestLogInfoMinutes) == 0x0001C0, "Member 'UPalDebugSetting::ExpireGuildEnterRequestLogInfoMinutes' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bFirstBuildPalBox) == 0x0001C4, "Member 'UPalDebugSetting::bFirstBuildPalBox' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, WorkExtraRate) == 0x0001C8, "Member 'UPalDebugSetting::WorkExtraRate' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsDisableFootIK) == 0x0001CC, "Member 'UPalDebugSetting::bIsDisableFootIK' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bBuildInstallCheckLookToCamera) == 0x0001CD, "Member 'UPalDebugSetting::bBuildInstallCheckLookToCamera' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bBuildFXDebugLog) == 0x0001CE, "Member 'UPalDebugSetting::bBuildFXDebugLog' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bDamageTextStack) == 0x0001CF, "Member 'UPalDebugSetting::bDamageTextStack' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bFootStepNotify_DebugDisplay) == 0x0001D0, "Member 'UPalDebugSetting::bFootStepNotify_DebugDisplay' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bSkipBossCutscene) == 0x0001D1, "Member 'UPalDebugSetting::bSkipBossCutscene' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bShowRangeDistributeExpAround) == 0x0001D2, "Member 'UPalDebugSetting::bShowRangeDistributeExpAround' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bNotDropOtomoAtPlayerDeath) == 0x0001D3, "Member 'UPalDebugSetting::bNotDropOtomoAtPlayerDeath' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bNotDropItemsAtPlayerDeath) == 0x0001D4, "Member 'UPalDebugSetting::bNotDropItemsAtPlayerDeath' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bEnableDebugMoveSpeed) == 0x0001D5, "Member 'UPalDebugSetting::bEnableDebugMoveSpeed' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bForceToggleDash) == 0x0001D6, "Member 'UPalDebugSetting::bForceToggleDash' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bDebugAutoRun) == 0x0001D7, "Member 'UPalDebugSetting::bDebugAutoRun' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bDrawPlayerInDoor) == 0x0001D8, "Member 'UPalDebugSetting::bDrawPlayerInDoor' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, PlayerPalStoragePage) == 0x0001DC, "Member 'UPalDebugSetting::PlayerPalStoragePage' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, ShowPlayerMoveSpeed) == 0x0001E0, "Member 'UPalDebugSetting::ShowPlayerMoveSpeed' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bSwimming_DebugDisplay) == 0x0001E1, "Member 'UPalDebugSetting::bSwimming_DebugDisplay' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bSwimming_NoDecreaseSP) == 0x0001E2, "Member 'UPalDebugSetting::bSwimming_NoDecreaseSP' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bPartnerSkill_DebugDisplay) == 0x0001E3, "Member 'UPalDebugSetting::bPartnerSkill_DebugDisplay' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bPartnerSkill_NoDecrease) == 0x0001E4, "Member 'UPalDebugSetting::bPartnerSkill_NoDecrease' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, PartnerSkill_CooldownSpeedRate) == 0x0001E8, "Member 'UPalDebugSetting::PartnerSkill_CooldownSpeedRate' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, PartnerSkill_IgnoreRestrictedByItems) == 0x0001EC, "Member 'UPalDebugSetting::PartnerSkill_IgnoreRestrictedByItems' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bNotConsumeMaterialsInCraft) == 0x0001ED, "Member 'UPalDebugSetting::bNotConsumeMaterialsInCraft' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bSelectableRecipeWhenNothingMaterials) == 0x0001EE, "Member 'UPalDebugSetting::bSelectableRecipeWhenNothingMaterials' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIgnoreWorkableElementType) == 0x0001EF, "Member 'UPalDebugSetting::bIgnoreWorkableElementType' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIgnoreWorkableGenusCategories) == 0x0001F0, "Member 'UPalDebugSetting::bIgnoreWorkableGenusCategories' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bShowDebugWorkAssign) == 0x0001F1, "Member 'UPalDebugSetting::bShowDebugWorkAssign' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bShowDebugWorkAssignTarget) == 0x0001F2, "Member 'UPalDebugSetting::bShowDebugWorkAssignTarget' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bForceRunInWork) == 0x0001F3, "Member 'UPalDebugSetting::bForceRunInWork' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bContinueSpeedInTransportWork) == 0x0001F4, "Member 'UPalDebugSetting::bContinueSpeedInTransportWork' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bNotInterruptTransportingWork) == 0x0001F5, "Member 'UPalDebugSetting::bNotInterruptTransportingWork' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bPrintLogWorkerEventDetail) == 0x0001F6, "Member 'UPalDebugSetting::bPrintLogWorkerEventDetail' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, BaseCampWorkerEventTriggerInterval) == 0x0001F8, "Member 'UPalDebugSetting::BaseCampWorkerEventTriggerInterval' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, IgnoreBaseCampTask) == 0x0001FC, "Member 'UPalDebugSetting::IgnoreBaseCampTask' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bBaseCampSpawnLevelMax) == 0x0001FD, "Member 'UPalDebugSetting::bBaseCampSpawnLevelMax' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bBaseCampWorkerSanityDetail) == 0x0001FE, "Member 'UPalDebugSetting::bBaseCampWorkerSanityDetail' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, BaseCampWorkerEatTime) == 0x000200, "Member 'UPalDebugSetting::BaseCampWorkerEatTime' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bBaseCampShowCannotTransportTarget) == 0x000204, "Member 'UPalDebugSetting::bBaseCampShowCannotTransportTarget' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, BaseCampCannotTransportTargetArrowSettings) == 0x000208, "Member 'UPalDebugSetting::BaseCampCannotTransportTargetArrowSettings' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bBaseCampMoveModeTeleportForce) == 0x000214, "Member 'UPalDebugSetting::bBaseCampMoveModeTeleportForce' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bShowBaseCampSquaredDistanceFromPlayer) == 0x000215, "Member 'UPalDebugSetting::bShowBaseCampSquaredDistanceFromPlayer' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bVisibleSpawnPointFromPalBox) == 0x000216, "Member 'UPalDebugSetting::bVisibleSpawnPointFromPalBox' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, FallBackDefense) == 0x000218, "Member 'UPalDebugSetting::FallBackDefense' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bDebugLogWorldSecurity) == 0x00021C, "Member 'UPalDebugSetting::bDebugLogWorldSecurity' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bDebugLogEnableCriminal) == 0x00021D, "Member 'UPalDebugSetting::bDebugLogEnableCriminal' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bDebugLogEnableWanted) == 0x00021E, "Member 'UPalDebugSetting::bDebugLogEnableWanted' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bDebugLogEnableCriminalPlayer) == 0x00021F, "Member 'UPalDebugSetting::bDebugLogEnableCriminalPlayer' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bShowDebugWantedSpawnerSphere) == 0x000220, "Member 'UPalDebugSetting::bShowDebugWantedSpawnerSphere' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bTransportGrantedMonsterToPalBox) == 0x000221, "Member 'UPalDebugSetting::bTransportGrantedMonsterToPalBox' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bInvaderDisable) == 0x000222, "Member 'UPalDebugSetting::bInvaderDisable' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, DebugSpawnWildPal_DistanceFromPlayer) == 0x000224, "Member 'UPalDebugSetting::DebugSpawnWildPal_DistanceFromPlayer' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, DebugAddStatus) == 0x000228, "Member 'UPalDebugSetting::DebugAddStatus' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsDisplayDebug_PassiveSkill) == 0x000229, "Member 'UPalDebugSetting::bIsDisplayDebug_PassiveSkill' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bShowPassiveSkillStatus) == 0x00022A, "Member 'UPalDebugSetting::bShowPassiveSkillStatus' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, ShowPassiveSkillStatusRange) == 0x00022C, "Member 'UPalDebugSetting::ShowPassiveSkillStatusRange' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIgnorePalPassiveSkill) == 0x000230, "Member 'UPalDebugSetting::bIgnorePalPassiveSkill' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, PalPassiveSkillOverride) == 0x000238, "Member 'UPalDebugSetting::PalPassiveSkillOverride' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bGrantPassiveSkillAlways) == 0x000248, "Member 'UPalDebugSetting::bGrantPassiveSkillAlways' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, PassiveSkill_AttachSkill) == 0x000250, "Member 'UPalDebugSetting::PassiveSkill_AttachSkill' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bPassiveSkill_CollectItem_10Sec) == 0x0002A0, "Member 'UPalDebugSetting::bPassiveSkill_CollectItem_10Sec' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bPassiveSkill_LifeSteal_DisplayRecoverHp) == 0x0002A1, "Member 'UPalDebugSetting::bPassiveSkill_LifeSteal_DisplayRecoverHp' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bLogMapObjectFailedSpawn) == 0x0002A2, "Member 'UPalDebugSetting::bLogMapObjectFailedSpawn' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bShowMapObjectStatus) == 0x0002A3, "Member 'UPalDebugSetting::bShowMapObjectStatus' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bShowMapObjectFoliageStatus) == 0x0002A4, "Member 'UPalDebugSetting::bShowMapObjectFoliageStatus' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, ShowMapObjectStatusRange) == 0x0002A8, "Member 'UPalDebugSetting::ShowMapObjectStatusRange' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bDisablePalFoliageComponentBeginPlay) == 0x0002AC, "Member 'UPalDebugSetting::bDisablePalFoliageComponentBeginPlay' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bShowMapObjectSpawnerStatus) == 0x0002AD, "Member 'UPalDebugSetting::bShowMapObjectSpawnerStatus' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bDisableMapObjectEffect) == 0x0002AE, "Member 'UPalDebugSetting::bDisableMapObjectEffect' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bDrawDetectMapObjectInDoor) == 0x0002AF, "Member 'UPalDebugSetting::bDrawDetectMapObjectInDoor' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bCanDamageToMapObjectFromSameGroup) == 0x0002B0, "Member 'UPalDebugSetting::bCanDamageToMapObjectFromSameGroup' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, MapObjectHpOverride) == 0x0002B4, "Member 'UPalDebugSetting::MapObjectHpOverride' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, FoliageRespawnIntervalOverrideSeconds) == 0x0002B8, "Member 'UPalDebugSetting::FoliageRespawnIntervalOverrideSeconds' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bVisibleFoliageChunk) == 0x0002BC, "Member 'UPalDebugSetting::bVisibleFoliageChunk' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bShowPalEggStatus) == 0x0002BD, "Member 'UPalDebugSetting::bShowPalEggStatus' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, ShowPalEggStatusRange) == 0x0002C0, "Member 'UPalDebugSetting::ShowPalEggStatusRange' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsHideAllHUD) == 0x0002C4, "Member 'UPalDebugSetting::bIsHideAllHUD' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsNowHUDHide) == 0x0002C5, "Member 'UPalDebugSetting::bIsNowHUDHide' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bForceCreateDispatchParameterByHUDService) == 0x0002C6, "Member 'UPalDebugSetting::bForceCreateDispatchParameterByHUDService' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bShowDebugMapIcon) == 0x0002C7, "Member 'UPalDebugSetting::bShowDebugMapIcon' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsHideUIForPV) == 0x0002C8, "Member 'UPalDebugSetting::bIsHideUIForPV' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsCompletePaldex) == 0x0002C9, "Member 'UPalDebugSetting::bIsCompletePaldex' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bUseFixedPositionPlayerUI) == 0x0002CA, "Member 'UPalDebugSetting::bUseFixedPositionPlayerUI' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bForceShowHPGauge) == 0x0002CB, "Member 'UPalDebugSetting::bForceShowHPGauge' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bForceWordFilter_ACE) == 0x0002CC, "Member 'UPalDebugSetting::bForceWordFilter_ACE' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, ForceWordFilterAPIType_ACE) == 0x0002CD, "Member 'UPalDebugSetting::ForceWordFilterAPIType_ACE' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsFixedRandomSeed) == 0x0002CE, "Member 'UPalDebugSetting::bIsFixedRandomSeed' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, ActionRandomSeed) == 0x0002D0, "Member 'UPalDebugSetting::ActionRandomSeed' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bAvailableBuildObjectInDevelop) == 0x0002D4, "Member 'UPalDebugSetting::bAvailableBuildObjectInDevelop' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bShowBuildObjectInstallCheck) == 0x0002D5, "Member 'UPalDebugSetting::bShowBuildObjectInstallCheck' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, IgnoreInstallErrors) == 0x0002D8, "Member 'UPalDebugSetting::IgnoreInstallErrors' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bDrawDebugInstallConnection) == 0x0002E8, "Member 'UPalDebugSetting::bDrawDebugInstallConnection' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bUseEagleForGlider) == 0x0002E9, "Member 'UPalDebugSetting::bUseEagleForGlider' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bEquipDefaultGlider) == 0x0002EA, "Member 'UPalDebugSetting::bEquipDefaultGlider' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, ExtraHpRegenRateInSleepingBed) == 0x0002EC, "Member 'UPalDebugSetting::ExtraHpRegenRateInSleepingBed' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bForceDisableLamp) == 0x0002F0, "Member 'UPalDebugSetting::bForceDisableLamp' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bForceDisableTimerLight) == 0x0002F1, "Member 'UPalDebugSetting::bForceDisableTimerLight' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bForceDisableTickOptimization) == 0x0002F2, "Member 'UPalDebugSetting::bForceDisableTickOptimization' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bForceDisableDamagePopup) == 0x0002F3, "Member 'UPalDebugSetting::bForceDisableDamagePopup' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsShowTickOptimizationType) == 0x0002F4, "Member 'UPalDebugSetting::bIsShowTickOptimizationType' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIgnoreFastTravelLock) == 0x0002F5, "Member 'UPalDebugSetting::bIgnoreFastTravelLock' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, AudioBusVolumes) == 0x0002F8, "Member 'UPalDebugSetting::AudioBusVolumes' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, AudioBusMute) == 0x000348, "Member 'UPalDebugSetting::AudioBusMute' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsShowPostAkEvent) == 0x000398, "Member 'UPalDebugSetting::bIsShowPostAkEvent' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, SoundDebugModelClass) == 0x0003A0, "Member 'UPalDebugSetting::SoundDebugModelClass' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsMuteForPlayerSoundOnly) == 0x0003A8, "Member 'UPalDebugSetting::bIsMuteForPlayerSoundOnly' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bDisplayPlaySoundId) == 0x0003A9, "Member 'UPalDebugSetting::bDisplayPlaySoundId' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bPlayFootStepSound) == 0x0003AA, "Member 'UPalDebugSetting::bPlayFootStepSound' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, IgnoreSoundIds) == 0x0003B0, "Member 'UPalDebugSetting::IgnoreSoundIds' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsSpawnFootStepEffect) == 0x0003C0, "Member 'UPalDebugSetting::bIsSpawnFootStepEffect' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsDisableCameraPitchLimit) == 0x0003C1, "Member 'UPalDebugSetting::bIsDisableCameraPitchLimit' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsIgnoreNetworkVersionCompatible) == 0x0003C2, "Member 'UPalDebugSetting::bIsIgnoreNetworkVersionCompatible' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsUseClientOtomoSetting) == 0x0003C3, "Member 'UPalDebugSetting::bIsUseClientOtomoSetting' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, DefaultOtomoPalForClient) == 0x0003C8, "Member 'UPalDebugSetting::DefaultOtomoPalForClient' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsForcedSynchronizedMapObject) == 0x0003D8, "Member 'UPalDebugSetting::bIsForcedSynchronizedMapObject' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bEnableCharacterCountInServer) == 0x0003D9, "Member 'UPalDebugSetting::bEnableCharacterCountInServer' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bUseDedicatedServerOptimizeInListenServer) == 0x0003DA, "Member 'UPalDebugSetting::bUseDedicatedServerOptimizeInListenServer' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsDisableInitRandomCharacterMake) == 0x0003DB, "Member 'UPalDebugSetting::bIsDisableInitRandomCharacterMake' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bForceSpawnTreasureBox) == 0x0003DC, "Member 'UPalDebugSetting::bForceSpawnTreasureBox' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bForceSpawnEnemyCamp) == 0x0003DD, "Member 'UPalDebugSetting::bForceSpawnEnemyCamp' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bForceSpawnPalEgg) == 0x0003DE, "Member 'UPalDebugSetting::bForceSpawnPalEgg' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bForceSpawnRarePal) == 0x0003DF, "Member 'UPalDebugSetting::bForceSpawnRarePal' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, IgnoreAudio) == 0x0003E0, "Member 'UPalDebugSetting::IgnoreAudio' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsShowAudioSoundPlayer) == 0x0003E1, "Member 'UPalDebugSetting::bIsShowAudioSoundPlayer' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bForceSpawnRandomIncident) == 0x0003E2, "Member 'UPalDebugSetting::bForceSpawnRandomIncident' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bForceDisableSpawnRandomIncident) == 0x0003E3, "Member 'UPalDebugSetting::bForceDisableSpawnRandomIncident' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, ForceSpawnRandomIncidentName) == 0x0003E8, "Member 'UPalDebugSetting::ForceSpawnRandomIncidentName' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bShowRandomIncidentSpawnArea) == 0x0003F8, "Member 'UPalDebugSetting::bShowRandomIncidentSpawnArea' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bShowRandomIncidentEndArea) == 0x0003F9, "Member 'UPalDebugSetting::bShowRandomIncidentEndArea' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bShowRandomIncidentExcludeArea) == 0x0003FA, "Member 'UPalDebugSetting::bShowRandomIncidentExcludeArea' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bInvadeSetting_Override) == 0x0003FB, "Member 'UPalDebugSetting::bInvadeSetting_Override' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, InvadeProbability_Override) == 0x0003FC, "Member 'UPalDebugSetting::InvadeProbability_Override' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, InvadeOccurablePlayerLevel_Override) == 0x000400, "Member 'UPalDebugSetting::InvadeOccurablePlayerLevel_Override' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, ForceOccurInvaderName) == 0x000408, "Member 'UPalDebugSetting::ForceOccurInvaderName' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, Biome_Override) == 0x000418, "Member 'UPalDebugSetting::Biome_Override' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, InvadeJudgmentInterval_Minutes_Override) == 0x00041C, "Member 'UPalDebugSetting::InvadeJudgmentInterval_Minutes_Override' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, InvadeCollTime_Max_Minutes_Override) == 0x000420, "Member 'UPalDebugSetting::InvadeCollTime_Max_Minutes_Override' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, InvadeCollTime_Min_Minutes_Override) == 0x000424, "Member 'UPalDebugSetting::InvadeCollTime_Min_Minutes_Override' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, InvadeReturnTime_Minutes_Override) == 0x000428, "Member 'UPalDebugSetting::InvadeReturnTime_Minutes_Override' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, InvadeStartPoint_BaseCampRadius_Min_cm_Override) == 0x00042C, "Member 'UPalDebugSetting::InvadeStartPoint_BaseCampRadius_Min_cm_Override' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, InvadeStartPoint_BaseCampRadius_Max_cm_Override) == 0x000430, "Member 'UPalDebugSetting::InvadeStartPoint_BaseCampRadius_Max_cm_Override' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, VisitorNPCProbability_Override) == 0x000434, "Member 'UPalDebugSetting::VisitorNPCProbability_Override' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, ForceOccurVisitorNPCName) == 0x000438, "Member 'UPalDebugSetting::ForceOccurVisitorNPCName' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, VisitorNPCReturnTime_Minutes_Override) == 0x000448, "Member 'UPalDebugSetting::VisitorNPCReturnTime_Minutes_Override' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsDisableCrossKeyQuickSwitch) == 0x00044C, "Member 'UPalDebugSetting::bIsDisableCrossKeyQuickSwitch' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsEnableAirRolling) == 0x00044D, "Member 'UPalDebugSetting::bIsEnableAirRolling' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsEnablePalWarp) == 0x00044E, "Member 'UPalDebugSetting::bIsEnablePalWarp' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bDungeonDevelopFlag) == 0x00044F, "Member 'UPalDebugSetting::bDungeonDevelopFlag' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsDisableOptionWorldLoadConfig) == 0x000450, "Member 'UPalDebugSetting::bIsDisableOptionWorldLoadConfig' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsShowNightSkipLog) == 0x000451, "Member 'UPalDebugSetting::bIsShowNightSkipLog' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsApplyOptionWorldModePreset) == 0x000452, "Member 'UPalDebugSetting::bIsApplyOptionWorldModePreset' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bShowAnimRateScale) == 0x000453, "Member 'UPalDebugSetting::bShowAnimRateScale' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, ShowAnimRateScaleRange) == 0x000454, "Member 'UPalDebugSetting::ShowAnimRateScaleRange' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsParallelForUpdateActiveTiles) == 0x000458, "Member 'UPalDebugSetting::bIsParallelForUpdateActiveTiles' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsDisablePlayerTeleportTimeout) == 0x000459, "Member 'UPalDebugSetting::bIsDisablePlayerTeleportTimeout' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bUseMalePlayer) == 0x00045A, "Member 'UPalDebugSetting::bUseMalePlayer' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bEnableLoadingScreen) == 0x00045B, "Member 'UPalDebugSetting::bEnableLoadingScreen' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, OnLoadingScreenVisibilityChanged) == 0x000460, "Member 'UPalDebugSetting::OnLoadingScreenVisibilityChanged' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bIsSkipCharacterMake) == 0x000470, "Member 'UPalDebugSetting::bIsSkipCharacterMake' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bDrawHitCollision) == 0x000471, "Member 'UPalDebugSetting::bDrawHitCollision' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bDisableGrapplingCoolDown) == 0x000472, "Member 'UPalDebugSetting::bDisableGrapplingCoolDown' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bDrawGrapplingLine) == 0x000473, "Member 'UPalDebugSetting::bDrawGrapplingLine' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bDrawGrapplingHitPoint) == 0x000474, "Member 'UPalDebugSetting::bDrawGrapplingHitPoint' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bDrawAmbientSoundLinePlayLocation) == 0x000475, "Member 'UPalDebugSetting::bDrawAmbientSoundLinePlayLocation' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bDrawAmbientSoundActivateTrigger) == 0x000476, "Member 'UPalDebugSetting::bDrawAmbientSoundActivateTrigger' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bDrawDefenseAttackableRange) == 0x000477, "Member 'UPalDebugSetting::bDrawDefenseAttackableRange' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bShowDefenseAttackTarget) == 0x000478, "Member 'UPalDebugSetting::bShowDefenseAttackTarget' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, ShowDefenseRange) == 0x00047C, "Member 'UPalDebugSetting::ShowDefenseRange' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bDisableInteractRecicleTarget) == 0x000480, "Member 'UPalDebugSetting::bDisableInteractRecicleTarget' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bShowStageDeathPenaltyLocation) == 0x000481, "Member 'UPalDebugSetting::bShowStageDeathPenaltyLocation' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bForceLocationTeleport) == 0x000482, "Member 'UPalDebugSetting::bForceLocationTeleport' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bShowInvaderDebugLog) == 0x000483, "Member 'UPalDebugSetting::bShowInvaderDebugLog' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bShowStreamingLevel) == 0x000484, "Member 'UPalDebugSetting::bShowStreamingLevel' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bShowInteractPoints) == 0x000485, "Member 'UPalDebugSetting::bShowInteractPoints' has a wrong offset!");
static_assert(offsetof(UPalDebugSetting, bEnableArenaTest) == 0x000486, "Member 'UPalDebugSetting::bEnableArenaTest' has a wrong offset!");

// Class Pal.PalDebug_SpawnInfoReporter
// 0x0010 (0x02A0 - 0x0290)
class APalDebug_SpawnInfoReporter : public AActor
{
public:
	TArray<class APalNPCSpawnerBase*>             CacheSpawner;                                      // 0x0290(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	class FString GetDebugInfoString(class APalNPCSpawnerBase* Spawner);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalDebug_SpawnInfoReporter">();
	}
	static class APalDebug_SpawnInfoReporter* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalDebug_SpawnInfoReporter>();
	}
};
static_assert(alignof(APalDebug_SpawnInfoReporter) == 0x000008, "Wrong alignment on APalDebug_SpawnInfoReporter");
static_assert(sizeof(APalDebug_SpawnInfoReporter) == 0x0002A0, "Wrong size on APalDebug_SpawnInfoReporter");
static_assert(offsetof(APalDebug_SpawnInfoReporter, CacheSpawner) == 0x000290, "Member 'APalDebug_SpawnInfoReporter::CacheSpawner' has a wrong offset!");

// Class Pal.PalRaidBossManager
// 0x00B0 (0x0120 - 0x0070)
class UPalRaidBossManager : public UPalWorldSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnRaidBossBattleStartDelegate;                     // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRaidBossBattleFinishDelegate;                    // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UDataTable*                             RaidBossDataTable;                                 // 0x0090(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeLimit;                                         // 0x0098(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BattleAreaRadius;                                  // 0x009C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NPCTargetCount_ForForcePlayerTarget;               // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B07[0x4];                                     // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 LargeDownHPRate;                                   // 0x00A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     RaidBossBattleActorClass;                          // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FGuid, class UPalRaidBossComponent*> RaidComponentMap;                                  // 0x00C0(0x0050)(Edit, ExportObject, DisableEditOnTemplate, Transient, EditConst, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FGuid                                  GroupGuid;                                         // 0x0110(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	struct FPalRaidBossDataRow FindRaidBossData(class FName ItemName);
	struct FPalRaidBossSpawnInfo FindRaidBossInfoByCharacterID(class FName CharacterID);
	class UPalRaidBossComponent* FindRaidComponent(const struct FGuid& BaseCampId);
	class UPalRaidBossComponent* FindRaidComponent_ByBuildObject(class APalMapObject* BuildObject);
	bool IsRaidBossOfferItem(class FName ItemName);
	void OnRaidBossBattleFinishDelegate__DelegateSignature(const struct FGuid& CampID, EPalRaidBossBattleFinishType FinishType);
	void OnRaidBossBattleStartDelegate__DelegateSignature(const struct FGuid& CampID);

	int32 GetNPCTargetCount_ForForcePlayerTarget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalRaidBossManager">();
	}
	static class UPalRaidBossManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalRaidBossManager>();
	}
};
static_assert(alignof(UPalRaidBossManager) == 0x000008, "Wrong alignment on UPalRaidBossManager");
static_assert(sizeof(UPalRaidBossManager) == 0x000120, "Wrong size on UPalRaidBossManager");
static_assert(offsetof(UPalRaidBossManager, OnRaidBossBattleStartDelegate) == 0x000070, "Member 'UPalRaidBossManager::OnRaidBossBattleStartDelegate' has a wrong offset!");
static_assert(offsetof(UPalRaidBossManager, OnRaidBossBattleFinishDelegate) == 0x000080, "Member 'UPalRaidBossManager::OnRaidBossBattleFinishDelegate' has a wrong offset!");
static_assert(offsetof(UPalRaidBossManager, RaidBossDataTable) == 0x000090, "Member 'UPalRaidBossManager::RaidBossDataTable' has a wrong offset!");
static_assert(offsetof(UPalRaidBossManager, TimeLimit) == 0x000098, "Member 'UPalRaidBossManager::TimeLimit' has a wrong offset!");
static_assert(offsetof(UPalRaidBossManager, BattleAreaRadius) == 0x00009C, "Member 'UPalRaidBossManager::BattleAreaRadius' has a wrong offset!");
static_assert(offsetof(UPalRaidBossManager, NPCTargetCount_ForForcePlayerTarget) == 0x0000A0, "Member 'UPalRaidBossManager::NPCTargetCount_ForForcePlayerTarget' has a wrong offset!");
static_assert(offsetof(UPalRaidBossManager, LargeDownHPRate) == 0x0000A8, "Member 'UPalRaidBossManager::LargeDownHPRate' has a wrong offset!");
static_assert(offsetof(UPalRaidBossManager, RaidBossBattleActorClass) == 0x0000B8, "Member 'UPalRaidBossManager::RaidBossBattleActorClass' has a wrong offset!");
static_assert(offsetof(UPalRaidBossManager, RaidComponentMap) == 0x0000C0, "Member 'UPalRaidBossManager::RaidComponentMap' has a wrong offset!");
static_assert(offsetof(UPalRaidBossManager, GroupGuid) == 0x000110, "Member 'UPalRaidBossManager::GroupGuid' has a wrong offset!");

// Class Pal.PalDefine
// 0x0000 (0x0028 - 0x0028)
class UPalDefine final : public UBlueprintFunctionLibrary
{
public:
	static class FName ActionBBKey_FeedItem();
	static class FName ActionNotify_MiningEndTiming();
	static class FName ActionNotify_MiningImpactTiming();
	static class FName BS_BodyArmMaxName();
	static class FName BS_BodyArmMinName();
	static class FName BS_LegArmMaxName();
	static class FName BS_LegArmMinName();
	static class FName BS_TorsoArmMaxName();
	static class FName BS_TorsoArmMinName();
	static class FName DecreaseFullStomachRate_Work();
	static class FName DecreaseFullStomachRate_WorkHard();
	static class FName DecreaseSanityRate_WorkHard();
	static class FName FlagName_CameraOffsetInLiftup();
	static class FName FlagName_DebugBotGuildName();
	static class FName FlagName_OverWeightInventory();
	static class FName MP_ArmNormalMaxIntensityName();
	static class FName MP_ArmNormalMinIntensityName();
	static class FName MP_CharacterMakeBaseColorBrightnessName();
	static class FName MP_CharacterMakeBaseColorHueName();
	static class FName MP_CharacterMakeBaseColorSaturationName();
	static class FName MP_CharacterMakeSubsurfaceColorName();
	static class FName MP_LegNormalMaxIntensityName();
	static class FName MP_LegNormalMinIntensityName();
	static class FName MP_PalLitBaseColorName();
	static class FName MP_TorsoNormalMaxIntensityName();
	static class FName MP_TorsoNormalMinIntensityName();
	static class FName MS_HumanBodyName();
	static class FName MS_HumanBrowName();
	static class FName MS_HumanClothName();
	static class FName MS_HumanEyeName();
	static class FName MS_HumanHairName();
	static class FName MS_HumanHeadName();
	static class FName NP_PlayerCenterPosition();
	static class FName Socket_AimTarget();
	static class FName Socket_BodyCenter();
	static class FName Socket_BulletMuzzle();
	static class FName Socket_EquipWeapon1();
	static class FName Socket_EquipWeapon2();
	static class FName Socket_EquipWeapon3();
	static class FName Socket_JumpEffect();
	static class FName Socket_Mouth();
	static class FName StaticItemID_Money();
	static class FName StaticItemID_UnlockAutoMeal_Tier(int32 Num);
	static class FName StaticItemID_UnlockLantern();
	static class FName StaticItemID_UnlockTalentCheck();
	static class FName StatusPointName_AddCaptureLevel();
	static class FName StatusPointName_AddMaxHP();
	static class FName StatusPointName_AddMaxInventoryWeight();
	static class FName StatusPointName_AddMaxSP();
	static class FName StatusPointName_AddPower();
	static class FName StatusPointName_AddWorkSpeed();
	static class FName TextId_UICommon_CONFIRM_DUNGEON_ENTER();
	static class FName TextId_UICommon_CONFIRM_DUNGEON_EXIT();
	static class FName TextId_UICommon_DISMANTLING_CONFIRM_PALBOX();
	static class FName TextId_UICommon_DISMANTLING_FAILED_PALBOX();
	static class FName TextId_UICommon_INFINITE();
	static class FName TextId_UICommon_InteractIndicator_ConsumeAndOpen();
	static class FName TextId_UICommon_InteractIndicator_InputPassword_CannotTry();
	static class FName TextId_UICommon_LOG_ConsumeItem();
	static class FName TextId_UICommon_LOG_NeedItemToOpenTreasureBox();
	static class FName TextId_UICommon_SystemErrorCantMoveNotOwned();
	static class FName TextId_UICommon_SystemMessageUnlockFastTravel();
	static struct FGameplayTag UILayerTag_Game();
	static struct FGameplayTag UILayerTag_GameMenu();
	static struct FGameplayTag UILayerTag_GameMenu2();
	static struct FGameplayTag UILayerTag_GameMenu3();
	static struct FGameplayTag UILayerTag_GameMenu4();
	static struct FGameplayTag UILayerTag_GameMenu5();
	static struct FGameplayTag UILayerTag_GameMenu6();
	static struct FGameplayTag UILayerTag_GameMenu7();
	static struct FGameplayTag UILayerTag_Menu();
	static struct FGameplayTag UILayerTag_Modal();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalDefine">();
	}
	static class UPalDefine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalDefine>();
	}
};
static_assert(alignof(UPalDefine) == 0x000008, "Wrong alignment on UPalDefine");
static_assert(sizeof(UPalDefine) == 0x000028, "Wrong size on UPalDefine");

// Class Pal.PalDismantleObjectChecker
// 0x0008 (0x0298 - 0x0290)
class APalDismantleObjectChecker final : public AActor
{
public:
	class APalBuildObject*                        TargetBuildObject;                                 // 0x0290(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class APalBuildObject* GetTargetObject();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalDismantleObjectChecker">();
	}
	static class APalDismantleObjectChecker* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalDismantleObjectChecker>();
	}
};
static_assert(alignof(APalDismantleObjectChecker) == 0x000008, "Wrong alignment on APalDismantleObjectChecker");
static_assert(sizeof(APalDismantleObjectChecker) == 0x000298, "Wrong size on APalDismantleObjectChecker");
static_assert(offsetof(APalDismantleObjectChecker, TargetBuildObject) == 0x000290, "Member 'APalDismantleObjectChecker::TargetBuildObject' has a wrong offset!");

// Class Pal.PalGuildEnterRequestSequence_ConfirmEnterGuildToApplicantPlayer
// 0x0008 (0x0070 - 0x0068)
class UPalGuildEnterRequestSequence_ConfirmEnterGuildToApplicantPlayer final : public UPalGuildRequestFlowSequenceWaitForConfirmPlayer
{
public:
	uint8                                         Pad_2B0A[0x8];                                     // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGuildEnterRequestSequence_ConfirmEnterGuildToApplicantPlayer">();
	}
	static class UPalGuildEnterRequestSequence_ConfirmEnterGuildToApplicantPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalGuildEnterRequestSequence_ConfirmEnterGuildToApplicantPlayer>();
	}
};
static_assert(alignof(UPalGuildEnterRequestSequence_ConfirmEnterGuildToApplicantPlayer) == 0x000008, "Wrong alignment on UPalGuildEnterRequestSequence_ConfirmEnterGuildToApplicantPlayer");
static_assert(sizeof(UPalGuildEnterRequestSequence_ConfirmEnterGuildToApplicantPlayer) == 0x000070, "Wrong size on UPalGuildEnterRequestSequence_ConfirmEnterGuildToApplicantPlayer");

// Class Pal.PalStageAreaVolume
// 0x0008 (0x0298 - 0x0290)
class APalStageAreaVolume : public AActor
{
public:
	class UDataLayerAsset*                        RelatedDataLayerAsset;                             // 0x0290(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetRelatedDataLayerAsset(class UDataLayerAsset* DataLayerAsset);

	struct FBox GetBoundingBox() const;
	class UDataLayerAsset* GetRelatedDataLayerAsset() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalStageAreaVolume">();
	}
	static class APalStageAreaVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalStageAreaVolume>();
	}
};
static_assert(alignof(APalStageAreaVolume) == 0x000008, "Wrong alignment on APalStageAreaVolume");
static_assert(sizeof(APalStageAreaVolume) == 0x000298, "Wrong size on APalStageAreaVolume");
static_assert(offsetof(APalStageAreaVolume, RelatedDataLayerAsset) == 0x000290, "Member 'APalStageAreaVolume::RelatedDataLayerAsset' has a wrong offset!");

// Class Pal.PalDungeonAreaVolume
// 0x0000 (0x0298 - 0x0298)
class APalDungeonAreaVolume final : public APalStageAreaVolume
{
public:
	void OnOverlapActor(class AActor* Other);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalDungeonAreaVolume">();
	}
	static class APalDungeonAreaVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalDungeonAreaVolume>();
	}
};
static_assert(alignof(APalDungeonAreaVolume) == 0x000008, "Wrong alignment on APalDungeonAreaVolume");
static_assert(sizeof(APalDungeonAreaVolume) == 0x000298, "Wrong size on APalDungeonAreaVolume");

// Class Pal.PalNPCSpawnerBase
// 0x00D8 (0x0368 - 0x0290)
class APalNPCSpawnerBase : public AActor
{
public:
	bool                                          bIsRunOnAnyThread;                                 // 0x0290(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Ignore_DebugSettingDisable;                        // 0x0291(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Ignore_DistanceLocationReset;                      // 0x0292(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Ignore_FarCheck;                                   // 0x0293(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoSpawnedTick;                                    // 0x0294(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPalSpawnRadiusType                           SpawnRadiusType;                                   // 0x0295(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsSquadBehaviour;                                  // 0x0296(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B0B[0x1];                                     // 0x0297(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DebugOrganizationName;                             // 0x0298(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LocationResetDistance_SpawnerToCharacterTooFar;    // 0x02A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LocationResetHeight_SpawnerToCharacterTooLow;      // 0x02AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 GroupName;                                         // 0x02B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalNavigationInvokerComponent*         NavInvokerComponent;                               // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FVector>                        NPCLocations;                                      // 0x02C8(0x0010)(BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnCreatedGroupDelegate;                            // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B0C[0x10];                                    // 0x02E8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  WildGroupGuid;                                     // 0x02F8(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalSquad*                              Squad;                                             // 0x0308(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFlagContainer                         DisableSpawn;                                      // 0x0310(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	EPalSpwnerImportanceType                      ImportanceType;                                    // 0x0360(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B0D[0x7];                                     // 0x0361(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddGroupCharacter(class UPalIndividualCharacterHandle* AddIndividualHandle);
	void AddGroupCharacterByGroupId(class UPalIndividualCharacterHandle* AddIndividualHandle, const struct FGuid& GroupID, const class FString& DebugName);
	void BlueprintTick(float DeltaTime);
	void BlueprintTick_AnyThread(float DeltaTime);
	void BlueprintTick_Despawning(float DeltaTime);
	void BlueprintTick_Spawned(float DeltaTime);
	void BlueprintTick_Spawning(float DeltaTime);
	EPalCheckSpawnResultType CheckSpawnDistance(bool Param_IsSpawned);
	void CreateDebugSpawnerGroupInfo(const struct FPalSpawnerGroupInfo& OneGroupInfo);
	void CreatedGroupDelegate__DelegateSignature();
	void GetAllNPCLocation(TArray<struct FVector>* OutLocations);
	void GetAllSpawnedNPCHandle(TArray<class UPalIndividualCharacterHandle*>* Handles);
	bool GetDisableBossSpawnerFlag_FromSaveData(class FName KeyName);
	bool GetIsServer();
	float GetSpawnerRadiusByType();
	int32 GetSpawnLevelRandom_OneTribe(const struct FPalSpawnerOneTribeInfo& Info);
	int32 GetSpawnNumRandom_OneTribe(const struct FPalSpawnerOneTribeInfo& Info);
	float GetSpawnPointRadius();
	bool IsNearBaseCamp();
	bool IsSuppressedByRandomIncident();
	void OnInitialized();
	void PathWalkNameSort(const TArray<class UObject*>& WalkPoint, TArray<class UObject*>* OutSortedWalkPoint);
	void ProcessBossDefeatInfo_ServerInternal(class AActor* BossActor, class FName SpawnerName);
	bool RandomSpawnLocationByRadiusLineTrace(struct FVector* OutLocation, float Radius, float RayStartUpOffset, float RayEndDownOffset, int32 SumSpawnNum, int32 SelfIndexInAll);
	bool RandomSpawnLocationByRadiusLineTraceWithWorldLocation(struct FVector* OutLocation, float Radius, float RayStartUpOffset, float RayEndDownOffset, const struct FVector& WorldPos, int32 SumSpawnNum, int32 SelfIndexInAll);
	void RemoveGroupCharacter(class UPalIndividualCharacterHandle* RemoveIndividualHandle);
	void RemoveGroupWhenDestoryActor(class AActor* DestoryActor);
	void Request_TickDespawningForGameThread(float DeltaTime);
	void Request_TickSpawnedForGameThread(float DeltaTime);
	void Request_TickSpawningForGameThread(float DeltaTime);
	void RequestCreateGroup(const TArray<class FName>& CharacterIDList);
	void RequestDeleteGroup();
	void SetAllNPCLocation();
	void SetCheckRadius(float SpawnRadius, float DespawnRadius);
	void SetDisableBossSpawner_ToSaveData(class FName KeyName);
	void SetSpawnDisableFlag(const class FName& Param_Name, bool IsDisable);
	void SetSpawnedFlag(bool IsSpawned);
	void SpawnRequest_ByOutside(bool IsDeleteAliveCharacter);
	void Tick_Despawning(float DeltaTime);
	void Tick_Spawned(float DeltaTime);
	void Tick_Spawning(float DeltaTime);

	int32 GetMaxMonsterLevel() const;
	TArray<struct FPalSpawnerGroupInfo> GetOriginalSpawnGroupList() const;
	class FString GetSpawnDisableDebugInfo() const;
	TArray<struct FPalSpawnerGroupInfo> GetSpawnGroupList() const;
	float GetSpawnRadiusCM() const;
	bool IsSpawnDisable() const;
	bool IsSpawned() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalNPCSpawnerBase">();
	}
	static class APalNPCSpawnerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalNPCSpawnerBase>();
	}
};
static_assert(alignof(APalNPCSpawnerBase) == 0x000008, "Wrong alignment on APalNPCSpawnerBase");
static_assert(sizeof(APalNPCSpawnerBase) == 0x000368, "Wrong size on APalNPCSpawnerBase");
static_assert(offsetof(APalNPCSpawnerBase, bIsRunOnAnyThread) == 0x000290, "Member 'APalNPCSpawnerBase::bIsRunOnAnyThread' has a wrong offset!");
static_assert(offsetof(APalNPCSpawnerBase, Ignore_DebugSettingDisable) == 0x000291, "Member 'APalNPCSpawnerBase::Ignore_DebugSettingDisable' has a wrong offset!");
static_assert(offsetof(APalNPCSpawnerBase, Ignore_DistanceLocationReset) == 0x000292, "Member 'APalNPCSpawnerBase::Ignore_DistanceLocationReset' has a wrong offset!");
static_assert(offsetof(APalNPCSpawnerBase, Ignore_FarCheck) == 0x000293, "Member 'APalNPCSpawnerBase::Ignore_FarCheck' has a wrong offset!");
static_assert(offsetof(APalNPCSpawnerBase, bDoSpawnedTick) == 0x000294, "Member 'APalNPCSpawnerBase::bDoSpawnedTick' has a wrong offset!");
static_assert(offsetof(APalNPCSpawnerBase, SpawnRadiusType) == 0x000295, "Member 'APalNPCSpawnerBase::SpawnRadiusType' has a wrong offset!");
static_assert(offsetof(APalNPCSpawnerBase, IsSquadBehaviour) == 0x000296, "Member 'APalNPCSpawnerBase::IsSquadBehaviour' has a wrong offset!");
static_assert(offsetof(APalNPCSpawnerBase, DebugOrganizationName) == 0x000298, "Member 'APalNPCSpawnerBase::DebugOrganizationName' has a wrong offset!");
static_assert(offsetof(APalNPCSpawnerBase, LocationResetDistance_SpawnerToCharacterTooFar) == 0x0002A8, "Member 'APalNPCSpawnerBase::LocationResetDistance_SpawnerToCharacterTooFar' has a wrong offset!");
static_assert(offsetof(APalNPCSpawnerBase, LocationResetHeight_SpawnerToCharacterTooLow) == 0x0002AC, "Member 'APalNPCSpawnerBase::LocationResetHeight_SpawnerToCharacterTooLow' has a wrong offset!");
static_assert(offsetof(APalNPCSpawnerBase, GroupName) == 0x0002B0, "Member 'APalNPCSpawnerBase::GroupName' has a wrong offset!");
static_assert(offsetof(APalNPCSpawnerBase, NavInvokerComponent) == 0x0002C0, "Member 'APalNPCSpawnerBase::NavInvokerComponent' has a wrong offset!");
static_assert(offsetof(APalNPCSpawnerBase, NPCLocations) == 0x0002C8, "Member 'APalNPCSpawnerBase::NPCLocations' has a wrong offset!");
static_assert(offsetof(APalNPCSpawnerBase, OnCreatedGroupDelegate) == 0x0002D8, "Member 'APalNPCSpawnerBase::OnCreatedGroupDelegate' has a wrong offset!");
static_assert(offsetof(APalNPCSpawnerBase, WildGroupGuid) == 0x0002F8, "Member 'APalNPCSpawnerBase::WildGroupGuid' has a wrong offset!");
static_assert(offsetof(APalNPCSpawnerBase, Squad) == 0x000308, "Member 'APalNPCSpawnerBase::Squad' has a wrong offset!");
static_assert(offsetof(APalNPCSpawnerBase, DisableSpawn) == 0x000310, "Member 'APalNPCSpawnerBase::DisableSpawn' has a wrong offset!");
static_assert(offsetof(APalNPCSpawnerBase, ImportanceType) == 0x000360, "Member 'APalNPCSpawnerBase::ImportanceType' has a wrong offset!");

// Class Pal.PalRandomIncidentNPCSpawner
// 0x0070 (0x03D8 - 0x0368)
class APalRandomIncidentNPCSpawner : public APalNPCSpawnerBase
{
public:
	FMulticastInlineDelegateProperty_             OnNPCSpawnedDelegate;                              // 0x0368(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNPCDespawnedDelegate;                            // 0x0378(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMap<int32, struct FGuid>                     GroupMap;                                          // 0x0388(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	void AddGroupCharacterByGroupNo(class UPalIndividualCharacterHandle* AddIndividualHandle, int32 GroupNo);
	void DespawnCharacters();
	class APalCharacter* FindCharacterByName(const class FName& Param_Name);
	class UPalIndividualCharacterHandle* FindIndividualCharacterHandleByName(const TMap<class UPalIndividualCharacterHandle*, class FName>& RowNames, const class FName& Param_Name);
	void GetSpawnedCharacters(TArray<class AActor*>* SpawnedCharacters);
	bool IsSpawnedCharacter(const class UPalIndividualCharacterHandle* Handle);
	void NPCDespawned__DelegateSignature(const class FName& RowName);
	void NPCSpawned__DelegateSignature(const class FName& RowName);
	void RequestCreateGroups(const TArray<int32>& Groups);
	void SpawnMonster(const class FName& RowName, const struct FPalRandomIncidentSpawnMonsterData& SpawnData, int32 SpawnPointIndex, int32 SpawnPointCount);
	void SpawnNPC(const class FName& RowName, const struct FPalRandomIncidentSpawnNPCData& SpawnData, int32 SpawnPointIndex, int32 SpawnPointCount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalRandomIncidentNPCSpawner">();
	}
	static class APalRandomIncidentNPCSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalRandomIncidentNPCSpawner>();
	}
};
static_assert(alignof(APalRandomIncidentNPCSpawner) == 0x000008, "Wrong alignment on APalRandomIncidentNPCSpawner");
static_assert(sizeof(APalRandomIncidentNPCSpawner) == 0x0003D8, "Wrong size on APalRandomIncidentNPCSpawner");
static_assert(offsetof(APalRandomIncidentNPCSpawner, OnNPCSpawnedDelegate) == 0x000368, "Member 'APalRandomIncidentNPCSpawner::OnNPCSpawnedDelegate' has a wrong offset!");
static_assert(offsetof(APalRandomIncidentNPCSpawner, OnNPCDespawnedDelegate) == 0x000378, "Member 'APalRandomIncidentNPCSpawner::OnNPCDespawnedDelegate' has a wrong offset!");
static_assert(offsetof(APalRandomIncidentNPCSpawner, GroupMap) == 0x000388, "Member 'APalRandomIncidentNPCSpawner::GroupMap' has a wrong offset!");

// Class Pal.SequentialProcessSystem
// 0x0028 (0x0050 - 0x0028)
class USequentialProcessSystem : public UObject
{
public:
	uint8                                         Pad_2B15[0x10];                                    // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSequentialProcessSequenceSet>  SequenceSets;                                      // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	int32                                         CurrentSequenceIndex;                              // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B16[0x4];                                     // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChangeProcessProgressRate(class USequentialProcessHandle* ChangedProcessHandle);
	void OnChangeProcessState(class USequentialProcessHandle* ChangedProcessHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SequentialProcessSystem">();
	}
	static class USequentialProcessSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<USequentialProcessSystem>();
	}
};
static_assert(alignof(USequentialProcessSystem) == 0x000008, "Wrong alignment on USequentialProcessSystem");
static_assert(sizeof(USequentialProcessSystem) == 0x000050, "Wrong size on USequentialProcessSystem");
static_assert(offsetof(USequentialProcessSystem, SequenceSets) == 0x000038, "Member 'USequentialProcessSystem::SequenceSets' has a wrong offset!");
static_assert(offsetof(USequentialProcessSystem, CurrentSequenceIndex) == 0x000048, "Member 'USequentialProcessSystem::CurrentSequenceIndex' has a wrong offset!");

// Class Pal.PalGuildRequestFlowBase
// 0x0020 (0x0070 - 0x0050)
class UPalGuildRequestFlowBase : public USequentialProcessSystem
{
public:
	uint8                                         Pad_2B17[0x10];                                    // 0x0050(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  FlowId;                                            // 0x0060(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnFinishFlow();
	void ReturnSelfDelegate__DelegateSignature(class UPalGuildRequestFlowBase* Flow);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGuildRequestFlowBase">();
	}
	static class UPalGuildRequestFlowBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalGuildRequestFlowBase>();
	}
};
static_assert(alignof(UPalGuildRequestFlowBase) == 0x000008, "Wrong alignment on UPalGuildRequestFlowBase");
static_assert(sizeof(UPalGuildRequestFlowBase) == 0x000070, "Wrong size on UPalGuildRequestFlowBase");
static_assert(offsetof(UPalGuildRequestFlowBase, FlowId) == 0x000060, "Member 'UPalGuildRequestFlowBase::FlowId' has a wrong offset!");

// Class Pal.PalDungeonLevelDataAsset
// 0x0038 (0x0068 - 0x0030)
class UPalDungeonLevelDataAsset final : public UDataAsset
{
public:
	struct FBox                                   LevelBounds;                                       // 0x0030(0x0038)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalDungeonLevelDataAsset">();
	}
	static class UPalDungeonLevelDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalDungeonLevelDataAsset>();
	}
};
static_assert(alignof(UPalDungeonLevelDataAsset) == 0x000008, "Wrong alignment on UPalDungeonLevelDataAsset");
static_assert(sizeof(UPalDungeonLevelDataAsset) == 0x000068, "Wrong size on UPalDungeonLevelDataAsset");
static_assert(offsetof(UPalDungeonLevelDataAsset, LevelBounds) == 0x000030, "Member 'UPalDungeonLevelDataAsset::LevelBounds' has a wrong offset!");

// Class Pal.PalDungeonSpawnerDataAsset
// 0x0010 (0x0040 - 0x0030)
class UPalDungeonSpawnerDataAsset final : public UDataAsset
{
public:
	TArray<class FName>                           SpawnerPatternNames;                               // 0x0030(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalDungeonSpawnerDataAsset">();
	}
	static class UPalDungeonSpawnerDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalDungeonSpawnerDataAsset>();
	}
};
static_assert(alignof(UPalDungeonSpawnerDataAsset) == 0x000008, "Wrong alignment on UPalDungeonSpawnerDataAsset");
static_assert(sizeof(UPalDungeonSpawnerDataAsset) == 0x000040, "Wrong size on UPalDungeonSpawnerDataAsset");
static_assert(offsetof(UPalDungeonSpawnerDataAsset, SpawnerPatternNames) == 0x000030, "Member 'UPalDungeonSpawnerDataAsset::SpawnerPatternNames' has a wrong offset!");

// Class Pal.PalGuildInfo
// 0x0018 (0x02A8 - 0x0290)
class APalGuildInfo final : public AInfo
{
public:
	struct FGuid                                  GroupID;                                           // 0x0290(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalGroupGuildBase*                     Guild;                                             // 0x02A0(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnRep_Guild(const class UPalGroupGuildBase* OldValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGuildInfo">();
	}
	static class APalGuildInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalGuildInfo>();
	}
};
static_assert(alignof(APalGuildInfo) == 0x000008, "Wrong alignment on APalGuildInfo");
static_assert(sizeof(APalGuildInfo) == 0x0002A8, "Wrong size on APalGuildInfo");
static_assert(offsetof(APalGuildInfo, GroupID) == 0x000290, "Member 'APalGuildInfo::GroupID' has a wrong offset!");
static_assert(offsetof(APalGuildInfo, Guild) == 0x0002A0, "Member 'APalGuildInfo::Guild' has a wrong offset!");

// Class Pal.PalDungeonDefines
// 0x0000 (0x0028 - 0x0028)
class UPalDungeonDefines final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalDungeonDefines">();
	}
	static class UPalDungeonDefines* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalDungeonDefines>();
	}
};
static_assert(alignof(UPalDungeonDefines) == 0x000008, "Wrong alignment on UPalDungeonDefines");
static_assert(sizeof(UPalDungeonDefines) == 0x000028, "Wrong size on UPalDungeonDefines");

// Class Pal.PalDungeonInfoParameterUtility
// 0x0000 (0x0028 - 0x0028)
class UPalDungeonInfoParameterUtility final : public UObject
{
public:
	static float CalcDisappearRemainSeconds(const class UObject* WorldContextObject, const struct FPalDungeonInfoParameter& InParameter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalDungeonInfoParameterUtility">();
	}
	static class UPalDungeonInfoParameterUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalDungeonInfoParameterUtility>();
	}
};
static_assert(alignof(UPalDungeonInfoParameterUtility) == 0x000008, "Wrong alignment on UPalDungeonInfoParameterUtility");
static_assert(sizeof(UPalDungeonInfoParameterUtility) == 0x000028, "Wrong size on UPalDungeonInfoParameterUtility");

// Class Pal.PalGuildEnterRequestFlow
// 0x0020 (0x0090 - 0x0070)
class UPalGuildEnterRequestFlow final : public UPalGuildRequestFlowBase
{
public:
	struct FGuid                                  ApplicantPlayerUId;                                // 0x0070(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  RespondentPlayerUId;                               // 0x0080(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGuildEnterRequestFlow">();
	}
	static class UPalGuildEnterRequestFlow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalGuildEnterRequestFlow>();
	}
};
static_assert(alignof(UPalGuildEnterRequestFlow) == 0x000008, "Wrong alignment on UPalGuildEnterRequestFlow");
static_assert(sizeof(UPalGuildEnterRequestFlow) == 0x000090, "Wrong size on UPalGuildEnterRequestFlow");
static_assert(offsetof(UPalGuildEnterRequestFlow, ApplicantPlayerUId) == 0x000070, "Member 'UPalGuildEnterRequestFlow::ApplicantPlayerUId' has a wrong offset!");
static_assert(offsetof(UPalGuildEnterRequestFlow, RespondentPlayerUId) == 0x000080, "Member 'UPalGuildEnterRequestFlow::RespondentPlayerUId' has a wrong offset!");

// Class Pal.PalDungeonEnemySpawnerPoint
// 0x0038 (0x02C8 - 0x0290)
class APalDungeonEnemySpawnerPoint final : public AActor
{
public:
	uint8                                         Pad_2B19[0x10];                                    // 0x0290(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	EPalDungeonEnemySpawnerRankType               RankType;                                          // 0x02A0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B1A[0x27];                                    // 0x02A1(0x0027)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckLevelStreamingCompleted();
	void OnChangeBossState_ServerInternal(class UPalDungeonInstanceModel* InstanceModel);
	void OnCreatedGroup();
	void OnEnterCharacterToGroup(class UPalIndividualCharacterHandle* IndividualHandle);
	void ReturnIndividualHandleDelegate__DelegateSignature(class UPalIndividualCharacterHandle* IndividualHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalDungeonEnemySpawnerPoint">();
	}
	static class APalDungeonEnemySpawnerPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalDungeonEnemySpawnerPoint>();
	}
};
static_assert(alignof(APalDungeonEnemySpawnerPoint) == 0x000008, "Wrong alignment on APalDungeonEnemySpawnerPoint");
static_assert(sizeof(APalDungeonEnemySpawnerPoint) == 0x0002C8, "Wrong size on APalDungeonEnemySpawnerPoint");
static_assert(offsetof(APalDungeonEnemySpawnerPoint, RankType) == 0x0002A0, "Member 'APalDungeonEnemySpawnerPoint::RankType' has a wrong offset!");

// Class Pal.PalHeadUpDisplayComponent
// 0x0038 (0x00D8 - 0x00A0)
class UPalHeadUpDisplayComponent final : public UActorComponent
{
public:
	float                                         HeadUpOffset;                                      // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B1B[0x34];                                    // 0x00A4(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInitializedCharacter(class APalCharacter* OwnerCharacter);
	void OnUpdateOwnerCharacterGroupId(const struct FGuid& GroupID);
	void OnUpdatePossessItem(class UPalCharacterParameterComponent* Parameter);
	void ShowInvaderHUD();
	void UpdateInvaderHUD();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalHeadUpDisplayComponent">();
	}
	static class UPalHeadUpDisplayComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalHeadUpDisplayComponent>();
	}
};
static_assert(alignof(UPalHeadUpDisplayComponent) == 0x000008, "Wrong alignment on UPalHeadUpDisplayComponent");
static_assert(sizeof(UPalHeadUpDisplayComponent) == 0x0000D8, "Wrong size on UPalHeadUpDisplayComponent");
static_assert(offsetof(UPalHeadUpDisplayComponent, HeadUpOffset) == 0x0000A0, "Member 'UPalHeadUpDisplayComponent::HeadUpOffset' has a wrong offset!");

// Class Pal.PalDungeonExit
// 0x0010 (0x02A0 - 0x0290)
class APalDungeonExit final : public AActor
{
public:
	uint8                                         Pad_2B1C[0x8];                                     // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bStartPoint;                                       // 0x0298(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B1D[0x7];                                     // 0x0299(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnResponseDialogExitDungeon(const bool bResponse);
	void OnTriggerInteract(class AActor* Other, EPalInteractiveObjectIndicatorType IndicatorType);

	struct FTransform GetWarpPoint() const;
	bool IsStartPoint() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalDungeonExit">();
	}
	static class APalDungeonExit* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalDungeonExit>();
	}
};
static_assert(alignof(APalDungeonExit) == 0x000008, "Wrong alignment on APalDungeonExit");
static_assert(sizeof(APalDungeonExit) == 0x0002A0, "Wrong size on APalDungeonExit");
static_assert(offsetof(APalDungeonExit, bStartPoint) == 0x000298, "Member 'APalDungeonExit::bStartPoint' has a wrong offset!");

// Class Pal.PalDungeonFixedEntrance
// 0x0080 (0x0320 - 0x02A0)
class APalDungeonFixedEntrance final : public APalDungeonEntrance
{
public:
	uint8                                         Pad_2B1F[0x8];                                     // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  LevelObjectInstanceId;                             // 0x02A8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, NonPIEDuplicateTransient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDataTableRowHandle                    DungeonNameRowHandle;                              // 0x02B8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	class UDataLayerAsset*                        DataLayerAsset;                                    // 0x02C8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, NonPIEDuplicateTransient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   EnemySpawnerSoftClass;                             // 0x02D0(0x0030)(Edit, DisableEditOnTemplate, NonPIEDuplicateTransient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RespawnCoolTimeMinutesAfterBossDefeated;           // 0x0300(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NonPIEDuplicateTransient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B20[0x14];                                    // 0x0304(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class APalNPCSpawnerBase>         EnemySpawnerClass;                                 // 0x0318(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UDataLayerAsset* GetDataLayerAsset() const;
	TSubclassOf<class APalNPCSpawnerBase> GetEnemySpawner() const;
	TSoftClassPtr<class UClass> GetEnemySpawnerSoftClass() const;
	const struct FGuid GetLevelObjectInstanceId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalDungeonFixedEntrance">();
	}
	static class APalDungeonFixedEntrance* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalDungeonFixedEntrance>();
	}
};
static_assert(alignof(APalDungeonFixedEntrance) == 0x000008, "Wrong alignment on APalDungeonFixedEntrance");
static_assert(sizeof(APalDungeonFixedEntrance) == 0x000320, "Wrong size on APalDungeonFixedEntrance");
static_assert(offsetof(APalDungeonFixedEntrance, LevelObjectInstanceId) == 0x0002A8, "Member 'APalDungeonFixedEntrance::LevelObjectInstanceId' has a wrong offset!");
static_assert(offsetof(APalDungeonFixedEntrance, DungeonNameRowHandle) == 0x0002B8, "Member 'APalDungeonFixedEntrance::DungeonNameRowHandle' has a wrong offset!");
static_assert(offsetof(APalDungeonFixedEntrance, DataLayerAsset) == 0x0002C8, "Member 'APalDungeonFixedEntrance::DataLayerAsset' has a wrong offset!");
static_assert(offsetof(APalDungeonFixedEntrance, EnemySpawnerSoftClass) == 0x0002D0, "Member 'APalDungeonFixedEntrance::EnemySpawnerSoftClass' has a wrong offset!");
static_assert(offsetof(APalDungeonFixedEntrance, RespawnCoolTimeMinutesAfterBossDefeated) == 0x000300, "Member 'APalDungeonFixedEntrance::RespawnCoolTimeMinutesAfterBossDefeated' has a wrong offset!");
static_assert(offsetof(APalDungeonFixedEntrance, EnemySpawnerClass) == 0x000318, "Member 'APalDungeonFixedEntrance::EnemySpawnerClass' has a wrong offset!");

// Class Pal.PalReplaceSetting
// 0x0050 (0x0078 - 0x0028)
class UPalReplaceSetting final : public UObject
{
public:
	TMap<class FName, class FName>                CharacterIDReplacer;                               // 0x0028(0x0050)(Edit, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalReplaceSetting">();
	}
	static class UPalReplaceSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalReplaceSetting>();
	}
};
static_assert(alignof(UPalReplaceSetting) == 0x000008, "Wrong alignment on UPalReplaceSetting");
static_assert(sizeof(UPalReplaceSetting) == 0x000078, "Wrong size on UPalReplaceSetting");
static_assert(offsetof(UPalReplaceSetting, CharacterIDReplacer) == 0x000028, "Member 'UPalReplaceSetting::CharacterIDReplacer' has a wrong offset!");

// Class Pal.PalGuildEnterRequestSequence_ConfirmLoseBaseCampToApplicantPlayer
// 0x0000 (0x0068 - 0x0068)
class UPalGuildEnterRequestSequence_ConfirmLoseBaseCampToApplicantPlayer final : public UPalGuildRequestFlowSequenceWaitForConfirmPlayer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGuildEnterRequestSequence_ConfirmLoseBaseCampToApplicantPlayer">();
	}
	static class UPalGuildEnterRequestSequence_ConfirmLoseBaseCampToApplicantPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalGuildEnterRequestSequence_ConfirmLoseBaseCampToApplicantPlayer>();
	}
};
static_assert(alignof(UPalGuildEnterRequestSequence_ConfirmLoseBaseCampToApplicantPlayer) == 0x000008, "Wrong alignment on UPalGuildEnterRequestSequence_ConfirmLoseBaseCampToApplicantPlayer");
static_assert(sizeof(UPalGuildEnterRequestSequence_ConfirmLoseBaseCampToApplicantPlayer) == 0x000068, "Wrong size on UPalGuildEnterRequestSequence_ConfirmLoseBaseCampToApplicantPlayer");

// Class Pal.PalDungeonGimmickUnlockableDoor
// 0x0000 (0x0290 - 0x0290)
class APalDungeonGimmickUnlockableDoor : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalDungeonGimmickUnlockableDoor">();
	}
	static class APalDungeonGimmickUnlockableDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalDungeonGimmickUnlockableDoor>();
	}
};
static_assert(alignof(APalDungeonGimmickUnlockableDoor) == 0x000008, "Wrong alignment on APalDungeonGimmickUnlockableDoor");
static_assert(sizeof(APalDungeonGimmickUnlockableDoor) == 0x000290, "Wrong size on APalDungeonGimmickUnlockableDoor");

// Class Pal.PalDungeonGimmickUnlockableDoor_DefeatBoss
// 0x0008 (0x0298 - 0x0290)
class APalDungeonGimmickUnlockableDoor_DefeatBoss final : public APalDungeonGimmickUnlockableDoor
{
public:
	EPalDungeonInstanceBossState                  BossState;                                         // 0x0290(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B21[0x7];                                     // 0x0291(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChangeBossState_ServerInternal(class UPalDungeonInstanceModel* InstanceModel);
	void OnChangeBossStateImpl(const EPalDungeonInstanceBossState ToState);
	void OnRep_BossState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalDungeonGimmickUnlockableDoor_DefeatBoss">();
	}
	static class APalDungeonGimmickUnlockableDoor_DefeatBoss* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalDungeonGimmickUnlockableDoor_DefeatBoss>();
	}
};
static_assert(alignof(APalDungeonGimmickUnlockableDoor_DefeatBoss) == 0x000008, "Wrong alignment on APalDungeonGimmickUnlockableDoor_DefeatBoss");
static_assert(sizeof(APalDungeonGimmickUnlockableDoor_DefeatBoss) == 0x000298, "Wrong size on APalDungeonGimmickUnlockableDoor_DefeatBoss");
static_assert(offsetof(APalDungeonGimmickUnlockableDoor_DefeatBoss, BossState) == 0x000290, "Member 'APalDungeonGimmickUnlockableDoor_DefeatBoss::BossState' has a wrong offset!");

// Class Pal.PalGuildChangeAdminRequestSequence_Trigger
// 0x0000 (0x0040 - 0x0040)
class UPalGuildChangeAdminRequestSequence_Trigger final : public USequentialProcessSequenceBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGuildChangeAdminRequestSequence_Trigger">();
	}
	static class UPalGuildChangeAdminRequestSequence_Trigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalGuildChangeAdminRequestSequence_Trigger>();
	}
};
static_assert(alignof(UPalGuildChangeAdminRequestSequence_Trigger) == 0x000008, "Wrong alignment on UPalGuildChangeAdminRequestSequence_Trigger");
static_assert(sizeof(UPalGuildChangeAdminRequestSequence_Trigger) == 0x000040, "Wrong size on UPalGuildChangeAdminRequestSequence_Trigger");

// Class Pal.PalMasterDataTableAccess_ItemShopLottery
// 0x0000 (0x0030 - 0x0030)
class UPalMasterDataTableAccess_ItemShopLottery final : public UPalMasterDataTableAccessBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMasterDataTableAccess_ItemShopLottery">();
	}
	static class UPalMasterDataTableAccess_ItemShopLottery* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMasterDataTableAccess_ItemShopLottery>();
	}
};
static_assert(alignof(UPalMasterDataTableAccess_ItemShopLottery) == 0x000008, "Wrong alignment on UPalMasterDataTableAccess_ItemShopLottery");
static_assert(sizeof(UPalMasterDataTableAccess_ItemShopLottery) == 0x000030, "Wrong size on UPalMasterDataTableAccess_ItemShopLottery");

// Class Pal.PalDynamicArmorItemDataBase
// 0x0040 (0x00A8 - 0x0068)
class UPalDynamicArmorItemDataBase final : public UPalDynamicItemDataBase
{
public:
	uint8                                         Pad_2B22[0x8];                                     // 0x0068(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Durability;                                        // 0x0070(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxDurability;                                     // 0x0074(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OldDurability;                                     // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B23[0x4];                                     // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           PassiveSkillList;                                  // 0x0080(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B24[0x18];                                    // 0x0090(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AddPassiveSkill(class FName SkillName);
	bool ChangePassiveSkill(int32 PassiveIndex, class FName SkillName);
	void DeleteAllPassive();
	void OnRep_Durability();
	void SetDurability(float NewDurability);

	float GetDurability() const;
	float GetMaxDurability() const;
	const TArray<class FName> GetPassiveSkillList() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalDynamicArmorItemDataBase">();
	}
	static class UPalDynamicArmorItemDataBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalDynamicArmorItemDataBase>();
	}
};
static_assert(alignof(UPalDynamicArmorItemDataBase) == 0x000008, "Wrong alignment on UPalDynamicArmorItemDataBase");
static_assert(sizeof(UPalDynamicArmorItemDataBase) == 0x0000A8, "Wrong size on UPalDynamicArmorItemDataBase");
static_assert(offsetof(UPalDynamicArmorItemDataBase, Durability) == 0x000070, "Member 'UPalDynamicArmorItemDataBase::Durability' has a wrong offset!");
static_assert(offsetof(UPalDynamicArmorItemDataBase, MaxDurability) == 0x000074, "Member 'UPalDynamicArmorItemDataBase::MaxDurability' has a wrong offset!");
static_assert(offsetof(UPalDynamicArmorItemDataBase, OldDurability) == 0x000078, "Member 'UPalDynamicArmorItemDataBase::OldDurability' has a wrong offset!");
static_assert(offsetof(UPalDynamicArmorItemDataBase, PassiveSkillList) == 0x000080, "Member 'UPalDynamicArmorItemDataBase::PassiveSkillList' has a wrong offset!");

// Class Pal.PalDynamicItemWorldSubsystem
// 0x00D0 (0x0140 - 0x0070)
class UPalDynamicItemWorldSubsystem final : public UPalWorldSubsystem
{
public:
	uint8                                         Pad_2B27[0x20];                                    // 0x0070(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FPalDynamicItemId, class UPalDynamicItemDataBase*> DynamicItemDataMap_InServer;                       // 0x0090(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	TMap<struct FPalDynamicItemId, struct FPalDynamicItemInfo> WeakDynamicItemDataMap_InClient;                   // 0x00E0(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	TArray<class UPalDynamicItemDataBase*>        DynamicItemDataCache_InClient;                     // 0x0130(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalDynamicItemWorldSubsystem">();
	}
	static class UPalDynamicItemWorldSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalDynamicItemWorldSubsystem>();
	}
};
static_assert(alignof(UPalDynamicItemWorldSubsystem) == 0x000008, "Wrong alignment on UPalDynamicItemWorldSubsystem");
static_assert(sizeof(UPalDynamicItemWorldSubsystem) == 0x000140, "Wrong size on UPalDynamicItemWorldSubsystem");
static_assert(offsetof(UPalDynamicItemWorldSubsystem, DynamicItemDataMap_InServer) == 0x000090, "Member 'UPalDynamicItemWorldSubsystem::DynamicItemDataMap_InServer' has a wrong offset!");
static_assert(offsetof(UPalDynamicItemWorldSubsystem, WeakDynamicItemDataMap_InClient) == 0x0000E0, "Member 'UPalDynamicItemWorldSubsystem::WeakDynamicItemDataMap_InClient' has a wrong offset!");
static_assert(offsetof(UPalDynamicItemWorldSubsystem, DynamicItemDataCache_InClient) == 0x000130, "Member 'UPalDynamicItemWorldSubsystem::DynamicItemDataCache_InClient' has a wrong offset!");

// Class Pal.PalMonsterControllerBaseCampLogTypeUtility
// 0x0000 (0x0028 - 0x0028)
class UPalMonsterControllerBaseCampLogTypeUtility final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMonsterControllerBaseCampLogTypeUtility">();
	}
	static class UPalMonsterControllerBaseCampLogTypeUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMonsterControllerBaseCampLogTypeUtility>();
	}
};
static_assert(alignof(UPalMonsterControllerBaseCampLogTypeUtility) == 0x000008, "Wrong alignment on UPalMonsterControllerBaseCampLogTypeUtility");
static_assert(sizeof(UPalMonsterControllerBaseCampLogTypeUtility) == 0x000028, "Wrong size on UPalMonsterControllerBaseCampLogTypeUtility");

// Class Pal.PalDynamicPalEggItemDataBase
// 0x0288 (0x02F0 - 0x0068)
class UPalDynamicPalEggItemDataBase final : public UPalDynamicItemDataBase
{
public:
	class FName                                   CharacterID;                                       // 0x0068(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPalIndividualCharacterSaveParameter   SaveParameter;                                     // 0x0070(0x0280)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalDynamicPalEggItemDataBase">();
	}
	static class UPalDynamicPalEggItemDataBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalDynamicPalEggItemDataBase>();
	}
};
static_assert(alignof(UPalDynamicPalEggItemDataBase) == 0x000008, "Wrong alignment on UPalDynamicPalEggItemDataBase");
static_assert(sizeof(UPalDynamicPalEggItemDataBase) == 0x0002F0, "Wrong size on UPalDynamicPalEggItemDataBase");
static_assert(offsetof(UPalDynamicPalEggItemDataBase, CharacterID) == 0x000068, "Member 'UPalDynamicPalEggItemDataBase::CharacterID' has a wrong offset!");
static_assert(offsetof(UPalDynamicPalEggItemDataBase, SaveParameter) == 0x000070, "Member 'UPalDynamicPalEggItemDataBase::SaveParameter' has a wrong offset!");

// Class Pal.PalEditorMapObjectCheckPlacer
// 0x0048 (0x02D8 - 0x0290)
class APalEditorMapObjectCheckPlacer final : public AActor
{
public:
	class UArrowComponent*                        LeftEdgeArrow;                                     // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UArrowComponent*                        RightEdgeArrow;                                    // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UArrowComponent*                        StackRowArrow;                                     // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              PlacementMargin;                                   // 0x02A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FPalDataTableRowName_MapObjectData> IgnoreRowNames;                                    // 0x02B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B28[0x10];                                    // 0x02C8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlaceMapObjects();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalEditorMapObjectCheckPlacer">();
	}
	static class APalEditorMapObjectCheckPlacer* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalEditorMapObjectCheckPlacer>();
	}
};
static_assert(alignof(APalEditorMapObjectCheckPlacer) == 0x000008, "Wrong alignment on APalEditorMapObjectCheckPlacer");
static_assert(sizeof(APalEditorMapObjectCheckPlacer) == 0x0002D8, "Wrong size on APalEditorMapObjectCheckPlacer");
static_assert(offsetof(APalEditorMapObjectCheckPlacer, LeftEdgeArrow) == 0x000290, "Member 'APalEditorMapObjectCheckPlacer::LeftEdgeArrow' has a wrong offset!");
static_assert(offsetof(APalEditorMapObjectCheckPlacer, RightEdgeArrow) == 0x000298, "Member 'APalEditorMapObjectCheckPlacer::RightEdgeArrow' has a wrong offset!");
static_assert(offsetof(APalEditorMapObjectCheckPlacer, StackRowArrow) == 0x0002A0, "Member 'APalEditorMapObjectCheckPlacer::StackRowArrow' has a wrong offset!");
static_assert(offsetof(APalEditorMapObjectCheckPlacer, PlacementMargin) == 0x0002A8, "Member 'APalEditorMapObjectCheckPlacer::PlacementMargin' has a wrong offset!");
static_assert(offsetof(APalEditorMapObjectCheckPlacer, IgnoreRowNames) == 0x0002B8, "Member 'APalEditorMapObjectCheckPlacer::IgnoreRowNames' has a wrong offset!");

// Class Pal.PalWeaponBase
// 0x02A8 (0x0538 - 0x0290)
class APalWeaponBase : public AActor
{
public:
	uint8                                         Pad_2B29[0x8];                                     // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnReloadDelegate;                                  // 0x0298(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUseBulletDelegate;                               // 0x02A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnShootBulletDelegate;                             // 0x02B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeCoolDownStateDelegate;                     // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCoolDownUpdateDelegate;                          // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCreatedBulletDelegate;                           // 0x02E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnGetWeaponDamageDelegate;                         // 0x02F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAttachWeaponDelegate;                            // 0x0308(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDetachWeaponDelegate;                            // 0x0318(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnWeaponNotifyDelegate;                            // 0x0328(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         BulletDeleteTime;                                  // 0x0338(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BulletDecayStartRate;                              // 0x033C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            RecoilCurve;                                       // 0x0340(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilYawRange;                                    // 0x0348(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilPitchTotalMax;                               // 0x034C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilDecaySpeed;                                  // 0x0350(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B2A[0x4];                                     // 0x0354(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UCameraShakeBase>           ShotCameraShake;                                   // 0x0358(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponCoopType                               WeaponCoopType;                                    // 0x0360(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPalWeaponType                                WeaponType;                                        // 0x0361(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRequiredBullet;                                  // 0x0362(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B2B[0x1];                                     // 0x0363(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BulletItemName;                                    // 0x0364(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B2C[0x4];                                     // 0x036C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     ShootBlurMaterial;                                 // 0x0370(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ShootBlurAlphaCurve;                               // 0x0378(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPalSpecialAttackRateInfo>      SpecialAttackRateInfos;                            // 0x0380(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              WeaponIconTexture;                                 // 0x0390(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPalDamageAnimationReactionType               WeaponBulletDamageReactionType;                    // 0x03C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B2D[0x7];                                     // 0x03C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   PalSoundSlotClass;                                 // 0x03C8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EWeaponPlaySoundType, struct FPalDataTableRowName_SoundID> PlaySoundIds;                                      // 0x03F8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          IsEmptyOtomoPal;                                   // 0x0448(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B2E[0x3];                                     // 0x0449(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CoolDownTime;                                      // 0x044C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               ShootBlurMaterialDynamic;                          // 0x0450(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B2F[0x14];                                    // 0x0458(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPalItemId                             OwnItemID;                                         // 0x046C(0x0028)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B30[0x4];                                     // 0x0494(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPalItemData                           OwnItemData;                                       // 0x0498(0x0010)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	class UPalStaticWeaponItemData*               OwnWeaponStaticData;                               // 0x04A8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalDynamicWeaponItemDataBase*          OwnWeaponDynamicData;                              // 0x04B0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFlagContainer                         HiddenWeapon;                                      // 0x04B8(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	class UPalSoundSlot*                          PalSoundSlotCache;                                 // 0x0508(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RecoilPowerRate;                                   // 0x0510(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsScopeMode;                                       // 0x0514(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsOneBulletReloadWeapon;                           // 0x0515(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B31[0x2];                                     // 0x0516(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayDestorySecond;                                // 0x0518(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsUnnecessaryDynamicData;                          // 0x051C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPalShooterFlagContainerPriority              ShooterFlagPriority;                               // 0x051D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B32[0x2];                                     // 0x051E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class APalBackWeaponBase>         BackWeaponClass;                                   // 0x0520(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APalBackWeaponBase*                     BackWeaponModel;                                   // 0x0528(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         LoadoutSelectorIndex;                              // 0x0530(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B33[0x4];                                     // 0x0534(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float CalcAccuracy();
	float CalcDPS();
	float CalcRange();
	float CalcStability();
	void ClearWeaponSkill();
	void CreatedBulletDelegate__DelegateSignature(class APalBullet* Bullet);
	bool DecrementBullet();
	int32 DecrementCurrentSelectPalSphere(int32 RequestConsumeNum, class FName* UsedItemID);
	float GetBlurModifierValue();
	class FName GetEquipSocketName();
	class USceneComponent* GetMainMesh();
	class APalCharacter* GetOwnerCharacter();
	float GetRandomFloat(float Min, float Max);
	void GetRequiredBulletName(class FName* OutName);
	float GetShooterComponentBlurRate();
	TArray<struct FPalPassiveSkillEffect> GetSkillEffectList();
	float GetSneakAttackRate();
	class AActor* GetWeaponAttacker();
	int32 GetWeaponDamageDelegate__DelegateSignature();
	bool IsExistBulletInPlayerInventory();
	bool IsHiddenWeapon();
	void OnAttachWeapon(class AActor* AttachActor);
	void OnAttachWeaponDelegate__DelegateSignature();
	void OnChangeCoolDownStateDelegate__DelegateSignature(bool IsStart);
	void OnChangeTargetDirection(const struct FVector& Direction);
	void OnCoolDownUpdateDelegate__DelegateSignature(float RemainingTime, float Param_CoolDownTime);
	void OnCreatedBullet(class APalBullet* Bullet);
	void OnDetachWeapon(class AActor* DetachActor);
	void OnDetachWeaponDelegate__DelegateSignature();
	void OnEndAim();
	void OnPullCancel();
	void OnPullTrigger();
	void OnReleaseTrigger();
	void OnReloadStart();
	void OnRequestClosing();
	void OnShootBulletDelegate__DelegateSignature();
	void OnStartAim();
	void OnWeaponNotify(EWeaponNotifyType Type);
	void PlaySound(const struct FPalDataTableRowName_SoundID& ID);
	void PlaySoundWithOption(const struct FPalDataTableRowName_SoundID& ID, const struct FPalSoundOptions& Arg);
	bool ReloadBullets();
	void ReloadBulletsDelegate__DelegateSignature(int32 bulletsNum);
	void RequestConsumeItem(const class FName& StaticItemId, int32 ConsumeNum);
	void RequestConsumeItem_ForThrowWeapon(const class FName& StaticItemId, int32 ConsumeNum);
	void RPCDummy();
	void SendWeaponNotify(EWeaponNotifyType Type);
	void SetHiddenWeapon(class FName FlagName, bool IsHidden);
	void SetHiddenWeaponDefault(bool IsHidden);
	void SetHiddenWeaponMyself(bool IsHidden);
	void SetupWeaponSkill();
	void StartCoolDown();
	void UnbindGetWeaponDamageDelegate();
	void UseBulletDelegate__DelegateSignature(int32 RemainingBulletsNum);
	void WeaponNotifyDelegate__DelegateSignature(EWeaponNotifyType NotifyType);

	float GetDefaultBlurAngle() const;
	const struct FPalItemId GetItemId() const;
	struct FTransform GetLeftHandTransform() const;
	int32 GetMagazineSize() const;
	int32 GetNPCWeaponDamage() const;
	float GetParameterWithPassiveSkillEffect(float OriginalValue, EPalPassiveSkillEffectType EffectType) const;
	int32 GetRemainBulletCount() const;
	float GetRemainingCoolDownTime() const;
	int32 GetWeaponBaseDamage() const;
	int32 GetWeaponDamage() const;
	int32 GetWeaponDamageFromDelegate() const;
	EPalAdditionalEffectType GetWeaponEffectType() const;
	int32 GetWeaponEffectValue() const;
	bool IsCoolDown() const;
	bool IsEmptyMagazine() const;
	bool IsEnableAutoAim() const;
	bool IsFullMagazine() const;
	bool IsUseLeftHandAttach() const;
	bool SeekLeftHandOpen() const;
	bool SeekRightHandOpen() const;
	class UPalDynamicWeaponItemDataBase* TryGetDynamicWeaponData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWeaponBase">();
	}
	static class APalWeaponBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalWeaponBase>();
	}
};
static_assert(alignof(APalWeaponBase) == 0x000008, "Wrong alignment on APalWeaponBase");
static_assert(sizeof(APalWeaponBase) == 0x000538, "Wrong size on APalWeaponBase");
static_assert(offsetof(APalWeaponBase, OnReloadDelegate) == 0x000298, "Member 'APalWeaponBase::OnReloadDelegate' has a wrong offset!");
static_assert(offsetof(APalWeaponBase, OnUseBulletDelegate) == 0x0002A8, "Member 'APalWeaponBase::OnUseBulletDelegate' has a wrong offset!");
static_assert(offsetof(APalWeaponBase, OnShootBulletDelegate) == 0x0002B8, "Member 'APalWeaponBase::OnShootBulletDelegate' has a wrong offset!");
static_assert(offsetof(APalWeaponBase, OnChangeCoolDownStateDelegate) == 0x0002C8, "Member 'APalWeaponBase::OnChangeCoolDownStateDelegate' has a wrong offset!");
static_assert(offsetof(APalWeaponBase, OnCoolDownUpdateDelegate) == 0x0002D8, "Member 'APalWeaponBase::OnCoolDownUpdateDelegate' has a wrong offset!");
static_assert(offsetof(APalWeaponBase, OnCreatedBulletDelegate) == 0x0002E8, "Member 'APalWeaponBase::OnCreatedBulletDelegate' has a wrong offset!");
static_assert(offsetof(APalWeaponBase, OnGetWeaponDamageDelegate) == 0x0002F8, "Member 'APalWeaponBase::OnGetWeaponDamageDelegate' has a wrong offset!");
static_assert(offsetof(APalWeaponBase, OnAttachWeaponDelegate) == 0x000308, "Member 'APalWeaponBase::OnAttachWeaponDelegate' has a wrong offset!");
static_assert(offsetof(APalWeaponBase, OnDetachWeaponDelegate) == 0x000318, "Member 'APalWeaponBase::OnDetachWeaponDelegate' has a wrong offset!");
static_assert(offsetof(APalWeaponBase, OnWeaponNotifyDelegate) == 0x000328, "Member 'APalWeaponBase::OnWeaponNotifyDelegate' has a wrong offset!");
static_assert(offsetof(APalWeaponBase, BulletDeleteTime) == 0x000338, "Member 'APalWeaponBase::BulletDeleteTime' has a wrong offset!");
static_assert(offsetof(APalWeaponBase, BulletDecayStartRate) == 0x00033C, "Member 'APalWeaponBase::BulletDecayStartRate' has a wrong offset!");
static_assert(offsetof(APalWeaponBase, RecoilCurve) == 0x000340, "Member 'APalWeaponBase::RecoilCurve' has a wrong offset!");
static_assert(offsetof(APalWeaponBase, RecoilYawRange) == 0x000348, "Member 'APalWeaponBase::RecoilYawRange' has a wrong offset!");
static_assert(offsetof(APalWeaponBase, RecoilPitchTotalMax) == 0x00034C, "Member 'APalWeaponBase::RecoilPitchTotalMax' has a wrong offset!");
static_assert(offsetof(APalWeaponBase, RecoilDecaySpeed) == 0x000350, "Member 'APalWeaponBase::RecoilDecaySpeed' has a wrong offset!");
static_assert(offsetof(APalWeaponBase, ShotCameraShake) == 0x000358, "Member 'APalWeaponBase::ShotCameraShake' has a wrong offset!");
static_assert(offsetof(APalWeaponBase, WeaponCoopType) == 0x000360, "Member 'APalWeaponBase::WeaponCoopType' has a wrong offset!");
static_assert(offsetof(APalWeaponBase, WeaponType) == 0x000361, "Member 'APalWeaponBase::WeaponType' has a wrong offset!");
static_assert(offsetof(APalWeaponBase, IsRequiredBullet) == 0x000362, "Member 'APalWeaponBase::IsRequiredBullet' has a wrong offset!");
static_assert(offsetof(APalWeaponBase, BulletItemName) == 0x000364, "Member 'APalWeaponBase::BulletItemName' has a wrong offset!");
static_assert(offsetof(APalWeaponBase, ShootBlurMaterial) == 0x000370, "Member 'APalWeaponBase::ShootBlurMaterial' has a wrong offset!");
static_assert(offsetof(APalWeaponBase, ShootBlurAlphaCurve) == 0x000378, "Member 'APalWeaponBase::ShootBlurAlphaCurve' has a wrong offset!");
static_assert(offsetof(APalWeaponBase, SpecialAttackRateInfos) == 0x000380, "Member 'APalWeaponBase::SpecialAttackRateInfos' has a wrong offset!");
static_assert(offsetof(APalWeaponBase, WeaponIconTexture) == 0x000390, "Member 'APalWeaponBase::WeaponIconTexture' has a wrong offset!");
static_assert(offsetof(APalWeaponBase, WeaponBulletDamageReactionType) == 0x0003C0, "Member 'APalWeaponBase::WeaponBulletDamageReactionType' has a wrong offset!");
static_assert(offsetof(APalWeaponBase, PalSoundSlotClass) == 0x0003C8, "Member 'APalWeaponBase::PalSoundSlotClass' has a wrong offset!");
static_assert(offsetof(APalWeaponBase, PlaySoundIds) == 0x0003F8, "Member 'APalWeaponBase::PlaySoundIds' has a wrong offset!");
static_assert(offsetof(APalWeaponBase, IsEmptyOtomoPal) == 0x000448, "Member 'APalWeaponBase::IsEmptyOtomoPal' has a wrong offset!");
static_assert(offsetof(APalWeaponBase, CoolDownTime) == 0x00044C, "Member 'APalWeaponBase::CoolDownTime' has a wrong offset!");
static_assert(offsetof(APalWeaponBase, ShootBlurMaterialDynamic) == 0x000450, "Member 'APalWeaponBase::ShootBlurMaterialDynamic' has a wrong offset!");
static_assert(offsetof(APalWeaponBase, OwnItemID) == 0x00046C, "Member 'APalWeaponBase::OwnItemID' has a wrong offset!");
static_assert(offsetof(APalWeaponBase, OwnItemData) == 0x000498, "Member 'APalWeaponBase::OwnItemData' has a wrong offset!");
static_assert(offsetof(APalWeaponBase, OwnWeaponStaticData) == 0x0004A8, "Member 'APalWeaponBase::OwnWeaponStaticData' has a wrong offset!");
static_assert(offsetof(APalWeaponBase, OwnWeaponDynamicData) == 0x0004B0, "Member 'APalWeaponBase::OwnWeaponDynamicData' has a wrong offset!");
static_assert(offsetof(APalWeaponBase, HiddenWeapon) == 0x0004B8, "Member 'APalWeaponBase::HiddenWeapon' has a wrong offset!");
static_assert(offsetof(APalWeaponBase, PalSoundSlotCache) == 0x000508, "Member 'APalWeaponBase::PalSoundSlotCache' has a wrong offset!");
static_assert(offsetof(APalWeaponBase, RecoilPowerRate) == 0x000510, "Member 'APalWeaponBase::RecoilPowerRate' has a wrong offset!");
static_assert(offsetof(APalWeaponBase, IsScopeMode) == 0x000514, "Member 'APalWeaponBase::IsScopeMode' has a wrong offset!");
static_assert(offsetof(APalWeaponBase, IsOneBulletReloadWeapon) == 0x000515, "Member 'APalWeaponBase::IsOneBulletReloadWeapon' has a wrong offset!");
static_assert(offsetof(APalWeaponBase, DelayDestorySecond) == 0x000518, "Member 'APalWeaponBase::DelayDestorySecond' has a wrong offset!");
static_assert(offsetof(APalWeaponBase, IsUnnecessaryDynamicData) == 0x00051C, "Member 'APalWeaponBase::IsUnnecessaryDynamicData' has a wrong offset!");
static_assert(offsetof(APalWeaponBase, ShooterFlagPriority) == 0x00051D, "Member 'APalWeaponBase::ShooterFlagPriority' has a wrong offset!");
static_assert(offsetof(APalWeaponBase, BackWeaponClass) == 0x000520, "Member 'APalWeaponBase::BackWeaponClass' has a wrong offset!");
static_assert(offsetof(APalWeaponBase, BackWeaponModel) == 0x000528, "Member 'APalWeaponBase::BackWeaponModel' has a wrong offset!");
static_assert(offsetof(APalWeaponBase, LoadoutSelectorIndex) == 0x000530, "Member 'APalWeaponBase::LoadoutSelectorIndex' has a wrong offset!");

// Class Pal.PalEnemySpawner
// 0x0008 (0x0298 - 0x0290)
class APalEnemySpawner final : public AActor
{
public:
	EPalEnemySpawnActorType                       EnemyActorType;                                    // 0x0290(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPalEnemySpawnDefaultAction                   DefaultAction;                                     // 0x0291(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B36[0x6];                                     // 0x0292(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalEnemySpawner">();
	}
	static class APalEnemySpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalEnemySpawner>();
	}
};
static_assert(alignof(APalEnemySpawner) == 0x000008, "Wrong alignment on APalEnemySpawner");
static_assert(sizeof(APalEnemySpawner) == 0x000298, "Wrong size on APalEnemySpawner");
static_assert(offsetof(APalEnemySpawner, EnemyActorType) == 0x000290, "Member 'APalEnemySpawner::EnemyActorType' has a wrong offset!");
static_assert(offsetof(APalEnemySpawner, DefaultAction) == 0x000291, "Member 'APalEnemySpawner::DefaultAction' has a wrong offset!");

// Class Pal.PalEquipWeaponShooterComponent
// 0x0050 (0x00F0 - 0x00A0)
class UPalEquipWeaponShooterComponent final : public UActorComponent
{
public:
	TMap<EPalMonsterEquipWeaponSocketType, struct FPalEquipWeaponInfo> SpawnedWeaponInfoMap;                              // 0x00A0(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	void PullTrigger();
	void SetWeapon_ForDebug(EPalMonsterEquipWeaponSocketType SocketType, class FName ItemName);
	void SetWeapon_ForDebug_DirectBP(EPalMonsterEquipWeaponSocketType SocketType, TSubclassOf<class APalMonsterEquipWeaponBase> WeaponActorClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalEquipWeaponShooterComponent">();
	}
	static class UPalEquipWeaponShooterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalEquipWeaponShooterComponent>();
	}
};
static_assert(alignof(UPalEquipWeaponShooterComponent) == 0x000008, "Wrong alignment on UPalEquipWeaponShooterComponent");
static_assert(sizeof(UPalEquipWeaponShooterComponent) == 0x0000F0, "Wrong size on UPalEquipWeaponShooterComponent");
static_assert(offsetof(UPalEquipWeaponShooterComponent, SpawnedWeaponInfoMap) == 0x0000A0, "Member 'UPalEquipWeaponShooterComponent::SpawnedWeaponInfoMap' has a wrong offset!");

// Class Pal.PalMapObjectSignboardModel
// 0x0030 (0x0248 - 0x0218)
class UPalMapObjectSignboardModel final : public UPalMapObjectConcreteModelBase
{
public:
	FMulticastInlineDelegateProperty_             OnUpdateSignboardTextDelegate;                     // 0x0218(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalUserWidgetOverlayUI>    MenuUIWidgetClass;                                 // 0x0228(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 SignboardText;                                     // 0x0230(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsEditing;                                        // 0x0240(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B39[0x7];                                     // 0x0241(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FString GetSignboardText();
	void OnOpenEdit();
	void OnReceivedWordFilteringResult(const class FString& ResponseBody, bool bResponseOK, int32 ResponseCode);
	void OnRep_Text();
	void OnUpdateText(const class FString& Text);
	void RequestEditText(const int32 RequestPlayerId, const bool IsEditing);
	void RequestUpdateText(const int32 RequestPlayerId, const struct FPalNetArchive& Archive);
	void UpdateSignboardTextDelegate__DelegateSignature(const class FString& TextValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectSignboardModel">();
	}
	static class UPalMapObjectSignboardModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectSignboardModel>();
	}
};
static_assert(alignof(UPalMapObjectSignboardModel) == 0x000008, "Wrong alignment on UPalMapObjectSignboardModel");
static_assert(sizeof(UPalMapObjectSignboardModel) == 0x000248, "Wrong size on UPalMapObjectSignboardModel");
static_assert(offsetof(UPalMapObjectSignboardModel, OnUpdateSignboardTextDelegate) == 0x000218, "Member 'UPalMapObjectSignboardModel::OnUpdateSignboardTextDelegate' has a wrong offset!");
static_assert(offsetof(UPalMapObjectSignboardModel, MenuUIWidgetClass) == 0x000228, "Member 'UPalMapObjectSignboardModel::MenuUIWidgetClass' has a wrong offset!");
static_assert(offsetof(UPalMapObjectSignboardModel, SignboardText) == 0x000230, "Member 'UPalMapObjectSignboardModel::SignboardText' has a wrong offset!");
static_assert(offsetof(UPalMapObjectSignboardModel, bIsEditing) == 0x000240, "Member 'UPalMapObjectSignboardModel::bIsEditing' has a wrong offset!");

// Class Pal.PalEventNotify_ItemContainer
// 0x0010 (0x0038 - 0x0028)
class UPalEventNotify_ItemContainer final : public UPalEventNotifyBase
{
public:
	FMulticastInlineDelegateProperty_             OnNotifyEventMoveInServer;                         // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UPalEventNotify_ItemContainer* GetEventNotify_Item(const class UObject* WorldContextObject);

	void OnItemOperationMove_ServerInternal(const TArray<struct FPalItemOperationInfo_Move>& OperationInfoSet);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalEventNotify_ItemContainer">();
	}
	static class UPalEventNotify_ItemContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalEventNotify_ItemContainer>();
	}
};
static_assert(alignof(UPalEventNotify_ItemContainer) == 0x000008, "Wrong alignment on UPalEventNotify_ItemContainer");
static_assert(sizeof(UPalEventNotify_ItemContainer) == 0x000038, "Wrong size on UPalEventNotify_ItemContainer");
static_assert(offsetof(UPalEventNotify_ItemContainer, OnNotifyEventMoveInServer) == 0x000028, "Member 'UPalEventNotify_ItemContainer::OnNotifyEventMoveInServer' has a wrong offset!");

// Class Pal.PalExponentialHeightFogVolume
// 0x0010 (0x02A0 - 0x0290)
class APalExponentialHeightFogVolume final : public AActor
{
public:
	class UExponentialHeightFogComponent*         Component;                                         // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bEnabled : 1;                                      // 0x0298(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2B3D[0x3];                                     // 0x0299(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnableSwitchVisibility;                           // 0x029C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisableEnabledFlag;                               // 0x029D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B3E[0x2];                                     // 0x029E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_bEnabled();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalExponentialHeightFogVolume">();
	}
	static class APalExponentialHeightFogVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalExponentialHeightFogVolume>();
	}
};
static_assert(alignof(APalExponentialHeightFogVolume) == 0x000008, "Wrong alignment on APalExponentialHeightFogVolume");
static_assert(sizeof(APalExponentialHeightFogVolume) == 0x0002A0, "Wrong size on APalExponentialHeightFogVolume");
static_assert(offsetof(APalExponentialHeightFogVolume, Component) == 0x000290, "Member 'APalExponentialHeightFogVolume::Component' has a wrong offset!");
static_assert(offsetof(APalExponentialHeightFogVolume, bEnableSwitchVisibility) == 0x00029C, "Member 'APalExponentialHeightFogVolume::bEnableSwitchVisibility' has a wrong offset!");
static_assert(offsetof(APalExponentialHeightFogVolume, bDisableEnabledFlag) == 0x00029D, "Member 'APalExponentialHeightFogVolume::bDisableEnabledFlag' has a wrong offset!");

// Class Pal.PalMapObjectSpawnerPalEgg
// 0x0018 (0x02E8 - 0x02D0)
class APalMapObjectSpawnerPalEgg final : public APalMapObjectSpawnerSingleBase
{
public:
	TArray<struct FPalMapObjectPickupItemPalEggLotteryData> SpawnPalEggLotteryDataArray;                       // 0x02D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         RespawnTimeMinutesObtained;                        // 0x02E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRespawnableMulti;                                 // 0x02E4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B3F[0x3];                                     // 0x02E5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFinishedSpawningMapObjectModel(const struct FGuid& InstanceId, const EPalMapObjectOperationResult Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectSpawnerPalEgg">();
	}
	static class APalMapObjectSpawnerPalEgg* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalMapObjectSpawnerPalEgg>();
	}
};
static_assert(alignof(APalMapObjectSpawnerPalEgg) == 0x000008, "Wrong alignment on APalMapObjectSpawnerPalEgg");
static_assert(sizeof(APalMapObjectSpawnerPalEgg) == 0x0002E8, "Wrong size on APalMapObjectSpawnerPalEgg");
static_assert(offsetof(APalMapObjectSpawnerPalEgg, SpawnPalEggLotteryDataArray) == 0x0002D0, "Member 'APalMapObjectSpawnerPalEgg::SpawnPalEggLotteryDataArray' has a wrong offset!");
static_assert(offsetof(APalMapObjectSpawnerPalEgg, RespawnTimeMinutesObtained) == 0x0002E0, "Member 'APalMapObjectSpawnerPalEgg::RespawnTimeMinutesObtained' has a wrong offset!");
static_assert(offsetof(APalMapObjectSpawnerPalEgg, bRespawnableMulti) == 0x0002E4, "Member 'APalMapObjectSpawnerPalEgg::bRespawnableMulti' has a wrong offset!");

// Class Pal.PalFacial_MainModule
// 0x0288 (0x02B0 - 0x0028)
class UPalFacial_MainModule final : public UObject
{
public:
	uint8                                         Pad_2B41[0x40];                                    // 0x0028(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EyeMaterialIndex;                                  // 0x0068(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MouthMaterialIndex;                                // 0x006C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         BrowMaterialIndex;                                 // 0x0070(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B42[0x54];                                    // 0x0074(0x0054)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EPalFacialEyeType, struct FPalMorphSetting> MorphSetting_Eye;                                  // 0x00C8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<EPalFacialMouthType, struct FPalMorphSetting> MorphSetting_Mouth;                                // 0x0118(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B43[0x8];                                     // 0x0168(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EPalFacialEyeType, float>                BlendShape_TypeEyeWeight;                          // 0x0170(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<EPalFacialMouthType, float>              BlendShape_TypeMouthWeight;                        // 0x01C0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class FName, float>                      BlendShape_EyeWeight;                              // 0x0210(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class FName, float>                      BlendShape_MouthWeight;                            // 0x0260(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	void Setup_FacialModule(class USkeletalMeshComponent* SkeletalMeshComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalFacial_MainModule">();
	}
	static class UPalFacial_MainModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalFacial_MainModule>();
	}
};
static_assert(alignof(UPalFacial_MainModule) == 0x000008, "Wrong alignment on UPalFacial_MainModule");
static_assert(sizeof(UPalFacial_MainModule) == 0x0002B0, "Wrong size on UPalFacial_MainModule");
static_assert(offsetof(UPalFacial_MainModule, EyeMaterialIndex) == 0x000068, "Member 'UPalFacial_MainModule::EyeMaterialIndex' has a wrong offset!");
static_assert(offsetof(UPalFacial_MainModule, MouthMaterialIndex) == 0x00006C, "Member 'UPalFacial_MainModule::MouthMaterialIndex' has a wrong offset!");
static_assert(offsetof(UPalFacial_MainModule, BrowMaterialIndex) == 0x000070, "Member 'UPalFacial_MainModule::BrowMaterialIndex' has a wrong offset!");
static_assert(offsetof(UPalFacial_MainModule, MorphSetting_Eye) == 0x0000C8, "Member 'UPalFacial_MainModule::MorphSetting_Eye' has a wrong offset!");
static_assert(offsetof(UPalFacial_MainModule, MorphSetting_Mouth) == 0x000118, "Member 'UPalFacial_MainModule::MorphSetting_Mouth' has a wrong offset!");
static_assert(offsetof(UPalFacial_MainModule, BlendShape_TypeEyeWeight) == 0x000170, "Member 'UPalFacial_MainModule::BlendShape_TypeEyeWeight' has a wrong offset!");
static_assert(offsetof(UPalFacial_MainModule, BlendShape_TypeMouthWeight) == 0x0001C0, "Member 'UPalFacial_MainModule::BlendShape_TypeMouthWeight' has a wrong offset!");
static_assert(offsetof(UPalFacial_MainModule, BlendShape_EyeWeight) == 0x000210, "Member 'UPalFacial_MainModule::BlendShape_EyeWeight' has a wrong offset!");
static_assert(offsetof(UPalFacial_MainModule, BlendShape_MouthWeight) == 0x000260, "Member 'UPalFacial_MainModule::BlendShape_MouthWeight' has a wrong offset!");

// Class Pal.PalFirePointLightComponent
// 0x0000 (0x0420 - 0x0420)
class UPalFirePointLightComponent final : public UPointLightComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalFirePointLightComponent">();
	}
	static class UPalFirePointLightComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalFirePointLightComponent>();
	}
};
static_assert(alignof(UPalFirePointLightComponent) == 0x000010, "Wrong alignment on UPalFirePointLightComponent");
static_assert(sizeof(UPalFirePointLightComponent) == 0x000420, "Wrong size on UPalFirePointLightComponent");

// Class Pal.PalMapObjectModelEffectBase
// 0x0018 (0x0040 - 0x0028)
class UPalMapObjectModelEffectBase : public UObject
{
public:
	uint8                                         Pad_2B44[0x18];                                    // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectModelEffectBase">();
	}
	static class UPalMapObjectModelEffectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectModelEffectBase>();
	}
};
static_assert(alignof(UPalMapObjectModelEffectBase) == 0x000008, "Wrong alignment on UPalMapObjectModelEffectBase");
static_assert(sizeof(UPalMapObjectModelEffectBase) == 0x000040, "Wrong size on UPalMapObjectModelEffectBase");

// Class Pal.PalFoliageInstallDataAssetByIFA
// 0x0050 (0x0080 - 0x0030)
class UPalFoliageInstallDataAssetByIFA final : public UDataAsset
{
public:
	TMap<class FName, struct FPalFoliageInstallDataArray> InstallDataArrayMap;                               // 0x0030(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalFoliageInstallDataAssetByIFA">();
	}
	static class UPalFoliageInstallDataAssetByIFA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalFoliageInstallDataAssetByIFA>();
	}
};
static_assert(alignof(UPalFoliageInstallDataAssetByIFA) == 0x000008, "Wrong alignment on UPalFoliageInstallDataAssetByIFA");
static_assert(sizeof(UPalFoliageInstallDataAssetByIFA) == 0x000080, "Wrong size on UPalFoliageInstallDataAssetByIFA");
static_assert(offsetof(UPalFoliageInstallDataAssetByIFA, InstallDataArrayMap) == 0x000030, "Member 'UPalFoliageInstallDataAssetByIFA::InstallDataArrayMap' has a wrong offset!");

// Class Pal.PalMapObjectModelEffectGrantParameterBase
// 0x0008 (0x0030 - 0x0028)
class UPalMapObjectModelEffectGrantParameterBase : public UObject
{
public:
	class UPalMapObjectModel*                     OwnerModel;                                        // 0x0028(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectModelEffectGrantParameterBase">();
	}
	static class UPalMapObjectModelEffectGrantParameterBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectModelEffectGrantParameterBase>();
	}
};
static_assert(alignof(UPalMapObjectModelEffectGrantParameterBase) == 0x000008, "Wrong alignment on UPalMapObjectModelEffectGrantParameterBase");
static_assert(sizeof(UPalMapObjectModelEffectGrantParameterBase) == 0x000030, "Wrong size on UPalMapObjectModelEffectGrantParameterBase");
static_assert(offsetof(UPalMapObjectModelEffectGrantParameterBase, OwnerModel) == 0x000028, "Member 'UPalMapObjectModelEffectGrantParameterBase::OwnerModel' has a wrong offset!");

// Class Pal.PalMapObjectModelEffectGrantParameter_AccumulateTrigger
// 0x0008 (0x0038 - 0x0030)
class UPalMapObjectModelEffectGrantParameter_AccumulateTrigger : public UPalMapObjectModelEffectGrantParameterBase
{
public:
	float                                         Value;                                             // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B45[0x4];                                     // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectModelEffectGrantParameter_AccumulateTrigger">();
	}
	static class UPalMapObjectModelEffectGrantParameter_AccumulateTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectModelEffectGrantParameter_AccumulateTrigger>();
	}
};
static_assert(alignof(UPalMapObjectModelEffectGrantParameter_AccumulateTrigger) == 0x000008, "Wrong alignment on UPalMapObjectModelEffectGrantParameter_AccumulateTrigger");
static_assert(sizeof(UPalMapObjectModelEffectGrantParameter_AccumulateTrigger) == 0x000038, "Wrong size on UPalMapObjectModelEffectGrantParameter_AccumulateTrigger");
static_assert(offsetof(UPalMapObjectModelEffectGrantParameter_AccumulateTrigger, Value) == 0x000030, "Member 'UPalMapObjectModelEffectGrantParameter_AccumulateTrigger::Value' has a wrong offset!");

// Class Pal.PalMapObjectModelInitializeExtraParameterTreasureBox
// 0x0008 (0x0030 - 0x0028)
class UPalMapObjectModelInitializeExtraParameterTreasureBox final : public UPalMapObjectModelInitializeExtraParameterBase
{
public:
	EPalMapObjectTreasureGradeType                GradeType;                                         // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B46[0x7];                                     // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectModelInitializeExtraParameterTreasureBox">();
	}
	static class UPalMapObjectModelInitializeExtraParameterTreasureBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectModelInitializeExtraParameterTreasureBox>();
	}
};
static_assert(alignof(UPalMapObjectModelInitializeExtraParameterTreasureBox) == 0x000008, "Wrong alignment on UPalMapObjectModelInitializeExtraParameterTreasureBox");
static_assert(sizeof(UPalMapObjectModelInitializeExtraParameterTreasureBox) == 0x000030, "Wrong size on UPalMapObjectModelInitializeExtraParameterTreasureBox");
static_assert(offsetof(UPalMapObjectModelInitializeExtraParameterTreasureBox, GradeType) == 0x000028, "Member 'UPalMapObjectModelInitializeExtraParameterTreasureBox::GradeType' has a wrong offset!");

// Class Pal.PalFoliageModelChunk
// 0x0150 (0x03E0 - 0x0290)
class APalFoliageModelChunk : public AActor
{
public:
	struct FPalFoliageInstanceRepInfoArray        RepInfoArray;                                      // 0x0290(0x0148)(Edit, Net, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	int32                                         ChunkGridSize;                                     // 0x03D8(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         InstanceNum;                                       // 0x03DC(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnReceivedChunkGridSize(const int32 NewChunkGridSize);
	void OnRep_ChunkGridSize();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalFoliageModelChunk">();
	}
	static class APalFoliageModelChunk* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalFoliageModelChunk>();
	}
};
static_assert(alignof(APalFoliageModelChunk) == 0x000008, "Wrong alignment on APalFoliageModelChunk");
static_assert(sizeof(APalFoliageModelChunk) == 0x0003E0, "Wrong size on APalFoliageModelChunk");
static_assert(offsetof(APalFoliageModelChunk, RepInfoArray) == 0x000290, "Member 'APalFoliageModelChunk::RepInfoArray' has a wrong offset!");
static_assert(offsetof(APalFoliageModelChunk, ChunkGridSize) == 0x0003D8, "Member 'APalFoliageModelChunk::ChunkGridSize' has a wrong offset!");
static_assert(offsetof(APalFoliageModelChunk, InstanceNum) == 0x0003DC, "Member 'APalFoliageModelChunk::InstanceNum' has a wrong offset!");

// Class Pal.PalFoliageType_InstancedStaticMesh
// 0x0008 (0x04F8 - 0x04F0)
class UPalFoliageType_InstancedStaticMesh final : public UFoliageType_InstancedStaticMesh
{
public:
	EPalFoliagePresetType                         PresetType;                                        // 0x04F0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B47[0x7];                                     // 0x04F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalFoliageType_InstancedStaticMesh">();
	}
	static class UPalFoliageType_InstancedStaticMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalFoliageType_InstancedStaticMesh>();
	}
};
static_assert(alignof(UPalFoliageType_InstancedStaticMesh) == 0x000008, "Wrong alignment on UPalFoliageType_InstancedStaticMesh");
static_assert(sizeof(UPalFoliageType_InstancedStaticMesh) == 0x0004F8, "Wrong size on UPalFoliageType_InstancedStaticMesh");
static_assert(offsetof(UPalFoliageType_InstancedStaticMesh, PresetType) == 0x0004F0, "Member 'UPalFoliageType_InstancedStaticMesh::PresetType' has a wrong offset!");

// Class Pal.PalFootStepEffectAssetBase
// 0x0050 (0x0078 - 0x0028)
class UPalFootStepEffectAssetBase : public UObject
{
public:
	TMap<EPalLandingType, struct FFootStepEffectInfo> FootStepEffectInfo;                                // 0x0028(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	bool GetEffectInfo(EPalLandingType LandingType, struct FFootStepEffectInfo* OutVal) const;
	TSoftObjectPtr<class UNiagaraSystem> GetEffectObjectPtr(EPalLandingType LandingType, EPhysicalSurface PhysicalSurface) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalFootStepEffectAssetBase">();
	}
	static class UPalFootStepEffectAssetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalFootStepEffectAssetBase>();
	}
};
static_assert(alignof(UPalFootStepEffectAssetBase) == 0x000008, "Wrong alignment on UPalFootStepEffectAssetBase");
static_assert(sizeof(UPalFootStepEffectAssetBase) == 0x000078, "Wrong size on UPalFootStepEffectAssetBase");
static_assert(offsetof(UPalFootStepEffectAssetBase, FootStepEffectInfo) == 0x000028, "Member 'UPalFootStepEffectAssetBase::FootStepEffectInfo' has a wrong offset!");

// Class Pal.PalFunnelSkillModuleCollectItem
// 0x0078 (0x00A8 - 0x0030)
class UPalFunnelSkillModuleCollectItem final : public UPalFunnelSkillModule
{
public:
	TArray<float>                                 SearchItemRange;                                   // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGuid                                  CollectItemId;                                     // 0x0040(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldSetSkillAction;                             // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B4B[0x7];                                     // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGuid, struct FPalFunnelSkillModuleCollectItemSearchInfo> SearchItemInfoList;                                // 0x0058(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	void ObserveCollectItem(float DeltaTime);
	bool Pickup();
	void Reset();
	void SearchCollectableItem(float DeltaTime);

	const struct FGuid GetTargetId() const;
	bool GetTargetLocation(struct FVector* Location) const;
	class APalMapObject* GetTargetObject() const;
	bool IsNearTargetLocation(const struct FVector& Location) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalFunnelSkillModuleCollectItem">();
	}
	static class UPalFunnelSkillModuleCollectItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalFunnelSkillModuleCollectItem>();
	}
};
static_assert(alignof(UPalFunnelSkillModuleCollectItem) == 0x000008, "Wrong alignment on UPalFunnelSkillModuleCollectItem");
static_assert(sizeof(UPalFunnelSkillModuleCollectItem) == 0x0000A8, "Wrong size on UPalFunnelSkillModuleCollectItem");
static_assert(offsetof(UPalFunnelSkillModuleCollectItem, SearchItemRange) == 0x000030, "Member 'UPalFunnelSkillModuleCollectItem::SearchItemRange' has a wrong offset!");
static_assert(offsetof(UPalFunnelSkillModuleCollectItem, CollectItemId) == 0x000040, "Member 'UPalFunnelSkillModuleCollectItem::CollectItemId' has a wrong offset!");
static_assert(offsetof(UPalFunnelSkillModuleCollectItem, bShouldSetSkillAction) == 0x000050, "Member 'UPalFunnelSkillModuleCollectItem::bShouldSetSkillAction' has a wrong offset!");
static_assert(offsetof(UPalFunnelSkillModuleCollectItem, SearchItemInfoList) == 0x000058, "Member 'UPalFunnelSkillModuleCollectItem::SearchItemInfoList' has a wrong offset!");

// Class Pal.PalGameInstance
// 0x05C0 (0x0780 - 0x01C0)
class UPalGameInstance : public UGameInstance
{
public:
	FMulticastInlineDelegateProperty_             OnCompletedCharacterMakeDelegate;                  // 0x01C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPawnLocalPlayerControllerChangedDelegates;       // 0x01D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	bool                                          bNetworkError;                                     // 0x01E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B4E[0x7];                                     // 0x01E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DisplayVersion;                                    // 0x01E8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B4F[0x8];                                     // 0x01F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ErrorString;                                       // 0x0200(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InputPassword;                                     // 0x0210(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         BanList;                                           // 0x0220(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B50[0x190];                                   // 0x0230(0x0190)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UPalGameSetting>            GameSettingClass;                                  // 0x03C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalGameSetting*                        GameSetting;                                       // 0x03C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalMasterDataTables>       MasterDataTablesClass;                             // 0x03D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalMasterDataTables*                   MasterDataTables;                                  // 0x03D8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalMapObjectManager>       MapObjectManagerClass;                             // 0x03E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalGroupManager>           GroupManagerClass;                                 // 0x03E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalCharacterManager>       CharacterManagerClass;                             // 0x03F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalCharacterContainerManager> CharacterContainerManagerClass;                    // 0x03F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalCharacterContainerManager*          CharacterContainerManager;                         // 0x0400(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalBaseCampManager>        BaseCampManagerClass;                              // 0x0408(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalWorkProgressManager>    WorkProgressManagerClass;                          // 0x0410(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalDamagePopUpManager>     DamagePopUpManagerClass;                           // 0x0418(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalDamagePopUpManager*                 DamagePopUpManager;                                // 0x0420(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalItemContainerManager>   ItemContainerManagerClass;                         // 0x0428(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalItemIDManager>          ItemIDManagerClass;                                // 0x0430(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalItemIDManager*                      ItemIDManager;                                     // 0x0438(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalWazaDatabase>           WazaDatabaseClass;                                 // 0x0440(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalWazaDatabase*                       WazaDatabase;                                      // 0x0448(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalBattleManager>          BattleManagerClass;                                // 0x0450(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalBossBattleManager>      BossBattleManagerClass;                            // 0x0458(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalRaidBossManager>        RaidBossManagerClass;                              // 0x0460(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalOilrigManager>          OilrigManagerClass;                                // 0x0468(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalPlayerDataStorage>      PlayerDataStorageClass;                            // 0x0470(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalPlayerDataStorage*                  PlayerDataStorage;                                 // 0x0478(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalHUDService>             HUDServiceClass;                                   // 0x0480(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalHUDService*                         HUDService;                                        // 0x0488(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalExpDatabase>            ExpDatabaseClass;                                  // 0x0490(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalExpDatabase*                        ExpDatabase;                                       // 0x0498(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalDatabaseCharacterParameter> DatabaseCharacterParameterClass;                   // 0x04A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalDatabaseCharacterParameter*         DatabaseCharacterParameter;                        // 0x04A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalAssetStreamableManager> AssetStreamableManagerClass;                       // 0x04B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalAssetStreamableManager*             AssetStreamableManager;                            // 0x04B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalPassiveSkillManager>    PassiveSkillManagerClass;                          // 0x04C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalPassiveSkillManager*                PassiveSkillManager;                               // 0x04C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalDataTableRowIdMapper>   DataTableRowIdMapperClass;                         // 0x04D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalDataTableRowIdMapper*               DataTableRowIdMapper;                              // 0x04D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalDeadBodyManager>        DeadBodyManagerClass;                              // 0x04E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalDeadBodyManager*                    DeadBodyManager;                                   // 0x04E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalBulletCreator>          BulletCreatorClass;                                // 0x04F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalBulletCreator*                      BulletCreator;                                     // 0x04F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalPlayerManager>          PlayerManagerClass;                                // 0x0500(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalSaveGameManager>        SaveGameManagerClass;                              // 0x0508(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalSaveGameManager*                    SaveGameManager;                                   // 0x0510(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalVisualEffectDataBase>   VisualEffectDataBaseClass;                         // 0x0518(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalVisualEffectDataBase*               VisualEffectDataBase;                              // 0x0520(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalEventNotifySystem>      EventNotifySystemClass;                            // 0x0528(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalWorldSecuritySystem>    WorldSecuritySystemClass;                          // 0x0530(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalLocationManager>        LocationManagerClass;                              // 0x0538(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalNPCManager>             NPCManagerClass;                                   // 0x0540(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalNPCManager*                         NPCManager;                                        // 0x0548(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalDeathPenaltyManager>    DeathPenaltyManagerClass;                          // 0x0550(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalDeathPenaltyManager*                DeathPenaltyManager;                               // 0x0558(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalCoopSkillSearchSystem>  CoopSkillSearchSystemClass;                        // 0x0560(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalCoopSkillSearchSystem*              CoopSkillSearchSystem;                             // 0x0568(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalCharacterImportanceManager> CharacterImportanceManagerClass;                   // 0x0570(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalCharacterImportanceManager*         CharacterImportanceManager;                        // 0x0578(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalAudioSettingSystem>     AudioSettingClass;                                 // 0x0580(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalAudioSettingSystem*                 AudioSettingSystem;                                // 0x0588(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalCharacterParameterStorageSubsystem> CharacterParameterStorageSubsystemClass;           // 0x0590(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalTutorialManager>        TutorialManagerClass;                              // 0x0598(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalObjectCollector>        ObjectCollectorClass;                              // 0x05A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalActionDummyTargetManager> ActionDummyTargetManager;                          // 0x05A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalLogManager>             LogManagerClass;                                   // 0x05B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RevisionNum;                                       // 0x05B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B51[0x4];                                     // 0x05BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             FxiedCharacterMakeDataDelegate;                    // 0x05C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             FxiedCharacterNameDelegate;                        // 0x05D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<TScriptInterface<class IPalGameSystemNeedSync>> NeedWorldSyncSystems;                              // 0x05E0(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B52[0x20];                                    // 0x05F0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UPalPersistentSoundPlayer>  TitleBGMPlayerClass;                               // 0x0610(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalPersistentSoundPlayer*              TitleBGMPlayer;                                    // 0x0618(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 SelectedWorldName;                                 // 0x0620(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 SelectedWorldSaveDirectoryName;                    // 0x0630(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsNewGame;                                        // 0x0640(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B53[0x7];                                     // 0x0641(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPalOptionWorldSettings                NewGameWorldSetting;                               // 0x0648(0x0138)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)

public:
	void ApplicationHasEnteredForeground();
	void ApplicationHasReactivated();
	void CheckInvite();
	void ClearNetworkError();
	void CompleteInitCharacterMakeData();
	void FxiedCharacterMakeData__DelegateSignature(const struct FPalPlayerDataCharacterMakeInfo& MakeInfo);
	void FxiedCharacterName__DelegateSignature(const class FString& Param_Name);
	void GoToDefaultMap();
	bool IsPlayFromTitle();
	void LoadingFinished();
	void OnCompletedCharacterMake__DelegateSignature();
	void OnCompletedFindSessions(bool bIsSuccess, const TArray<struct FBlueprintSessionResult>& Results, const class FString& ErrorStr);
	void OnCompletedJoinSession(bool IsSuccess, EJoinSessionResultType Type);
	void OnInitializeCompleteSystem();
	void OnPawnLocalPlayerControllerChanged__DelegateSignature(class APawn* Pawn, class AController* Controller);
	void OverrideLoadMap(const TSoftObjectPtr<class UWorld>& World);
	bool SelectWorld(const class FString& WorldName);
	bool SelectWorldSaveDirectoryName(const class FString& WorldSaveDirectoryName);
	void SetIsNewGame();
	void SetNewWorldName(const class FString& WorldName);
	void SetupGameInit();
	void ShowCharacterMakeScreen();
	void ShowUIMultiplayRestriction(bool bOverrideChecking);

	class FString GetSelectedWorldName() const;
	class FString GetSelectedWorldSaveDirectoryName() const;
	bool IsNewGame() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGameInstance">();
	}
	static class UPalGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalGameInstance>();
	}
};
static_assert(alignof(UPalGameInstance) == 0x000008, "Wrong alignment on UPalGameInstance");
static_assert(sizeof(UPalGameInstance) == 0x000780, "Wrong size on UPalGameInstance");
static_assert(offsetof(UPalGameInstance, OnCompletedCharacterMakeDelegate) == 0x0001C0, "Member 'UPalGameInstance::OnCompletedCharacterMakeDelegate' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, OnPawnLocalPlayerControllerChangedDelegates) == 0x0001D0, "Member 'UPalGameInstance::OnPawnLocalPlayerControllerChangedDelegates' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, bNetworkError) == 0x0001E0, "Member 'UPalGameInstance::bNetworkError' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, DisplayVersion) == 0x0001E8, "Member 'UPalGameInstance::DisplayVersion' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, ErrorString) == 0x000200, "Member 'UPalGameInstance::ErrorString' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, InputPassword) == 0x000210, "Member 'UPalGameInstance::InputPassword' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, BanList) == 0x000220, "Member 'UPalGameInstance::BanList' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, GameSettingClass) == 0x0003C0, "Member 'UPalGameInstance::GameSettingClass' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, GameSetting) == 0x0003C8, "Member 'UPalGameInstance::GameSetting' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, MasterDataTablesClass) == 0x0003D0, "Member 'UPalGameInstance::MasterDataTablesClass' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, MasterDataTables) == 0x0003D8, "Member 'UPalGameInstance::MasterDataTables' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, MapObjectManagerClass) == 0x0003E0, "Member 'UPalGameInstance::MapObjectManagerClass' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, GroupManagerClass) == 0x0003E8, "Member 'UPalGameInstance::GroupManagerClass' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, CharacterManagerClass) == 0x0003F0, "Member 'UPalGameInstance::CharacterManagerClass' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, CharacterContainerManagerClass) == 0x0003F8, "Member 'UPalGameInstance::CharacterContainerManagerClass' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, CharacterContainerManager) == 0x000400, "Member 'UPalGameInstance::CharacterContainerManager' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, BaseCampManagerClass) == 0x000408, "Member 'UPalGameInstance::BaseCampManagerClass' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, WorkProgressManagerClass) == 0x000410, "Member 'UPalGameInstance::WorkProgressManagerClass' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, DamagePopUpManagerClass) == 0x000418, "Member 'UPalGameInstance::DamagePopUpManagerClass' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, DamagePopUpManager) == 0x000420, "Member 'UPalGameInstance::DamagePopUpManager' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, ItemContainerManagerClass) == 0x000428, "Member 'UPalGameInstance::ItemContainerManagerClass' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, ItemIDManagerClass) == 0x000430, "Member 'UPalGameInstance::ItemIDManagerClass' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, ItemIDManager) == 0x000438, "Member 'UPalGameInstance::ItemIDManager' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, WazaDatabaseClass) == 0x000440, "Member 'UPalGameInstance::WazaDatabaseClass' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, WazaDatabase) == 0x000448, "Member 'UPalGameInstance::WazaDatabase' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, BattleManagerClass) == 0x000450, "Member 'UPalGameInstance::BattleManagerClass' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, BossBattleManagerClass) == 0x000458, "Member 'UPalGameInstance::BossBattleManagerClass' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, RaidBossManagerClass) == 0x000460, "Member 'UPalGameInstance::RaidBossManagerClass' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, OilrigManagerClass) == 0x000468, "Member 'UPalGameInstance::OilrigManagerClass' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, PlayerDataStorageClass) == 0x000470, "Member 'UPalGameInstance::PlayerDataStorageClass' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, PlayerDataStorage) == 0x000478, "Member 'UPalGameInstance::PlayerDataStorage' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, HUDServiceClass) == 0x000480, "Member 'UPalGameInstance::HUDServiceClass' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, HUDService) == 0x000488, "Member 'UPalGameInstance::HUDService' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, ExpDatabaseClass) == 0x000490, "Member 'UPalGameInstance::ExpDatabaseClass' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, ExpDatabase) == 0x000498, "Member 'UPalGameInstance::ExpDatabase' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, DatabaseCharacterParameterClass) == 0x0004A0, "Member 'UPalGameInstance::DatabaseCharacterParameterClass' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, DatabaseCharacterParameter) == 0x0004A8, "Member 'UPalGameInstance::DatabaseCharacterParameter' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, AssetStreamableManagerClass) == 0x0004B0, "Member 'UPalGameInstance::AssetStreamableManagerClass' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, AssetStreamableManager) == 0x0004B8, "Member 'UPalGameInstance::AssetStreamableManager' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, PassiveSkillManagerClass) == 0x0004C0, "Member 'UPalGameInstance::PassiveSkillManagerClass' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, PassiveSkillManager) == 0x0004C8, "Member 'UPalGameInstance::PassiveSkillManager' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, DataTableRowIdMapperClass) == 0x0004D0, "Member 'UPalGameInstance::DataTableRowIdMapperClass' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, DataTableRowIdMapper) == 0x0004D8, "Member 'UPalGameInstance::DataTableRowIdMapper' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, DeadBodyManagerClass) == 0x0004E0, "Member 'UPalGameInstance::DeadBodyManagerClass' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, DeadBodyManager) == 0x0004E8, "Member 'UPalGameInstance::DeadBodyManager' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, BulletCreatorClass) == 0x0004F0, "Member 'UPalGameInstance::BulletCreatorClass' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, BulletCreator) == 0x0004F8, "Member 'UPalGameInstance::BulletCreator' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, PlayerManagerClass) == 0x000500, "Member 'UPalGameInstance::PlayerManagerClass' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, SaveGameManagerClass) == 0x000508, "Member 'UPalGameInstance::SaveGameManagerClass' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, SaveGameManager) == 0x000510, "Member 'UPalGameInstance::SaveGameManager' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, VisualEffectDataBaseClass) == 0x000518, "Member 'UPalGameInstance::VisualEffectDataBaseClass' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, VisualEffectDataBase) == 0x000520, "Member 'UPalGameInstance::VisualEffectDataBase' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, EventNotifySystemClass) == 0x000528, "Member 'UPalGameInstance::EventNotifySystemClass' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, WorldSecuritySystemClass) == 0x000530, "Member 'UPalGameInstance::WorldSecuritySystemClass' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, LocationManagerClass) == 0x000538, "Member 'UPalGameInstance::LocationManagerClass' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, NPCManagerClass) == 0x000540, "Member 'UPalGameInstance::NPCManagerClass' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, NPCManager) == 0x000548, "Member 'UPalGameInstance::NPCManager' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, DeathPenaltyManagerClass) == 0x000550, "Member 'UPalGameInstance::DeathPenaltyManagerClass' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, DeathPenaltyManager) == 0x000558, "Member 'UPalGameInstance::DeathPenaltyManager' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, CoopSkillSearchSystemClass) == 0x000560, "Member 'UPalGameInstance::CoopSkillSearchSystemClass' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, CoopSkillSearchSystem) == 0x000568, "Member 'UPalGameInstance::CoopSkillSearchSystem' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, CharacterImportanceManagerClass) == 0x000570, "Member 'UPalGameInstance::CharacterImportanceManagerClass' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, CharacterImportanceManager) == 0x000578, "Member 'UPalGameInstance::CharacterImportanceManager' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, AudioSettingClass) == 0x000580, "Member 'UPalGameInstance::AudioSettingClass' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, AudioSettingSystem) == 0x000588, "Member 'UPalGameInstance::AudioSettingSystem' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, CharacterParameterStorageSubsystemClass) == 0x000590, "Member 'UPalGameInstance::CharacterParameterStorageSubsystemClass' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, TutorialManagerClass) == 0x000598, "Member 'UPalGameInstance::TutorialManagerClass' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, ObjectCollectorClass) == 0x0005A0, "Member 'UPalGameInstance::ObjectCollectorClass' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, ActionDummyTargetManager) == 0x0005A8, "Member 'UPalGameInstance::ActionDummyTargetManager' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, LogManagerClass) == 0x0005B0, "Member 'UPalGameInstance::LogManagerClass' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, RevisionNum) == 0x0005B8, "Member 'UPalGameInstance::RevisionNum' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, FxiedCharacterMakeDataDelegate) == 0x0005C0, "Member 'UPalGameInstance::FxiedCharacterMakeDataDelegate' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, FxiedCharacterNameDelegate) == 0x0005D0, "Member 'UPalGameInstance::FxiedCharacterNameDelegate' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, NeedWorldSyncSystems) == 0x0005E0, "Member 'UPalGameInstance::NeedWorldSyncSystems' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, TitleBGMPlayerClass) == 0x000610, "Member 'UPalGameInstance::TitleBGMPlayerClass' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, TitleBGMPlayer) == 0x000618, "Member 'UPalGameInstance::TitleBGMPlayer' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, SelectedWorldName) == 0x000620, "Member 'UPalGameInstance::SelectedWorldName' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, SelectedWorldSaveDirectoryName) == 0x000630, "Member 'UPalGameInstance::SelectedWorldSaveDirectoryName' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, bIsNewGame) == 0x000640, "Member 'UPalGameInstance::bIsNewGame' has a wrong offset!");
static_assert(offsetof(UPalGameInstance, NewGameWorldSetting) == 0x000648, "Member 'UPalGameInstance::NewGameWorldSetting' has a wrong offset!");

// Class Pal.PalMasterDataTableAccess_ItemLotteryData
// 0x0000 (0x0030 - 0x0030)
class UPalMasterDataTableAccess_ItemLotteryData final : public UPalMasterDataTableAccessBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMasterDataTableAccess_ItemLotteryData">();
	}
	static class UPalMasterDataTableAccess_ItemLotteryData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMasterDataTableAccess_ItemLotteryData>();
	}
};
static_assert(alignof(UPalMasterDataTableAccess_ItemLotteryData) == 0x000008, "Wrong alignment on UPalMasterDataTableAccess_ItemLotteryData");
static_assert(sizeof(UPalMasterDataTableAccess_ItemLotteryData) == 0x000030, "Wrong size on UPalMasterDataTableAccess_ItemLotteryData");

// Class Pal.PalGameLocalSettings
// 0x0038 (0x0060 - 0x0028)
class UPalGameLocalSettings final : public UObject
{
public:
	struct FPalOptionAudioSettings                AudioSettings;                                     // 0x0028(0x001C)(Edit, Config, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	EPalOptionGraphicsLevel                       GraphicsLevel;                                     // 0x0044(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPalOptionGraphicsLevel                       DefaultGraphicsLevel;                              // 0x0045(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRunedBenchMark;                                   // 0x0046(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasAppliedUserSetting;                            // 0x0047(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DedicatedServerName;                               // 0x0048(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAntiAliasingMethod                           AntiAliasingType;                                  // 0x0058(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUDLSSMode                                    DLSSMode;                                          // 0x0059(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B57[0x2];                                     // 0x005A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GraphicsCommonQuality;                             // 0x005C(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool RequireBenchMarkScalaBility();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGameLocalSettings">();
	}
	static class UPalGameLocalSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalGameLocalSettings>();
	}
};
static_assert(alignof(UPalGameLocalSettings) == 0x000008, "Wrong alignment on UPalGameLocalSettings");
static_assert(sizeof(UPalGameLocalSettings) == 0x000060, "Wrong size on UPalGameLocalSettings");
static_assert(offsetof(UPalGameLocalSettings, AudioSettings) == 0x000028, "Member 'UPalGameLocalSettings::AudioSettings' has a wrong offset!");
static_assert(offsetof(UPalGameLocalSettings, GraphicsLevel) == 0x000044, "Member 'UPalGameLocalSettings::GraphicsLevel' has a wrong offset!");
static_assert(offsetof(UPalGameLocalSettings, DefaultGraphicsLevel) == 0x000045, "Member 'UPalGameLocalSettings::DefaultGraphicsLevel' has a wrong offset!");
static_assert(offsetof(UPalGameLocalSettings, bRunedBenchMark) == 0x000046, "Member 'UPalGameLocalSettings::bRunedBenchMark' has a wrong offset!");
static_assert(offsetof(UPalGameLocalSettings, bHasAppliedUserSetting) == 0x000047, "Member 'UPalGameLocalSettings::bHasAppliedUserSetting' has a wrong offset!");
static_assert(offsetof(UPalGameLocalSettings, DedicatedServerName) == 0x000048, "Member 'UPalGameLocalSettings::DedicatedServerName' has a wrong offset!");
static_assert(offsetof(UPalGameLocalSettings, AntiAliasingType) == 0x000058, "Member 'UPalGameLocalSettings::AntiAliasingType' has a wrong offset!");
static_assert(offsetof(UPalGameLocalSettings, DLSSMode) == 0x000059, "Member 'UPalGameLocalSettings::DLSSMode' has a wrong offset!");
static_assert(offsetof(UPalGameLocalSettings, GraphicsCommonQuality) == 0x00005C, "Member 'UPalGameLocalSettings::GraphicsCommonQuality' has a wrong offset!");

// Class Pal.PalGameMode
// 0x0050 (0x0388 - 0x0338)
class APalGameMode final : public APalGameModeBase
{
public:
	class APlayerStart*                           CachePlayerStart;                                  // 0x0338(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B58[0x48];                                    // 0x0340(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CreateSession(const class FString& Address);
	class APlayerStart* FindPlayerStartWithTag(const class FName& Tag);
	void InitDedicatedServer();
	void OnCompleteCreateSession(const class FString& ResponseBody, bool bResponseOK, int32 ResponseCode);
	void OnEOSLoginDedicatedServerComplete(const class UPocketpairUserInfo* UserInfo, bool bSuccess, const class FString& ErrorStr);
	void OnUpdateSession(const class FString& ResponseBody, bool bResponseOK, int32 ResponseCode);
	void RespawnPlayer(int32 PlayerIndex);
	void RestartGame();

	void OnServerLobbyUpdate() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGameMode">();
	}
	static class APalGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalGameMode>();
	}
};
static_assert(alignof(APalGameMode) == 0x000008, "Wrong alignment on APalGameMode");
static_assert(sizeof(APalGameMode) == 0x000388, "Wrong size on APalGameMode");
static_assert(offsetof(APalGameMode, CachePlayerStart) == 0x000338, "Member 'APalGameMode::CachePlayerStart' has a wrong offset!");

// Class Pal.PalOnlineSubsystemSteam
// 0x0000 (0x0028 - 0x0028)
class UPalOnlineSubsystemSteam final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalOnlineSubsystemSteam">();
	}
	static class UPalOnlineSubsystemSteam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalOnlineSubsystemSteam>();
	}
};
static_assert(alignof(UPalOnlineSubsystemSteam) == 0x000008, "Wrong alignment on UPalOnlineSubsystemSteam");
static_assert(sizeof(UPalOnlineSubsystemSteam) == 0x000028, "Wrong size on UPalOnlineSubsystemSteam");

// Class Pal.PalGameModeLogin
// 0x0008 (0x0340 - 0x0338)
class APalGameModeLogin final : public APalGameModeBase
{
public:
	uint8                                         Pad_2B5C[0x8];                                     // 0x0338(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GoToTitle();
	void OnCloseEalryAccess(bool _);
	void OnConfirmAlert_EOSLogin(bool bSuccess);
	void OnConfirmAlert_MultiplayRestricted(bool bSuccess);
	void OnLoginCompleted(const class UPocketpairUserInfo* UserInfo, bool bSuccess, const class FString& ErrorStr);
	void OnLoginEOSCompleted(const class UPocketpairUserInfo* UserInfo, bool bSuccess, const class FString& ErrorStr);
	void OnSwitchUserUICompleted(const class UPocketpairUserInfo* UserInfo, bool bSuccess, const class FString& ErrorStr);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGameModeLogin">();
	}
	static class APalGameModeLogin* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalGameModeLogin>();
	}
};
static_assert(alignof(APalGameModeLogin) == 0x000008, "Wrong alignment on APalGameModeLogin");
static_assert(sizeof(APalGameModeLogin) == 0x000340, "Wrong size on APalGameModeLogin");

// Class Pal.PalGameModeServerEntry
// 0x0000 (0x0338 - 0x0338)
class APalGameModeServerEntry final : public APalGameModeBase
{
public:
	void LoadLevel();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGameModeServerEntry">();
	}
	static class APalGameModeServerEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalGameModeServerEntry>();
	}
};
static_assert(alignof(APalGameModeServerEntry) == 0x000008, "Wrong alignment on APalGameModeServerEntry");
static_assert(sizeof(APalGameModeServerEntry) == 0x000338, "Wrong size on APalGameModeServerEntry");

// Class Pal.PalGameSetting
// 0x1690 (0x16B8 - 0x0028)
class UPalGameSetting : public UBlueprintFunctionLibrary
{
public:
	int32                                         CharacterMaxLevel;                                 // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuildCharacterMaxLevel;                            // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtomoLevelSyncAddMaxLevel;                         // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPalPlayerSprintStaminaDecreaseType           PlayerSprintStaminaType;                           // 0x0034(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B60[0x3];                                     // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CharacterMaxRank;                                  // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConsumStamina_PalThrow;                            // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnOtomoPalCoolTime;                            // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtomoSlotNum;                                      // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OtomoWazaCoolDownSpeedRate;                        // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BerserkerOtomoSerchRadius_FromPlayer;              // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerHPRateFromRespawn;                           // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerStomachRateFromRespawn;                      // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RarePal_AppearanceProbability;                     // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RarePal_LevelMultiply;                             // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BossOrRarePal_TalentMin;                           // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharacterRankUpRequiredNumDefault;                 // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, int32>                            CharacterRankUpRequiredNumMap;                     // 0x0068(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         NaturalUpdateSaveParameterInterval;                // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterHUDDisplayRange;                          // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterFedEatingTime;                            // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterStayingSecondsInSpa;                      // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PalBoxPageNum;                                     // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PalBoxSlotNumInPage;                               // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PalBoxTimePeriodRecoverySick;                      // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerBattleJudge_EnemyDistance;                   // 0x00D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, float>                            BodyTemperature_SlipDamage_Percent;                // 0x00D8(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<int32, float>                            BodyTemperature_StomachDecreaceRate;               // 0x0128(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UNiagaraSystem>          SleepFXDefault;                                    // 0x0178(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LiftupCharacterThrownVelocityScalar;               // 0x01A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LiftupCharacterClearCollisionDelayTime;            // 0x01AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NickNameMaxLength;                                 // 0x01B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IntervalForPalAttackFromBall;                      // 0x01B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanShootRiderByFullRide;                           // 0x01B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HitWazaAttackForMapObject;                         // 0x01B9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B61[0x2];                                     // 0x01BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         KnockBack_MaxHpPercent;                            // 0x01BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KnockBack_Power;                                   // 0x01C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StunTime;                                          // 0x01C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StepCooldownTime;                                  // 0x01C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Stun_GunDamageRate;                                // 0x01CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEnableAutoReload;                                // 0x01D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B62[0x3];                                     // 0x01D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DeadShootImpulseRate;                              // 0x01D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeadShootImpulseMax;                               // 0x01D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OtomoDamageRate_Defense;                           // 0x01DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DamageValueMin_MapObject;                          // 0x01E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageRate_WealPoint;                              // 0x01E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageRate_StrongPoint;                            // 0x01E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageRate_SleepHit;                               // 0x01EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FinalDamageRate_Waza;                              // 0x01F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FinalDamageRate_Weapon;                            // 0x01F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FinalDamageRate_Mine;                              // 0x01F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FinalDamageRate_MapObject_Waza;                    // 0x01FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FinalDamageRate_MapObject_Weapon;                  // 0x0200(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FinalDamageRate_MapObject_Mine;                    // 0x0204(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FoliageDefault_Defense;                            // 0x0208(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WazaAttackerLevelDamage_Power;                     // 0x020C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageRandomRate_Min;                              // 0x0210(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageRandomRate_Max;                              // 0x0214(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LevelDamageCorrect;                                // 0x0218(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LevelStatusAccumulateCorrect;                      // 0x021C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageElementMatchRate;                            // 0x0220(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MineAttack_DefensePower;                           // 0x0224(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StatusCalculate_LevelMultiply_HP;                  // 0x0228(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StatusCalculate_TribePlus_HP;                      // 0x022C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StatusCalculate_ConstPlus_HP;                      // 0x0230(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StatusCalculate_LevelMultiply_Attack;              // 0x0234(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StatusCalculate_ConstPlus_Attack;                  // 0x0238(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StatusCalculate_LevelMultiply_Defense;             // 0x023C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StatusCalculate_ConstPlus_Defense;                 // 0x0240(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StatusCalculate_TribeMultiply_CraftSpeed;          // 0x0244(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StatusCalculate_GenkaiToppa_PerAdd;                // 0x0248(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StatusCalculate_Talent_PerAdd;                     // 0x024C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BreakedWeaponDamageRate;                           // 0x0250(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BreakedArmorDefenseRate;                           // 0x0254(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmorDurabilityDamageDivide;                       // 0x0258(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbingStamina_Move;                              // 0x025C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbingStamina_Jump;                              // 0x0260(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RideWazaStaminaRate;                               // 0x0264(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEnableJumpPreliminary;                          // 0x0268(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B63[0x3];                                     // 0x0269(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpInterval;                                      // 0x026C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlyMaxHeight;                                      // 0x0270(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlyHover_SP;                                       // 0x0274(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlyHorizon_SP;                                     // 0x0278(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlyHorizon_Dash_SP;                                // 0x027C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlyVertical_SP;                                    // 0x0280(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimingSpeedRateInRide;                             // 0x0284(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlidingEndSpeed;                                   // 0x0288(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         JumpSP;                                            // 0x028C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StepSP;                                            // 0x0290(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MeleeAttackSP;                                     // 0x0294(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintSP;                                          // 0x0298(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GliderSP;                                          // 0x029C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwimmingFallWaitTimeSec;                           // 0x02A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Swimming_SP_Idle;                                  // 0x02A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Swimming_SP_Swim;                                  // 0x02A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Swimming_SP_DashSwim;                              // 0x02AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FluidFriction;                                     // 0x02B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverWeightSpeedZero_AddPercent;                    // 0x02B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverWeightMinSpeed;                                // 0x02B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkableFloorAngleForDefault;                      // 0x02BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkableFloorAngleForRide;                         // 0x02C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEnableSpeedCollision;                            // 0x02C4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B64[0x3];                                     // 0x02C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CollisionDamageMinSpeed;                           // 0x02C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedCollisionDamagePower;                         // 0x02CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionDamageSpeedMultiplay;                     // 0x02D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionDamageWeightThreshold;                    // 0x02D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoHPRegene_Percent_perSecond;                    // 0x02D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoHPRegene_Percent_perSecond_Sleeping;           // 0x02DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PosionHPDecrease_Percent_perSecond;                // 0x02E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Starvation_DecreaseHP_Percent_perSecond;           // 0x02E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoSANRegene_Percent_perSecond_PalStorage;        // 0x02E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StomachDecreace_perSecond_Monster;                 // 0x02EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StomachDecreace_perSecond_Player;                  // 0x02F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StomachDecreace_AutoHealing;                       // 0x02F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StomachDecreace_WorkingRate;                       // 0x02F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HungerStart_StomachValue;                          // 0x02FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FullStomachPalStartEatFood;                        // 0x0300(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FullStomachCost_ByWazaUse_Base;                    // 0x0304(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, float>                            FullStomachCost_ByWazaUse_RateMap;                 // 0x0308(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         StomachDecreaceRate_GroundRide_Sprint;             // 0x0358(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StomachDecreaceRate_WaterRide;                     // 0x035C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StomachDecreaceRate_WaterRide_Sprint;              // 0x0360(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StomachDecreaceRate_FlyRide;                       // 0x0364(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StomachDecreaceRate_FlyRide_Sprint;                // 0x0368(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RemainderOfLife_Second;                            // 0x036C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HpDecreaseRate_Drowning;                           // 0x0370(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerShield_RecoverStartTime;                     // 0x0374(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerShield_RecoverPercentPerSecond;              // 0x0378(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StaminaRecover_PercentPerSecond;                   // 0x037C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResuscitationTime;                                 // 0x0380(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerDeath_DropOtomoNum;                          // 0x0384(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerDeath_DropOtomoRange;                        // 0x0388(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerDeath_DropOtomoDisappearHours;               // 0x038C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerDeath_DropItemStorage_HoursCanOpen;          // 0x0390(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerDyingDamagePerTime;                          // 0x0394(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ElementStatus_ResistanceInitialValue;              // 0x0398(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElementStatus_AutoDecreasePerSecond;               // 0x039C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ElementStatus_ResetResistanceSecond;               // 0x03A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuildExp;                                          // 0x03A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CraftExp;                                          // 0x03A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PickupItemOnLevelExp;                              // 0x03AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MapObjectDestroyProceedExp;                        // 0x03B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MapObjectDistributeExpRange;                       // 0x03B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, int32>                            OtomoExp_LevelDifferenceMap;                       // 0x03B8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         OtomoExp_HigherPlayerLevel;                        // 0x0408(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CaptureExpBonus_Tier1_TableReferenceNum;           // 0x040C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CaptureExpBonus_Tier2_TableReferenceNum;           // 0x0410(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CaptureExpBonus_Tier3_TableReferenceNum;           // 0x0414(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPalDebugOtomoPalInfo>          NewGameOtomoPalSet;                                // 0x0418(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FName, int32>                      NewGameInventoryItemSet;                           // 0x0428(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FName, int32>                      NewGameLoadoutItemSet;                             // 0x0478(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FVector                                WorldHUDDisplayOffsetDefault;                      // 0x04C8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorldHUDDisplayRangeDefault;                       // 0x04E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorldHUDDetailDisplayRange;                        // 0x04E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPalDataTableRowName_ItemData>  FarmCropWaterItemIds;                              // 0x04E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         FarmCropGrowupSpeedBySec;                          // 0x04F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FarmCropIncreaseRateByWaterFillRate;               // 0x04FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MaxMoney;                                          // 0x0500(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultMoney;                                      // 0x0510(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SneakAttackBackJudgeAngle_Degree;                  // 0x0514(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SneakAttack_PalMeleeWaza_AttackRate;               // 0x0518(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoAimCameraMoveRate;                             // 0x051C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoAimCharacterMoveRate;                          // 0x0520(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoAimCameraAdsorptionSpeed;                      // 0x0524(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoAimLockOnScreenSpaceRate;                      // 0x0528(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForceAutoAimTime;                                  // 0x052C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SellItemRate;                                      // 0x0530(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PalPriceConstantValueA;                            // 0x0534(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PalPriceConstantValueB;                            // 0x0538(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SellPalRate;                                       // 0x053C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchRangeOnThrowedCharacterLanded;               // 0x0540(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorkCompleteReactionRangeFromPlayer;               // 0x0544(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WorkerCollectResourceStackMaxNum;                  // 0x0548(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPalFacialEyeType                             FacialTypeHardWork;                                // 0x054C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B65[0x3];                                     // 0x054D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Timeout_WorkerApproachToTarget;                    // 0x0550(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaitTime_WorkRepairFailedFindPath;                 // 0x0554(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorkerWaitingNotifyInterval;                       // 0x0558(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WarpCheckInterval;                                 // 0x055C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WarpCheckMoveDistanceThreshold;                    // 0x0560(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WarpThreshold;                                     // 0x0564(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoDecreaseHateValue_PercentMaxHP_PerSecond;      // 0x0568(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HateDecreaseDamageRate;                            // 0x056C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Hate_ForceUp_HPRate_OtomoActive;                   // 0x0570(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Hate_ForceUp_HPRate_IncidentBattle;                // 0x0574(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CombatEndDistance_BattleStartSelfPos_To_SelfPos;   // 0x0578(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CombatEndDistance_BattleStartSelfPos_To_TargetPos; // 0x057C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CombatEndDistance_BattleStartSelfPos_To_TargetPos_AddFirstTargetDistance; // 0x0580(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NavigationAreaDivideExtents;                       // 0x0584(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPalNavigationUpdateFrequencySetting> NavigationUpdateFrequencySettingsFromPlayer;       // 0x0588(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         AutoSaveSpan;                                      // 0x0598(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SaveDataName_WorldBaseInfo;                        // 0x059C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SaveDataName_World;                                // 0x05A4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SaveDataName_PlayerDirectory;                      // 0x05AC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SaveDataName_LocalData;                            // 0x05B4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SaveDataName_WorldOption;                          // 0x05BC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B66[0x4];                                     // 0x05C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EPalSupportedPlatformType, int32>        MaxWorldDataNumMap;                                // 0x05C8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         PalWorldTime_GameStartHour;                        // 0x0618(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PalWorldMinutes_RealOneMinute;                     // 0x061C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NightStartHour;                                    // 0x0620(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NightEndHour;                                      // 0x0624(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerMorningHour;                                 // 0x0628(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerSleepStartHour;                              // 0x062C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NightSkipWaitSecond;                               // 0x0630(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocalPlayerAndOtomo_LightRangeScale;               // 0x0634(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BuildBaseUnitGridDefinition;                       // 0x0638(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BuildSimulationVerticalAdjustRate;                 // 0x0650(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BuildSimulationVerticalMinLength;                  // 0x0654(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BuildSimulationFoundationFloatingAllowance;        // 0x0658(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B67[0x4];                                     // 0x065C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EPalBuildObjectInstallStrategy, struct FVector> BuildSimulationFoundationCheckCollisionScale;      // 0x0660(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         BuildSimulationRoofHeightOffset;                   // 0x06B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BuildSimulationStairHeightOffset;                  // 0x06B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BuildSimulationLeanAngleMax;                       // 0x06B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BuildingProgressInterpolationSpeed;                // 0x06BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerRecord_BuildingObjectMaxNum;                 // 0x06C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BuildingMaxZ;                                      // 0x06C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuildObj_HatchedPalCharacterLevel;                 // 0x06C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BuildObj_DamageScarecrowStartRecoveryTime;         // 0x06CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseCampAreaRange;                                 // 0x06D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseCampPalFindWorkRange;                          // 0x06D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PalArriveToWorkLocationRange;                      // 0x06D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PalArriveToWorkLocationRangeZ;                     // 0x06DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseCampNeighborMinimumDistance;                   // 0x06E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PalRotateSpeedToWork;                              // 0x06E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseCampFoliageWorkableRange;                      // 0x06E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseCampHungerApproachToPlayer;                    // 0x06EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseCampHungerUnreachableObjectTimeoutRealSeconds; // 0x06F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HungerHUDDisplayRange;                             // 0x06F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorkAmountBySecForPlayer;                          // 0x06F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseCampWorkerEventTriggerInterval;                // 0x06FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseCampWorkerEventTriggerProbability;             // 0x0700(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseCampWorkerSanityWarningThreshold;              // 0x0704(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseCampWorkerFinishEatingFullStomach;             // 0x0708(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseCampWorkerFinishEatingSanity;                  // 0x070C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BaseCampWorkerFinishEatCount;                      // 0x0710(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseCampWorkerRecoverHungryTurnToTargetTimeout;    // 0x0714(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseCampWorkerStartSleepHpPercentage;              // 0x0718(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseCampWorkerSleepInPlaceRecoverSanityRate;       // 0x071C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseCampWorkerDistancePickableItem;                // 0x0720(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B68[0x4];                                     // 0x0724(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EPalBaseCampItemContainerType>         BaseCampBuildingItemContainerPriority;             // 0x0728(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         FoliageRespawnFailedExtraRangeOfBaseCamp;          // 0x0738(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseCampPalCombatRange_AddCampRange;               // 0x073C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         BaseCampPalWalkTime_BeforeSleep;                   // 0x0740(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseCampTimeFinishBattleModeAfterEmptyEnemy;       // 0x0748(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPalCharacterImportanceType                   BaseCampWorkerMoveModeChangeThreshold;             // 0x074C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B69[0x3];                                     // 0x074D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BaseCampWorkerDirectorTickForAssignWorkByCount;    // 0x0750(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseCampWorkerTimeDetectContinuousStuck;           // 0x0754(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseCampWorkerMaxTimeReturnBack;                   // 0x0758(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseCampWorkerLookToTargetWork;                    // 0x075C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReviveWorkAdditionalRange;                         // 0x0760(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorkAroundRangeDefault;                            // 0x0764(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EPalWorkType>                          IssueNotifyWorkTypes;                              // 0x0768(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         WorkAmountByManMonth;                              // 0x0778(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorkNotifyDelayTime;                               // 0x077C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorkFinishDelayCallAddWorkNotifyDelayTime;         // 0x0780(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorkIgnitionTorchWaitTime;                         // 0x0784(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EPalWorkAssignableCheckResult, EPalMonsterControllerBaseCampLogType> WorkAssignFailedLogTypeMap;                        // 0x0788(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         WorkTransportingSpeedRate;                         // 0x07D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B6A[0x4];                                     // 0x07DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPalDataTableRowName_ItemData>  BaseCampNotTransportItemBlackList;                 // 0x07E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         WorkTransportingDelayTimeDropItem;                 // 0x07F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseCampStopProvideEnergyInterval;                 // 0x07F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EPalBaseCampPassiveEffectWorkHardType, struct FPalBaseCampPassiveEffectWorkHardInfo> BaseCampPassiveEffectWorkHardInfoMap;              // 0x07F8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         BaseCampWorkCollectionRestoreStashSeconds;         // 0x0848(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B6B[0x4];                                     // 0x084C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPalWorkTypeSet>                WorkTypeAssignPriorityOrder;                       // 0x0850(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FPalWorkAssignDefineDataStaticSetting  WorkAssignDefineData_Build;                        // 0x0860(0x0040)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FPalWorkAssignDefineDataStaticSetting  WorkAssignDefineData_FoliageWork;                  // 0x08A0(0x0040)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FPalWorkAssignDefineDataStaticSetting  WorkAssignDefineData_ReviveCharacterWork;          // 0x08E0(0x0040)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FPalWorkAssignDefineDataStaticSetting  WorkAssignDefineData_TransportItemInBaseCamp;      // 0x0920(0x0040)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FPalWorkAssignDefineDataStaticSetting  WorkAssignDefineData_RepairBuildObjectInBaseCamp;  // 0x0960(0x0040)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FPalWorkAssignDefineDataStaticSetting  WorkAssignDefineData_BreedFarm;                    // 0x09A0(0x0040)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FPalWorkAssignDefineDataStaticSetting  WorkAssignDefineData_ExtinguishBurn;               // 0x09E0(0x0040)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         WorkSuitabilityMaxRank;                            // 0x0A20(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B6C[0x4];                                     // 0x0A24(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EPalWorkSuitability, struct FPalWorkSuitabilityDefineData> WorkSuitabilityDefineDataMap;                      // 0x0A28(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FPalWorkSuitabilityCollectionDefineData WorkSuitabilityDefineData_Collection;              // 0x0A78(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FPalWorkSuitabilityDeforestDefineData  WorkSuitabilityDefineData_Deforest;                // 0x0AA0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FPalWorkSuitabilityMiningDefineData    WorkSuitabilityDefineData_Mining;                  // 0x0AC8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         DropItemWaitInsertMaxNumPerTick;                   // 0x0AF0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B6D[0x4];                                     // 0x0AF4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPalItemFilterPreference               ItemFilterPreference;                              // 0x0AF8(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FPalDungeonMarkerPointSpawnParameter   DungeonSpawnParameterDefault;                      // 0x0B48(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         GamePad_NotAimCameraRotateSpeed_DegreePerSecond;   // 0x0B58(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamePad_AimCameraRotateSpeed_DegreePerSecond;      // 0x0B5C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Mouse_NotAimCameraRotateSpeed;                     // 0x0B60(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Mouse_AimCameraRotateSpeed;                        // 0x0B64(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawCameraMaxSpeedRate;                             // 0x0B68(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeForCameraMaxSpeed;                             // 0x0B6C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimInterpInterval;                                 // 0x0B70(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InvaderSelfDeleteAddTime;                          // 0x0B74(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VisitorSelfDeleteTime;                             // 0x0B78(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InvadeProbability;                                 // 0x0B7C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InvadeOccurablePlayerLevel;                        // 0x0B80(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InvadeJudgmentInterval_Minutes;                    // 0x0B84(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InvadeCollTime_Max_Minutes;                        // 0x0B88(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InvadeCollTime_Min_Minutes;                        // 0x0B8C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InvadeReturnTime_Minutes;                          // 0x0B90(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InvadeStartPoint_BaseCampRadius_Min_cm;            // 0x0B94(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InvadeStartPoint_BaseCampRadius_Max_cm;            // 0x0B98(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VisitorNPCProbability;                             // 0x0B9C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VisitorNPCReturnTime_Minutes;                      // 0x0BA0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RidingAimOpacity;                                  // 0x0BA4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HideUITimeWhenNotConflict;                         // 0x0BA8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FirstCapturedUIDisplayTime;                        // 0x0BAC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CapturedUIDisplayTime;                             // 0x0BB0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FirstActivatedOtomoInfoDisplayTime;                // 0x0BB4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerLevelUpUIDIsplayTime;                        // 0x0BB8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerExpGaugeUIDisplayTime;                       // 0x0BBC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OtomoExpGaugeUIDisplayTime;                        // 0x0BC0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NpcGaugeDisplayDistance;                           // 0x0BC4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NpcGaugeDisplayRange_CameraSight;                  // 0x0BC8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GuildMemberGaugeDisplayDIstance;                   // 0x0BCC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DownPlayerLoupeDisplayDistance;                    // 0x0BD0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DownPlayerGaugeDisplayRange_CameraSight;           // 0x0BD4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ReticleOffsetRate;                                 // 0x0BD8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LowHealthEffectParcent;                            // 0x0BE8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B6E[0x4];                                     // 0x0BEC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EPalDamageTextType, int32>               DamageTextMargineMap;                              // 0x0BF0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         DamageTextDisplayLength;                           // 0x0C40(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B6F[0x4];                                     // 0x0C44(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              DamageTextMaxOffset;                               // 0x0C48(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageTextOffsetInterpolationLength;               // 0x0C58(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B70[0x4];                                     // 0x0C5C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EPalDamageTextType, float>               DamageTextScaleMap;                                // 0x0C60(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FVector2D                              DamageTextRandomOffset;                            // 0x0CB0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StrongEnemyMarkLevel;                              // 0x0CC0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OtomoInteractUIDisplayDistance;                    // 0x0CC4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnemyMarkUIMinScale;                               // 0x0CC8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnemyMarkScaleInterpolationLength;                 // 0x0CCC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              NpcHPGaugeGlobalOffset;                            // 0x0CD0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayGaugeStartTime;                               // 0x0CE0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayGaugeProgressPerSecond;                       // 0x0CE4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InventoryWeaponRangeMaxBorder;                     // 0x0CE8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InventoryWeaponStabilityMinBorder;                 // 0x0CEC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InventoryWeaponAccuracyMinBorder;                  // 0x0CF0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorldmapUIMaskClearSize;                           // 0x0CF4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorldmapUIFTMergeDistance;                         // 0x0CF8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WorldmapUIMaxMarker;                               // 0x0CFC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NPCHPGaugeUpdateSpan;                              // 0x0D00(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CaptureFailedUIDisplayTime;                        // 0x0D04(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPalDataTableRowName_ItemData>  CaptureSphereSortArray;                            // 0x0D08(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         OpenGameOverUITime;                                // 0x0D18(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlockRespawnTime;                                  // 0x0D1C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InventoryWeightAlertRate;                          // 0x0D20(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InventoryWeightGaugeDIsplayTime;                   // 0x0D24(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OtomoLevelUpNoticeUIDisplayTime;                   // 0x0D28(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OtomoMasteredWazaNoticeUIDisplayTime;              // 0x0D2C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProgressGaugeInterpolationSpeed;                   // 0x0D30(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TeleportFadeInTime;                                // 0x0D34(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TeleportFadeOutTime;                               // 0x0D38(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerTeleportTimeoutTime;                         // 0x0D3C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 PassiveSkillAppendNumWeights;                      // 0x0D40(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bIsEggLauncherExplosion;                           // 0x0D50(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B71[0x3];                                     // 0x0D51(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ThrowPalBattleRadius;                              // 0x0D54(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThrowPalWorkRadius;                                // 0x0D58(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RopeHitPowe;                                       // 0x0D5C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RopePullPower;                                     // 0x0D60(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultMaxInventoryWeight;                         // 0x0D64(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RaycastLengthForDetectIndoor;                      // 0x0D68(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MapObjectConnectAnyPlaceRaycastLength;             // 0x0D6C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShootingTargetRayCastDistance;                     // 0x0D70(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B72[0x4];                                     // 0x0D74(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 CaptureJudgeRateArray;                             // 0x0D78(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         CaptureBallBoundCountMax;                          // 0x0D88(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B73[0x4];                                     // 0x0D8C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ExceptCapturedItemList;                            // 0x0D90(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EPalCaptureSphereLevelType, int32>       CaptureSphereLevelMap;                             // 0x0DA0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EPalStatusID, float>                     CaptureRateAddByStatusMap;                         // 0x0DF0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         IgnoreFirstCaptureFailedHPRate;                    // 0x0E40(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CaptureRateAdd_ByLegHold;                          // 0x0E44(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LongPressInterval;                                 // 0x0E48(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LongPressInterval_EnemyCampCage;                   // 0x0E4C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LongPressInterval_StartRaidBoss;                   // 0x0E50(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LongPressInterval_GetHatchedPal;                   // 0x0E54(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchLockAttenuation;                             // 0x0E58(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEnableCharacterWazaScale;                        // 0x0E5C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOverrideDamageAdditiveAnimation;                 // 0x0E5D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B74[0x2];                                     // 0x0E5E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlinkInterval;                                     // 0x0E60(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrimeStateMaintainDurationBaseDefault;             // 0x0E64(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TechnologyPointPerLevel;                           // 0x0E68(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bossTechnologyPointPerTowerBoss;                   // 0x0E6C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bossTechnologyPointPerNormalBoss;                  // 0x0E70(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B75[0x4];                                     // 0x0E74(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPalDataTableRowName_RecipeTechnologyData> DefaultUnlockTechnology;                           // 0x0E78(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         DefaultTechnologyPoint;                            // 0x0E88(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TechnologyPoint_UnlockFastTravel;                  // 0x0E8C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecreaseSanity_DamagedMultiply;                    // 0x0E90(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FullStomachPercent_RecoverySanity;                 // 0x0E94(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoverySanity_FullStomach;                        // 0x0E98(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecreaseSanity_Hunger;                             // 0x0E9C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecreaseSanity_Starvation;                         // 0x0EA0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Spawner_IsCheckLoadedWorldPartition;               // 0x0EA4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B76[0x3];                                     // 0x0EA5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnerDisableDistanceCM_FromBaseCamp;             // 0x0EA8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Spawner_DefaultSpawnRadius_S;                      // 0x0EAC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Spawner_DefaultSpawnRadius_M;                      // 0x0EB0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Spawner_DefaultSpawnRadius_L;                      // 0x0EB4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Spawner_DefaultSpawnRadius_NPC;                    // 0x0EB8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Spawner_DefaultDespawnDistance_S;                  // 0x0EBC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Spawner_DefaultDespawnDistance_M;                  // 0x0EC0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Spawner_DefaultDespawnDistance_L;                  // 0x0EC4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Spawner_DefaultDespawnDistance_NPC;                // 0x0EC8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B77[0x4];                                     // 0x0ECC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             CharacterHeadMeshDataTable;                        // 0x0ED0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             CharacterBodyMeshDataTable;                        // 0x0ED8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             CharacterHairMeshDataTable;                        // 0x0EE0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             CharacterEquipmentArmorMeshDataTable;              // 0x0EE8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             CharacterEyeMaterialDataTable;                     // 0x0EF0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterMakeColorLimit_SV;                        // 0x0EF8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAutoEquipMasteredWaza;                           // 0x0EFC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ActiveUNKO;                                        // 0x0EFD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B78[0x2];                                     // 0x0EFE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxSpawnableDeathPenaltyChest;                     // 0x0F00(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BuildObjectInstallStrategy_SinkAllowCollisionPresetName; // 0x0F04(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MapObjectShakeTimeOnDamaged;                       // 0x0F0C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MapObjectShakeOffsetOnDamaged;                     // 0x0F10(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MapObjectOutlineByReticleTargetting;               // 0x0F28(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MapObjectOutlineByInteractable;                    // 0x0F2C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPalMapObjectRepairInfo                MapObjectRepairInfo;                               // 0x0F30(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         FoliageExtentsXY;                                  // 0x0F40(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FoliageChunkSeparateScale;                         // 0x0F44(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MapObjectHPDisplayDistance;                        // 0x0F48(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MapObjectHPDisplayTime;                            // 0x0F4C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MapObjectGateLockTime;                             // 0x0F50(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDirectObtainFromTreasureBox;                      // 0x0F54(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B79[0x3];                                     // 0x0F55(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MapObjectEffectTriggerAccumulate_Burn;             // 0x0F58(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MapObjectEffect_Burn_DamageHpRate;                 // 0x0F5C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MapObjectEffect_Burn_DamageAroundRange;            // 0x0F60(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MapObjectEffect_Burn_DamageAroundInterval;         // 0x0F78(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MapObjectEffect_Burn_DamageAroundDamageValue;      // 0x0F7C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MapObjectEffect_Burn_DamageAroundAccumulateValue;  // 0x0F80(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MapObjectEffect_Burn_DamageAroundAccumulateValue_ForCharacter; // 0x0F84(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PasswordLockFailedMaxNum;                          // 0x0F88(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MapObjectItemChestCorruptionRateFromWorkSpeed;     // 0x0F8C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPalOptimizeParameter                  RuntimeOptimizeParameter;                          // 0x0F90(0x0490)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<int32, struct FPalWorldSecurityWantedPoliceSettingData> WorldSecurityWantedPoliceSettingDataMap;           // 0x1420(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<int32, struct FPalWorldSecurityWantedPoliceSettingData> WorldSecurityWantedPoliceSettingDataMapForDS;      // 0x1470(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         StatusPointPerLevel;                               // 0x14C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddMaxHPPerStatusPoint;                            // 0x14C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddMaxSPPerStatusPoint;                            // 0x14C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddPowerPerStatusPoint;                            // 0x14CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddMaxInventoryWeightPerStatusPoint;               // 0x14D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddCaptureLevelPerStatusPoint;                     // 0x14D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddWorkSpeedPerStatusPoint;                        // 0x14D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddMaxHPPerHPRank;                                 // 0x14DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddAttackPerAttackRank;                            // 0x14E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddDefencePerDefenceRank;                          // 0x14E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddWorkSpeedPerWorkSpeedRank;                      // 0x14E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxUseablePoint_SumStatusPointAndExStatusPoint_PerParameter; // 0x14EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 Combi_TalentInheritNum;                            // 0x14F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<float>                                 Combi_PassiveInheritNum;                           // 0x1500(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<float>                                 Combi_PassiveRandomAddNum;                         // 0x1510(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FPalEggRankInfo>                PalEggRankInfoArray;                               // 0x1520(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EPalElementType, struct FPalDataTableRowName_MapObjectData> PalEggMapObjectIdMap;                              // 0x1530(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<int32, float>                            PalEggHatchingSpeedRateByTemperature;              // 0x1580(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UFont*                                  DebugInfoFont;                                     // 0x15D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxGuildNameLength;                                // 0x15D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JoinGuildRequestInteractLongPushTime;              // 0x15DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TutorialMinDisplayTime;                            // 0x15E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TutorialDisplayTime;                               // 0x15E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EPalUIRewardDisplayType, float>          CommonRewardDisplayTime;                           // 0x15E8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         DeadBodyDestroySecond;                             // 0x1638(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnemyCampRespawnCoolTime;                          // 0x163C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnemyCampDespawnDelayTime;                         // 0x1640(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PalBoxReviveTime;                                  // 0x1644(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AfterNPCTalkDelayTime_Interact;                    // 0x1648(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSprintThreshold;                                // 0x164C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSprintThreshold;                                // 0x1650(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinHPGaugeDisplayTime;                             // 0x1654(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ToggleInteractMoveDelay;                           // 0x1658(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B7A[0x4];                                     // 0x165C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             SoundSourceDataTable;                              // 0x1660(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EPalPlatformType, TSubclassOf<class UPalOptimizeParameterSetting>> OptimizeParameterSettingClass;                     // 0x1668(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	float CalcCaptureRate(float CaptureItemLevel, const class UPalIndividualCharacterHandle* TargetHandle, const class UPalIndividualCharacterHandle* ThrowCharacterHandle);
	float GetCaptureRateByStatus_ForGameSettingBP(const class AActor* TargetPal);
	float GetCollectionDropNumRate(int32 CollectionRank);
	float GetDeforestDamageRate(int32 DeforestRank);
	void GetDeforestRankDefineData(int32 DeforestRank, struct FPalDeforestRankDefineData* OutDefineData);
	float GetEnemyMarkScale(const struct FVector& TargetPosition, const struct FVector& SelfPosition);
	float GetMiningDamageRate(int32 MiningRank);
	void GetMiningRankDefineData(int32 MiningRank, struct FPalMiningRankDefineData* OutDefineData);
	int32 GetSoundRadius_cm(class FName RowName);
	float GetWeakScale(int32 WeakCount);
	bool IsSoundMuteable(class FName RowName);
	bool TryGetWorkSuitabilityDefineData(const EPalWorkSuitability WorkSuitability, struct FPalWorkSuitabilityDefineData* OutDefineData);

	int32 GetCaptureLevelBySphereType(EPalCaptureSphereLevelType SphereType) const;
	const class UPalOptionSubsystem* GetOptionSubsystem(const class UObject* WorldContextObject) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGameSetting">();
	}
	static class UPalGameSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalGameSetting>();
	}
};
static_assert(alignof(UPalGameSetting) == 0x000008, "Wrong alignment on UPalGameSetting");
static_assert(sizeof(UPalGameSetting) == 0x0016B8, "Wrong size on UPalGameSetting");
static_assert(offsetof(UPalGameSetting, CharacterMaxLevel) == 0x000028, "Member 'UPalGameSetting::CharacterMaxLevel' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, GuildCharacterMaxLevel) == 0x00002C, "Member 'UPalGameSetting::GuildCharacterMaxLevel' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, OtomoLevelSyncAddMaxLevel) == 0x000030, "Member 'UPalGameSetting::OtomoLevelSyncAddMaxLevel' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, PlayerSprintStaminaType) == 0x000034, "Member 'UPalGameSetting::PlayerSprintStaminaType' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, CharacterMaxRank) == 0x000038, "Member 'UPalGameSetting::CharacterMaxRank' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, ConsumStamina_PalThrow) == 0x00003C, "Member 'UPalGameSetting::ConsumStamina_PalThrow' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, ReturnOtomoPalCoolTime) == 0x000040, "Member 'UPalGameSetting::ReturnOtomoPalCoolTime' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, OtomoSlotNum) == 0x000044, "Member 'UPalGameSetting::OtomoSlotNum' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, OtomoWazaCoolDownSpeedRate) == 0x000048, "Member 'UPalGameSetting::OtomoWazaCoolDownSpeedRate' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BerserkerOtomoSerchRadius_FromPlayer) == 0x00004C, "Member 'UPalGameSetting::BerserkerOtomoSerchRadius_FromPlayer' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, PlayerHPRateFromRespawn) == 0x000050, "Member 'UPalGameSetting::PlayerHPRateFromRespawn' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, PlayerStomachRateFromRespawn) == 0x000054, "Member 'UPalGameSetting::PlayerStomachRateFromRespawn' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, RarePal_AppearanceProbability) == 0x000058, "Member 'UPalGameSetting::RarePal_AppearanceProbability' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, RarePal_LevelMultiply) == 0x00005C, "Member 'UPalGameSetting::RarePal_LevelMultiply' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BossOrRarePal_TalentMin) == 0x000060, "Member 'UPalGameSetting::BossOrRarePal_TalentMin' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, CharacterRankUpRequiredNumDefault) == 0x000064, "Member 'UPalGameSetting::CharacterRankUpRequiredNumDefault' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, CharacterRankUpRequiredNumMap) == 0x000068, "Member 'UPalGameSetting::CharacterRankUpRequiredNumMap' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, NaturalUpdateSaveParameterInterval) == 0x0000B8, "Member 'UPalGameSetting::NaturalUpdateSaveParameterInterval' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, CharacterHUDDisplayRange) == 0x0000BC, "Member 'UPalGameSetting::CharacterHUDDisplayRange' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, CharacterFedEatingTime) == 0x0000C0, "Member 'UPalGameSetting::CharacterFedEatingTime' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, CharacterStayingSecondsInSpa) == 0x0000C4, "Member 'UPalGameSetting::CharacterStayingSecondsInSpa' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, PalBoxPageNum) == 0x0000C8, "Member 'UPalGameSetting::PalBoxPageNum' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, PalBoxSlotNumInPage) == 0x0000CC, "Member 'UPalGameSetting::PalBoxSlotNumInPage' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, PalBoxTimePeriodRecoverySick) == 0x0000D0, "Member 'UPalGameSetting::PalBoxTimePeriodRecoverySick' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, PlayerBattleJudge_EnemyDistance) == 0x0000D4, "Member 'UPalGameSetting::PlayerBattleJudge_EnemyDistance' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BodyTemperature_SlipDamage_Percent) == 0x0000D8, "Member 'UPalGameSetting::BodyTemperature_SlipDamage_Percent' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BodyTemperature_StomachDecreaceRate) == 0x000128, "Member 'UPalGameSetting::BodyTemperature_StomachDecreaceRate' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, SleepFXDefault) == 0x000178, "Member 'UPalGameSetting::SleepFXDefault' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, LiftupCharacterThrownVelocityScalar) == 0x0001A8, "Member 'UPalGameSetting::LiftupCharacterThrownVelocityScalar' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, LiftupCharacterClearCollisionDelayTime) == 0x0001AC, "Member 'UPalGameSetting::LiftupCharacterClearCollisionDelayTime' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, NickNameMaxLength) == 0x0001B0, "Member 'UPalGameSetting::NickNameMaxLength' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, IntervalForPalAttackFromBall) == 0x0001B4, "Member 'UPalGameSetting::IntervalForPalAttackFromBall' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, CanShootRiderByFullRide) == 0x0001B8, "Member 'UPalGameSetting::CanShootRiderByFullRide' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, HitWazaAttackForMapObject) == 0x0001B9, "Member 'UPalGameSetting::HitWazaAttackForMapObject' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, KnockBack_MaxHpPercent) == 0x0001BC, "Member 'UPalGameSetting::KnockBack_MaxHpPercent' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, KnockBack_Power) == 0x0001C0, "Member 'UPalGameSetting::KnockBack_Power' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, StunTime) == 0x0001C4, "Member 'UPalGameSetting::StunTime' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, StepCooldownTime) == 0x0001C8, "Member 'UPalGameSetting::StepCooldownTime' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, Stun_GunDamageRate) == 0x0001CC, "Member 'UPalGameSetting::Stun_GunDamageRate' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, IsEnableAutoReload) == 0x0001D0, "Member 'UPalGameSetting::IsEnableAutoReload' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, DeadShootImpulseRate) == 0x0001D4, "Member 'UPalGameSetting::DeadShootImpulseRate' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, DeadShootImpulseMax) == 0x0001D8, "Member 'UPalGameSetting::DeadShootImpulseMax' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, OtomoDamageRate_Defense) == 0x0001DC, "Member 'UPalGameSetting::OtomoDamageRate_Defense' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, DamageValueMin_MapObject) == 0x0001E0, "Member 'UPalGameSetting::DamageValueMin_MapObject' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, DamageRate_WealPoint) == 0x0001E4, "Member 'UPalGameSetting::DamageRate_WealPoint' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, DamageRate_StrongPoint) == 0x0001E8, "Member 'UPalGameSetting::DamageRate_StrongPoint' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, DamageRate_SleepHit) == 0x0001EC, "Member 'UPalGameSetting::DamageRate_SleepHit' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, FinalDamageRate_Waza) == 0x0001F0, "Member 'UPalGameSetting::FinalDamageRate_Waza' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, FinalDamageRate_Weapon) == 0x0001F4, "Member 'UPalGameSetting::FinalDamageRate_Weapon' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, FinalDamageRate_Mine) == 0x0001F8, "Member 'UPalGameSetting::FinalDamageRate_Mine' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, FinalDamageRate_MapObject_Waza) == 0x0001FC, "Member 'UPalGameSetting::FinalDamageRate_MapObject_Waza' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, FinalDamageRate_MapObject_Weapon) == 0x000200, "Member 'UPalGameSetting::FinalDamageRate_MapObject_Weapon' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, FinalDamageRate_MapObject_Mine) == 0x000204, "Member 'UPalGameSetting::FinalDamageRate_MapObject_Mine' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, FoliageDefault_Defense) == 0x000208, "Member 'UPalGameSetting::FoliageDefault_Defense' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, WazaAttackerLevelDamage_Power) == 0x00020C, "Member 'UPalGameSetting::WazaAttackerLevelDamage_Power' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, DamageRandomRate_Min) == 0x000210, "Member 'UPalGameSetting::DamageRandomRate_Min' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, DamageRandomRate_Max) == 0x000214, "Member 'UPalGameSetting::DamageRandomRate_Max' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, LevelDamageCorrect) == 0x000218, "Member 'UPalGameSetting::LevelDamageCorrect' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, LevelStatusAccumulateCorrect) == 0x00021C, "Member 'UPalGameSetting::LevelStatusAccumulateCorrect' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, DamageElementMatchRate) == 0x000220, "Member 'UPalGameSetting::DamageElementMatchRate' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, MineAttack_DefensePower) == 0x000224, "Member 'UPalGameSetting::MineAttack_DefensePower' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, StatusCalculate_LevelMultiply_HP) == 0x000228, "Member 'UPalGameSetting::StatusCalculate_LevelMultiply_HP' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, StatusCalculate_TribePlus_HP) == 0x00022C, "Member 'UPalGameSetting::StatusCalculate_TribePlus_HP' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, StatusCalculate_ConstPlus_HP) == 0x000230, "Member 'UPalGameSetting::StatusCalculate_ConstPlus_HP' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, StatusCalculate_LevelMultiply_Attack) == 0x000234, "Member 'UPalGameSetting::StatusCalculate_LevelMultiply_Attack' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, StatusCalculate_ConstPlus_Attack) == 0x000238, "Member 'UPalGameSetting::StatusCalculate_ConstPlus_Attack' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, StatusCalculate_LevelMultiply_Defense) == 0x00023C, "Member 'UPalGameSetting::StatusCalculate_LevelMultiply_Defense' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, StatusCalculate_ConstPlus_Defense) == 0x000240, "Member 'UPalGameSetting::StatusCalculate_ConstPlus_Defense' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, StatusCalculate_TribeMultiply_CraftSpeed) == 0x000244, "Member 'UPalGameSetting::StatusCalculate_TribeMultiply_CraftSpeed' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, StatusCalculate_GenkaiToppa_PerAdd) == 0x000248, "Member 'UPalGameSetting::StatusCalculate_GenkaiToppa_PerAdd' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, StatusCalculate_Talent_PerAdd) == 0x00024C, "Member 'UPalGameSetting::StatusCalculate_Talent_PerAdd' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BreakedWeaponDamageRate) == 0x000250, "Member 'UPalGameSetting::BreakedWeaponDamageRate' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BreakedArmorDefenseRate) == 0x000254, "Member 'UPalGameSetting::BreakedArmorDefenseRate' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, ArmorDurabilityDamageDivide) == 0x000258, "Member 'UPalGameSetting::ArmorDurabilityDamageDivide' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, ClimbingStamina_Move) == 0x00025C, "Member 'UPalGameSetting::ClimbingStamina_Move' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, ClimbingStamina_Jump) == 0x000260, "Member 'UPalGameSetting::ClimbingStamina_Jump' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, RideWazaStaminaRate) == 0x000264, "Member 'UPalGameSetting::RideWazaStaminaRate' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, bIsEnableJumpPreliminary) == 0x000268, "Member 'UPalGameSetting::bIsEnableJumpPreliminary' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, JumpInterval) == 0x00026C, "Member 'UPalGameSetting::JumpInterval' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, FlyMaxHeight) == 0x000270, "Member 'UPalGameSetting::FlyMaxHeight' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, FlyHover_SP) == 0x000274, "Member 'UPalGameSetting::FlyHover_SP' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, FlyHorizon_SP) == 0x000278, "Member 'UPalGameSetting::FlyHorizon_SP' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, FlyHorizon_Dash_SP) == 0x00027C, "Member 'UPalGameSetting::FlyHorizon_Dash_SP' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, FlyVertical_SP) == 0x000280, "Member 'UPalGameSetting::FlyVertical_SP' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, AimingSpeedRateInRide) == 0x000284, "Member 'UPalGameSetting::AimingSpeedRateInRide' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, SlidingEndSpeed) == 0x000288, "Member 'UPalGameSetting::SlidingEndSpeed' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, JumpSP) == 0x00028C, "Member 'UPalGameSetting::JumpSP' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, StepSP) == 0x000290, "Member 'UPalGameSetting::StepSP' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, MeleeAttackSP) == 0x000294, "Member 'UPalGameSetting::MeleeAttackSP' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, SprintSP) == 0x000298, "Member 'UPalGameSetting::SprintSP' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, GliderSP) == 0x00029C, "Member 'UPalGameSetting::GliderSP' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, SwimmingFallWaitTimeSec) == 0x0002A0, "Member 'UPalGameSetting::SwimmingFallWaitTimeSec' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, Swimming_SP_Idle) == 0x0002A4, "Member 'UPalGameSetting::Swimming_SP_Idle' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, Swimming_SP_Swim) == 0x0002A8, "Member 'UPalGameSetting::Swimming_SP_Swim' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, Swimming_SP_DashSwim) == 0x0002AC, "Member 'UPalGameSetting::Swimming_SP_DashSwim' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, FluidFriction) == 0x0002B0, "Member 'UPalGameSetting::FluidFriction' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, OverWeightSpeedZero_AddPercent) == 0x0002B4, "Member 'UPalGameSetting::OverWeightSpeedZero_AddPercent' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, OverWeightMinSpeed) == 0x0002B8, "Member 'UPalGameSetting::OverWeightMinSpeed' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, WalkableFloorAngleForDefault) == 0x0002BC, "Member 'UPalGameSetting::WalkableFloorAngleForDefault' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, WalkableFloorAngleForRide) == 0x0002C0, "Member 'UPalGameSetting::WalkableFloorAngleForRide' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, IsEnableSpeedCollision) == 0x0002C4, "Member 'UPalGameSetting::IsEnableSpeedCollision' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, CollisionDamageMinSpeed) == 0x0002C8, "Member 'UPalGameSetting::CollisionDamageMinSpeed' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, SpeedCollisionDamagePower) == 0x0002CC, "Member 'UPalGameSetting::SpeedCollisionDamagePower' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, CollisionDamageSpeedMultiplay) == 0x0002D0, "Member 'UPalGameSetting::CollisionDamageSpeedMultiplay' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, CollisionDamageWeightThreshold) == 0x0002D4, "Member 'UPalGameSetting::CollisionDamageWeightThreshold' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, AutoHPRegene_Percent_perSecond) == 0x0002D8, "Member 'UPalGameSetting::AutoHPRegene_Percent_perSecond' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, AutoHPRegene_Percent_perSecond_Sleeping) == 0x0002DC, "Member 'UPalGameSetting::AutoHPRegene_Percent_perSecond_Sleeping' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, PosionHPDecrease_Percent_perSecond) == 0x0002E0, "Member 'UPalGameSetting::PosionHPDecrease_Percent_perSecond' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, Starvation_DecreaseHP_Percent_perSecond) == 0x0002E4, "Member 'UPalGameSetting::Starvation_DecreaseHP_Percent_perSecond' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, AutoSANRegene_Percent_perSecond_PalStorage) == 0x0002E8, "Member 'UPalGameSetting::AutoSANRegene_Percent_perSecond_PalStorage' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, StomachDecreace_perSecond_Monster) == 0x0002EC, "Member 'UPalGameSetting::StomachDecreace_perSecond_Monster' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, StomachDecreace_perSecond_Player) == 0x0002F0, "Member 'UPalGameSetting::StomachDecreace_perSecond_Player' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, StomachDecreace_AutoHealing) == 0x0002F4, "Member 'UPalGameSetting::StomachDecreace_AutoHealing' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, StomachDecreace_WorkingRate) == 0x0002F8, "Member 'UPalGameSetting::StomachDecreace_WorkingRate' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, HungerStart_StomachValue) == 0x0002FC, "Member 'UPalGameSetting::HungerStart_StomachValue' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, FullStomachPalStartEatFood) == 0x000300, "Member 'UPalGameSetting::FullStomachPalStartEatFood' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, FullStomachCost_ByWazaUse_Base) == 0x000304, "Member 'UPalGameSetting::FullStomachCost_ByWazaUse_Base' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, FullStomachCost_ByWazaUse_RateMap) == 0x000308, "Member 'UPalGameSetting::FullStomachCost_ByWazaUse_RateMap' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, StomachDecreaceRate_GroundRide_Sprint) == 0x000358, "Member 'UPalGameSetting::StomachDecreaceRate_GroundRide_Sprint' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, StomachDecreaceRate_WaterRide) == 0x00035C, "Member 'UPalGameSetting::StomachDecreaceRate_WaterRide' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, StomachDecreaceRate_WaterRide_Sprint) == 0x000360, "Member 'UPalGameSetting::StomachDecreaceRate_WaterRide_Sprint' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, StomachDecreaceRate_FlyRide) == 0x000364, "Member 'UPalGameSetting::StomachDecreaceRate_FlyRide' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, StomachDecreaceRate_FlyRide_Sprint) == 0x000368, "Member 'UPalGameSetting::StomachDecreaceRate_FlyRide_Sprint' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, RemainderOfLife_Second) == 0x00036C, "Member 'UPalGameSetting::RemainderOfLife_Second' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, HpDecreaseRate_Drowning) == 0x000370, "Member 'UPalGameSetting::HpDecreaseRate_Drowning' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, PlayerShield_RecoverStartTime) == 0x000374, "Member 'UPalGameSetting::PlayerShield_RecoverStartTime' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, PlayerShield_RecoverPercentPerSecond) == 0x000378, "Member 'UPalGameSetting::PlayerShield_RecoverPercentPerSecond' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, StaminaRecover_PercentPerSecond) == 0x00037C, "Member 'UPalGameSetting::StaminaRecover_PercentPerSecond' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, ResuscitationTime) == 0x000380, "Member 'UPalGameSetting::ResuscitationTime' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, PlayerDeath_DropOtomoNum) == 0x000384, "Member 'UPalGameSetting::PlayerDeath_DropOtomoNum' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, PlayerDeath_DropOtomoRange) == 0x000388, "Member 'UPalGameSetting::PlayerDeath_DropOtomoRange' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, PlayerDeath_DropOtomoDisappearHours) == 0x00038C, "Member 'UPalGameSetting::PlayerDeath_DropOtomoDisappearHours' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, PlayerDeath_DropItemStorage_HoursCanOpen) == 0x000390, "Member 'UPalGameSetting::PlayerDeath_DropItemStorage_HoursCanOpen' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, PlayerDyingDamagePerTime) == 0x000394, "Member 'UPalGameSetting::PlayerDyingDamagePerTime' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, ElementStatus_ResistanceInitialValue) == 0x000398, "Member 'UPalGameSetting::ElementStatus_ResistanceInitialValue' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, ElementStatus_AutoDecreasePerSecond) == 0x00039C, "Member 'UPalGameSetting::ElementStatus_AutoDecreasePerSecond' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, ElementStatus_ResetResistanceSecond) == 0x0003A0, "Member 'UPalGameSetting::ElementStatus_ResetResistanceSecond' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BuildExp) == 0x0003A4, "Member 'UPalGameSetting::BuildExp' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, CraftExp) == 0x0003A8, "Member 'UPalGameSetting::CraftExp' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, PickupItemOnLevelExp) == 0x0003AC, "Member 'UPalGameSetting::PickupItemOnLevelExp' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, MapObjectDestroyProceedExp) == 0x0003B0, "Member 'UPalGameSetting::MapObjectDestroyProceedExp' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, MapObjectDistributeExpRange) == 0x0003B4, "Member 'UPalGameSetting::MapObjectDistributeExpRange' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, OtomoExp_LevelDifferenceMap) == 0x0003B8, "Member 'UPalGameSetting::OtomoExp_LevelDifferenceMap' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, OtomoExp_HigherPlayerLevel) == 0x000408, "Member 'UPalGameSetting::OtomoExp_HigherPlayerLevel' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, CaptureExpBonus_Tier1_TableReferenceNum) == 0x00040C, "Member 'UPalGameSetting::CaptureExpBonus_Tier1_TableReferenceNum' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, CaptureExpBonus_Tier2_TableReferenceNum) == 0x000410, "Member 'UPalGameSetting::CaptureExpBonus_Tier2_TableReferenceNum' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, CaptureExpBonus_Tier3_TableReferenceNum) == 0x000414, "Member 'UPalGameSetting::CaptureExpBonus_Tier3_TableReferenceNum' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, NewGameOtomoPalSet) == 0x000418, "Member 'UPalGameSetting::NewGameOtomoPalSet' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, NewGameInventoryItemSet) == 0x000428, "Member 'UPalGameSetting::NewGameInventoryItemSet' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, NewGameLoadoutItemSet) == 0x000478, "Member 'UPalGameSetting::NewGameLoadoutItemSet' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, WorldHUDDisplayOffsetDefault) == 0x0004C8, "Member 'UPalGameSetting::WorldHUDDisplayOffsetDefault' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, WorldHUDDisplayRangeDefault) == 0x0004E0, "Member 'UPalGameSetting::WorldHUDDisplayRangeDefault' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, WorldHUDDetailDisplayRange) == 0x0004E4, "Member 'UPalGameSetting::WorldHUDDetailDisplayRange' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, FarmCropWaterItemIds) == 0x0004E8, "Member 'UPalGameSetting::FarmCropWaterItemIds' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, FarmCropGrowupSpeedBySec) == 0x0004F8, "Member 'UPalGameSetting::FarmCropGrowupSpeedBySec' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, FarmCropIncreaseRateByWaterFillRate) == 0x0004FC, "Member 'UPalGameSetting::FarmCropIncreaseRateByWaterFillRate' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, MaxMoney) == 0x000500, "Member 'UPalGameSetting::MaxMoney' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, DefaultMoney) == 0x000510, "Member 'UPalGameSetting::DefaultMoney' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, SneakAttackBackJudgeAngle_Degree) == 0x000514, "Member 'UPalGameSetting::SneakAttackBackJudgeAngle_Degree' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, SneakAttack_PalMeleeWaza_AttackRate) == 0x000518, "Member 'UPalGameSetting::SneakAttack_PalMeleeWaza_AttackRate' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, AutoAimCameraMoveRate) == 0x00051C, "Member 'UPalGameSetting::AutoAimCameraMoveRate' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, AutoAimCharacterMoveRate) == 0x000520, "Member 'UPalGameSetting::AutoAimCharacterMoveRate' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, AutoAimCameraAdsorptionSpeed) == 0x000524, "Member 'UPalGameSetting::AutoAimCameraAdsorptionSpeed' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, AutoAimLockOnScreenSpaceRate) == 0x000528, "Member 'UPalGameSetting::AutoAimLockOnScreenSpaceRate' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, ForceAutoAimTime) == 0x00052C, "Member 'UPalGameSetting::ForceAutoAimTime' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, SellItemRate) == 0x000530, "Member 'UPalGameSetting::SellItemRate' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, PalPriceConstantValueA) == 0x000534, "Member 'UPalGameSetting::PalPriceConstantValueA' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, PalPriceConstantValueB) == 0x000538, "Member 'UPalGameSetting::PalPriceConstantValueB' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, SellPalRate) == 0x00053C, "Member 'UPalGameSetting::SellPalRate' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, SearchRangeOnThrowedCharacterLanded) == 0x000540, "Member 'UPalGameSetting::SearchRangeOnThrowedCharacterLanded' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, WorkCompleteReactionRangeFromPlayer) == 0x000544, "Member 'UPalGameSetting::WorkCompleteReactionRangeFromPlayer' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, WorkerCollectResourceStackMaxNum) == 0x000548, "Member 'UPalGameSetting::WorkerCollectResourceStackMaxNum' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, FacialTypeHardWork) == 0x00054C, "Member 'UPalGameSetting::FacialTypeHardWork' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, Timeout_WorkerApproachToTarget) == 0x000550, "Member 'UPalGameSetting::Timeout_WorkerApproachToTarget' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, WaitTime_WorkRepairFailedFindPath) == 0x000554, "Member 'UPalGameSetting::WaitTime_WorkRepairFailedFindPath' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, WorkerWaitingNotifyInterval) == 0x000558, "Member 'UPalGameSetting::WorkerWaitingNotifyInterval' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, WarpCheckInterval) == 0x00055C, "Member 'UPalGameSetting::WarpCheckInterval' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, WarpCheckMoveDistanceThreshold) == 0x000560, "Member 'UPalGameSetting::WarpCheckMoveDistanceThreshold' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, WarpThreshold) == 0x000564, "Member 'UPalGameSetting::WarpThreshold' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, AutoDecreaseHateValue_PercentMaxHP_PerSecond) == 0x000568, "Member 'UPalGameSetting::AutoDecreaseHateValue_PercentMaxHP_PerSecond' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, HateDecreaseDamageRate) == 0x00056C, "Member 'UPalGameSetting::HateDecreaseDamageRate' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, Hate_ForceUp_HPRate_OtomoActive) == 0x000570, "Member 'UPalGameSetting::Hate_ForceUp_HPRate_OtomoActive' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, Hate_ForceUp_HPRate_IncidentBattle) == 0x000574, "Member 'UPalGameSetting::Hate_ForceUp_HPRate_IncidentBattle' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, CombatEndDistance_BattleStartSelfPos_To_SelfPos) == 0x000578, "Member 'UPalGameSetting::CombatEndDistance_BattleStartSelfPos_To_SelfPos' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, CombatEndDistance_BattleStartSelfPos_To_TargetPos) == 0x00057C, "Member 'UPalGameSetting::CombatEndDistance_BattleStartSelfPos_To_TargetPos' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, CombatEndDistance_BattleStartSelfPos_To_TargetPos_AddFirstTargetDistance) == 0x000580, "Member 'UPalGameSetting::CombatEndDistance_BattleStartSelfPos_To_TargetPos_AddFirstTargetDistance' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, NavigationAreaDivideExtents) == 0x000584, "Member 'UPalGameSetting::NavigationAreaDivideExtents' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, NavigationUpdateFrequencySettingsFromPlayer) == 0x000588, "Member 'UPalGameSetting::NavigationUpdateFrequencySettingsFromPlayer' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, AutoSaveSpan) == 0x000598, "Member 'UPalGameSetting::AutoSaveSpan' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, SaveDataName_WorldBaseInfo) == 0x00059C, "Member 'UPalGameSetting::SaveDataName_WorldBaseInfo' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, SaveDataName_World) == 0x0005A4, "Member 'UPalGameSetting::SaveDataName_World' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, SaveDataName_PlayerDirectory) == 0x0005AC, "Member 'UPalGameSetting::SaveDataName_PlayerDirectory' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, SaveDataName_LocalData) == 0x0005B4, "Member 'UPalGameSetting::SaveDataName_LocalData' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, SaveDataName_WorldOption) == 0x0005BC, "Member 'UPalGameSetting::SaveDataName_WorldOption' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, MaxWorldDataNumMap) == 0x0005C8, "Member 'UPalGameSetting::MaxWorldDataNumMap' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, PalWorldTime_GameStartHour) == 0x000618, "Member 'UPalGameSetting::PalWorldTime_GameStartHour' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, PalWorldMinutes_RealOneMinute) == 0x00061C, "Member 'UPalGameSetting::PalWorldMinutes_RealOneMinute' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, NightStartHour) == 0x000620, "Member 'UPalGameSetting::NightStartHour' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, NightEndHour) == 0x000624, "Member 'UPalGameSetting::NightEndHour' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, PlayerMorningHour) == 0x000628, "Member 'UPalGameSetting::PlayerMorningHour' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, PlayerSleepStartHour) == 0x00062C, "Member 'UPalGameSetting::PlayerSleepStartHour' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, NightSkipWaitSecond) == 0x000630, "Member 'UPalGameSetting::NightSkipWaitSecond' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, LocalPlayerAndOtomo_LightRangeScale) == 0x000634, "Member 'UPalGameSetting::LocalPlayerAndOtomo_LightRangeScale' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BuildBaseUnitGridDefinition) == 0x000638, "Member 'UPalGameSetting::BuildBaseUnitGridDefinition' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BuildSimulationVerticalAdjustRate) == 0x000650, "Member 'UPalGameSetting::BuildSimulationVerticalAdjustRate' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BuildSimulationVerticalMinLength) == 0x000654, "Member 'UPalGameSetting::BuildSimulationVerticalMinLength' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BuildSimulationFoundationFloatingAllowance) == 0x000658, "Member 'UPalGameSetting::BuildSimulationFoundationFloatingAllowance' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BuildSimulationFoundationCheckCollisionScale) == 0x000660, "Member 'UPalGameSetting::BuildSimulationFoundationCheckCollisionScale' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BuildSimulationRoofHeightOffset) == 0x0006B0, "Member 'UPalGameSetting::BuildSimulationRoofHeightOffset' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BuildSimulationStairHeightOffset) == 0x0006B4, "Member 'UPalGameSetting::BuildSimulationStairHeightOffset' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BuildSimulationLeanAngleMax) == 0x0006B8, "Member 'UPalGameSetting::BuildSimulationLeanAngleMax' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BuildingProgressInterpolationSpeed) == 0x0006BC, "Member 'UPalGameSetting::BuildingProgressInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, PlayerRecord_BuildingObjectMaxNum) == 0x0006C0, "Member 'UPalGameSetting::PlayerRecord_BuildingObjectMaxNum' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BuildingMaxZ) == 0x0006C4, "Member 'UPalGameSetting::BuildingMaxZ' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BuildObj_HatchedPalCharacterLevel) == 0x0006C8, "Member 'UPalGameSetting::BuildObj_HatchedPalCharacterLevel' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BuildObj_DamageScarecrowStartRecoveryTime) == 0x0006CC, "Member 'UPalGameSetting::BuildObj_DamageScarecrowStartRecoveryTime' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BaseCampAreaRange) == 0x0006D0, "Member 'UPalGameSetting::BaseCampAreaRange' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BaseCampPalFindWorkRange) == 0x0006D4, "Member 'UPalGameSetting::BaseCampPalFindWorkRange' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, PalArriveToWorkLocationRange) == 0x0006D8, "Member 'UPalGameSetting::PalArriveToWorkLocationRange' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, PalArriveToWorkLocationRangeZ) == 0x0006DC, "Member 'UPalGameSetting::PalArriveToWorkLocationRangeZ' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BaseCampNeighborMinimumDistance) == 0x0006E0, "Member 'UPalGameSetting::BaseCampNeighborMinimumDistance' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, PalRotateSpeedToWork) == 0x0006E4, "Member 'UPalGameSetting::PalRotateSpeedToWork' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BaseCampFoliageWorkableRange) == 0x0006E8, "Member 'UPalGameSetting::BaseCampFoliageWorkableRange' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BaseCampHungerApproachToPlayer) == 0x0006EC, "Member 'UPalGameSetting::BaseCampHungerApproachToPlayer' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BaseCampHungerUnreachableObjectTimeoutRealSeconds) == 0x0006F0, "Member 'UPalGameSetting::BaseCampHungerUnreachableObjectTimeoutRealSeconds' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, HungerHUDDisplayRange) == 0x0006F4, "Member 'UPalGameSetting::HungerHUDDisplayRange' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, WorkAmountBySecForPlayer) == 0x0006F8, "Member 'UPalGameSetting::WorkAmountBySecForPlayer' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BaseCampWorkerEventTriggerInterval) == 0x0006FC, "Member 'UPalGameSetting::BaseCampWorkerEventTriggerInterval' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BaseCampWorkerEventTriggerProbability) == 0x000700, "Member 'UPalGameSetting::BaseCampWorkerEventTriggerProbability' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BaseCampWorkerSanityWarningThreshold) == 0x000704, "Member 'UPalGameSetting::BaseCampWorkerSanityWarningThreshold' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BaseCampWorkerFinishEatingFullStomach) == 0x000708, "Member 'UPalGameSetting::BaseCampWorkerFinishEatingFullStomach' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BaseCampWorkerFinishEatingSanity) == 0x00070C, "Member 'UPalGameSetting::BaseCampWorkerFinishEatingSanity' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BaseCampWorkerFinishEatCount) == 0x000710, "Member 'UPalGameSetting::BaseCampWorkerFinishEatCount' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BaseCampWorkerRecoverHungryTurnToTargetTimeout) == 0x000714, "Member 'UPalGameSetting::BaseCampWorkerRecoverHungryTurnToTargetTimeout' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BaseCampWorkerStartSleepHpPercentage) == 0x000718, "Member 'UPalGameSetting::BaseCampWorkerStartSleepHpPercentage' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BaseCampWorkerSleepInPlaceRecoverSanityRate) == 0x00071C, "Member 'UPalGameSetting::BaseCampWorkerSleepInPlaceRecoverSanityRate' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BaseCampWorkerDistancePickableItem) == 0x000720, "Member 'UPalGameSetting::BaseCampWorkerDistancePickableItem' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BaseCampBuildingItemContainerPriority) == 0x000728, "Member 'UPalGameSetting::BaseCampBuildingItemContainerPriority' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, FoliageRespawnFailedExtraRangeOfBaseCamp) == 0x000738, "Member 'UPalGameSetting::FoliageRespawnFailedExtraRangeOfBaseCamp' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BaseCampPalCombatRange_AddCampRange) == 0x00073C, "Member 'UPalGameSetting::BaseCampPalCombatRange_AddCampRange' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BaseCampPalWalkTime_BeforeSleep) == 0x000740, "Member 'UPalGameSetting::BaseCampPalWalkTime_BeforeSleep' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BaseCampTimeFinishBattleModeAfterEmptyEnemy) == 0x000748, "Member 'UPalGameSetting::BaseCampTimeFinishBattleModeAfterEmptyEnemy' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BaseCampWorkerMoveModeChangeThreshold) == 0x00074C, "Member 'UPalGameSetting::BaseCampWorkerMoveModeChangeThreshold' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BaseCampWorkerDirectorTickForAssignWorkByCount) == 0x000750, "Member 'UPalGameSetting::BaseCampWorkerDirectorTickForAssignWorkByCount' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BaseCampWorkerTimeDetectContinuousStuck) == 0x000754, "Member 'UPalGameSetting::BaseCampWorkerTimeDetectContinuousStuck' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BaseCampWorkerMaxTimeReturnBack) == 0x000758, "Member 'UPalGameSetting::BaseCampWorkerMaxTimeReturnBack' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BaseCampWorkerLookToTargetWork) == 0x00075C, "Member 'UPalGameSetting::BaseCampWorkerLookToTargetWork' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, ReviveWorkAdditionalRange) == 0x000760, "Member 'UPalGameSetting::ReviveWorkAdditionalRange' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, WorkAroundRangeDefault) == 0x000764, "Member 'UPalGameSetting::WorkAroundRangeDefault' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, IssueNotifyWorkTypes) == 0x000768, "Member 'UPalGameSetting::IssueNotifyWorkTypes' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, WorkAmountByManMonth) == 0x000778, "Member 'UPalGameSetting::WorkAmountByManMonth' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, WorkNotifyDelayTime) == 0x00077C, "Member 'UPalGameSetting::WorkNotifyDelayTime' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, WorkFinishDelayCallAddWorkNotifyDelayTime) == 0x000780, "Member 'UPalGameSetting::WorkFinishDelayCallAddWorkNotifyDelayTime' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, WorkIgnitionTorchWaitTime) == 0x000784, "Member 'UPalGameSetting::WorkIgnitionTorchWaitTime' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, WorkAssignFailedLogTypeMap) == 0x000788, "Member 'UPalGameSetting::WorkAssignFailedLogTypeMap' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, WorkTransportingSpeedRate) == 0x0007D8, "Member 'UPalGameSetting::WorkTransportingSpeedRate' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BaseCampNotTransportItemBlackList) == 0x0007E0, "Member 'UPalGameSetting::BaseCampNotTransportItemBlackList' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, WorkTransportingDelayTimeDropItem) == 0x0007F0, "Member 'UPalGameSetting::WorkTransportingDelayTimeDropItem' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BaseCampStopProvideEnergyInterval) == 0x0007F4, "Member 'UPalGameSetting::BaseCampStopProvideEnergyInterval' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BaseCampPassiveEffectWorkHardInfoMap) == 0x0007F8, "Member 'UPalGameSetting::BaseCampPassiveEffectWorkHardInfoMap' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BaseCampWorkCollectionRestoreStashSeconds) == 0x000848, "Member 'UPalGameSetting::BaseCampWorkCollectionRestoreStashSeconds' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, WorkTypeAssignPriorityOrder) == 0x000850, "Member 'UPalGameSetting::WorkTypeAssignPriorityOrder' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, WorkAssignDefineData_Build) == 0x000860, "Member 'UPalGameSetting::WorkAssignDefineData_Build' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, WorkAssignDefineData_FoliageWork) == 0x0008A0, "Member 'UPalGameSetting::WorkAssignDefineData_FoliageWork' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, WorkAssignDefineData_ReviveCharacterWork) == 0x0008E0, "Member 'UPalGameSetting::WorkAssignDefineData_ReviveCharacterWork' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, WorkAssignDefineData_TransportItemInBaseCamp) == 0x000920, "Member 'UPalGameSetting::WorkAssignDefineData_TransportItemInBaseCamp' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, WorkAssignDefineData_RepairBuildObjectInBaseCamp) == 0x000960, "Member 'UPalGameSetting::WorkAssignDefineData_RepairBuildObjectInBaseCamp' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, WorkAssignDefineData_BreedFarm) == 0x0009A0, "Member 'UPalGameSetting::WorkAssignDefineData_BreedFarm' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, WorkAssignDefineData_ExtinguishBurn) == 0x0009E0, "Member 'UPalGameSetting::WorkAssignDefineData_ExtinguishBurn' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, WorkSuitabilityMaxRank) == 0x000A20, "Member 'UPalGameSetting::WorkSuitabilityMaxRank' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, WorkSuitabilityDefineDataMap) == 0x000A28, "Member 'UPalGameSetting::WorkSuitabilityDefineDataMap' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, WorkSuitabilityDefineData_Collection) == 0x000A78, "Member 'UPalGameSetting::WorkSuitabilityDefineData_Collection' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, WorkSuitabilityDefineData_Deforest) == 0x000AA0, "Member 'UPalGameSetting::WorkSuitabilityDefineData_Deforest' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, WorkSuitabilityDefineData_Mining) == 0x000AC8, "Member 'UPalGameSetting::WorkSuitabilityDefineData_Mining' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, DropItemWaitInsertMaxNumPerTick) == 0x000AF0, "Member 'UPalGameSetting::DropItemWaitInsertMaxNumPerTick' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, ItemFilterPreference) == 0x000AF8, "Member 'UPalGameSetting::ItemFilterPreference' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, DungeonSpawnParameterDefault) == 0x000B48, "Member 'UPalGameSetting::DungeonSpawnParameterDefault' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, GamePad_NotAimCameraRotateSpeed_DegreePerSecond) == 0x000B58, "Member 'UPalGameSetting::GamePad_NotAimCameraRotateSpeed_DegreePerSecond' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, GamePad_AimCameraRotateSpeed_DegreePerSecond) == 0x000B5C, "Member 'UPalGameSetting::GamePad_AimCameraRotateSpeed_DegreePerSecond' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, Mouse_NotAimCameraRotateSpeed) == 0x000B60, "Member 'UPalGameSetting::Mouse_NotAimCameraRotateSpeed' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, Mouse_AimCameraRotateSpeed) == 0x000B64, "Member 'UPalGameSetting::Mouse_AimCameraRotateSpeed' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, YawCameraMaxSpeedRate) == 0x000B68, "Member 'UPalGameSetting::YawCameraMaxSpeedRate' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, TimeForCameraMaxSpeed) == 0x000B6C, "Member 'UPalGameSetting::TimeForCameraMaxSpeed' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, AimInterpInterval) == 0x000B70, "Member 'UPalGameSetting::AimInterpInterval' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, InvaderSelfDeleteAddTime) == 0x000B74, "Member 'UPalGameSetting::InvaderSelfDeleteAddTime' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, VisitorSelfDeleteTime) == 0x000B78, "Member 'UPalGameSetting::VisitorSelfDeleteTime' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, InvadeProbability) == 0x000B7C, "Member 'UPalGameSetting::InvadeProbability' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, InvadeOccurablePlayerLevel) == 0x000B80, "Member 'UPalGameSetting::InvadeOccurablePlayerLevel' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, InvadeJudgmentInterval_Minutes) == 0x000B84, "Member 'UPalGameSetting::InvadeJudgmentInterval_Minutes' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, InvadeCollTime_Max_Minutes) == 0x000B88, "Member 'UPalGameSetting::InvadeCollTime_Max_Minutes' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, InvadeCollTime_Min_Minutes) == 0x000B8C, "Member 'UPalGameSetting::InvadeCollTime_Min_Minutes' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, InvadeReturnTime_Minutes) == 0x000B90, "Member 'UPalGameSetting::InvadeReturnTime_Minutes' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, InvadeStartPoint_BaseCampRadius_Min_cm) == 0x000B94, "Member 'UPalGameSetting::InvadeStartPoint_BaseCampRadius_Min_cm' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, InvadeStartPoint_BaseCampRadius_Max_cm) == 0x000B98, "Member 'UPalGameSetting::InvadeStartPoint_BaseCampRadius_Max_cm' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, VisitorNPCProbability) == 0x000B9C, "Member 'UPalGameSetting::VisitorNPCProbability' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, VisitorNPCReturnTime_Minutes) == 0x000BA0, "Member 'UPalGameSetting::VisitorNPCReturnTime_Minutes' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, RidingAimOpacity) == 0x000BA4, "Member 'UPalGameSetting::RidingAimOpacity' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, HideUITimeWhenNotConflict) == 0x000BA8, "Member 'UPalGameSetting::HideUITimeWhenNotConflict' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, FirstCapturedUIDisplayTime) == 0x000BAC, "Member 'UPalGameSetting::FirstCapturedUIDisplayTime' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, CapturedUIDisplayTime) == 0x000BB0, "Member 'UPalGameSetting::CapturedUIDisplayTime' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, FirstActivatedOtomoInfoDisplayTime) == 0x000BB4, "Member 'UPalGameSetting::FirstActivatedOtomoInfoDisplayTime' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, PlayerLevelUpUIDIsplayTime) == 0x000BB8, "Member 'UPalGameSetting::PlayerLevelUpUIDIsplayTime' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, PlayerExpGaugeUIDisplayTime) == 0x000BBC, "Member 'UPalGameSetting::PlayerExpGaugeUIDisplayTime' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, OtomoExpGaugeUIDisplayTime) == 0x000BC0, "Member 'UPalGameSetting::OtomoExpGaugeUIDisplayTime' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, NpcGaugeDisplayDistance) == 0x000BC4, "Member 'UPalGameSetting::NpcGaugeDisplayDistance' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, NpcGaugeDisplayRange_CameraSight) == 0x000BC8, "Member 'UPalGameSetting::NpcGaugeDisplayRange_CameraSight' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, GuildMemberGaugeDisplayDIstance) == 0x000BCC, "Member 'UPalGameSetting::GuildMemberGaugeDisplayDIstance' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, DownPlayerLoupeDisplayDistance) == 0x000BD0, "Member 'UPalGameSetting::DownPlayerLoupeDisplayDistance' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, DownPlayerGaugeDisplayRange_CameraSight) == 0x000BD4, "Member 'UPalGameSetting::DownPlayerGaugeDisplayRange_CameraSight' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, ReticleOffsetRate) == 0x000BD8, "Member 'UPalGameSetting::ReticleOffsetRate' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, LowHealthEffectParcent) == 0x000BE8, "Member 'UPalGameSetting::LowHealthEffectParcent' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, DamageTextMargineMap) == 0x000BF0, "Member 'UPalGameSetting::DamageTextMargineMap' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, DamageTextDisplayLength) == 0x000C40, "Member 'UPalGameSetting::DamageTextDisplayLength' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, DamageTextMaxOffset) == 0x000C48, "Member 'UPalGameSetting::DamageTextMaxOffset' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, DamageTextOffsetInterpolationLength) == 0x000C58, "Member 'UPalGameSetting::DamageTextOffsetInterpolationLength' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, DamageTextScaleMap) == 0x000C60, "Member 'UPalGameSetting::DamageTextScaleMap' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, DamageTextRandomOffset) == 0x000CB0, "Member 'UPalGameSetting::DamageTextRandomOffset' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, StrongEnemyMarkLevel) == 0x000CC0, "Member 'UPalGameSetting::StrongEnemyMarkLevel' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, OtomoInteractUIDisplayDistance) == 0x000CC4, "Member 'UPalGameSetting::OtomoInteractUIDisplayDistance' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, EnemyMarkUIMinScale) == 0x000CC8, "Member 'UPalGameSetting::EnemyMarkUIMinScale' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, EnemyMarkScaleInterpolationLength) == 0x000CCC, "Member 'UPalGameSetting::EnemyMarkScaleInterpolationLength' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, NpcHPGaugeGlobalOffset) == 0x000CD0, "Member 'UPalGameSetting::NpcHPGaugeGlobalOffset' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, DelayGaugeStartTime) == 0x000CE0, "Member 'UPalGameSetting::DelayGaugeStartTime' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, DelayGaugeProgressPerSecond) == 0x000CE4, "Member 'UPalGameSetting::DelayGaugeProgressPerSecond' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, InventoryWeaponRangeMaxBorder) == 0x000CE8, "Member 'UPalGameSetting::InventoryWeaponRangeMaxBorder' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, InventoryWeaponStabilityMinBorder) == 0x000CEC, "Member 'UPalGameSetting::InventoryWeaponStabilityMinBorder' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, InventoryWeaponAccuracyMinBorder) == 0x000CF0, "Member 'UPalGameSetting::InventoryWeaponAccuracyMinBorder' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, WorldmapUIMaskClearSize) == 0x000CF4, "Member 'UPalGameSetting::WorldmapUIMaskClearSize' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, WorldmapUIFTMergeDistance) == 0x000CF8, "Member 'UPalGameSetting::WorldmapUIFTMergeDistance' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, WorldmapUIMaxMarker) == 0x000CFC, "Member 'UPalGameSetting::WorldmapUIMaxMarker' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, NPCHPGaugeUpdateSpan) == 0x000D00, "Member 'UPalGameSetting::NPCHPGaugeUpdateSpan' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, CaptureFailedUIDisplayTime) == 0x000D04, "Member 'UPalGameSetting::CaptureFailedUIDisplayTime' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, CaptureSphereSortArray) == 0x000D08, "Member 'UPalGameSetting::CaptureSphereSortArray' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, OpenGameOverUITime) == 0x000D18, "Member 'UPalGameSetting::OpenGameOverUITime' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BlockRespawnTime) == 0x000D1C, "Member 'UPalGameSetting::BlockRespawnTime' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, InventoryWeightAlertRate) == 0x000D20, "Member 'UPalGameSetting::InventoryWeightAlertRate' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, InventoryWeightGaugeDIsplayTime) == 0x000D24, "Member 'UPalGameSetting::InventoryWeightGaugeDIsplayTime' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, OtomoLevelUpNoticeUIDisplayTime) == 0x000D28, "Member 'UPalGameSetting::OtomoLevelUpNoticeUIDisplayTime' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, OtomoMasteredWazaNoticeUIDisplayTime) == 0x000D2C, "Member 'UPalGameSetting::OtomoMasteredWazaNoticeUIDisplayTime' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, ProgressGaugeInterpolationSpeed) == 0x000D30, "Member 'UPalGameSetting::ProgressGaugeInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, TeleportFadeInTime) == 0x000D34, "Member 'UPalGameSetting::TeleportFadeInTime' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, TeleportFadeOutTime) == 0x000D38, "Member 'UPalGameSetting::TeleportFadeOutTime' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, PlayerTeleportTimeoutTime) == 0x000D3C, "Member 'UPalGameSetting::PlayerTeleportTimeoutTime' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, PassiveSkillAppendNumWeights) == 0x000D40, "Member 'UPalGameSetting::PassiveSkillAppendNumWeights' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, bIsEggLauncherExplosion) == 0x000D50, "Member 'UPalGameSetting::bIsEggLauncherExplosion' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, ThrowPalBattleRadius) == 0x000D54, "Member 'UPalGameSetting::ThrowPalBattleRadius' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, ThrowPalWorkRadius) == 0x000D58, "Member 'UPalGameSetting::ThrowPalWorkRadius' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, RopeHitPowe) == 0x000D5C, "Member 'UPalGameSetting::RopeHitPowe' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, RopePullPower) == 0x000D60, "Member 'UPalGameSetting::RopePullPower' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, DefaultMaxInventoryWeight) == 0x000D64, "Member 'UPalGameSetting::DefaultMaxInventoryWeight' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, RaycastLengthForDetectIndoor) == 0x000D68, "Member 'UPalGameSetting::RaycastLengthForDetectIndoor' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, MapObjectConnectAnyPlaceRaycastLength) == 0x000D6C, "Member 'UPalGameSetting::MapObjectConnectAnyPlaceRaycastLength' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, ShootingTargetRayCastDistance) == 0x000D70, "Member 'UPalGameSetting::ShootingTargetRayCastDistance' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, CaptureJudgeRateArray) == 0x000D78, "Member 'UPalGameSetting::CaptureJudgeRateArray' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, CaptureBallBoundCountMax) == 0x000D88, "Member 'UPalGameSetting::CaptureBallBoundCountMax' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, ExceptCapturedItemList) == 0x000D90, "Member 'UPalGameSetting::ExceptCapturedItemList' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, CaptureSphereLevelMap) == 0x000DA0, "Member 'UPalGameSetting::CaptureSphereLevelMap' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, CaptureRateAddByStatusMap) == 0x000DF0, "Member 'UPalGameSetting::CaptureRateAddByStatusMap' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, IgnoreFirstCaptureFailedHPRate) == 0x000E40, "Member 'UPalGameSetting::IgnoreFirstCaptureFailedHPRate' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, CaptureRateAdd_ByLegHold) == 0x000E44, "Member 'UPalGameSetting::CaptureRateAdd_ByLegHold' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, LongPressInterval) == 0x000E48, "Member 'UPalGameSetting::LongPressInterval' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, LongPressInterval_EnemyCampCage) == 0x000E4C, "Member 'UPalGameSetting::LongPressInterval_EnemyCampCage' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, LongPressInterval_StartRaidBoss) == 0x000E50, "Member 'UPalGameSetting::LongPressInterval_StartRaidBoss' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, LongPressInterval_GetHatchedPal) == 0x000E54, "Member 'UPalGameSetting::LongPressInterval_GetHatchedPal' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, CrouchLockAttenuation) == 0x000E58, "Member 'UPalGameSetting::CrouchLockAttenuation' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, IsEnableCharacterWazaScale) == 0x000E5C, "Member 'UPalGameSetting::IsEnableCharacterWazaScale' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, IsOverrideDamageAdditiveAnimation) == 0x000E5D, "Member 'UPalGameSetting::IsOverrideDamageAdditiveAnimation' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BlinkInterval) == 0x000E60, "Member 'UPalGameSetting::BlinkInterval' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, CrimeStateMaintainDurationBaseDefault) == 0x000E64, "Member 'UPalGameSetting::CrimeStateMaintainDurationBaseDefault' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, TechnologyPointPerLevel) == 0x000E68, "Member 'UPalGameSetting::TechnologyPointPerLevel' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, bossTechnologyPointPerTowerBoss) == 0x000E6C, "Member 'UPalGameSetting::bossTechnologyPointPerTowerBoss' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, bossTechnologyPointPerNormalBoss) == 0x000E70, "Member 'UPalGameSetting::bossTechnologyPointPerNormalBoss' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, DefaultUnlockTechnology) == 0x000E78, "Member 'UPalGameSetting::DefaultUnlockTechnology' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, DefaultTechnologyPoint) == 0x000E88, "Member 'UPalGameSetting::DefaultTechnologyPoint' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, TechnologyPoint_UnlockFastTravel) == 0x000E8C, "Member 'UPalGameSetting::TechnologyPoint_UnlockFastTravel' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, DecreaseSanity_DamagedMultiply) == 0x000E90, "Member 'UPalGameSetting::DecreaseSanity_DamagedMultiply' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, FullStomachPercent_RecoverySanity) == 0x000E94, "Member 'UPalGameSetting::FullStomachPercent_RecoverySanity' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, RecoverySanity_FullStomach) == 0x000E98, "Member 'UPalGameSetting::RecoverySanity_FullStomach' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, DecreaseSanity_Hunger) == 0x000E9C, "Member 'UPalGameSetting::DecreaseSanity_Hunger' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, DecreaseSanity_Starvation) == 0x000EA0, "Member 'UPalGameSetting::DecreaseSanity_Starvation' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, Spawner_IsCheckLoadedWorldPartition) == 0x000EA4, "Member 'UPalGameSetting::Spawner_IsCheckLoadedWorldPartition' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, SpawnerDisableDistanceCM_FromBaseCamp) == 0x000EA8, "Member 'UPalGameSetting::SpawnerDisableDistanceCM_FromBaseCamp' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, Spawner_DefaultSpawnRadius_S) == 0x000EAC, "Member 'UPalGameSetting::Spawner_DefaultSpawnRadius_S' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, Spawner_DefaultSpawnRadius_M) == 0x000EB0, "Member 'UPalGameSetting::Spawner_DefaultSpawnRadius_M' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, Spawner_DefaultSpawnRadius_L) == 0x000EB4, "Member 'UPalGameSetting::Spawner_DefaultSpawnRadius_L' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, Spawner_DefaultSpawnRadius_NPC) == 0x000EB8, "Member 'UPalGameSetting::Spawner_DefaultSpawnRadius_NPC' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, Spawner_DefaultDespawnDistance_S) == 0x000EBC, "Member 'UPalGameSetting::Spawner_DefaultDespawnDistance_S' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, Spawner_DefaultDespawnDistance_M) == 0x000EC0, "Member 'UPalGameSetting::Spawner_DefaultDespawnDistance_M' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, Spawner_DefaultDespawnDistance_L) == 0x000EC4, "Member 'UPalGameSetting::Spawner_DefaultDespawnDistance_L' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, Spawner_DefaultDespawnDistance_NPC) == 0x000EC8, "Member 'UPalGameSetting::Spawner_DefaultDespawnDistance_NPC' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, CharacterHeadMeshDataTable) == 0x000ED0, "Member 'UPalGameSetting::CharacterHeadMeshDataTable' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, CharacterBodyMeshDataTable) == 0x000ED8, "Member 'UPalGameSetting::CharacterBodyMeshDataTable' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, CharacterHairMeshDataTable) == 0x000EE0, "Member 'UPalGameSetting::CharacterHairMeshDataTable' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, CharacterEquipmentArmorMeshDataTable) == 0x000EE8, "Member 'UPalGameSetting::CharacterEquipmentArmorMeshDataTable' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, CharacterEyeMaterialDataTable) == 0x000EF0, "Member 'UPalGameSetting::CharacterEyeMaterialDataTable' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, CharacterMakeColorLimit_SV) == 0x000EF8, "Member 'UPalGameSetting::CharacterMakeColorLimit_SV' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, IsAutoEquipMasteredWaza) == 0x000EFC, "Member 'UPalGameSetting::IsAutoEquipMasteredWaza' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, ActiveUNKO) == 0x000EFD, "Member 'UPalGameSetting::ActiveUNKO' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, MaxSpawnableDeathPenaltyChest) == 0x000F00, "Member 'UPalGameSetting::MaxSpawnableDeathPenaltyChest' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, BuildObjectInstallStrategy_SinkAllowCollisionPresetName) == 0x000F04, "Member 'UPalGameSetting::BuildObjectInstallStrategy_SinkAllowCollisionPresetName' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, MapObjectShakeTimeOnDamaged) == 0x000F0C, "Member 'UPalGameSetting::MapObjectShakeTimeOnDamaged' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, MapObjectShakeOffsetOnDamaged) == 0x000F10, "Member 'UPalGameSetting::MapObjectShakeOffsetOnDamaged' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, MapObjectOutlineByReticleTargetting) == 0x000F28, "Member 'UPalGameSetting::MapObjectOutlineByReticleTargetting' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, MapObjectOutlineByInteractable) == 0x000F2C, "Member 'UPalGameSetting::MapObjectOutlineByInteractable' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, MapObjectRepairInfo) == 0x000F30, "Member 'UPalGameSetting::MapObjectRepairInfo' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, FoliageExtentsXY) == 0x000F40, "Member 'UPalGameSetting::FoliageExtentsXY' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, FoliageChunkSeparateScale) == 0x000F44, "Member 'UPalGameSetting::FoliageChunkSeparateScale' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, MapObjectHPDisplayDistance) == 0x000F48, "Member 'UPalGameSetting::MapObjectHPDisplayDistance' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, MapObjectHPDisplayTime) == 0x000F4C, "Member 'UPalGameSetting::MapObjectHPDisplayTime' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, MapObjectGateLockTime) == 0x000F50, "Member 'UPalGameSetting::MapObjectGateLockTime' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, bDirectObtainFromTreasureBox) == 0x000F54, "Member 'UPalGameSetting::bDirectObtainFromTreasureBox' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, MapObjectEffectTriggerAccumulate_Burn) == 0x000F58, "Member 'UPalGameSetting::MapObjectEffectTriggerAccumulate_Burn' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, MapObjectEffect_Burn_DamageHpRate) == 0x000F5C, "Member 'UPalGameSetting::MapObjectEffect_Burn_DamageHpRate' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, MapObjectEffect_Burn_DamageAroundRange) == 0x000F60, "Member 'UPalGameSetting::MapObjectEffect_Burn_DamageAroundRange' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, MapObjectEffect_Burn_DamageAroundInterval) == 0x000F78, "Member 'UPalGameSetting::MapObjectEffect_Burn_DamageAroundInterval' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, MapObjectEffect_Burn_DamageAroundDamageValue) == 0x000F7C, "Member 'UPalGameSetting::MapObjectEffect_Burn_DamageAroundDamageValue' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, MapObjectEffect_Burn_DamageAroundAccumulateValue) == 0x000F80, "Member 'UPalGameSetting::MapObjectEffect_Burn_DamageAroundAccumulateValue' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, MapObjectEffect_Burn_DamageAroundAccumulateValue_ForCharacter) == 0x000F84, "Member 'UPalGameSetting::MapObjectEffect_Burn_DamageAroundAccumulateValue_ForCharacter' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, PasswordLockFailedMaxNum) == 0x000F88, "Member 'UPalGameSetting::PasswordLockFailedMaxNum' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, MapObjectItemChestCorruptionRateFromWorkSpeed) == 0x000F8C, "Member 'UPalGameSetting::MapObjectItemChestCorruptionRateFromWorkSpeed' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, RuntimeOptimizeParameter) == 0x000F90, "Member 'UPalGameSetting::RuntimeOptimizeParameter' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, WorldSecurityWantedPoliceSettingDataMap) == 0x001420, "Member 'UPalGameSetting::WorldSecurityWantedPoliceSettingDataMap' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, WorldSecurityWantedPoliceSettingDataMapForDS) == 0x001470, "Member 'UPalGameSetting::WorldSecurityWantedPoliceSettingDataMapForDS' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, StatusPointPerLevel) == 0x0014C0, "Member 'UPalGameSetting::StatusPointPerLevel' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, AddMaxHPPerStatusPoint) == 0x0014C4, "Member 'UPalGameSetting::AddMaxHPPerStatusPoint' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, AddMaxSPPerStatusPoint) == 0x0014C8, "Member 'UPalGameSetting::AddMaxSPPerStatusPoint' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, AddPowerPerStatusPoint) == 0x0014CC, "Member 'UPalGameSetting::AddPowerPerStatusPoint' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, AddMaxInventoryWeightPerStatusPoint) == 0x0014D0, "Member 'UPalGameSetting::AddMaxInventoryWeightPerStatusPoint' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, AddCaptureLevelPerStatusPoint) == 0x0014D4, "Member 'UPalGameSetting::AddCaptureLevelPerStatusPoint' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, AddWorkSpeedPerStatusPoint) == 0x0014D8, "Member 'UPalGameSetting::AddWorkSpeedPerStatusPoint' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, AddMaxHPPerHPRank) == 0x0014DC, "Member 'UPalGameSetting::AddMaxHPPerHPRank' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, AddAttackPerAttackRank) == 0x0014E0, "Member 'UPalGameSetting::AddAttackPerAttackRank' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, AddDefencePerDefenceRank) == 0x0014E4, "Member 'UPalGameSetting::AddDefencePerDefenceRank' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, AddWorkSpeedPerWorkSpeedRank) == 0x0014E8, "Member 'UPalGameSetting::AddWorkSpeedPerWorkSpeedRank' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, MaxUseablePoint_SumStatusPointAndExStatusPoint_PerParameter) == 0x0014EC, "Member 'UPalGameSetting::MaxUseablePoint_SumStatusPointAndExStatusPoint_PerParameter' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, Combi_TalentInheritNum) == 0x0014F0, "Member 'UPalGameSetting::Combi_TalentInheritNum' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, Combi_PassiveInheritNum) == 0x001500, "Member 'UPalGameSetting::Combi_PassiveInheritNum' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, Combi_PassiveRandomAddNum) == 0x001510, "Member 'UPalGameSetting::Combi_PassiveRandomAddNum' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, PalEggRankInfoArray) == 0x001520, "Member 'UPalGameSetting::PalEggRankInfoArray' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, PalEggMapObjectIdMap) == 0x001530, "Member 'UPalGameSetting::PalEggMapObjectIdMap' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, PalEggHatchingSpeedRateByTemperature) == 0x001580, "Member 'UPalGameSetting::PalEggHatchingSpeedRateByTemperature' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, DebugInfoFont) == 0x0015D0, "Member 'UPalGameSetting::DebugInfoFont' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, MaxGuildNameLength) == 0x0015D8, "Member 'UPalGameSetting::MaxGuildNameLength' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, JoinGuildRequestInteractLongPushTime) == 0x0015DC, "Member 'UPalGameSetting::JoinGuildRequestInteractLongPushTime' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, TutorialMinDisplayTime) == 0x0015E0, "Member 'UPalGameSetting::TutorialMinDisplayTime' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, TutorialDisplayTime) == 0x0015E4, "Member 'UPalGameSetting::TutorialDisplayTime' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, CommonRewardDisplayTime) == 0x0015E8, "Member 'UPalGameSetting::CommonRewardDisplayTime' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, DeadBodyDestroySecond) == 0x001638, "Member 'UPalGameSetting::DeadBodyDestroySecond' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, EnemyCampRespawnCoolTime) == 0x00163C, "Member 'UPalGameSetting::EnemyCampRespawnCoolTime' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, EnemyCampDespawnDelayTime) == 0x001640, "Member 'UPalGameSetting::EnemyCampDespawnDelayTime' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, PalBoxReviveTime) == 0x001644, "Member 'UPalGameSetting::PalBoxReviveTime' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, AfterNPCTalkDelayTime_Interact) == 0x001648, "Member 'UPalGameSetting::AfterNPCTalkDelayTime_Interact' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, MinSprintThreshold) == 0x00164C, "Member 'UPalGameSetting::MinSprintThreshold' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, MaxSprintThreshold) == 0x001650, "Member 'UPalGameSetting::MaxSprintThreshold' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, MinHPGaugeDisplayTime) == 0x001654, "Member 'UPalGameSetting::MinHPGaugeDisplayTime' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, ToggleInteractMoveDelay) == 0x001658, "Member 'UPalGameSetting::ToggleInteractMoveDelay' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, SoundSourceDataTable) == 0x001660, "Member 'UPalGameSetting::SoundSourceDataTable' has a wrong offset!");
static_assert(offsetof(UPalGameSetting, OptimizeParameterSettingClass) == 0x001668, "Member 'UPalGameSetting::OptimizeParameterSettingClass' has a wrong offset!");

// Class Pal.PalGameStateInGame
// 0x0148 (0x0428 - 0x02E0)
class APalGameStateInGame final : public APalGameState
{
public:
	class UPalCharacterManagerReplicator*         CharacterManagerReplicator;                        // 0x02E0(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalBaseCampReplicator*                 BaseCampReplicator;                                // 0x02E8(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalOptionReplicator*                   OptionReplicator;                                  // 0x02F0(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalStageReplicator*                    StageReplicator;                                   // 0x02F8(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalLocationReplicator*                 LocationReplicator;                                // 0x0300(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B83[0x50];                                    // 0x0308(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class APalNetworkTransmitter*                 DedicatedServerTransmitter;                        // 0x0358(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalGameSystemInitManagerComponent*     GameSystemInitManager;                             // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class APalBotBuilderLocationBase*>     BotBuilderLocation;                                // 0x0368(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class FString                                 WorldName;                                         // 0x0378(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 WorldSaveDirectoryName;                            // 0x0388(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsDedicatedServer;                                // 0x0398(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B84[0x3];                                     // 0x0399(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxPlayerNum;                                      // 0x039C(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameDateTime                          WorldTime;                                         // 0x03A0(0x0008)(Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDateTime                              RealUtcTime;                                       // 0x03A8(0x0008)(Net, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ServerFrameTime;                                   // 0x03B0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B85[0x4];                                     // 0x03B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ServerSessionId;                                   // 0x03B8(0x0010)(Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ServerWildMonsterCount;                            // 0x03C8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ServerOtomoMonsterCount;                           // 0x03CC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ServerBaseCampMonsterCount;                        // 0x03D0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ServerNPCCount;                                    // 0x03D4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ServerOtherCharacterCount;                         // 0x03D8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ImportanceCharacterCount_AllUpdate;                // 0x03DC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ImportanceCharacterCount_Nearest;                  // 0x03E0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ImportanceCharacterCount_Near;                     // 0x03E4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ImportanceCharacterCount_MidInSight;               // 0x03E8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ImportanceCharacterCount_FarInSight;               // 0x03EC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ImportanceCharacterCount_MidOutSight;              // 0x03F0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ImportanceCharacterCount_FarOutSight;              // 0x03F4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ImportanceCharacterCount_Farthest;                 // 0x03F8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         BaseCampCount;                                     // 0x03FC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         NavMeshInvokerCount;                               // 0x0400(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B86[0x4];                                     // 0x0404(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPalChatMessage>                ChatMessages;                                      // 0x0408(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRecievedChatMessageDelegate;                     // 0x0418(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void BroadcastChatMessage(const struct FPalChatMessage& ChatMessage);
	void OnRecievedChatMessageDelegate__DelegateSignature(const struct FPalChatMessage& Message);
	void OnRep_BaseCampReplicator();
	void OnRep_CharacterManagerReplicator();
	void OnRep_LocationReplicator();
	void OnRep_OptionReplicator();
	void OnRep_StageReplicator();
	void OnRep_WorldSaveDirectoryName();

	int32 GetMaxPlayerNum() const;
	float GetServerFrameTime() const;
	class FString GetWorldName() const;
	class FString GetWorldSaveDirectoryName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGameStateInGame">();
	}
	static class APalGameStateInGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalGameStateInGame>();
	}
};
static_assert(alignof(APalGameStateInGame) == 0x000008, "Wrong alignment on APalGameStateInGame");
static_assert(sizeof(APalGameStateInGame) == 0x000428, "Wrong size on APalGameStateInGame");
static_assert(offsetof(APalGameStateInGame, CharacterManagerReplicator) == 0x0002E0, "Member 'APalGameStateInGame::CharacterManagerReplicator' has a wrong offset!");
static_assert(offsetof(APalGameStateInGame, BaseCampReplicator) == 0x0002E8, "Member 'APalGameStateInGame::BaseCampReplicator' has a wrong offset!");
static_assert(offsetof(APalGameStateInGame, OptionReplicator) == 0x0002F0, "Member 'APalGameStateInGame::OptionReplicator' has a wrong offset!");
static_assert(offsetof(APalGameStateInGame, StageReplicator) == 0x0002F8, "Member 'APalGameStateInGame::StageReplicator' has a wrong offset!");
static_assert(offsetof(APalGameStateInGame, LocationReplicator) == 0x000300, "Member 'APalGameStateInGame::LocationReplicator' has a wrong offset!");
static_assert(offsetof(APalGameStateInGame, DedicatedServerTransmitter) == 0x000358, "Member 'APalGameStateInGame::DedicatedServerTransmitter' has a wrong offset!");
static_assert(offsetof(APalGameStateInGame, GameSystemInitManager) == 0x000360, "Member 'APalGameStateInGame::GameSystemInitManager' has a wrong offset!");
static_assert(offsetof(APalGameStateInGame, BotBuilderLocation) == 0x000368, "Member 'APalGameStateInGame::BotBuilderLocation' has a wrong offset!");
static_assert(offsetof(APalGameStateInGame, WorldName) == 0x000378, "Member 'APalGameStateInGame::WorldName' has a wrong offset!");
static_assert(offsetof(APalGameStateInGame, WorldSaveDirectoryName) == 0x000388, "Member 'APalGameStateInGame::WorldSaveDirectoryName' has a wrong offset!");
static_assert(offsetof(APalGameStateInGame, bIsDedicatedServer) == 0x000398, "Member 'APalGameStateInGame::bIsDedicatedServer' has a wrong offset!");
static_assert(offsetof(APalGameStateInGame, MaxPlayerNum) == 0x00039C, "Member 'APalGameStateInGame::MaxPlayerNum' has a wrong offset!");
static_assert(offsetof(APalGameStateInGame, WorldTime) == 0x0003A0, "Member 'APalGameStateInGame::WorldTime' has a wrong offset!");
static_assert(offsetof(APalGameStateInGame, RealUtcTime) == 0x0003A8, "Member 'APalGameStateInGame::RealUtcTime' has a wrong offset!");
static_assert(offsetof(APalGameStateInGame, ServerFrameTime) == 0x0003B0, "Member 'APalGameStateInGame::ServerFrameTime' has a wrong offset!");
static_assert(offsetof(APalGameStateInGame, ServerSessionId) == 0x0003B8, "Member 'APalGameStateInGame::ServerSessionId' has a wrong offset!");
static_assert(offsetof(APalGameStateInGame, ServerWildMonsterCount) == 0x0003C8, "Member 'APalGameStateInGame::ServerWildMonsterCount' has a wrong offset!");
static_assert(offsetof(APalGameStateInGame, ServerOtomoMonsterCount) == 0x0003CC, "Member 'APalGameStateInGame::ServerOtomoMonsterCount' has a wrong offset!");
static_assert(offsetof(APalGameStateInGame, ServerBaseCampMonsterCount) == 0x0003D0, "Member 'APalGameStateInGame::ServerBaseCampMonsterCount' has a wrong offset!");
static_assert(offsetof(APalGameStateInGame, ServerNPCCount) == 0x0003D4, "Member 'APalGameStateInGame::ServerNPCCount' has a wrong offset!");
static_assert(offsetof(APalGameStateInGame, ServerOtherCharacterCount) == 0x0003D8, "Member 'APalGameStateInGame::ServerOtherCharacterCount' has a wrong offset!");
static_assert(offsetof(APalGameStateInGame, ImportanceCharacterCount_AllUpdate) == 0x0003DC, "Member 'APalGameStateInGame::ImportanceCharacterCount_AllUpdate' has a wrong offset!");
static_assert(offsetof(APalGameStateInGame, ImportanceCharacterCount_Nearest) == 0x0003E0, "Member 'APalGameStateInGame::ImportanceCharacterCount_Nearest' has a wrong offset!");
static_assert(offsetof(APalGameStateInGame, ImportanceCharacterCount_Near) == 0x0003E4, "Member 'APalGameStateInGame::ImportanceCharacterCount_Near' has a wrong offset!");
static_assert(offsetof(APalGameStateInGame, ImportanceCharacterCount_MidInSight) == 0x0003E8, "Member 'APalGameStateInGame::ImportanceCharacterCount_MidInSight' has a wrong offset!");
static_assert(offsetof(APalGameStateInGame, ImportanceCharacterCount_FarInSight) == 0x0003EC, "Member 'APalGameStateInGame::ImportanceCharacterCount_FarInSight' has a wrong offset!");
static_assert(offsetof(APalGameStateInGame, ImportanceCharacterCount_MidOutSight) == 0x0003F0, "Member 'APalGameStateInGame::ImportanceCharacterCount_MidOutSight' has a wrong offset!");
static_assert(offsetof(APalGameStateInGame, ImportanceCharacterCount_FarOutSight) == 0x0003F4, "Member 'APalGameStateInGame::ImportanceCharacterCount_FarOutSight' has a wrong offset!");
static_assert(offsetof(APalGameStateInGame, ImportanceCharacterCount_Farthest) == 0x0003F8, "Member 'APalGameStateInGame::ImportanceCharacterCount_Farthest' has a wrong offset!");
static_assert(offsetof(APalGameStateInGame, BaseCampCount) == 0x0003FC, "Member 'APalGameStateInGame::BaseCampCount' has a wrong offset!");
static_assert(offsetof(APalGameStateInGame, NavMeshInvokerCount) == 0x000400, "Member 'APalGameStateInGame::NavMeshInvokerCount' has a wrong offset!");
static_assert(offsetof(APalGameStateInGame, ChatMessages) == 0x000408, "Member 'APalGameStateInGame::ChatMessages' has a wrong offset!");
static_assert(offsetof(APalGameStateInGame, OnRecievedChatMessageDelegate) == 0x000418, "Member 'APalGameStateInGame::OnRecievedChatMessageDelegate' has a wrong offset!");

// Class Pal.PalOtomoHolderComponentBase
// 0x0078 (0x0118 - 0x00A0)
class UPalOtomoHolderComponentBase : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnCreatedCharacterContainerDelegate;               // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateOtomoSlotDelegate;                         // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateOtomoSlotWithActorDelegate;                // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateOtomoSlotWithInitializedParameterDelegate; // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnOtomoSpawnedDelegate;                            // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	class UPalOtomoSpawnCollisionChecker*         CollisionChecker;                                  // 0x00F0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPalOtomoPalOrderType                         OtomoOrder;                                        // 0x00F8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B87[0x7];                                     // 0x00F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalIndividualCharacterContainer*       CharacterContainer;                                // 0x0100(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UPalIndividualCharacterHandle*>  CreatingHandleCache;                               // 0x0108(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	bool ActivateCurrentOtomo(const struct FTransform& SpawnTransform);
	bool ActivateCurrentOtomoNearThePlayer();
	void AddLogOtomoPartnerSkill_ToClient(class AActor* Otomo, EPalLogType PalLogType, int32 Value, bool AddSkillName);
	void AddLogOtomoPartnerSkill_Waza_ToClient(class AActor* Otomo, EPalLogType PalLogType);
	bool AddOtomoHandleToFreeSlot(class UPalIndividualCharacterHandle* Handle);
	void CallCancelCommand();
	void CoopCallCommand();
	void DecrementSelectOtomoID();
	void DecrementSelectOtomoID_Internal();
	void DecrementSelectOtomoID_ToALL(int32 ID);
	void DecrementSelectOtomoID_ToServer(int32 ID);
	class APalCharacter* GetEnemyWhenOtomoThrow(const struct FVector& OtomoAppearedLocation);
	int32 GetNextOtomoSlotID();
	int32 GetPreviousOtomoSlotID();
	struct FTransform GetTransform_SpawnPalNearTrainer();
	void InactivateCurrentOtomo();
	void InactiveOtomoByHandle_PreProcess(class UPalIndividualCharacterHandle* Handle);
	void IncrementSelectOtomoID();
	void IncrementSelectOtomoID_Internal();
	void IncrementSelectOtomoID_ToALL(int32 ID);
	void IncrementSelectOtomoID_ToServer(int32 ID);
	void Initialize();
	void Initialize_ServerInternal();
	bool IsActivatedSelectOtomo();
	bool IsAllDeadOtomo();
	bool IsDeadSelectedOtomo();
	bool IsRidingBySelectSlotID();
	bool IsRidingBySpawnSlotID();
	bool IsValidCurrentSelectPalActor();
	void OnChangeOtomoActive(class APalCharacter* Otomo, bool Param_IsActive);
	void OnCreatedCharacterContainer();
	void OnCreatedCharacterContainer__DelegateSignature();
	void OnInitializedCharacter(class APalCharacter* Character);
	void OnRep_CharacterContainer();
	void OnReplicated_CharacterContainer_AllSlots(class UPalIndividualCharacterContainer* Container);
	void OnSpawnDebugOtomoCallback_ServerInternal(const struct FPalInstanceID& ID);
	void OnSpawnOtomoCallback_ServerInternal(const struct FPalInstanceID& ID);
	void OnUpdateIndividualActor(class UPalIndividualCharacterHandle* LastHandle);
	void OnUpdateSlot(class UPalIndividualCharacterSlot* Slot, class UPalIndividualCharacterHandle* LastHandle);
	void OtomoSpawnedDelegate__DelegateSignature(class AController* HolderController, class APalCharacter* OtomoPal);
	void SetInteractComponent(class AActor* SpawnPal);
	void SetOtomoOrder_ToServer(EPalOtomoPalOrderType OrderType);
	void SetSelectOtomoID(int32 Param_Index);
	void SetSelectOtomoID_Internal(int32 Param_Index);
	void SetSelectOtomoID_ToALL(int32 ID, int32 Param_Index);
	void SetSelectOtomoID_ToServer(int32 ID, int32 Param_Index);
	void SpawnOtomoByLoad(int32 SlotIndex);
	void Tmp_EmptySlot(const struct FPalCharacterSlotId& SlotID);
	void TryFixAssignNearestWorkSelectedOtomo(const class AActor* HitActor);
	class APalCharacter* TryGetCurrentSelectPalActor();
	void TryGetLoadedOtomoData(bool* bLoaded, TMap<struct FPalInstanceID, struct FPalIndividualCharacterSaveParameter>* OutParameterMap);
	void UpdateOtomoSlotDelegate__DelegateSignature(int32 SlotIndex, class UPalIndividualCharacterHandle* LastHandle);
	void UpdateOtomoSlotWithInitializedParameterDelegate__DelegateSignature(class APalCharacter* Character);

	void GetAllIndividualHandle(TArray<class UPalIndividualCharacterHandle*>* OutArray) const;
	class UPalIndividualCharacterSlot* GetEmptySlot() const;
	int32 GetMaxOtomoNum() const;
	int32 GetOtomoCount() const;
	class UPalIndividualCharacterSlot* GetOtomoIndividualCharacterSlot(const int32 SlotIndex) const;
	class UPalIndividualCharacterSlot* GetOtomoIndividualCharacterSlot_Internal(const int32 SlotIndex) const;
	class UPalIndividualCharacterHandle* GetOtomoIndividualHandle(const int32 SlotIndex) const;
	EPalOtomoPalOrderType GetOtomoOrder() const;
	int32 GetSelectedOtomoID() const;
	int32 GetSlotIndexByIndividualHandle(const class UPalIndividualCharacterHandle* IndividualHandle) const;
	void GetSlots(TArray<class UPalIndividualCharacterSlot*>* Slots) const;
	int32 GetSpawnedOtomoID() const;
	bool IsALLEmpty() const;
	bool IsControlledByPlayer() const;
	bool IsCreatedOtomoContainer() const;
	bool IsFullMember() const;
	void LostOtomoByID_ToClient(const struct FPalInstanceID& ID) const;
	bool TryGetContainer(class UPalIndividualCharacterContainer** Container) const;
	class APalCharacter* TryGetOtomoActorBySlotIndex(const int32 SlotIndex) const;
	class APalCharacter* TryGetOwnerControlledCharacter() const;
	class APawn* TryGetOwnerControlledPawn() const;
	class APalCharacter* TryGetSpawnedOtomo() const;
	class UPalIndividualCharacterHandle* TryGetSpawnedOtomoHandle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalOtomoHolderComponentBase">();
	}
	static class UPalOtomoHolderComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalOtomoHolderComponentBase>();
	}
};
static_assert(alignof(UPalOtomoHolderComponentBase) == 0x000008, "Wrong alignment on UPalOtomoHolderComponentBase");
static_assert(sizeof(UPalOtomoHolderComponentBase) == 0x000118, "Wrong size on UPalOtomoHolderComponentBase");
static_assert(offsetof(UPalOtomoHolderComponentBase, OnCreatedCharacterContainerDelegate) == 0x0000A0, "Member 'UPalOtomoHolderComponentBase::OnCreatedCharacterContainerDelegate' has a wrong offset!");
static_assert(offsetof(UPalOtomoHolderComponentBase, OnUpdateOtomoSlotDelegate) == 0x0000B0, "Member 'UPalOtomoHolderComponentBase::OnUpdateOtomoSlotDelegate' has a wrong offset!");
static_assert(offsetof(UPalOtomoHolderComponentBase, OnUpdateOtomoSlotWithActorDelegate) == 0x0000C0, "Member 'UPalOtomoHolderComponentBase::OnUpdateOtomoSlotWithActorDelegate' has a wrong offset!");
static_assert(offsetof(UPalOtomoHolderComponentBase, OnUpdateOtomoSlotWithInitializedParameterDelegate) == 0x0000D0, "Member 'UPalOtomoHolderComponentBase::OnUpdateOtomoSlotWithInitializedParameterDelegate' has a wrong offset!");
static_assert(offsetof(UPalOtomoHolderComponentBase, OnOtomoSpawnedDelegate) == 0x0000E0, "Member 'UPalOtomoHolderComponentBase::OnOtomoSpawnedDelegate' has a wrong offset!");
static_assert(offsetof(UPalOtomoHolderComponentBase, CollisionChecker) == 0x0000F0, "Member 'UPalOtomoHolderComponentBase::CollisionChecker' has a wrong offset!");
static_assert(offsetof(UPalOtomoHolderComponentBase, OtomoOrder) == 0x0000F8, "Member 'UPalOtomoHolderComponentBase::OtomoOrder' has a wrong offset!");
static_assert(offsetof(UPalOtomoHolderComponentBase, CharacterContainer) == 0x000100, "Member 'UPalOtomoHolderComponentBase::CharacterContainer' has a wrong offset!");
static_assert(offsetof(UPalOtomoHolderComponentBase, CreatingHandleCache) == 0x000108, "Member 'UPalOtomoHolderComponentBase::CreatingHandleCache' has a wrong offset!");

// Class Pal.PalGameSystemInitSequence_WaitForWorldSystemInit
// 0x0000 (0x0038 - 0x0038)
class UPalGameSystemInitSequence_WaitForWorldSystemInit final : public UPalGameSystemInitSequenceBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGameSystemInitSequence_WaitForWorldSystemInit">();
	}
	static class UPalGameSystemInitSequence_WaitForWorldSystemInit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalGameSystemInitSequence_WaitForWorldSystemInit>();
	}
};
static_assert(alignof(UPalGameSystemInitSequence_WaitForWorldSystemInit) == 0x000008, "Wrong alignment on UPalGameSystemInitSequence_WaitForWorldSystemInit");
static_assert(sizeof(UPalGameSystemInitSequence_WaitForWorldSystemInit) == 0x000038, "Wrong size on UPalGameSystemInitSequence_WaitForWorldSystemInit");

// Class Pal.PalGameSystemInitSequence_WaitForLocalPlayerStateSetup
// 0x0000 (0x0038 - 0x0038)
class UPalGameSystemInitSequence_WaitForLocalPlayerStateSetup final : public UPalGameSystemInitSequenceBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGameSystemInitSequence_WaitForLocalPlayerStateSetup">();
	}
	static class UPalGameSystemInitSequence_WaitForLocalPlayerStateSetup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalGameSystemInitSequence_WaitForLocalPlayerStateSetup>();
	}
};
static_assert(alignof(UPalGameSystemInitSequence_WaitForLocalPlayerStateSetup) == 0x000008, "Wrong alignment on UPalGameSystemInitSequence_WaitForLocalPlayerStateSetup");
static_assert(sizeof(UPalGameSystemInitSequence_WaitForLocalPlayerStateSetup) == 0x000038, "Wrong size on UPalGameSystemInitSequence_WaitForLocalPlayerStateSetup");

// Class Pal.PalPartnerSkillParameterComponent
// 0x0168 (0x0208 - 0x00A0)
class UPalPartnerSkillParameterComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnOverheat;                                        // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCoolDownCompleted;                               // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEffectTimeChanged;                               // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCoolDownTimeChanged;                             // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStart;                                           // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStop;                                            // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnToggleExecute;                                   // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSearchEffectExecute;                             // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FPalDataTableRowName_ItemData>  RestrictionItems;                                  // 0x0120(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FName                                   SkillName;                                         // 0x0130(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPalWazaID                                    WazaID;                                            // 0x0138(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B96[0x3];                                     // 0x0139(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFixedPoint                            EffectTime;                                        // 0x013C(0x0004)(Edit, DisableEditOnTemplate, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FFixedPoint                            EffectTimeMax;                                     // 0x0140(0x0004)(Edit, DisableEditOnTemplate, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FFixedPoint                            ExecCost;                                          // 0x0144(0x0004)(Edit, DisableEditOnTemplate, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FFixedPoint                            IdleCost;                                          // 0x0148(0x0004)(Edit, DisableEditOnTemplate, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FFixedPoint                            IdleTime;                                          // 0x014C(0x0004)(Edit, DisableEditOnTemplate, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FFixedPoint                            CoolDownTime;                                      // 0x0150(0x0004)(Edit, DisableEditOnTemplate, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FFixedPoint                            CoolDownTimeMax;                                   // 0x0154(0x0004)(Edit, DisableEditOnTemplate, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bCanThrowPal;                                      // 0x0158(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanChangeWeapon;                                  // 0x0159(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsToggleKey;                                      // 0x015A(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIdlelCostDecreaseEveryFrame;                      // 0x015B(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsExecSkillContinuation;                          // 0x015C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRunning;                                        // 0x015D(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOverheat;                                       // 0x015E(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsExecuting;                                      // 0x015F(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalCoopSkillModuleBase*                SkillModule;                                       // 0x0160(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPalPassivePartnerSkillIdAndParameters> PassiveSkills;                                     // 0x0168(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FPalPartnerSkillParameterRide          RideParameter;                                     // 0x0178(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class APalFunnelCharacter>        FunnelCharacterClass;                              // 0x0180(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class APalAIController>           FunnelControllerClass;                             // 0x0188(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPalWazaID                                    FunnelAttackWazaID;                                // 0x0190(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B97[0x7];                                     // 0x0191(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalPartnerSkillPassiveSkill*           PassiveSkill;                                      // 0x0198(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B98[0x50];                                    // 0x01A0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ActiveSkill_MainValue_Overview_EditorOnly;         // 0x01F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<float>                                 ActiveSkill_MainValueByRank;                       // 0x01F8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	void CallOnCoolDownCompleted_ToAll();
	void CallOnCoolDownTimeChanged_ToAll(const struct FFixedPoint& Param_CoolDownTime, const struct FFixedPoint& Param_CoolDownTimeMax);
	void CallOnEffectTimeChanged_ToAll(const struct FFixedPoint& Param_EffectTime, const struct FFixedPoint& Param_EffectTimeMax);
	void CallOnOverheat_ToAll();
	void CallOnStart_ToAll();
	void CallOnStartSearchEffect_ToAll(const struct FGuid& RequestPlayerUId, const struct FPalCoopSkillSearchEffectParameter& EffectParam);
	void CallOnStop_ToAll();
	void CallOnToggleExecute_ToAll(bool Execute);
	class UPalCoopSkillModuleBase* CreateSkillModule(TSubclassOf<class UPalCoopSkillModuleBase> SkillModuleClass);
	void ExecDuring(float DeltaTime);
	void ForceOverheat();
	float GetCoolDownTimeRatio();
	float GetEffectTimeRatio();
	void GetRideParameter(struct FPalPartnerSkillParameterRide* OutParam);
	void OnActivatedAsOtomoHolder();
	void OnActivatedAsPartner();
	void OnActivatedAsWorker();
	void OnComplated();
	void OnCoolDownCompleted__DelegateSignature();
	void OnCoolDownTimeChanged__DelegateSignature(const struct FFixedPoint& Param_CoolDownTime, const struct FFixedPoint& Param_CoolDownTimeMax);
	void OnEffectTimeChanged__DelegateSignature(const struct FFixedPoint& Param_EffectTime, const struct FFixedPoint& Param_EffectTimeMax);
	void OnExec();
	void OnInactivatedAsOtomoHolder();
	void OnInactivatedAsPartner();
	void OnInactivatedAsWorker();
	void OnInitializedCharacter(class APalCharacter* OwnerCharacter);
	void OnOverheat__DelegateSignature();
	void OnOwnerCharacterSpawned(const struct FPalInstanceID& ID);
	void OnRideActivated();
	void OnRideInactivated();
	void OnSearchEffect__DelegateSignature();
	void OnStart__DelegateSignature();
	void OnStop__DelegateSignature();
	void OnToggleExecute__DelegateSignature(bool IsExecuting);
	void OnUpdateInventoryContainer(class UPalItemContainer* Container);
	void Recover();
	void SetCoopFlag_ForServer(bool IsCoop);
	void SetDisableFlagsBySetting(bool IsDisable);
	void SetName(class FName Param_Name);
	void Start();
	void Stop();

	bool CanChangeWeapon() const;
	bool CanExec() const;
	float GetActiveSkillMainValueByRank() const;
	const struct FFixedPoint GetCoolDownTime() const;
	const struct FFixedPoint GetCoolDownTimeMax() const;
	const struct FFixedPoint GetEffectTime() const;
	const struct FFixedPoint GetEffectTimeMax() const;
	struct FFixedPoint GetMainDamage() const;
	const TArray<struct FPalDataTableRowName_ItemData> GetRestrictionItems() const;
	const class FName GetSkillName() const;
	EPalWazaID GetWazaID() const;
	float GetWazaPowerRate(EPalWazaID Waza) const;
	bool IsCoolDown() const;
	bool IsExistActiveSkill() const;
	bool IsOverheat() const;
	bool IsRestrictedByItems(class AActor* Trainer) const;
	bool IsRunning() const;
	bool IsToggleKey() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalPartnerSkillParameterComponent">();
	}
	static class UPalPartnerSkillParameterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalPartnerSkillParameterComponent>();
	}
};
static_assert(alignof(UPalPartnerSkillParameterComponent) == 0x000008, "Wrong alignment on UPalPartnerSkillParameterComponent");
static_assert(sizeof(UPalPartnerSkillParameterComponent) == 0x000208, "Wrong size on UPalPartnerSkillParameterComponent");
static_assert(offsetof(UPalPartnerSkillParameterComponent, OnOverheat) == 0x0000A0, "Member 'UPalPartnerSkillParameterComponent::OnOverheat' has a wrong offset!");
static_assert(offsetof(UPalPartnerSkillParameterComponent, OnCoolDownCompleted) == 0x0000B0, "Member 'UPalPartnerSkillParameterComponent::OnCoolDownCompleted' has a wrong offset!");
static_assert(offsetof(UPalPartnerSkillParameterComponent, OnEffectTimeChanged) == 0x0000C0, "Member 'UPalPartnerSkillParameterComponent::OnEffectTimeChanged' has a wrong offset!");
static_assert(offsetof(UPalPartnerSkillParameterComponent, OnCoolDownTimeChanged) == 0x0000D0, "Member 'UPalPartnerSkillParameterComponent::OnCoolDownTimeChanged' has a wrong offset!");
static_assert(offsetof(UPalPartnerSkillParameterComponent, OnStart) == 0x0000E0, "Member 'UPalPartnerSkillParameterComponent::OnStart' has a wrong offset!");
static_assert(offsetof(UPalPartnerSkillParameterComponent, OnStop) == 0x0000F0, "Member 'UPalPartnerSkillParameterComponent::OnStop' has a wrong offset!");
static_assert(offsetof(UPalPartnerSkillParameterComponent, OnToggleExecute) == 0x000100, "Member 'UPalPartnerSkillParameterComponent::OnToggleExecute' has a wrong offset!");
static_assert(offsetof(UPalPartnerSkillParameterComponent, OnSearchEffectExecute) == 0x000110, "Member 'UPalPartnerSkillParameterComponent::OnSearchEffectExecute' has a wrong offset!");
static_assert(offsetof(UPalPartnerSkillParameterComponent, RestrictionItems) == 0x000120, "Member 'UPalPartnerSkillParameterComponent::RestrictionItems' has a wrong offset!");
static_assert(offsetof(UPalPartnerSkillParameterComponent, SkillName) == 0x000130, "Member 'UPalPartnerSkillParameterComponent::SkillName' has a wrong offset!");
static_assert(offsetof(UPalPartnerSkillParameterComponent, WazaID) == 0x000138, "Member 'UPalPartnerSkillParameterComponent::WazaID' has a wrong offset!");
static_assert(offsetof(UPalPartnerSkillParameterComponent, EffectTime) == 0x00013C, "Member 'UPalPartnerSkillParameterComponent::EffectTime' has a wrong offset!");
static_assert(offsetof(UPalPartnerSkillParameterComponent, EffectTimeMax) == 0x000140, "Member 'UPalPartnerSkillParameterComponent::EffectTimeMax' has a wrong offset!");
static_assert(offsetof(UPalPartnerSkillParameterComponent, ExecCost) == 0x000144, "Member 'UPalPartnerSkillParameterComponent::ExecCost' has a wrong offset!");
static_assert(offsetof(UPalPartnerSkillParameterComponent, IdleCost) == 0x000148, "Member 'UPalPartnerSkillParameterComponent::IdleCost' has a wrong offset!");
static_assert(offsetof(UPalPartnerSkillParameterComponent, IdleTime) == 0x00014C, "Member 'UPalPartnerSkillParameterComponent::IdleTime' has a wrong offset!");
static_assert(offsetof(UPalPartnerSkillParameterComponent, CoolDownTime) == 0x000150, "Member 'UPalPartnerSkillParameterComponent::CoolDownTime' has a wrong offset!");
static_assert(offsetof(UPalPartnerSkillParameterComponent, CoolDownTimeMax) == 0x000154, "Member 'UPalPartnerSkillParameterComponent::CoolDownTimeMax' has a wrong offset!");
static_assert(offsetof(UPalPartnerSkillParameterComponent, bCanThrowPal) == 0x000158, "Member 'UPalPartnerSkillParameterComponent::bCanThrowPal' has a wrong offset!");
static_assert(offsetof(UPalPartnerSkillParameterComponent, bCanChangeWeapon) == 0x000159, "Member 'UPalPartnerSkillParameterComponent::bCanChangeWeapon' has a wrong offset!");
static_assert(offsetof(UPalPartnerSkillParameterComponent, bIsToggleKey) == 0x00015A, "Member 'UPalPartnerSkillParameterComponent::bIsToggleKey' has a wrong offset!");
static_assert(offsetof(UPalPartnerSkillParameterComponent, bIdlelCostDecreaseEveryFrame) == 0x00015B, "Member 'UPalPartnerSkillParameterComponent::bIdlelCostDecreaseEveryFrame' has a wrong offset!");
static_assert(offsetof(UPalPartnerSkillParameterComponent, bIsExecSkillContinuation) == 0x00015C, "Member 'UPalPartnerSkillParameterComponent::bIsExecSkillContinuation' has a wrong offset!");
static_assert(offsetof(UPalPartnerSkillParameterComponent, bIsRunning) == 0x00015D, "Member 'UPalPartnerSkillParameterComponent::bIsRunning' has a wrong offset!");
static_assert(offsetof(UPalPartnerSkillParameterComponent, bIsOverheat) == 0x00015E, "Member 'UPalPartnerSkillParameterComponent::bIsOverheat' has a wrong offset!");
static_assert(offsetof(UPalPartnerSkillParameterComponent, bIsExecuting) == 0x00015F, "Member 'UPalPartnerSkillParameterComponent::bIsExecuting' has a wrong offset!");
static_assert(offsetof(UPalPartnerSkillParameterComponent, SkillModule) == 0x000160, "Member 'UPalPartnerSkillParameterComponent::SkillModule' has a wrong offset!");
static_assert(offsetof(UPalPartnerSkillParameterComponent, PassiveSkills) == 0x000168, "Member 'UPalPartnerSkillParameterComponent::PassiveSkills' has a wrong offset!");
static_assert(offsetof(UPalPartnerSkillParameterComponent, RideParameter) == 0x000178, "Member 'UPalPartnerSkillParameterComponent::RideParameter' has a wrong offset!");
static_assert(offsetof(UPalPartnerSkillParameterComponent, FunnelCharacterClass) == 0x000180, "Member 'UPalPartnerSkillParameterComponent::FunnelCharacterClass' has a wrong offset!");
static_assert(offsetof(UPalPartnerSkillParameterComponent, FunnelControllerClass) == 0x000188, "Member 'UPalPartnerSkillParameterComponent::FunnelControllerClass' has a wrong offset!");
static_assert(offsetof(UPalPartnerSkillParameterComponent, FunnelAttackWazaID) == 0x000190, "Member 'UPalPartnerSkillParameterComponent::FunnelAttackWazaID' has a wrong offset!");
static_assert(offsetof(UPalPartnerSkillParameterComponent, PassiveSkill) == 0x000198, "Member 'UPalPartnerSkillParameterComponent::PassiveSkill' has a wrong offset!");
static_assert(offsetof(UPalPartnerSkillParameterComponent, ActiveSkill_MainValue_Overview_EditorOnly) == 0x0001F0, "Member 'UPalPartnerSkillParameterComponent::ActiveSkill_MainValue_Overview_EditorOnly' has a wrong offset!");
static_assert(offsetof(UPalPartnerSkillParameterComponent, ActiveSkill_MainValueByRank) == 0x0001F8, "Member 'UPalPartnerSkillParameterComponent::ActiveSkill_MainValueByRank' has a wrong offset!");

// Class Pal.PalGameSystemInitSequence_ReadyWorldSaveData
// 0x0000 (0x0038 - 0x0038)
class UPalGameSystemInitSequence_ReadyWorldSaveData final : public UPalGameSystemInitSequenceBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGameSystemInitSequence_ReadyWorldSaveData">();
	}
	static class UPalGameSystemInitSequence_ReadyWorldSaveData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalGameSystemInitSequence_ReadyWorldSaveData>();
	}
};
static_assert(alignof(UPalGameSystemInitSequence_ReadyWorldSaveData) == 0x000008, "Wrong alignment on UPalGameSystemInitSequence_ReadyWorldSaveData");
static_assert(sizeof(UPalGameSystemInitSequence_ReadyWorldSaveData) == 0x000038, "Wrong size on UPalGameSystemInitSequence_ReadyWorldSaveData");

// Class Pal.PalUIStatusModel
// 0x0028 (0x0050 - 0x0028)
class UPalUIStatusModel final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnChangeSelectedIndexDelegate;                     // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UPalIndividualCharacterHandle*>  PalHandles;                                        // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B9B[0x8];                                     // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangedIndex__DelegateSignature();
	void ChangeIndex(uint8 Param_Index);
	void ChangeNickname(int32 Param_Index, const class FString& NewNickName);
	void GetDisplayNickName(int32 Param_Index, class FString* OutName);
	void Initialize(const TArray<class UPalIndividualCharacterHandle*>& Handles);
	void OnClickedPalIcon(int32 Param_Index);

	class FText GetDisplayActiveSkillName(int32 Param_Index, int32 SkillIndex) const;
	class FText GetDisplayCoopActionName(int32 Param_Index) const;
	class FText GetDisplayDefaultName(int32 Param_Index) const;
	int32 GetDisplayDefence(int32 Param_Index) const;
	int32 GetDisplayEatingHabits(int32 Param_Index) const;
	EPalElementType GetDisplayElementType1(int32 Param_Index) const;
	EPalElementType GetDisplayElementType2(int32 Param_Index) const;
	struct FFixedPoint64 GetDisplayHP(int32 Param_Index) const;
	float GetDisplayHunger(int32 Param_Index) const;
	int32 GetDisplayLevel(int32 Param_Index) const;
	struct FFixedPoint64 GetDisplayMaxHP(int32 Param_Index) const;
	float GetDisplayMaxHunger(int32 Param_Index) const;
	int32 GetDisplayMeleeAttack(int32 Param_Index) const;
	int32 GetDisplayNextExp(int32 Param_Index) const;
	int32 GetDisplayNowExp(int32 Param_Index) const;
	class UPalIndividualCharacterHandle* GetDisplayPalHandle(uint8 Param_Index) const;
	const uint8 GetDisplayPalNum() const;
	bool GetDisplayPassiveSkillList(int32 Param_Index, TArray<class FName>* OutArray) const;
	EPalStatusPhysicalHealthType GetDisplayPhysicalHealthType(int32 Param_Index) const;
	int32 GetDisplayShotAttack(int32 Param_Index) const;
	int32 GetDisplaySpeed(int32 Param_Index) const;
	const uint8 GetNowSelectedIndex() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIStatusModel">();
	}
	static class UPalUIStatusModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIStatusModel>();
	}
};
static_assert(alignof(UPalUIStatusModel) == 0x000008, "Wrong alignment on UPalUIStatusModel");
static_assert(sizeof(UPalUIStatusModel) == 0x000050, "Wrong size on UPalUIStatusModel");
static_assert(offsetof(UPalUIStatusModel, OnChangeSelectedIndexDelegate) == 0x000028, "Member 'UPalUIStatusModel::OnChangeSelectedIndexDelegate' has a wrong offset!");
static_assert(offsetof(UPalUIStatusModel, PalHandles) == 0x000038, "Member 'UPalUIStatusModel::PalHandles' has a wrong offset!");

// Class Pal.PalGameSystemInitSequence_ApplyWorldSaveData
// 0x0000 (0x0038 - 0x0038)
class UPalGameSystemInitSequence_ApplyWorldSaveData final : public UPalGameSystemInitSequenceBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGameSystemInitSequence_ApplyWorldSaveData">();
	}
	static class UPalGameSystemInitSequence_ApplyWorldSaveData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalGameSystemInitSequence_ApplyWorldSaveData>();
	}
};
static_assert(alignof(UPalGameSystemInitSequence_ApplyWorldSaveData) == 0x000008, "Wrong alignment on UPalGameSystemInitSequence_ApplyWorldSaveData");
static_assert(sizeof(UPalGameSystemInitSequence_ApplyWorldSaveData) == 0x000038, "Wrong size on UPalGameSystemInitSequence_ApplyWorldSaveData");

// Class Pal.PalGameSystemInitSequence_StartAutoSave_WorldOnly
// 0x0000 (0x0038 - 0x0038)
class UPalGameSystemInitSequence_StartAutoSave_WorldOnly final : public UPalGameSystemInitSequenceBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGameSystemInitSequence_StartAutoSave_WorldOnly">();
	}
	static class UPalGameSystemInitSequence_StartAutoSave_WorldOnly* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalGameSystemInitSequence_StartAutoSave_WorldOnly>();
	}
};
static_assert(alignof(UPalGameSystemInitSequence_StartAutoSave_WorldOnly) == 0x000008, "Wrong alignment on UPalGameSystemInitSequence_StartAutoSave_WorldOnly");
static_assert(sizeof(UPalGameSystemInitSequence_StartAutoSave_WorldOnly) == 0x000038, "Wrong size on UPalGameSystemInitSequence_StartAutoSave_WorldOnly");

// Class Pal.PalGameSystemInitSequence_MapObjectRegistration
// 0x0000 (0x0038 - 0x0038)
class UPalGameSystemInitSequence_MapObjectRegistration final : public UPalGameSystemInitSequenceBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGameSystemInitSequence_MapObjectRegistration">();
	}
	static class UPalGameSystemInitSequence_MapObjectRegistration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalGameSystemInitSequence_MapObjectRegistration>();
	}
};
static_assert(alignof(UPalGameSystemInitSequence_MapObjectRegistration) == 0x000008, "Wrong alignment on UPalGameSystemInitSequence_MapObjectRegistration");
static_assert(sizeof(UPalGameSystemInitSequence_MapObjectRegistration) == 0x000038, "Wrong size on UPalGameSystemInitSequence_MapObjectRegistration");

// Class Pal.PalUISelectNumWidgetBase
// 0x0000 (0x0430 - 0x0430)
class UPalUISelectNumWidgetBase final : public UPalUserWidgetOverlayUI
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUISelectNumWidgetBase">();
	}
	static class UPalUISelectNumWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUISelectNumWidgetBase>();
	}
};
static_assert(alignof(UPalUISelectNumWidgetBase) == 0x000008, "Wrong alignment on UPalUISelectNumWidgetBase");
static_assert(sizeof(UPalUISelectNumWidgetBase) == 0x000430, "Wrong size on UPalUISelectNumWidgetBase");

// Class Pal.PalGameWorldSettings
// 0x0138 (0x0160 - 0x0028)
class UPalGameWorldSettings final : public UObject
{
public:
	struct FPalOptionWorldSettings                OptionSettings;                                    // 0x0028(0x0138)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGameWorldSettings">();
	}
	static class UPalGameWorldSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalGameWorldSettings>();
	}
};
static_assert(alignof(UPalGameWorldSettings) == 0x000008, "Wrong alignment on UPalGameWorldSettings");
static_assert(sizeof(UPalGameWorldSettings) == 0x000160, "Wrong size on UPalGameWorldSettings");
static_assert(offsetof(UPalGameWorldSettings, OptionSettings) == 0x000028, "Member 'UPalGameWorldSettings::OptionSettings' has a wrong offset!");

// Class Pal.PalGetWorldUObject
// 0x0000 (0x0028 - 0x0028)
class UPalGetWorldUObject : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGetWorldUObject">();
	}
	static class UPalGetWorldUObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalGetWorldUObject>();
	}
};
static_assert(alignof(UPalGetWorldUObject) == 0x000008, "Wrong alignment on UPalGetWorldUObject");
static_assert(sizeof(UPalGetWorldUObject) == 0x000028, "Wrong size on UPalGetWorldUObject");

// Class Pal.PalMapObjectDropItemParameterComponent
// 0x0010 (0x00B0 - 0x00A0)
class UPalMapObjectDropItemParameterComponent final : public UActorComponent
{
public:
	TArray<struct FPalMapObjectDropItemData>      DropItems;                                         // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectDropItemParameterComponent">();
	}
	static class UPalMapObjectDropItemParameterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectDropItemParameterComponent>();
	}
};
static_assert(alignof(UPalMapObjectDropItemParameterComponent) == 0x000008, "Wrong alignment on UPalMapObjectDropItemParameterComponent");
static_assert(sizeof(UPalMapObjectDropItemParameterComponent) == 0x0000B0, "Wrong size on UPalMapObjectDropItemParameterComponent");
static_assert(offsetof(UPalMapObjectDropItemParameterComponent, DropItems) == 0x0000A0, "Member 'UPalMapObjectDropItemParameterComponent::DropItems' has a wrong offset!");

// Class Pal.PalUIWorkSuitabilitySettingModel
// 0x0008 (0x0030 - 0x0028)
class UPalUIWorkSuitabilitySettingModel final : public UObject
{
public:
	uint8                                         Pad_2BA8[0x8];                                     // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RequestChangeBaseCampBattle(const struct FPalInstanceID& TargetIndividualId, const bool bOn);
	void RequestChangeWorkSuitability(const struct FPalInstanceID& TargetIndividualId, const EPalWorkSuitability WorkSuitability, const bool bOn);

	class UPalIndividualCharacterContainer* GetTargetBaseCampWorkerCharacterContainer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIWorkSuitabilitySettingModel">();
	}
	static class UPalUIWorkSuitabilitySettingModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIWorkSuitabilitySettingModel>();
	}
};
static_assert(alignof(UPalUIWorkSuitabilitySettingModel) == 0x000008, "Wrong alignment on UPalUIWorkSuitabilitySettingModel");
static_assert(sizeof(UPalUIWorkSuitabilitySettingModel) == 0x000030, "Wrong size on UPalUIWorkSuitabilitySettingModel");

// Class Pal.PalGliderComponent
// 0x0078 (0x0118 - 0x00A0)
class UPalGliderComponent : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnStartGlidingDelegate;                            // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEndGlidingDelegate;                              // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FPalGliderPalInfo>              GliderPalInfos;                                    // 0x00C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class APalGliderObject*                       CurrentGlider;                                     // 0x00D0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   CurrentGliderSoftClass;                            // 0x00D8(0x0030)(Net, Transient, RepNotify, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class APalGliderObject>           CurrentGliderClass;                                // 0x0108(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsGliding;                                        // 0x0110(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2BAB[0x7];                                     // 0x0111(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelGliding();
	void EndGliding();
	void EndGliding_ToServer();
	void OnChangeGliderVisibility(bool bIsVisibility);
	void OnChangeMovementMode(class UPalCharacterMovementComponent* Component, EMovementMode PrevMode, EMovementMode NewMode, EPalCharacterMovementCustomMode PrevCustomMode, EPalCharacterMovementCustomMode NewCustomMode);
	void OnCompleteOwnerInitialize();
	void OnDeadGliderPal(const struct FPalDeadInfo& DeadInfo);
	void OnEndGliding();
	void OnEndGliding__DelegateSignature();
	void OnInitializeGlider();
	void OnRep_CurrentGliderSoftClass();
	void OnRep_IsGliding();
	void OnStartGliding();
	void OnStartGliding__DelegateSignature();
	void OnUpdateEquipmentSlot(class UPalItemSlot* ItemSlot, EPalPlayerEquipItemSlotType SlotType);
	void OnUpdateIndividualActor(class UPalIndividualCharacterHandle* Handle);
	void OnUpdateInventoryContainer(class UPalItemContainer* Container);
	void OnUpdateOtomoHolderInitialized(class APalCharacter* Character);
	void OnUpdateOtomoHolderSlot(int32 SlotIndex, class UPalIndividualCharacterHandle* LastHandle);
	void PlayGliderSound(const struct FPalDataTableRowName_SoundID& ID, const struct FPalSoundOptions& Option);
	void SetCurrentGliderSoftClass_ToServer(const TSoftClassPtr<class UClass>& GliderSoftClass);
	void StartGliding();
	void StartGliding_ToServer();
	void StopGliderSound(const struct FPalDataTableRowName_SoundID& ID);

	bool CanEndGliding() const;
	bool CanGliding() const;
	TArray<class FName> GetAllGliderPalNames() const;
	bool HasGliderPal() const;
	bool IsEquipGlider() const;
	bool IsGliding() const;
	class UPalIndividualCharacterHandle* TryGetGliderIndividualHandleFromOtomoHolder() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGliderComponent">();
	}
	static class UPalGliderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalGliderComponent>();
	}
};
static_assert(alignof(UPalGliderComponent) == 0x000008, "Wrong alignment on UPalGliderComponent");
static_assert(sizeof(UPalGliderComponent) == 0x000118, "Wrong size on UPalGliderComponent");
static_assert(offsetof(UPalGliderComponent, OnStartGlidingDelegate) == 0x0000A0, "Member 'UPalGliderComponent::OnStartGlidingDelegate' has a wrong offset!");
static_assert(offsetof(UPalGliderComponent, OnEndGlidingDelegate) == 0x0000B0, "Member 'UPalGliderComponent::OnEndGlidingDelegate' has a wrong offset!");
static_assert(offsetof(UPalGliderComponent, GliderPalInfos) == 0x0000C0, "Member 'UPalGliderComponent::GliderPalInfos' has a wrong offset!");
static_assert(offsetof(UPalGliderComponent, CurrentGlider) == 0x0000D0, "Member 'UPalGliderComponent::CurrentGlider' has a wrong offset!");
static_assert(offsetof(UPalGliderComponent, CurrentGliderSoftClass) == 0x0000D8, "Member 'UPalGliderComponent::CurrentGliderSoftClass' has a wrong offset!");
static_assert(offsetof(UPalGliderComponent, CurrentGliderClass) == 0x000108, "Member 'UPalGliderComponent::CurrentGliderClass' has a wrong offset!");
static_assert(offsetof(UPalGliderComponent, bIsGliding) == 0x000110, "Member 'UPalGliderComponent::bIsGliding' has a wrong offset!");

// Class Pal.PalNetworkBaseCampComponent
// 0x0020 (0x00C0 - 0x00A0)
class UPalNetworkBaseCampComponent final : public UActorComponent
{
public:
	struct FGuid                                  BurningBaseCampLogId;                              // 0x00A0(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FGuid>                          BurningBaseCampIds;                                // 0x00B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void AddBaseCampBurningLog_Client(const struct FGuid& BaseCampId);
	void AddBaseCampLog_Client(const struct FPalMonsterControllerBaseCampLogContent& LogContent);
	void AddBaseCampWorkerDeathLog_Client(const struct FPalInstanceID& WorkerCharacterInstanceId);
	void AddBaseCampWorkerLog_Client(EPalLogType DisplayLogType, const struct FPalInstanceID& WorkerCharacterInstanceId, const class FName& EventDataID);
	void BroadcastAddBaseCampBurningLog_Server(const struct FGuid& BaseCampId);
	void BroadcastBaseCampLog_Server(const struct FPalMonsterControllerBaseCampLogContent& LogContent);
	void BroadcastBaseCampWorkerLog_Server(EPalLogType DisplayLogType, const struct FPalInstanceID& WorkerCharacterInstanceId, const class FName& EventDataID);
	void BroadcastBaseCampWorkerMealLog_Server(const struct FPalMealLogDisplayData& DisplayData);
	void BroadcastRemoveBaseCampBurningLog_Server(const struct FGuid& BaseCampId);
	void Notify_Multicast_bool(const struct FGuid& BaseCampId, const class FName FunctionName, bool Value);
	void Notify_Multicast_FPalNetArchive(const struct FGuid& BaseCampId, const class FName FunctionName, const struct FPalNetArchive& Value);
	void Notify_Multicast_FVector(const struct FGuid& BaseCampId, const class FName FunctionName, const struct FVector& Value);
	void Notify_Multicast_int32(const struct FGuid& BaseCampId, const class FName FunctionName, int32 Value);
	void Notify_Multicast_void(const struct FGuid& BaseCampId, const class FName FunctionName);
	void Notify_RequestClient_bool(const struct FGuid& BaseCampId, const class FName FunctionName, bool Value);
	void Notify_RequestClient_FPalNetArchive(const struct FGuid& BaseCampId, const class FName FunctionName, const struct FPalNetArchive& Value);
	void Notify_RequestClient_FVector(const struct FGuid& BaseCampId, const class FName FunctionName, const struct FVector& Value);
	void Notify_RequestClient_int32(const struct FGuid& BaseCampId, const class FName FunctionName, int32 Value);
	void Notify_RequestClient_void(const struct FGuid& BaseCampId, const class FName FunctionName);
	void NotifyModule_Multicast_bool(const struct FGuid& BaseCampId, const EPalBaseCampModuleType ModuleType, const class FName FunctionName, bool Value);
	void NotifyModule_Multicast_FPalNetArchive(const struct FGuid& BaseCampId, const EPalBaseCampModuleType ModuleType, const class FName FunctionName, const struct FPalNetArchive& Value);
	void NotifyModule_Multicast_FVector(const struct FGuid& BaseCampId, const EPalBaseCampModuleType ModuleType, const class FName FunctionName, const struct FVector& Value);
	void NotifyModule_Multicast_int32(const struct FGuid& BaseCampId, const EPalBaseCampModuleType ModuleType, const class FName FunctionName, int32 Value);
	void NotifyModule_Multicast_void(const struct FGuid& BaseCampId, const EPalBaseCampModuleType ModuleType, const class FName FunctionName);
	void NotifyModule_RequestClient_bool(const struct FGuid& BaseCampId, const EPalBaseCampModuleType ModuleType, const class FName FunctionName, bool Value);
	void NotifyModule_RequestClient_FPalNetArchive(const struct FGuid& BaseCampId, const EPalBaseCampModuleType ModuleType, const class FName FunctionName, const struct FPalNetArchive& Value);
	void NotifyModule_RequestClient_FVector(const struct FGuid& BaseCampId, const EPalBaseCampModuleType ModuleType, const class FName FunctionName, const struct FVector& Value);
	void NotifyModule_RequestClient_int32(const struct FGuid& BaseCampId, const EPalBaseCampModuleType ModuleType, const class FName FunctionName, int32 Value);
	void NotifyModule_RequestClient_void(const struct FGuid& BaseCampId, const EPalBaseCampModuleType ModuleType, const class FName FunctionName);
	void RemoveBaseCampBurningLog_Client(const struct FGuid& BaseCampId);
	void Request_Server_bool(const struct FGuid& BaseCampId, const class FName FunctionName, bool Value);
	void Request_Server_FPalNetArchive(const struct FGuid& BaseCampId, const class FName FunctionName, const struct FPalNetArchive& Value);
	void Request_Server_FVector(const struct FGuid& BaseCampId, const class FName FunctionName, const struct FVector& Value);
	void Request_Server_int32(const struct FGuid& BaseCampId, const class FName FunctionName, int32 Value);
	void Request_Server_void(const struct FGuid& BaseCampId, const class FName FunctionName);
	void RequestChangeBaseCampBattle_ToServer(const struct FPalInstanceID& TargetIndividualId, const bool bOn);
	void RequestChangeWorkSuitability_ToServer(const struct FPalInstanceID& TargetIndividualId, const EPalWorkSuitability WorkSuitability, const bool bOn);
	void RequestModule_Server_bool(const struct FGuid& BaseCampId, const EPalBaseCampModuleType ModuleType, const class FName FunctionName, bool Value);
	void RequestModule_Server_FPalNetArchive(const struct FGuid& BaseCampId, const EPalBaseCampModuleType ModuleType, const class FName FunctionName, const struct FPalNetArchive& Value);
	void RequestModule_Server_FVector(const struct FGuid& BaseCampId, const EPalBaseCampModuleType ModuleType, const class FName FunctionName, const struct FVector& Value);
	void RequestModule_Server_int32(const struct FGuid& BaseCampId, const EPalBaseCampModuleType ModuleType, const class FName FunctionName, int32 Value);
	void RequestModule_Server_void(const struct FGuid& BaseCampId, const EPalBaseCampModuleType ModuleType, const class FName FunctionName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalNetworkBaseCampComponent">();
	}
	static class UPalNetworkBaseCampComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalNetworkBaseCampComponent>();
	}
};
static_assert(alignof(UPalNetworkBaseCampComponent) == 0x000008, "Wrong alignment on UPalNetworkBaseCampComponent");
static_assert(sizeof(UPalNetworkBaseCampComponent) == 0x0000C0, "Wrong size on UPalNetworkBaseCampComponent");
static_assert(offsetof(UPalNetworkBaseCampComponent, BurningBaseCampLogId) == 0x0000A0, "Member 'UPalNetworkBaseCampComponent::BurningBaseCampLogId' has a wrong offset!");
static_assert(offsetof(UPalNetworkBaseCampComponent, BurningBaseCampIds) == 0x0000B0, "Member 'UPalNetworkBaseCampComponent::BurningBaseCampIds' has a wrong offset!");

// Class Pal.PalGliderObject
// 0x0078 (0x0308 - 0x0290)
class APalGliderObject : public AActor
{
public:
	float                                         GliderMaxSpeed;                                    // 0x0290(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GliderSP;                                          // 0x0294(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GliderAirControl;                                  // 0x0298(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GliderGravityScale;                                // 0x029C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OffsetLocation;                                    // 0x02A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               OffsetRotation;                                    // 0x02B8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseLeftHand;                                      // 0x02D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRightHand;                                     // 0x02D1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BCE[0x2];                                     // 0x02D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AttachBoneName;                                    // 0x02D4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BCF[0x4];                                     // 0x02DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           GliderStartAnimation;                              // 0x02E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           GliderLoopAnimation;                               // 0x02E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           GliderStartPlayerAnimation;                        // 0x02F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           GliderLoopPlayerAnimation;                         // 0x02F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalSoundPlayerComponent*               SoundPlayerComponent;                              // 0x0300(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class USceneComponent* GetAkOwnerComponent();

	class UPalSkeletalMeshComponent* GetMainMesh() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGliderObject">();
	}
	static class APalGliderObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalGliderObject>();
	}
};
static_assert(alignof(APalGliderObject) == 0x000008, "Wrong alignment on APalGliderObject");
static_assert(sizeof(APalGliderObject) == 0x000308, "Wrong size on APalGliderObject");
static_assert(offsetof(APalGliderObject, GliderMaxSpeed) == 0x000290, "Member 'APalGliderObject::GliderMaxSpeed' has a wrong offset!");
static_assert(offsetof(APalGliderObject, GliderSP) == 0x000294, "Member 'APalGliderObject::GliderSP' has a wrong offset!");
static_assert(offsetof(APalGliderObject, GliderAirControl) == 0x000298, "Member 'APalGliderObject::GliderAirControl' has a wrong offset!");
static_assert(offsetof(APalGliderObject, GliderGravityScale) == 0x00029C, "Member 'APalGliderObject::GliderGravityScale' has a wrong offset!");
static_assert(offsetof(APalGliderObject, OffsetLocation) == 0x0002A0, "Member 'APalGliderObject::OffsetLocation' has a wrong offset!");
static_assert(offsetof(APalGliderObject, OffsetRotation) == 0x0002B8, "Member 'APalGliderObject::OffsetRotation' has a wrong offset!");
static_assert(offsetof(APalGliderObject, bUseLeftHand) == 0x0002D0, "Member 'APalGliderObject::bUseLeftHand' has a wrong offset!");
static_assert(offsetof(APalGliderObject, bUseRightHand) == 0x0002D1, "Member 'APalGliderObject::bUseRightHand' has a wrong offset!");
static_assert(offsetof(APalGliderObject, AttachBoneName) == 0x0002D4, "Member 'APalGliderObject::AttachBoneName' has a wrong offset!");
static_assert(offsetof(APalGliderObject, GliderStartAnimation) == 0x0002E0, "Member 'APalGliderObject::GliderStartAnimation' has a wrong offset!");
static_assert(offsetof(APalGliderObject, GliderLoopAnimation) == 0x0002E8, "Member 'APalGliderObject::GliderLoopAnimation' has a wrong offset!");
static_assert(offsetof(APalGliderObject, GliderStartPlayerAnimation) == 0x0002F0, "Member 'APalGliderObject::GliderStartPlayerAnimation' has a wrong offset!");
static_assert(offsetof(APalGliderObject, GliderLoopPlayerAnimation) == 0x0002F8, "Member 'APalGliderObject::GliderLoopPlayerAnimation' has a wrong offset!");
static_assert(offsetof(APalGliderObject, SoundPlayerComponent) == 0x000300, "Member 'APalGliderObject::SoundPlayerComponent' has a wrong offset!");

// Class Pal.PalGroupDefine
// 0x0000 (0x0028 - 0x0028)
class UPalGroupDefine final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGroupDefine">();
	}
	static class UPalGroupDefine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalGroupDefine>();
	}
};
static_assert(alignof(UPalGroupDefine) == 0x000008, "Wrong alignment on UPalGroupDefine");
static_assert(sizeof(UPalGroupDefine) == 0x000028, "Wrong size on UPalGroupDefine");

// Class Pal.PalNetworkCharacterStatusOperationComponent
// 0x0010 (0x00B0 - 0x00A0)
class UPalNetworkCharacterStatusOperationComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnReceiveRequestResultDelegate;                    // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UPalNetworkCharacterStatusOperationComponent* NetCharacterStatusOperation(const class UObject* WorldContextObject);

	void ReceiveOperationResult_ToClient(const EPalCharacterStatusOperationResult Result);
	void RequestOtomoStatusPointAdd(const class UPalIndividualCharacterHandle* IndividualHandle, const EPalCharacterStatusOperationName StatusName, const int32 ToRank);
	void RequestOtomoStatusPointAdd_ToServer(const struct FPalInstanceID& IndividualId, const EPalCharacterStatusOperationName StatusName, const int32 ToRank);
	void RequestOtomoStatusPointClear(const class UPalIndividualCharacterHandle* IndividualHandle, const EPalCharacterStatusOperationName StatusName);
	void RequestOtomoStatusPointClear_ToServer(const struct FPalInstanceID& IndividualId, const EPalCharacterStatusOperationName StatusName);
	void RequestOtomoStatusPointClearAll(const class UPalIndividualCharacterHandle* IndividualHandle);
	void RequestOtomoStatusPointClearAll_ToServer(const struct FPalInstanceID& IndividualId);
	void RequestPlayerRankAdd(const int32 ToRank);
	void RequestPlayerRankClear();
	void RequestPlayerStatusClear_ToServer();
	void RequestPlayerStatusUp_ToServer(int32 ToRank);
	void RequestReviveCharacterFromDying(class APalCharacter* Character);
	void RequestReviveCharacterFromDying_ToServer(class APalCharacter* Character);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalNetworkCharacterStatusOperationComponent">();
	}
	static class UPalNetworkCharacterStatusOperationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalNetworkCharacterStatusOperationComponent>();
	}
};
static_assert(alignof(UPalNetworkCharacterStatusOperationComponent) == 0x000008, "Wrong alignment on UPalNetworkCharacterStatusOperationComponent");
static_assert(sizeof(UPalNetworkCharacterStatusOperationComponent) == 0x0000B0, "Wrong size on UPalNetworkCharacterStatusOperationComponent");
static_assert(offsetof(UPalNetworkCharacterStatusOperationComponent, OnReceiveRequestResultDelegate) == 0x0000A0, "Member 'UPalNetworkCharacterStatusOperationComponent::OnReceiveRequestResultDelegate' has a wrong offset!");

// Class Pal.PalUIWorkerSimpleDetailCanvas
// 0x0000 (0x0408 - 0x0408)
class UPalUIWorkerSimpleDetailCanvas final : public UPalUserWidget
{
public:
	void BindBaseCampEvent(class UPalBaseCampModel* TargetCampModel);
	void BindWorkerEvent(class UPalIndividualCharacterHandle* WorkerHandle);
	class UPalBaseCampModel* GetInsideBaseCampModel();
	void OnAddedNewWorker(class UPalIndividualCharacterHandle* WorkerHandle);
	void OnBeginInteractWorker(class AActor* Actor, TScriptInterface<class IPalInteractiveObjectComponentInterface> InteractiveObject);
	void OnEndInteractWorker(class AActor* Actor, TScriptInterface<class IPalInteractiveObjectComponentInterface> InteractiveObject);
	void OnRequestCloseDetail();
	void OnRequestOpenDetail(class AActor* TargetActor);
	void UnbindBaseCampEvent(class UPalBaseCampModel* TargetCampModel);
	void UnbindWorkerEvent(class UPalIndividualCharacterHandle* WorkerHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIWorkerSimpleDetailCanvas">();
	}
	static class UPalUIWorkerSimpleDetailCanvas* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIWorkerSimpleDetailCanvas>();
	}
};
static_assert(alignof(UPalUIWorkerSimpleDetailCanvas) == 0x000008, "Wrong alignment on UPalUIWorkerSimpleDetailCanvas");
static_assert(sizeof(UPalUIWorkerSimpleDetailCanvas) == 0x000408, "Wrong size on UPalUIWorkerSimpleDetailCanvas");

// Class Pal.PlGuildPlayerInfoFilteringWaiter
// 0x0040 (0x0068 - 0x0028)
class UPlGuildPlayerInfoFilteringWaiter final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnFilteredGuildPlayerInfoDelegate;                 // 0x0028(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	struct FPalGuildPlayerInfo                    PlayerInfo;                                        // 0x0038(0x0020)(NativeAccessSpecifierPrivate)
	struct FGuid                                  PlayerUId;                                         // 0x0058(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnFilteredGuildPlayerInfoDelegate__DelegateSignature(class UPlGuildPlayerInfoFilteringWaiter* Waiter, const struct FPalGuildPlayerInfo& FilteredInfo);
	void OnReceivedWordFilteringResult(const class FString& ResponseBody, bool bResponseOK, int32 ResponseCode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlGuildPlayerInfoFilteringWaiter">();
	}
	static class UPlGuildPlayerInfoFilteringWaiter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlGuildPlayerInfoFilteringWaiter>();
	}
};
static_assert(alignof(UPlGuildPlayerInfoFilteringWaiter) == 0x000008, "Wrong alignment on UPlGuildPlayerInfoFilteringWaiter");
static_assert(sizeof(UPlGuildPlayerInfoFilteringWaiter) == 0x000068, "Wrong size on UPlGuildPlayerInfoFilteringWaiter");
static_assert(offsetof(UPlGuildPlayerInfoFilteringWaiter, OnFilteredGuildPlayerInfoDelegate) == 0x000028, "Member 'UPlGuildPlayerInfoFilteringWaiter::OnFilteredGuildPlayerInfoDelegate' has a wrong offset!");
static_assert(offsetof(UPlGuildPlayerInfoFilteringWaiter, PlayerInfo) == 0x000038, "Member 'UPlGuildPlayerInfoFilteringWaiter::PlayerInfo' has a wrong offset!");
static_assert(offsetof(UPlGuildPlayerInfoFilteringWaiter, PlayerUId) == 0x000058, "Member 'UPlGuildPlayerInfoFilteringWaiter::PlayerUId' has a wrong offset!");

// Class Pal.PalMapObjectTestGlobalContainerModel
// 0x0000 (0x0218 - 0x0218)
class UPalMapObjectTestGlobalContainerModel final : public UPalMapObjectConcreteModelBase
{
public:
	void CloseContainerUI();
	void OpenContainerUI();

	void Dispose(const int32 SlotIndex, const int32 Num) const;
	void Move(const int32 Num, const int32 ToSlotIndex, const int32 FromSlotIndex) const;
	void Produce(const class FName StaticItemId, const int32 Num) const;
	void ProduceWithSlot(const class FName StaticItemId, const int32 Num, const int32 SlotIndex) const;
	void ProduceWithSlotWithConsume(const class FName StaticItemId, const int32 Num, const int32 SlotIndex, const int32 ConsumeSlotIndex, const int32 ConsumeNum) const;
	void Swap(const int32 ASlotIndex, const int32 BSlotIndex) const;
	void WatchContainer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectTestGlobalContainerModel">();
	}
	static class UPalMapObjectTestGlobalContainerModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectTestGlobalContainerModel>();
	}
};
static_assert(alignof(UPalMapObjectTestGlobalContainerModel) == 0x000008, "Wrong alignment on UPalMapObjectTestGlobalContainerModel");
static_assert(sizeof(UPalMapObjectTestGlobalContainerModel) == 0x000218, "Wrong size on UPalMapObjectTestGlobalContainerModel");

// Class Pal.PalGuildJoinRequestResultUtility
// 0x0000 (0x0028 - 0x0028)
class UPalGuildJoinRequestResultUtility final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGuildJoinRequestResultUtility">();
	}
	static class UPalGuildJoinRequestResultUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalGuildJoinRequestResultUtility>();
	}
};
static_assert(alignof(UPalGuildJoinRequestResultUtility) == 0x000008, "Wrong alignment on UPalGuildJoinRequestResultUtility");
static_assert(sizeof(UPalGuildJoinRequestResultUtility) == 0x000028, "Wrong size on UPalGuildJoinRequestResultUtility");

// Class Pal.PalGroupUtility
// 0x0000 (0x0028 - 0x0028)
class UPalGroupUtility final : public UBlueprintFunctionLibrary
{
public:
	static const struct FGuid GetGroupIdByIndividualId(const class UObject* WorldContextObject, const struct FPalInstanceID& IndividualId);
	static class UPalGroupGuildBase* GetLocalPlayerGuild(const class UObject* WorldContextObject);
	static EPalOrganizationType GetOrganizationTypeByIndividualHandle(const class UObject* WorldContextObject, class UPalIndividualCharacterHandle* IndividualHandle);
	static EPalOrganizationType GetOrganizationTypeByIndividualId(const class UObject* WorldContextObject, const struct FPalInstanceID& IndividualId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGroupUtility">();
	}
	static class UPalGroupUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalGroupUtility>();
	}
};
static_assert(alignof(UPalGroupUtility) == 0x000008, "Wrong alignment on UPalGroupUtility");
static_assert(sizeof(UPalGroupUtility) == 0x000028, "Wrong size on UPalGroupUtility");

// Class Pal.PalGuildPalStorage
// 0x0010 (0x0038 - 0x0028)
class UPalGuildPalStorage final : public UObject
{
public:
	uint8                                         Pad_2BD7[0x10];                                    // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnNotifiedObtainCharacterInServer(class UPalIndividualCharacterHandle* Handle);
	void OnNotifiedRemovedCharacterFromPalBoxInServer(class UPalIndividualCharacterHandle* Handle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGuildPalStorage">();
	}
	static class UPalGuildPalStorage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalGuildPalStorage>();
	}
};
static_assert(alignof(UPalGuildPalStorage) == 0x000008, "Wrong alignment on UPalGuildPalStorage");
static_assert(sizeof(UPalGuildPalStorage) == 0x000038, "Wrong size on UPalGuildPalStorage");

// Class Pal.PalMapObjectWaterRecievableInterface
// 0x0000 (0x0028 - 0x0028)
class IPalMapObjectWaterRecievableInterface final : public IInterface
{
public:
	void OnWateringBegin(class AActor* Waterer);
	void OnWateringEnd(class AActor* Waterer);
	void OnWaterOneshot(class AActor* Waterer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectWaterRecievableInterface">();
	}
	static class IPalMapObjectWaterRecievableInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPalMapObjectWaterRecievableInterface>();
	}
};
static_assert(alignof(IPalMapObjectWaterRecievableInterface) == 0x000008, "Wrong alignment on IPalMapObjectWaterRecievableInterface");
static_assert(sizeof(IPalMapObjectWaterRecievableInterface) == 0x000028, "Wrong size on IPalMapObjectWaterRecievableInterface");

// Class Pal.PalMapObjectWorldDisposerBase
// 0x0008 (0x0030 - 0x0028)
class UPalMapObjectWorldDisposerBase : public UObject
{
public:
	uint8                                         Pad_2BD8[0x8];                                     // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectWorldDisposerBase">();
	}
	static class UPalMapObjectWorldDisposerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectWorldDisposerBase>();
	}
};
static_assert(alignof(UPalMapObjectWorldDisposerBase) == 0x000008, "Wrong alignment on UPalMapObjectWorldDisposerBase");
static_assert(sizeof(UPalMapObjectWorldDisposerBase) == 0x000030, "Wrong size on UPalMapObjectWorldDisposerBase");

// Class Pal.PalMapObjectWorldDisposer_DropItem
// 0x0060 (0x0090 - 0x0030)
class alignas(0x10) UPalMapObjectWorldDisposer_DropItem final : public UPalMapObjectWorldDisposerBase
{
public:
	uint8                                         Pad_2BD9[0x10];                                    // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EPalDropItemType, struct FPalMapObjectWorldDropItemInfoSet> DropItemInfoSetMap;                                // 0x0040(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)

public:
	void OnCreateMapObject_ServerInternal(class UPalMapObjectModel* SpawnedModel, const struct FVector& SpawnLocation);
	void OnRestoreMapObject_ServerInternal(class UPalMapObjectModel* Model);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectWorldDisposer_DropItem">();
	}
	static class UPalMapObjectWorldDisposer_DropItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectWorldDisposer_DropItem>();
	}
};
static_assert(alignof(UPalMapObjectWorldDisposer_DropItem) == 0x000010, "Wrong alignment on UPalMapObjectWorldDisposer_DropItem");
static_assert(sizeof(UPalMapObjectWorldDisposer_DropItem) == 0x000090, "Wrong size on UPalMapObjectWorldDisposer_DropItem");
static_assert(offsetof(UPalMapObjectWorldDisposer_DropItem, DropItemInfoSetMap) == 0x000040, "Member 'UPalMapObjectWorldDisposer_DropItem::DropItemInfoSetMap' has a wrong offset!");

// Class Pal.PalGuildChangeAdminRequestFlow
// 0x0030 (0x00A0 - 0x0070)
class UPalGuildChangeAdminRequestFlow final : public UPalGuildRequestFlowBase
{
public:
	struct FGuid                                  TargetGuildId;                                     // 0x0070(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  NextAdminPlayerUId;                                // 0x0080(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  ApplicantPlayerUId;                                // 0x0090(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGuildChangeAdminRequestFlow">();
	}
	static class UPalGuildChangeAdminRequestFlow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalGuildChangeAdminRequestFlow>();
	}
};
static_assert(alignof(UPalGuildChangeAdminRequestFlow) == 0x000008, "Wrong alignment on UPalGuildChangeAdminRequestFlow");
static_assert(sizeof(UPalGuildChangeAdminRequestFlow) == 0x0000A0, "Wrong size on UPalGuildChangeAdminRequestFlow");
static_assert(offsetof(UPalGuildChangeAdminRequestFlow, TargetGuildId) == 0x000070, "Member 'UPalGuildChangeAdminRequestFlow::TargetGuildId' has a wrong offset!");
static_assert(offsetof(UPalGuildChangeAdminRequestFlow, NextAdminPlayerUId) == 0x000080, "Member 'UPalGuildChangeAdminRequestFlow::NextAdminPlayerUId' has a wrong offset!");
static_assert(offsetof(UPalGuildChangeAdminRequestFlow, ApplicantPlayerUId) == 0x000090, "Member 'UPalGuildChangeAdminRequestFlow::ApplicantPlayerUId' has a wrong offset!");

// Class Pal.PalGuildChangeAdminRequestSequence_ChangeAdminMainProcess
// 0x0000 (0x0040 - 0x0040)
class UPalGuildChangeAdminRequestSequence_ChangeAdminMainProcess final : public USequentialProcessSequenceBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGuildChangeAdminRequestSequence_ChangeAdminMainProcess">();
	}
	static class UPalGuildChangeAdminRequestSequence_ChangeAdminMainProcess* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalGuildChangeAdminRequestSequence_ChangeAdminMainProcess>();
	}
};
static_assert(alignof(UPalGuildChangeAdminRequestSequence_ChangeAdminMainProcess) == 0x000008, "Wrong alignment on UPalGuildChangeAdminRequestSequence_ChangeAdminMainProcess");
static_assert(sizeof(UPalGuildChangeAdminRequestSequence_ChangeAdminMainProcess) == 0x000040, "Wrong size on UPalGuildChangeAdminRequestSequence_ChangeAdminMainProcess");

// Class Pal.PalNPCInteractCondition
// 0x0018 (0x0040 - 0x0028)
class UPalNPCInteractCondition final : public UObject
{
public:
	uint8                                         Pad_2BDA[0x18];                                    // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetResult(bool bResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalNPCInteractCondition">();
	}
	static class UPalNPCInteractCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalNPCInteractCondition>();
	}
};
static_assert(alignof(UPalNPCInteractCondition) == 0x000008, "Wrong alignment on UPalNPCInteractCondition");
static_assert(sizeof(UPalNPCInteractCondition) == 0x000040, "Wrong size on UPalNPCInteractCondition");

// Class Pal.PalGuildEnterRequestSequence_Trigger
// 0x0000 (0x0040 - 0x0040)
class UPalGuildEnterRequestSequence_Trigger final : public USequentialProcessSequenceBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGuildEnterRequestSequence_Trigger">();
	}
	static class UPalGuildEnterRequestSequence_Trigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalGuildEnterRequestSequence_Trigger>();
	}
};
static_assert(alignof(UPalGuildEnterRequestSequence_Trigger) == 0x000008, "Wrong alignment on UPalGuildEnterRequestSequence_Trigger");
static_assert(sizeof(UPalGuildEnterRequestSequence_Trigger) == 0x000040, "Wrong size on UPalGuildEnterRequestSequence_Trigger");

// Class Pal.PalGuildEnterRequestSequence_OfferEnterGuildToRespondentPlayer
// 0x0000 (0x0068 - 0x0068)
class UPalGuildEnterRequestSequence_OfferEnterGuildToRespondentPlayer final : public UPalGuildRequestFlowSequenceWaitForConfirmPlayer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGuildEnterRequestSequence_OfferEnterGuildToRespondentPlayer">();
	}
	static class UPalGuildEnterRequestSequence_OfferEnterGuildToRespondentPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalGuildEnterRequestSequence_OfferEnterGuildToRespondentPlayer>();
	}
};
static_assert(alignof(UPalGuildEnterRequestSequence_OfferEnterGuildToRespondentPlayer) == 0x000008, "Wrong alignment on UPalGuildEnterRequestSequence_OfferEnterGuildToRespondentPlayer");
static_assert(sizeof(UPalGuildEnterRequestSequence_OfferEnterGuildToRespondentPlayer) == 0x000068, "Wrong size on UPalGuildEnterRequestSequence_OfferEnterGuildToRespondentPlayer");

// Class Pal.PalNPCManager
// 0x0218 (0x0240 - 0x0028)
class UPalNPCManager : public UObject
{
public:
	uint8                                         Pad_2BDB[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavigationQueryFilter>     AIOnNavMeshFilterClass;                            // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class UPalIndividualCharacterHandle*, TDelegate<void(const struct FPalInstanceID& ID)>> CallbackMap;                                       // 0x0038(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<class UPalIndividualCharacterHandle*, struct FPalNPCSpawnInfo> SpawnInfoMap;                                      // 0x0088(0x0050)(Transient, NativeAccessSpecifierPrivate)
	class UPalWildPalDrinkWaterSpotProvider*      DrinkWaterSpotProvider;                            // 0x00D8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FName, bool>                       RespawnDisableFlag;                                // 0x00E0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2BDC[0x50];                                    // 0x0130(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class APalAIController>           NPCAIControllerBaseClass;                          // 0x0180(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             UniqueNPCDataTable;                                // 0x0188(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             NPCOneTalkDataTable;                               // 0x0190(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             NPCMultiTalkDataTable;                             // 0x0198(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EPalNPCTalkUIType, class UDataTable*>    TalkDataTableMap;                                  // 0x01A0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, EPalNPCTalkUIType>          NPCNameTalkTypeMap;                                // 0x01F0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void AllResetBossRespawnFlag();
	class FName GetCharacterIDFromCharacterIDAndUniqueNPCID(class FName CharacterID, class FName UniqueNPCID);
	class UPalWildPalDrinkWaterSpotProvider* GetDrinkWaterSpotProvider();
	class UDataTable* GetNPCCharacterTalkDT(class FName CharacterID);
	TSubclassOf<class UPalNPCMultiTalkHandle> GetNPCMultiTalkClass(class APalCharacter* Character);
	TSubclassOf<class UPalNPCMultiTalkHandle> GetNPCMultiTalkClassFromTalkId(class FName TalkId);
	class UDataTable* GetNPCOneTalkDTFromCharacter(class APalCharacter* Character);
	class UDataTable* GetNPCOneTalkDTFromTalkId(class FName TalkId);
	class UDataTable* GetNPCTalkDTFromTalkUIType(EPalNPCTalkUIType TalkUIType);
	EPalNPCTalkUIType GetTalkUIType(class APalCharacter* Character);
	bool IsTalkable(class APalCharacter* Character);
	bool IsTransientTalkCount(class APalCharacter* Character);
	void NPCSpawnCallback__DelegateSignature(const struct FPalInstanceID& ID);
	void RemoveGroupWhenDestoryActor(class AActor* DestoryActor);
	void SetEnemyCampStatus(class FName KeyName, const struct FPalEnemyCampStatus& EnemyCampStatus);
	class UPalIndividualCharacterHandle* SpawnNPCForServer(const struct FPalNPCSpawnInfo& SpawnInfo, TDelegate<void(const struct FPalInstanceID& ID)> SpawnCallback);
	void SpawNPCCallback(const struct FPalInstanceID& ID);

	struct FPalEnemyCampStatus GetEnemyCampStatus(class FName KeyName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalNPCManager">();
	}
	static class UPalNPCManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalNPCManager>();
	}
};
static_assert(alignof(UPalNPCManager) == 0x000008, "Wrong alignment on UPalNPCManager");
static_assert(sizeof(UPalNPCManager) == 0x000240, "Wrong size on UPalNPCManager");
static_assert(offsetof(UPalNPCManager, AIOnNavMeshFilterClass) == 0x000030, "Member 'UPalNPCManager::AIOnNavMeshFilterClass' has a wrong offset!");
static_assert(offsetof(UPalNPCManager, CallbackMap) == 0x000038, "Member 'UPalNPCManager::CallbackMap' has a wrong offset!");
static_assert(offsetof(UPalNPCManager, SpawnInfoMap) == 0x000088, "Member 'UPalNPCManager::SpawnInfoMap' has a wrong offset!");
static_assert(offsetof(UPalNPCManager, DrinkWaterSpotProvider) == 0x0000D8, "Member 'UPalNPCManager::DrinkWaterSpotProvider' has a wrong offset!");
static_assert(offsetof(UPalNPCManager, RespawnDisableFlag) == 0x0000E0, "Member 'UPalNPCManager::RespawnDisableFlag' has a wrong offset!");
static_assert(offsetof(UPalNPCManager, NPCAIControllerBaseClass) == 0x000180, "Member 'UPalNPCManager::NPCAIControllerBaseClass' has a wrong offset!");
static_assert(offsetof(UPalNPCManager, UniqueNPCDataTable) == 0x000188, "Member 'UPalNPCManager::UniqueNPCDataTable' has a wrong offset!");
static_assert(offsetof(UPalNPCManager, NPCOneTalkDataTable) == 0x000190, "Member 'UPalNPCManager::NPCOneTalkDataTable' has a wrong offset!");
static_assert(offsetof(UPalNPCManager, NPCMultiTalkDataTable) == 0x000198, "Member 'UPalNPCManager::NPCMultiTalkDataTable' has a wrong offset!");
static_assert(offsetof(UPalNPCManager, TalkDataTableMap) == 0x0001A0, "Member 'UPalNPCManager::TalkDataTableMap' has a wrong offset!");
static_assert(offsetof(UPalNPCManager, NPCNameTalkTypeMap) == 0x0001F0, "Member 'UPalNPCManager::NPCNameTalkTypeMap' has a wrong offset!");

// Class Pal.PalGuildEnterRequestSequence_EnterGuildMainProcess
// 0x0000 (0x0040 - 0x0040)
class UPalGuildEnterRequestSequence_EnterGuildMainProcess final : public USequentialProcessSequenceBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGuildEnterRequestSequence_EnterGuildMainProcess">();
	}
	static class UPalGuildEnterRequestSequence_EnterGuildMainProcess* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalGuildEnterRequestSequence_EnterGuildMainProcess>();
	}
};
static_assert(alignof(UPalGuildEnterRequestSequence_EnterGuildMainProcess) == 0x000008, "Wrong alignment on UPalGuildEnterRequestSequence_EnterGuildMainProcess");
static_assert(sizeof(UPalGuildEnterRequestSequence_EnterGuildMainProcess) == 0x000040, "Wrong size on UPalGuildEnterRequestSequence_EnterGuildMainProcess");

// Class Pal.PalGuildExitRequestFlow
// 0x0030 (0x00A0 - 0x0070)
class UPalGuildExitRequestFlow final : public UPalGuildRequestFlowBase
{
public:
	struct FGuid                                  TargetGuildId;                                     // 0x0070(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  TargetPlayerUId;                                   // 0x0080(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  ApplicantPlayerUId;                                // 0x0090(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGuildExitRequestFlow">();
	}
	static class UPalGuildExitRequestFlow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalGuildExitRequestFlow>();
	}
};
static_assert(alignof(UPalGuildExitRequestFlow) == 0x000008, "Wrong alignment on UPalGuildExitRequestFlow");
static_assert(sizeof(UPalGuildExitRequestFlow) == 0x0000A0, "Wrong size on UPalGuildExitRequestFlow");
static_assert(offsetof(UPalGuildExitRequestFlow, TargetGuildId) == 0x000070, "Member 'UPalGuildExitRequestFlow::TargetGuildId' has a wrong offset!");
static_assert(offsetof(UPalGuildExitRequestFlow, TargetPlayerUId) == 0x000080, "Member 'UPalGuildExitRequestFlow::TargetPlayerUId' has a wrong offset!");
static_assert(offsetof(UPalGuildExitRequestFlow, ApplicantPlayerUId) == 0x000090, "Member 'UPalGuildExitRequestFlow::ApplicantPlayerUId' has a wrong offset!");

// Class Pal.PalGuildExitRequestSequence_Trigger
// 0x0000 (0x0040 - 0x0040)
class UPalGuildExitRequestSequence_Trigger final : public USequentialProcessSequenceBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGuildExitRequestSequence_Trigger">();
	}
	static class UPalGuildExitRequestSequence_Trigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalGuildExitRequestSequence_Trigger>();
	}
};
static_assert(alignof(UPalGuildExitRequestSequence_Trigger) == 0x000008, "Wrong alignment on UPalGuildExitRequestSequence_Trigger");
static_assert(sizeof(UPalGuildExitRequestSequence_Trigger) == 0x000040, "Wrong size on UPalGuildExitRequestSequence_Trigger");

// Class Pal.PalNPCTalkSystem
// 0x00B0 (0x00D8 - 0x0028)
class UPalNPCTalkSystem final : public UObject
{
public:
	uint8                                         Pad_2BE1[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalTalkWidgetParameter*                TalkWidgetParameter;                               // 0x0030(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalTalkWindowWidgetBase*               TalkWidget;                                        // 0x0038(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPalNPCTalkData                        NowExecutedTalkData;                               // 0x0040(0x0058)(NativeAccessSpecifierPrivate)
	int32                                         NowTalkDataIndex;                                  // 0x0098(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   NowTalkDataSeqenceName;                            // 0x009C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2BE2[0x4];                                     // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           DefaultYesNoChoiceText;                            // 0x00A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UFunction*                              TargetFunc;                                        // 0x00B8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             FuncParam;                                         // 0x00C0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPalNPCTalkCustomFunctionResult               CustomFuncResult;                                  // 0x00C8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2BE3[0x3];                                     // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CustomFuncChoseIndex;                              // 0x00CC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CustomFuncTalkDataIndex;                           // 0x00D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2BE4[0x4];                                     // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddArgument_Implementation(const class FString& Key, const class FText& Text);
	bool CallCustomFunc();
	bool ChangeSeqence(class FName TargetSeqenceName);
	void Initialize(class UPalTalkWidgetParameter* InParameter, class UPalTalkWindowWidgetBase* InTalkWidget);
	EPalNPCTalkProceedResult Proceed();
	void SetCustomFunctionChoseIndex_Implementation(int32 Param_Index);
	void SetCustomFunctionResult_Implementation(EPalNPCTalkCustomFunctionResult Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalNPCTalkSystem">();
	}
	static class UPalNPCTalkSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalNPCTalkSystem>();
	}
};
static_assert(alignof(UPalNPCTalkSystem) == 0x000008, "Wrong alignment on UPalNPCTalkSystem");
static_assert(sizeof(UPalNPCTalkSystem) == 0x0000D8, "Wrong size on UPalNPCTalkSystem");
static_assert(offsetof(UPalNPCTalkSystem, TalkWidgetParameter) == 0x000030, "Member 'UPalNPCTalkSystem::TalkWidgetParameter' has a wrong offset!");
static_assert(offsetof(UPalNPCTalkSystem, TalkWidget) == 0x000038, "Member 'UPalNPCTalkSystem::TalkWidget' has a wrong offset!");
static_assert(offsetof(UPalNPCTalkSystem, NowExecutedTalkData) == 0x000040, "Member 'UPalNPCTalkSystem::NowExecutedTalkData' has a wrong offset!");
static_assert(offsetof(UPalNPCTalkSystem, NowTalkDataIndex) == 0x000098, "Member 'UPalNPCTalkSystem::NowTalkDataIndex' has a wrong offset!");
static_assert(offsetof(UPalNPCTalkSystem, NowTalkDataSeqenceName) == 0x00009C, "Member 'UPalNPCTalkSystem::NowTalkDataSeqenceName' has a wrong offset!");
static_assert(offsetof(UPalNPCTalkSystem, DefaultYesNoChoiceText) == 0x0000A8, "Member 'UPalNPCTalkSystem::DefaultYesNoChoiceText' has a wrong offset!");
static_assert(offsetof(UPalNPCTalkSystem, TargetFunc) == 0x0000B8, "Member 'UPalNPCTalkSystem::TargetFunc' has a wrong offset!");
static_assert(offsetof(UPalNPCTalkSystem, FuncParam) == 0x0000C0, "Member 'UPalNPCTalkSystem::FuncParam' has a wrong offset!");
static_assert(offsetof(UPalNPCTalkSystem, CustomFuncResult) == 0x0000C8, "Member 'UPalNPCTalkSystem::CustomFuncResult' has a wrong offset!");
static_assert(offsetof(UPalNPCTalkSystem, CustomFuncChoseIndex) == 0x0000CC, "Member 'UPalNPCTalkSystem::CustomFuncChoseIndex' has a wrong offset!");
static_assert(offsetof(UPalNPCTalkSystem, CustomFuncTalkDataIndex) == 0x0000D0, "Member 'UPalNPCTalkSystem::CustomFuncTalkDataIndex' has a wrong offset!");

// Class Pal.PalHate
// 0x0058 (0x0080 - 0x0028)
class UPalHate final : public UObject
{
public:
	TMap<struct FPalInstanceID, float>            HateMap;                                           // 0x0028(0x0050)(Transient, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           HateTimerHandle;                                   // 0x0078(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AttackSuccessEvent(const struct FPalDamageResult& DamageResult);
	void ChangeHate(const class AActor* Attacker, float PlusHateValue);
	void DamageEvent(const struct FPalDamageResult& DamageResult);
	class AActor* FindMostHateTarget();
	void ForceHateUp_ForActiveAndAttackOtomoPal(const class AActor* OtomoPal);
	void SelfDeathEvent(const struct FPalDeadInfo& DeadInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalHate">();
	}
	static class UPalHate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalHate>();
	}
};
static_assert(alignof(UPalHate) == 0x000008, "Wrong alignment on UPalHate");
static_assert(sizeof(UPalHate) == 0x000080, "Wrong size on UPalHate");
static_assert(offsetof(UPalHate, HateMap) == 0x000028, "Member 'UPalHate::HateMap' has a wrong offset!");
static_assert(offsetof(UPalHate, HateTimerHandle) == 0x000078, "Member 'UPalHate::HateTimerHandle' has a wrong offset!");

// Class Pal.PalHeatSourceBoxComponent
// 0x0010 (0x0590 - 0x0580)
class UPalHeatSourceBoxComponent final : public UBoxComponent
{
public:
	bool                                          DefaultActive;                                     // 0x0578(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2BE7[0x7];                                     // 0x0579(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalHeatSourceModule*                   HeatSourceModule;                                  // 0x0580(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2BE8[0x8];                                     // 0x0588(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UPalHeatSourceModule* GetModule();
	void SetActiveHeatSource(bool NextIsActive);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalHeatSourceBoxComponent">();
	}
	static class UPalHeatSourceBoxComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalHeatSourceBoxComponent>();
	}
};
static_assert(alignof(UPalHeatSourceBoxComponent) == 0x000010, "Wrong alignment on UPalHeatSourceBoxComponent");
static_assert(sizeof(UPalHeatSourceBoxComponent) == 0x000590, "Wrong size on UPalHeatSourceBoxComponent");
static_assert(offsetof(UPalHeatSourceBoxComponent, DefaultActive) == 0x000578, "Member 'UPalHeatSourceBoxComponent::DefaultActive' has a wrong offset!");
static_assert(offsetof(UPalHeatSourceBoxComponent, HeatSourceModule) == 0x000580, "Member 'UPalHeatSourceBoxComponent::HeatSourceModule' has a wrong offset!");

// Class Pal.PalObjectDurabilityInterface
// 0x0000 (0x0028 - 0x0028)
class IPalObjectDurabilityInterface final : public IInterface
{
public:
	void SetDurability(float NewDurability);

	float GetDurability() const;
	float GetMaxDurability() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalObjectDurabilityInterface">();
	}
	static class IPalObjectDurabilityInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPalObjectDurabilityInterface>();
	}
};
static_assert(alignof(IPalObjectDurabilityInterface) == 0x000008, "Wrong alignment on IPalObjectDurabilityInterface");
static_assert(sizeof(IPalObjectDurabilityInterface) == 0x000028, "Wrong size on IPalObjectDurabilityInterface");

// Class Pal.PalHeatSourceSphereComponent
// 0x0010 (0x0570 - 0x0560)
class UPalHeatSourceSphereComponent final : public USphereComponent
{
public:
	bool                                          DefaultActive;                                     // 0x0560(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2BE9[0x7];                                     // 0x0561(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalHeatSourceModule*                   HeatSourceModule;                                  // 0x0568(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UPalHeatSourceModule* GetModule();
	void SetActiveHeatSource(bool NextIsActive);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalHeatSourceSphereComponent">();
	}
	static class UPalHeatSourceSphereComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalHeatSourceSphereComponent>();
	}
};
static_assert(alignof(UPalHeatSourceSphereComponent) == 0x000010, "Wrong alignment on UPalHeatSourceSphereComponent");
static_assert(sizeof(UPalHeatSourceSphereComponent) == 0x000570, "Wrong size on UPalHeatSourceSphereComponent");
static_assert(offsetof(UPalHeatSourceSphereComponent, DefaultActive) == 0x000560, "Member 'UPalHeatSourceSphereComponent::DefaultActive' has a wrong offset!");
static_assert(offsetof(UPalHeatSourceSphereComponent, HeatSourceModule) == 0x000568, "Member 'UPalHeatSourceSphereComponent::HeatSourceModule' has a wrong offset!");

// Class Pal.PalMapObjectCharacterStatusOperatorModel
// 0x0000 (0x0218 - 0x0218)
class UPalMapObjectCharacterStatusOperatorModel final : public UPalMapObjectConcreteModelBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectCharacterStatusOperatorModel">();
	}
	static class UPalMapObjectCharacterStatusOperatorModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectCharacterStatusOperatorModel>();
	}
};
static_assert(alignof(UPalMapObjectCharacterStatusOperatorModel) == 0x000008, "Wrong alignment on UPalMapObjectCharacterStatusOperatorModel");
static_assert(sizeof(UPalMapObjectCharacterStatusOperatorModel) == 0x000218, "Wrong size on UPalMapObjectCharacterStatusOperatorModel");

// Class Pal.PalHiddenAreaCapsule
// 0x0008 (0x02A0 - 0x0298)
class APalHiddenAreaCapsule final : public APalHiddenAreaBase
{
public:
	class UPalHiddenCapsuleComponent*             HiddenCapsuleComponent;                            // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalHiddenAreaCapsule">();
	}
	static class APalHiddenAreaCapsule* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalHiddenAreaCapsule>();
	}
};
static_assert(alignof(APalHiddenAreaCapsule) == 0x000008, "Wrong alignment on APalHiddenAreaCapsule");
static_assert(sizeof(APalHiddenAreaCapsule) == 0x0002A0, "Wrong size on APalHiddenAreaCapsule");
static_assert(offsetof(APalHiddenAreaCapsule, HiddenCapsuleComponent) == 0x000298, "Member 'APalHiddenAreaCapsule::HiddenCapsuleComponent' has a wrong offset!");

// Class Pal.PalHiddenCapsuleComponent
// 0x0000 (0x0560 - 0x0560)
class UPalHiddenCapsuleComponent final : public UCapsuleComponent
{
public:
	void BeginOverlapEvent(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void EndOverlapEvent(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalHiddenCapsuleComponent">();
	}
	static class UPalHiddenCapsuleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalHiddenCapsuleComponent>();
	}
};
static_assert(alignof(UPalHiddenCapsuleComponent) == 0x000010, "Wrong alignment on UPalHiddenCapsuleComponent");
static_assert(sizeof(UPalHiddenCapsuleComponent) == 0x000560, "Wrong size on UPalHiddenCapsuleComponent");

// Class Pal.PalMapObjectDamagedScarecrowModel
// 0x0008 (0x0220 - 0x0218)
class UPalMapObjectDamagedScarecrowModel final : public UPalMapObjectConcreteModelBase
{
public:
	float                                         ProgressTimeStartAtDamaged;                        // 0x0218(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2BEC[0x4];                                     // 0x021C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDamage_ServerInternal(class UPalMapObjectModel* Model, const struct FPalDamageInfo& DamageInfo, const int32 LastHp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectDamagedScarecrowModel">();
	}
	static class UPalMapObjectDamagedScarecrowModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectDamagedScarecrowModel>();
	}
};
static_assert(alignof(UPalMapObjectDamagedScarecrowModel) == 0x000008, "Wrong alignment on UPalMapObjectDamagedScarecrowModel");
static_assert(sizeof(UPalMapObjectDamagedScarecrowModel) == 0x000220, "Wrong size on UPalMapObjectDamagedScarecrowModel");
static_assert(offsetof(UPalMapObjectDamagedScarecrowModel, ProgressTimeStartAtDamaged) == 0x000218, "Member 'UPalMapObjectDamagedScarecrowModel::ProgressTimeStartAtDamaged' has a wrong offset!");

// Class Pal.PalHitCollisionBox
// 0x0008 (0x02A0 - 0x0298)
class APalHitCollisionBox final : public APalHitCollision
{
public:
	class UBoxComponent*                          BoxComponent;                                      // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void DrawHitCollision();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalHitCollisionBox">();
	}
	static class APalHitCollisionBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalHitCollisionBox>();
	}
};
static_assert(alignof(APalHitCollisionBox) == 0x000008, "Wrong alignment on APalHitCollisionBox");
static_assert(sizeof(APalHitCollisionBox) == 0x0002A0, "Wrong size on APalHitCollisionBox");
static_assert(offsetof(APalHitCollisionBox, BoxComponent) == 0x000298, "Member 'APalHitCollisionBox::BoxComponent' has a wrong offset!");

// Class Pal.PalHUDDispatchParameter_ConvertItem
// 0x0008 (0x0040 - 0x0038)
class UPalHUDDispatchParameter_ConvertItem final : public UPalHUDDispatchParameterBase
{
public:
	class UPalMapObjectConvertItemModel*          ConvertItemModel;                                  // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalHUDDispatchParameter_ConvertItem">();
	}
	static class UPalHUDDispatchParameter_ConvertItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalHUDDispatchParameter_ConvertItem>();
	}
};
static_assert(alignof(UPalHUDDispatchParameter_ConvertItem) == 0x000008, "Wrong alignment on UPalHUDDispatchParameter_ConvertItem");
static_assert(sizeof(UPalHUDDispatchParameter_ConvertItem) == 0x000040, "Wrong size on UPalHUDDispatchParameter_ConvertItem");
static_assert(offsetof(UPalHUDDispatchParameter_ConvertItem, ConvertItemModel) == 0x000038, "Member 'UPalHUDDispatchParameter_ConvertItem::ConvertItemModel' has a wrong offset!");

// Class Pal.PalMapObjectDefenseWaitModel
// 0x0008 (0x0220 - 0x0218)
class UPalMapObjectDefenseWaitModel final : public UPalMapObjectDefenseModelBase
{
public:
	TWeakObjectPtr<class APalMapObject>           WeakLauncherControlMapObject;                      // 0x0218(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectDefenseWaitModel">();
	}
	static class UPalMapObjectDefenseWaitModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectDefenseWaitModel>();
	}
};
static_assert(alignof(UPalMapObjectDefenseWaitModel) == 0x000008, "Wrong alignment on UPalMapObjectDefenseWaitModel");
static_assert(sizeof(UPalMapObjectDefenseWaitModel) == 0x000220, "Wrong size on UPalMapObjectDefenseWaitModel");
static_assert(offsetof(UPalMapObjectDefenseWaitModel, WeakLauncherControlMapObject) == 0x000218, "Member 'UPalMapObjectDefenseWaitModel::WeakLauncherControlMapObject' has a wrong offset!");

// Class Pal.PalHUDDispatchParameter_RecoverOtomo
// 0x0008 (0x0040 - 0x0038)
class UPalHUDDispatchParameter_RecoverOtomo final : public UPalHUDDispatchParameterBase
{
public:
	class UPalMapObjectRecoverOtomoModel*         RecoverOtomoModel;                                 // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalHUDDispatchParameter_RecoverOtomo">();
	}
	static class UPalHUDDispatchParameter_RecoverOtomo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalHUDDispatchParameter_RecoverOtomo>();
	}
};
static_assert(alignof(UPalHUDDispatchParameter_RecoverOtomo) == 0x000008, "Wrong alignment on UPalHUDDispatchParameter_RecoverOtomo");
static_assert(sizeof(UPalHUDDispatchParameter_RecoverOtomo) == 0x000040, "Wrong size on UPalHUDDispatchParameter_RecoverOtomo");
static_assert(offsetof(UPalHUDDispatchParameter_RecoverOtomo, RecoverOtomoModel) == 0x000038, "Member 'UPalHUDDispatchParameter_RecoverOtomo::RecoverOtomoModel' has a wrong offset!");

// Class Pal.PalHUDDispatchParameter_PalBox
// 0x0010 (0x0048 - 0x0038)
class UPalHUDDispatchParameter_PalBox final : public UPalHUDDispatchParameterBase
{
public:
	struct FGuid                                  BaseCampId;                                        // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalHUDDispatchParameter_PalBox">();
	}
	static class UPalHUDDispatchParameter_PalBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalHUDDispatchParameter_PalBox>();
	}
};
static_assert(alignof(UPalHUDDispatchParameter_PalBox) == 0x000008, "Wrong alignment on UPalHUDDispatchParameter_PalBox");
static_assert(sizeof(UPalHUDDispatchParameter_PalBox) == 0x000048, "Wrong size on UPalHUDDispatchParameter_PalBox");
static_assert(offsetof(UPalHUDDispatchParameter_PalBox, BaseCampId) == 0x000038, "Member 'UPalHUDDispatchParameter_PalBox::BaseCampId' has a wrong offset!");

// Class Pal.PalMapObjectModelInitializeExtraParameterPalEgg
// 0x0008 (0x0030 - 0x0028)
class UPalMapObjectModelInitializeExtraParameterPalEgg final : public UPalMapObjectModelInitializeExtraParameterBase
{
public:
	class FName                                   CharacterID;                                       // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectModelInitializeExtraParameterPalEgg">();
	}
	static class UPalMapObjectModelInitializeExtraParameterPalEgg* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectModelInitializeExtraParameterPalEgg>();
	}
};
static_assert(alignof(UPalMapObjectModelInitializeExtraParameterPalEgg) == 0x000008, "Wrong alignment on UPalMapObjectModelInitializeExtraParameterPalEgg");
static_assert(sizeof(UPalMapObjectModelInitializeExtraParameterPalEgg) == 0x000030, "Wrong size on UPalMapObjectModelInitializeExtraParameterPalEgg");
static_assert(offsetof(UPalMapObjectModelInitializeExtraParameterPalEgg, CharacterID) == 0x000028, "Member 'UPalMapObjectModelInitializeExtraParameterPalEgg::CharacterID' has a wrong offset!");

// Class Pal.PalHUDDispatchParameter_HungerIcon
// 0x0018 (0x0050 - 0x0038)
class UPalHUDDispatchParameter_HungerIcon final : public UPalHUDDispatchParameterBase
{
public:
	bool                                          IsExistFood;                                       // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BEE[0x3];                                     // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  BelongGroupId;                                     // 0x003C(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BEF[0x4];                                     // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalHUDDispatchParameter_HungerIcon">();
	}
	static class UPalHUDDispatchParameter_HungerIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalHUDDispatchParameter_HungerIcon>();
	}
};
static_assert(alignof(UPalHUDDispatchParameter_HungerIcon) == 0x000008, "Wrong alignment on UPalHUDDispatchParameter_HungerIcon");
static_assert(sizeof(UPalHUDDispatchParameter_HungerIcon) == 0x000050, "Wrong size on UPalHUDDispatchParameter_HungerIcon");
static_assert(offsetof(UPalHUDDispatchParameter_HungerIcon, IsExistFood) == 0x000038, "Member 'UPalHUDDispatchParameter_HungerIcon::IsExistFood' has a wrong offset!");
static_assert(offsetof(UPalHUDDispatchParameter_HungerIcon, BelongGroupId) == 0x00003C, "Member 'UPalHUDDispatchParameter_HungerIcon::BelongGroupId' has a wrong offset!");

// Class Pal.PalHUDDispatchParameter_FadeWidget
// 0x0060 (0x0098 - 0x0038)
class UPalHUDDispatchParameter_FadeWidget final : public UPalHUDDispatchParameterBase
{
public:
	EPalFadeWidgetType                            FadeWidgetType;                                    // 0x0038(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BF0[0x3];                                     // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           CustomColor;                                       // 0x003C(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeInTime;                                        // 0x004C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutTime;                                       // 0x0050(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BF1[0x4];                                     // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnStartFadeIn;                                     // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEndFadeIn;                                       // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStartFadeOut;                                    // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEndFadeOut;                                      // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalHUDDispatchParameter_FadeWidget">();
	}
	static class UPalHUDDispatchParameter_FadeWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalHUDDispatchParameter_FadeWidget>();
	}
};
static_assert(alignof(UPalHUDDispatchParameter_FadeWidget) == 0x000008, "Wrong alignment on UPalHUDDispatchParameter_FadeWidget");
static_assert(sizeof(UPalHUDDispatchParameter_FadeWidget) == 0x000098, "Wrong size on UPalHUDDispatchParameter_FadeWidget");
static_assert(offsetof(UPalHUDDispatchParameter_FadeWidget, FadeWidgetType) == 0x000038, "Member 'UPalHUDDispatchParameter_FadeWidget::FadeWidgetType' has a wrong offset!");
static_assert(offsetof(UPalHUDDispatchParameter_FadeWidget, CustomColor) == 0x00003C, "Member 'UPalHUDDispatchParameter_FadeWidget::CustomColor' has a wrong offset!");
static_assert(offsetof(UPalHUDDispatchParameter_FadeWidget, FadeInTime) == 0x00004C, "Member 'UPalHUDDispatchParameter_FadeWidget::FadeInTime' has a wrong offset!");
static_assert(offsetof(UPalHUDDispatchParameter_FadeWidget, FadeOutTime) == 0x000050, "Member 'UPalHUDDispatchParameter_FadeWidget::FadeOutTime' has a wrong offset!");
static_assert(offsetof(UPalHUDDispatchParameter_FadeWidget, OnStartFadeIn) == 0x000058, "Member 'UPalHUDDispatchParameter_FadeWidget::OnStartFadeIn' has a wrong offset!");
static_assert(offsetof(UPalHUDDispatchParameter_FadeWidget, OnEndFadeIn) == 0x000068, "Member 'UPalHUDDispatchParameter_FadeWidget::OnEndFadeIn' has a wrong offset!");
static_assert(offsetof(UPalHUDDispatchParameter_FadeWidget, OnStartFadeOut) == 0x000078, "Member 'UPalHUDDispatchParameter_FadeWidget::OnStartFadeOut' has a wrong offset!");
static_assert(offsetof(UPalHUDDispatchParameter_FadeWidget, OnEndFadeOut) == 0x000088, "Member 'UPalHUDDispatchParameter_FadeWidget::OnEndFadeOut' has a wrong offset!");

// Class Pal.PalMapObjectModelInitializeExtraParameterByPlayerUId
// 0x0010 (0x0038 - 0x0028)
class UPalMapObjectModelInitializeExtraParameterByPlayerUId final : public UPalMapObjectModelInitializeExtraParameterBase
{
public:
	struct FGuid                                  ByPlayerUId;                                       // 0x0028(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectModelInitializeExtraParameterByPlayerUId">();
	}
	static class UPalMapObjectModelInitializeExtraParameterByPlayerUId* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectModelInitializeExtraParameterByPlayerUId>();
	}
};
static_assert(alignof(UPalMapObjectModelInitializeExtraParameterByPlayerUId) == 0x000008, "Wrong alignment on UPalMapObjectModelInitializeExtraParameterByPlayerUId");
static_assert(sizeof(UPalMapObjectModelInitializeExtraParameterByPlayerUId) == 0x000038, "Wrong size on UPalMapObjectModelInitializeExtraParameterByPlayerUId");
static_assert(offsetof(UPalMapObjectModelInitializeExtraParameterByPlayerUId, ByPlayerUId) == 0x000028, "Member 'UPalMapObjectModelInitializeExtraParameterByPlayerUId::ByPlayerUId' has a wrong offset!");

// Class Pal.PalWorldHUDDisplayInfo
// 0x0090 (0x00B8 - 0x0028)
class UPalWorldHUDDisplayInfo final : public UObject
{
public:
	struct FPalWorldHUDParameter                  Parameter;                                         // 0x0028(0x0068)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FGuid                                  ID;                                                // 0x0090(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisposeFlag;                                      // 0x00A0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BF2[0x3];                                     // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  WidgetId;                                          // 0x00A4(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BF3[0x4];                                     // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorldHUDDisplayInfo">();
	}
	static class UPalWorldHUDDisplayInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWorldHUDDisplayInfo>();
	}
};
static_assert(alignof(UPalWorldHUDDisplayInfo) == 0x000008, "Wrong alignment on UPalWorldHUDDisplayInfo");
static_assert(sizeof(UPalWorldHUDDisplayInfo) == 0x0000B8, "Wrong size on UPalWorldHUDDisplayInfo");
static_assert(offsetof(UPalWorldHUDDisplayInfo, Parameter) == 0x000028, "Member 'UPalWorldHUDDisplayInfo::Parameter' has a wrong offset!");
static_assert(offsetof(UPalWorldHUDDisplayInfo, ID) == 0x000090, "Member 'UPalWorldHUDDisplayInfo::ID' has a wrong offset!");
static_assert(offsetof(UPalWorldHUDDisplayInfo, bDisposeFlag) == 0x0000A0, "Member 'UPalWorldHUDDisplayInfo::bDisposeFlag' has a wrong offset!");
static_assert(offsetof(UPalWorldHUDDisplayInfo, WidgetId) == 0x0000A4, "Member 'UPalWorldHUDDisplayInfo::WidgetId' has a wrong offset!");

// Class Pal.PalHUDLayout
// 0x0030 (0x0400 - 0x03D0)
class UPalHUDLayout final : public UPalActivatableWidget
{
public:
	TSoftClassPtr<class UClass>                   EscapeMenuClass;                                   // 0x03D0(0x0030)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalHUDLayout">();
	}
	static class UPalHUDLayout* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalHUDLayout>();
	}
};
static_assert(alignof(UPalHUDLayout) == 0x000008, "Wrong alignment on UPalHUDLayout");
static_assert(sizeof(UPalHUDLayout) == 0x000400, "Wrong size on UPalHUDLayout");
static_assert(offsetof(UPalHUDLayout, EscapeMenuClass) == 0x0003D0, "Member 'UPalHUDLayout::EscapeMenuClass' has a wrong offset!");

// Class Pal.PalMapObjectPalEgg
// 0x0008 (0x03B8 - 0x03B0)
class APalMapObjectPalEgg final : public APalMapObject
{
public:
	class UPalMapObjectPickupItemPalEggParameterComponent* ParameterComponent;                                // 0x03B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class FName GetCharacterID();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectPalEgg">();
	}
	static class APalMapObjectPalEgg* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalMapObjectPalEgg>();
	}
};
static_assert(alignof(APalMapObjectPalEgg) == 0x000008, "Wrong alignment on APalMapObjectPalEgg");
static_assert(sizeof(APalMapObjectPalEgg) == 0x0003B8, "Wrong size on APalMapObjectPalEgg");
static_assert(offsetof(APalMapObjectPalEgg, ParameterComponent) == 0x0003B0, "Member 'APalMapObjectPalEgg::ParameterComponent' has a wrong offset!");

// Class Pal.PalHUDService
// 0x00E0 (0x0108 - 0x0028)
class UPalHUDService : public UObject
{
public:
	uint8                                         Pad_2BF4[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnPushedStackableUI;                               // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSuccessedCapturePal;                             // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnApplicationActivationStateChanged;               // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInvalidatePlayerInputGuard;                      // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FUITransientData                       TransientData;                                     // 0x0070(0x0088)(BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	TScriptInterface<class IPalHUDServiceProviderInterface> ServiceProvider;                                   // 0x00F8(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UPalHUDDispatchParameterBase* CreateDispatchParameterForK2Node(const class UObject* WorldContextObject, TSubclassOf<class UPalHUDDispatchParameterBase> ParameterClass);

	void ActivateFocusCursor(class UWidget* TargetWidget);
	void ActivatePlayerInputGuard();
	struct FGuid AddHUD(TSubclassOf<class UPalUserWidget> WidgetClass, const EPalHUDWidgetPriority Priority, class UPalHUDDispatchParameterBase* Parameter);
	struct FGuid AddWorldHUD(const struct FPalWorldHUDParameter& Parameter);
	void Close(const struct FGuid& ID);
	void CloseOverlayUIAll();
	void CloseOwnerStackableUI(const class UObject* InObject);
	void DeactivateFocusCursor();
	class UPalUILiftSlotModel* GetLiftSlotModel();
	class UPalSoundPlayer* GetSoundPlayer();
	void HideCommonItemInfo();
	void InvalidatePlayerInputGuard__DelegateSignature();
	void InvokeFunction(const class FName FunctionName);
	void InvokeFunction_FName(const class FName FunctionName, class FName Value);
	void InvokeFunction_Int32(const class FName FunctionName, int32 Value);
	void OnApplicationActivationStateChangedDelegate__DelegateSignature(bool bIsFocused);
	void OnPushedStackableUI__DelegateSignature(const struct FGuid& PushedWidgetID);
	void OnSuccessedCapturePal__DelegateSignature(const struct FPalUIPalCaptureInfo& CaptureInfo);
	void PlayAkSound(class UAkAudioEvent* AkEvent);
	struct FGuid Push(TSubclassOf<class UPalUserWidgetStackableUI> WidgetClass, class UPalHUDDispatchParameterBase* Parameter);
	void RemoveHUD(const struct FGuid& ID);
	void RemoveWorldHUD(const struct FGuid& ID);
	void RemoveWorldHUDFromWidgetId(const struct FGuid& ID);
	void SetHUDLayerHideFlag(const struct FGameplayTag& LayerTagName, const class FName& HideReasonName, bool IsHide);
	void ShowCommonItemInfo(const struct FPalUICommonItemInfoDisplayData& DisplayData);
	void ShowCommonReward(const struct FPalUICommonRewardDisplayData& RewardDisplayData);
	struct FGuid ShowCommonUI(const EPalWidgetBlueprintType WBPType, class UPalHUDDispatchParameterBase* Parameter);
	void StartFadeIn(EPalFadeWidgetLayerType LayerType, class UPalHUDDispatchParameter_FadeWidget* FadeParameter);
	void StartFadeOut(EPalFadeWidgetLayerType LayerType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalHUDService">();
	}
	static class UPalHUDService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalHUDService>();
	}
};
static_assert(alignof(UPalHUDService) == 0x000008, "Wrong alignment on UPalHUDService");
static_assert(sizeof(UPalHUDService) == 0x000108, "Wrong size on UPalHUDService");
static_assert(offsetof(UPalHUDService, OnPushedStackableUI) == 0x000030, "Member 'UPalHUDService::OnPushedStackableUI' has a wrong offset!");
static_assert(offsetof(UPalHUDService, OnSuccessedCapturePal) == 0x000040, "Member 'UPalHUDService::OnSuccessedCapturePal' has a wrong offset!");
static_assert(offsetof(UPalHUDService, OnApplicationActivationStateChanged) == 0x000050, "Member 'UPalHUDService::OnApplicationActivationStateChanged' has a wrong offset!");
static_assert(offsetof(UPalHUDService, OnInvalidatePlayerInputGuard) == 0x000060, "Member 'UPalHUDService::OnInvalidatePlayerInputGuard' has a wrong offset!");
static_assert(offsetof(UPalHUDService, TransientData) == 0x000070, "Member 'UPalHUDService::TransientData' has a wrong offset!");
static_assert(offsetof(UPalHUDService, ServiceProvider) == 0x0000F8, "Member 'UPalHUDService::ServiceProvider' has a wrong offset!");

// Class Pal.PalDebugWindowSetting
// 0x0010 (0x0040 - 0x0030)
class UPalDebugWindowSetting final : public UDataAsset
{
public:
	TArray<class FString>                         PriorityFunctions;                                 // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalDebugWindowSetting">();
	}
	static class UPalDebugWindowSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalDebugWindowSetting>();
	}
};
static_assert(alignof(UPalDebugWindowSetting) == 0x000008, "Wrong alignment on UPalDebugWindowSetting");
static_assert(sizeof(UPalDebugWindowSetting) == 0x000040, "Wrong size on UPalDebugWindowSetting");
static_assert(offsetof(UPalDebugWindowSetting, PriorityFunctions) == 0x000030, "Member 'UPalDebugWindowSetting::PriorityFunctions' has a wrong offset!");

// Class Pal.PalMapObjectPalStorageModel
// 0x00E8 (0x0300 - 0x0218)
class alignas(0x10) UPalMapObjectPalStorageModel final : public UPalMapObjectConcreteModelBase
{
public:
	FMulticastInlineDelegateProperty_             OnSpawnedCharacterDelegate;                        // 0x0218(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BF9[0xC8];                                    // 0x0228(0x00C8)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPalInstanceID>                 SpawnedIndividualIds;                              // 0x02F0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	void OnAddGuildPalStorage_ServerInternal(class UPalIndividualCharacterHandle* NewCharacter);
	void OnDroppedCharacterToPhantom(const struct FPalInstanceID& IndividualId, int32 PhantomId);
	void OnOverlapBeginCageWalls(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp);
	void OnOverlapEndCageWalls(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp);
	void OnSpawnedPhantomCharacter(const struct FPalInstanceID& IndividualId, int32 PhantomId);
	void OnTriggerInteract_BP(class AActor* Other, EPalInteractiveObjectIndicatorType IndicatorType);
	void OnUpdateGuildPalStorage_ServerInternal(class UPalBaseCampModel* BaseCampModel, class UPalGuildPalStorage* GuildPalStorage);
	void SpawnedCharacterDelegate__DelegateSignature(const struct FPalInstanceID& IndividualId, int32 PhantomId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectPalStorageModel">();
	}
	static class UPalMapObjectPalStorageModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectPalStorageModel>();
	}
};
static_assert(alignof(UPalMapObjectPalStorageModel) == 0x000010, "Wrong alignment on UPalMapObjectPalStorageModel");
static_assert(sizeof(UPalMapObjectPalStorageModel) == 0x000300, "Wrong size on UPalMapObjectPalStorageModel");
static_assert(offsetof(UPalMapObjectPalStorageModel, OnSpawnedCharacterDelegate) == 0x000218, "Member 'UPalMapObjectPalStorageModel::OnSpawnedCharacterDelegate' has a wrong offset!");
static_assert(offsetof(UPalMapObjectPalStorageModel, SpawnedIndividualIds) == 0x0002F0, "Member 'UPalMapObjectPalStorageModel::SpawnedIndividualIds' has a wrong offset!");

// Class Pal.PalIncidentList
// 0x0040 (0x01A0 - 0x0160)
class UPalIncidentList final : public UPalIncidentBase
{
public:
	TArray<class FName>                           FirstIncidentIds;                                  // 0x0160(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UPalIncidentBase*>               WaitingIncidents;                                  // 0x0170(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	class UPalIncidentBase*                       CurrentIncident;                                   // 0x0180(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UPalIncidentBase*>               CompletedIncidents;                                // 0x0188(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	int32                                         ProgressCount;                                     // 0x0198(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2BFE[0x4];                                     // 0x019C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddIncident(const class FName& ID);
	void AddIncidents(const TArray<class FName>& IDs);
	void InsertIncidentsToTop(const TArray<class FName>& IDs);
	void InsertIncidentToTop(const class FName& ID);
	void OnAllIncidentsCompleted();
	void OnIncidentProgressed(class UPalIncidentBase* PrevIncident, class UPalIncidentBase* NextIncident, int32 ProcessCount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalIncidentList">();
	}
	static class UPalIncidentList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalIncidentList>();
	}
};
static_assert(alignof(UPalIncidentList) == 0x000010, "Wrong alignment on UPalIncidentList");
static_assert(sizeof(UPalIncidentList) == 0x0001A0, "Wrong size on UPalIncidentList");
static_assert(offsetof(UPalIncidentList, FirstIncidentIds) == 0x000160, "Member 'UPalIncidentList::FirstIncidentIds' has a wrong offset!");
static_assert(offsetof(UPalIncidentList, WaitingIncidents) == 0x000170, "Member 'UPalIncidentList::WaitingIncidents' has a wrong offset!");
static_assert(offsetof(UPalIncidentList, CurrentIncident) == 0x000180, "Member 'UPalIncidentList::CurrentIncident' has a wrong offset!");
static_assert(offsetof(UPalIncidentList, CompletedIncidents) == 0x000188, "Member 'UPalIncidentList::CompletedIncidents' has a wrong offset!");
static_assert(offsetof(UPalIncidentList, ProgressCount) == 0x000198, "Member 'UPalIncidentList::ProgressCount' has a wrong offset!");

// Class Pal.PalIncidentSystem
// 0x0180 (0x01F0 - 0x0070)
class alignas(0x10) UPalIncidentSystem : public UPalWorldSubsystem
{
public:
	TArray<class FName>                           ResidentIncidentList;                              // 0x0070(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FName, TSubclassOf<class UPalIncidentBase>> IncidentClassMap;                                  // 0x0080(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	class UDataTable*                             IncidentParameterDataTable;                        // 0x00D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnIncidentStateNotifyDelegate;                     // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UPalIncidentBase*>               WaitingIncidents;                                  // 0x00E8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class UPalIncidentBase*>               ExecuteIncidents;                                  // 0x00F8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class UPalIncidentBase*>               ResidentIncidents;                                 // 0x0108(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UPalIncidentNotifyListener*>     Listeners;                                         // 0x0118(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C00[0xC8];                                    // 0x0128(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ForceStopByIncidentId(class FName IncidentId);
	void ForceStopByIncidentType(class FName IncidentType);
	void ForceStopByOccuredObject(class UObject* OccuredObject);
	void ForceStopByOwner(class UObject* OwnerObject);
	class UPalIncidentBase* GenerateIncident(struct FPalIncidentInitializeParameter* InitializeParam);
	void IncidentStateNotify__DelegateSignature(EPalIncidentState IncidentState, const struct FPalIncidentNotifyParameter& Parameter);
	bool IsIncidentBeginAllowed(class UPalIncidentBase* Incident);
	void NotifyIncidentState(EPalIncidentState NotifyType, const struct FPalIncidentNotifyParameter& Parameter);
	class UPalIncidentBase* RequestIncident(class FName IncidentId, class UObject* OccuredObject, class UObject* OwnerObject, class UPalIncidentDynamicParameter* Parameter);
	class UPalIncidentList* RequestIncidents(const TArray<class FName>& Incidents, class UObject* OccuredObject, class UObject* OwnerObject, class UPalIncidentDynamicParameter* Parameter);
	void TalkCustomFunction_AttackToPlayer(class APalPlayerCharacter* TalkPlayer, class APalCharacter* TargetNPC, const class UDataTable* CunstomFuncParam);

	void LotteryItemAndNum(const class UDataTable* PresentLotteryDataTable, class FName* OutItemName, int32* OutNum) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalIncidentSystem">();
	}
	static class UPalIncidentSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalIncidentSystem>();
	}
};
static_assert(alignof(UPalIncidentSystem) == 0x000010, "Wrong alignment on UPalIncidentSystem");
static_assert(sizeof(UPalIncidentSystem) == 0x0001F0, "Wrong size on UPalIncidentSystem");
static_assert(offsetof(UPalIncidentSystem, ResidentIncidentList) == 0x000070, "Member 'UPalIncidentSystem::ResidentIncidentList' has a wrong offset!");
static_assert(offsetof(UPalIncidentSystem, IncidentClassMap) == 0x000080, "Member 'UPalIncidentSystem::IncidentClassMap' has a wrong offset!");
static_assert(offsetof(UPalIncidentSystem, IncidentParameterDataTable) == 0x0000D0, "Member 'UPalIncidentSystem::IncidentParameterDataTable' has a wrong offset!");
static_assert(offsetof(UPalIncidentSystem, OnIncidentStateNotifyDelegate) == 0x0000D8, "Member 'UPalIncidentSystem::OnIncidentStateNotifyDelegate' has a wrong offset!");
static_assert(offsetof(UPalIncidentSystem, WaitingIncidents) == 0x0000E8, "Member 'UPalIncidentSystem::WaitingIncidents' has a wrong offset!");
static_assert(offsetof(UPalIncidentSystem, ExecuteIncidents) == 0x0000F8, "Member 'UPalIncidentSystem::ExecuteIncidents' has a wrong offset!");
static_assert(offsetof(UPalIncidentSystem, ResidentIncidents) == 0x000108, "Member 'UPalIncidentSystem::ResidentIncidents' has a wrong offset!");
static_assert(offsetof(UPalIncidentSystem, Listeners) == 0x000118, "Member 'UPalIncidentSystem::Listeners' has a wrong offset!");

// Class Pal.PalMapObjectFarmBlockV2ModelStateBehaviourWatering
// 0x0010 (0x0040 - 0x0030)
class UPalMapObjectFarmBlockV2ModelStateBehaviourWatering final : public UPalMapObjectFarmBlockV2ModelStateBehaviourBase
{
public:
	uint8                                         Pad_2C05[0x10];                                    // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFinishWorkInServer(class UPalWorkBase* Work);
	void OnProgressWorkInServer(class UPalWorkProgress* WorkProgress);
	void UpdateWaterStackRateDelegate__DelegateSignature(float WaterStackRate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectFarmBlockV2ModelStateBehaviourWatering">();
	}
	static class UPalMapObjectFarmBlockV2ModelStateBehaviourWatering* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectFarmBlockV2ModelStateBehaviourWatering>();
	}
};
static_assert(alignof(UPalMapObjectFarmBlockV2ModelStateBehaviourWatering) == 0x000008, "Wrong alignment on UPalMapObjectFarmBlockV2ModelStateBehaviourWatering");
static_assert(sizeof(UPalMapObjectFarmBlockV2ModelStateBehaviourWatering) == 0x000040, "Wrong size on UPalMapObjectFarmBlockV2ModelStateBehaviourWatering");

// Class Pal.PalUniqueRideWeaponBase
// 0x0008 (0x0540 - 0x0538)
class APalUniqueRideWeaponBase final : public APalWeaponBase
{
public:
	uint8                                         Pad_2C06[0x8];                                     // 0x0538(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanUse();
	void GetAllMeshComponent(TArray<class UMeshComponent*>* OutMesh);
	TSubclassOf<class AActor> GetAmmoClass();
	struct FTransform GetAmmoEjectTransform();
	TSubclassOf<class APalBullet> GetBulletClass();
	float GetBulrAngle();
	struct FVector GetCommonTargetLocation();
	class UNiagaraSystem* GetMuzzleEffect();
	struct FVector GetMuzzleLocation();
	struct FRotator GetMuzzleRotation();
	void OnActionBegin(const class UPalActionBase* Action);
	void OnActionCompleted(const class UPalActionComponent* ActionComp);
	void OnCancellShooting();
	void OnUniqueShoot();
	void ShootOneBullet(TSubclassOf<class APalBullet> bulletClass, class UNiagaraSystem* MuzzleEffect, const struct FVector& MuzzleLocation, const struct FRotator& MuzzleRotate, float BulrAngle, TSubclassOf<class AActor> AmmoClass, const struct FTransform& AmmoEject);
	void ShootOneBulletByDefault();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUniqueRideWeaponBase">();
	}
	static class APalUniqueRideWeaponBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalUniqueRideWeaponBase>();
	}
};
static_assert(alignof(APalUniqueRideWeaponBase) == 0x000008, "Wrong alignment on APalUniqueRideWeaponBase");
static_assert(sizeof(APalUniqueRideWeaponBase) == 0x000540, "Wrong size on APalUniqueRideWeaponBase");

// Class Pal.PalNetworkItemComponent
// 0x0140 (0x01E0 - 0x00A0)
class UPalNetworkItemComponent final : public UActorComponent
{
public:
	TMap<struct FGuid, struct FPalNetworkDynamicItemParameter> DynamicItemParamMap;                               // 0x00A0(0x0050)(NativeAccessSpecifierPrivate)
	TMap<struct FGuid, struct FPalNetworkContainerParameter> ContainerParamMap;                                 // 0x00F0(0x0050)(NativeAccessSpecifierPrivate)
	TMap<struct FGuid, struct FPalNetworkItemOperationParameter> ItemOperationParamMap;                             // 0x0140(0x0050)(NativeAccessSpecifierPrivate)
	TMap<struct FGuid, struct FPalNetworkParameter> OperationParamMap;                                 // 0x0190(0x0050)(NativeAccessSpecifierPrivate)

public:
	void ReceiveProduceResult_ToRequestClient(const struct FGuid& RequestID, const EPalItemOperationResult Result);
	void ReceiveProduceWithSlotResult_ToRequestClient(const struct FGuid& RequestID, const EPalItemOperationResult Result);
	void RequestDispose_ToServer(const struct FGuid& RequestID, const struct FPalItemSlotIdAndNum& SlotInfo);
	void RequestDrop_ToServer(const TArray<struct FPalItemSlotIdAndNum>& DropSlotAndNumArray, const struct FVector& DropLocation, bool IsAutoPickup);
	void RequestMove_ToServer(const struct FGuid& RequestID, const struct FPalItemSlotId& To, const TArray<struct FPalItemSlotIdAndNum>& Froms);
	void RequestMoveToContainer_ToServer(const struct FGuid& RequestID, const struct FPalContainerId& ToContainerId, const TArray<struct FPalItemSlotIdAndNum>& Froms);
	void RequestProduce_ToServer(const struct FGuid& RequestID, const struct FPalStaticItemIdAndNum& ProductData, const struct FPalContainerId& ContainerId, const struct FPalNetArchive& CreateParamArchive);
	void RequestProduceWithSlot_ToServer(const struct FGuid& RequestID, const struct FPalStaticItemIdAndNum& ProductData, const struct FPalItemAndSlot& To, const struct FPalNetArchive& CreateParamArchive);
	void RequestSwap_ToServer(const struct FGuid& RequestID, const struct FPalItemSlotId& SlotA, const struct FPalItemSlotId& SlotB);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalNetworkItemComponent">();
	}
	static class UPalNetworkItemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalNetworkItemComponent>();
	}
};
static_assert(alignof(UPalNetworkItemComponent) == 0x000008, "Wrong alignment on UPalNetworkItemComponent");
static_assert(sizeof(UPalNetworkItemComponent) == 0x0001E0, "Wrong size on UPalNetworkItemComponent");
static_assert(offsetof(UPalNetworkItemComponent, DynamicItemParamMap) == 0x0000A0, "Member 'UPalNetworkItemComponent::DynamicItemParamMap' has a wrong offset!");
static_assert(offsetof(UPalNetworkItemComponent, ContainerParamMap) == 0x0000F0, "Member 'UPalNetworkItemComponent::ContainerParamMap' has a wrong offset!");
static_assert(offsetof(UPalNetworkItemComponent, ItemOperationParamMap) == 0x000140, "Member 'UPalNetworkItemComponent::ItemOperationParamMap' has a wrong offset!");
static_assert(offsetof(UPalNetworkItemComponent, OperationParamMap) == 0x000190, "Member 'UPalNetworkItemComponent::OperationParamMap' has a wrong offset!");

// Class Pal.PalIncidentDynamicParameterTalk
// 0x0020 (0x0050 - 0x0030)
class UPalIncidentDynamicParameterTalk final : public UPalIncidentDynamicParameter
{
public:
	EPalIncidentTalkType                          TalkType;                                          // 0x0030(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C0E[0x3];                                     // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TalkId;                                            // 0x0034(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RequestItem;                                       // 0x003C(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequestItemNum;                                    // 0x0044(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRequestSucceed;                                  // 0x0048(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C0F[0x7];                                     // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalIncidentDynamicParameterTalk">();
	}
	static class UPalIncidentDynamicParameterTalk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalIncidentDynamicParameterTalk>();
	}
};
static_assert(alignof(UPalIncidentDynamicParameterTalk) == 0x000008, "Wrong alignment on UPalIncidentDynamicParameterTalk");
static_assert(sizeof(UPalIncidentDynamicParameterTalk) == 0x000050, "Wrong size on UPalIncidentDynamicParameterTalk");
static_assert(offsetof(UPalIncidentDynamicParameterTalk, TalkType) == 0x000030, "Member 'UPalIncidentDynamicParameterTalk::TalkType' has a wrong offset!");
static_assert(offsetof(UPalIncidentDynamicParameterTalk, TalkId) == 0x000034, "Member 'UPalIncidentDynamicParameterTalk::TalkId' has a wrong offset!");
static_assert(offsetof(UPalIncidentDynamicParameterTalk, RequestItem) == 0x00003C, "Member 'UPalIncidentDynamicParameterTalk::RequestItem' has a wrong offset!");
static_assert(offsetof(UPalIncidentDynamicParameterTalk, RequestItemNum) == 0x000044, "Member 'UPalIncidentDynamicParameterTalk::RequestItemNum' has a wrong offset!");
static_assert(offsetof(UPalIncidentDynamicParameterTalk, IsRequestSucceed) == 0x000048, "Member 'UPalIncidentDynamicParameterTalk::IsRequestSucceed' has a wrong offset!");

// Class Pal.PalIndividualCharacterContainer
// 0x0040 (0x0090 - 0x0050)
class UPalIndividualCharacterContainer final : public UPalContainerBase
{
public:
	FMulticastInlineDelegateProperty_             OnUpdateContentsDelegate;                          // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateSlotsDelegate;                             // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C10[0x10];                                    // 0x0070(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UPalIndividualCharacterSlot*>    SlotArray;                                         // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, RepNotify, Protected, NativeAccessSpecifierProtected)

public:
	void OnRep_Slots();
	void UpdateContentsDelegate__DelegateSignature(class UPalIndividualCharacterContainer* Container);

	class UPalIndividualCharacterSlot* FindByHandle(class UPalIndividualCharacterHandle* Handle) const;
	class UPalIndividualCharacterSlot* FindEmptySlot() const;
	class UPalIndividualCharacterSlot* Get(const int32 Param_Index) const;
	TArray<class UPalIndividualCharacterSlot*> GetSlots() const;
	int32 Num() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalIndividualCharacterContainer">();
	}
	static class UPalIndividualCharacterContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalIndividualCharacterContainer>();
	}
};
static_assert(alignof(UPalIndividualCharacterContainer) == 0x000008, "Wrong alignment on UPalIndividualCharacterContainer");
static_assert(sizeof(UPalIndividualCharacterContainer) == 0x000090, "Wrong size on UPalIndividualCharacterContainer");
static_assert(offsetof(UPalIndividualCharacterContainer, OnUpdateContentsDelegate) == 0x000050, "Member 'UPalIndividualCharacterContainer::OnUpdateContentsDelegate' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterContainer, OnUpdateSlotsDelegate) == 0x000060, "Member 'UPalIndividualCharacterContainer::OnUpdateSlotsDelegate' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterContainer, SlotArray) == 0x000080, "Member 'UPalIndividualCharacterContainer::SlotArray' has a wrong offset!");

// Class Pal.PalMapObjectFarmCropDataUtility
// 0x0000 (0x0028 - 0x0028)
class UPalMapObjectFarmCropDataUtility final : public UBlueprintFunctionLibrary
{
public:
	static bool IsValid(struct FPalMapObjectFarmCropData* Data);
	static void MaterialInfos(const struct FPalMapObjectFarmCropData& Data, TArray<struct FPalStaticItemIdAndNum>* Param_MaterialInfos);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectFarmCropDataUtility">();
	}
	static class UPalMapObjectFarmCropDataUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectFarmCropDataUtility>();
	}
};
static_assert(alignof(UPalMapObjectFarmCropDataUtility) == 0x000008, "Wrong alignment on UPalMapObjectFarmCropDataUtility");
static_assert(sizeof(UPalMapObjectFarmCropDataUtility) == 0x000028, "Wrong size on UPalMapObjectFarmCropDataUtility");

// Class Pal.PalIndividualCharacterHandle
// 0x0040 (0x0068 - 0x0028)
class UPalIndividualCharacterHandle : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnUpdateIndividualActorDelegate;                   // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FPalInstanceID                         ID;                                                // 0x0038(0x0030)(Edit, DisableEditOnTemplate, Transient, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void UpdateIndividualActorDelegate__DelegateSignature(class UPalIndividualCharacterHandle* Handle);

	struct FPalInstanceID GetIndividualID() const;
	int32 GetPhantomIDByActor(class APalCharacter* Character) const;
	class APalCharacter* TryGetIndividualActor() const;
	class UPalIndividualCharacterParameter* TryGetIndividualParameter() const;
	class APalCharacter* TryGetPhantomActor(int32 PhantomId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalIndividualCharacterHandle">();
	}
	static class UPalIndividualCharacterHandle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalIndividualCharacterHandle>();
	}
};
static_assert(alignof(UPalIndividualCharacterHandle) == 0x000008, "Wrong alignment on UPalIndividualCharacterHandle");
static_assert(sizeof(UPalIndividualCharacterHandle) == 0x000068, "Wrong size on UPalIndividualCharacterHandle");
static_assert(offsetof(UPalIndividualCharacterHandle, OnUpdateIndividualActorDelegate) == 0x000028, "Member 'UPalIndividualCharacterHandle::OnUpdateIndividualActorDelegate' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterHandle, ID) == 0x000038, "Member 'UPalIndividualCharacterHandle::ID' has a wrong offset!");

// Class Pal.PalNetworkRaidBossComponent
// 0x0000 (0x00A0 - 0x00A0)
class UPalNetworkRaidBossComponent final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalNetworkRaidBossComponent">();
	}
	static class UPalNetworkRaidBossComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalNetworkRaidBossComponent>();
	}
};
static_assert(alignof(UPalNetworkRaidBossComponent) == 0x000008, "Wrong alignment on UPalNetworkRaidBossComponent");
static_assert(sizeof(UPalNetworkRaidBossComponent) == 0x0000A0, "Wrong size on UPalNetworkRaidBossComponent");

// Class Pal.PalIndividualCharacterHandleReference
// 0x0000 (0x0068 - 0x0068)
class UPalIndividualCharacterHandleReference final : public UPalIndividualCharacterHandle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalIndividualCharacterHandleReference">();
	}
	static class UPalIndividualCharacterHandleReference* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalIndividualCharacterHandleReference>();
	}
};
static_assert(alignof(UPalIndividualCharacterHandleReference) == 0x000008, "Wrong alignment on UPalIndividualCharacterHandleReference");
static_assert(sizeof(UPalIndividualCharacterHandleReference) == 0x000068, "Wrong size on UPalIndividualCharacterHandleReference");

// Class Pal.PalHUDDispatchParameter_WorldSetting
// 0x0030 (0x0068 - 0x0038)
class UPalHUDDispatchParameter_WorldSetting final : public UPalHUDDispatchParameterBase
{
public:
	bool                                          IsNewWorld;                                        // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C15[0x7];                                     // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 WorldSaveDirectoryName;                            // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WorldName;                                         // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanMultiplay;                                      // 0x0060(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C16[0x7];                                     // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalHUDDispatchParameter_WorldSetting">();
	}
	static class UPalHUDDispatchParameter_WorldSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalHUDDispatchParameter_WorldSetting>();
	}
};
static_assert(alignof(UPalHUDDispatchParameter_WorldSetting) == 0x000008, "Wrong alignment on UPalHUDDispatchParameter_WorldSetting");
static_assert(sizeof(UPalHUDDispatchParameter_WorldSetting) == 0x000068, "Wrong size on UPalHUDDispatchParameter_WorldSetting");
static_assert(offsetof(UPalHUDDispatchParameter_WorldSetting, IsNewWorld) == 0x000038, "Member 'UPalHUDDispatchParameter_WorldSetting::IsNewWorld' has a wrong offset!");
static_assert(offsetof(UPalHUDDispatchParameter_WorldSetting, WorldSaveDirectoryName) == 0x000040, "Member 'UPalHUDDispatchParameter_WorldSetting::WorldSaveDirectoryName' has a wrong offset!");
static_assert(offsetof(UPalHUDDispatchParameter_WorldSetting, WorldName) == 0x000050, "Member 'UPalHUDDispatchParameter_WorldSetting::WorldName' has a wrong offset!");
static_assert(offsetof(UPalHUDDispatchParameter_WorldSetting, CanMultiplay) == 0x000060, "Member 'UPalHUDDispatchParameter_WorldSetting::CanMultiplay' has a wrong offset!");

// Class Pal.PalStatusHungerTypeUtility
// 0x0000 (0x0028 - 0x0028)
class UPalStatusHungerTypeUtility final : public UBlueprintFunctionLibrary
{
public:
	static bool IsHunger(EPalStatusHungerType Type);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalStatusHungerTypeUtility">();
	}
	static class UPalStatusHungerTypeUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalStatusHungerTypeUtility>();
	}
};
static_assert(alignof(UPalStatusHungerTypeUtility) == 0x000008, "Wrong alignment on UPalStatusHungerTypeUtility");
static_assert(sizeof(UPalStatusHungerTypeUtility) == 0x000028, "Wrong size on UPalStatusHungerTypeUtility");

// Class Pal.PalEquipItemContainerUtility
// 0x0000 (0x0028 - 0x0028)
class UPalEquipItemContainerUtility final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalEquipItemContainerUtility">();
	}
	static class UPalEquipItemContainerUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalEquipItemContainerUtility>();
	}
};
static_assert(alignof(UPalEquipItemContainerUtility) == 0x000008, "Wrong alignment on UPalEquipItemContainerUtility");
static_assert(sizeof(UPalEquipItemContainerUtility) == 0x000028, "Wrong size on UPalEquipItemContainerUtility");

// Class Pal.PalMapObjectFoodBoxParameterComponent
// 0x0008 (0x00A8 - 0x00A0)
class UPalMapObjectFoodBoxParameterComponent final : public UActorComponent
{
public:
	float                                         CorruptionMultiplier;                              // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C17[0x4];                                     // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectFoodBoxParameterComponent">();
	}
	static class UPalMapObjectFoodBoxParameterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectFoodBoxParameterComponent>();
	}
};
static_assert(alignof(UPalMapObjectFoodBoxParameterComponent) == 0x000008, "Wrong alignment on UPalMapObjectFoodBoxParameterComponent");
static_assert(sizeof(UPalMapObjectFoodBoxParameterComponent) == 0x0000A8, "Wrong size on UPalMapObjectFoodBoxParameterComponent");
static_assert(offsetof(UPalMapObjectFoodBoxParameterComponent, CorruptionMultiplier) == 0x0000A0, "Member 'UPalMapObjectFoodBoxParameterComponent::CorruptionMultiplier' has a wrong offset!");

// Class Pal.PalIndividualCharacterParameter
// 0x08C0 (0x08E8 - 0x0028)
class UPalIndividualCharacterParameter final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnUpdateLevelDelegate;                             // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateRankDelegate;                              // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateRankUpExpDelegate;                         // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAddExpDelegate;                                  // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateHPDelegate;                                // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateSPDelegate;                                // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateFullStomachDelegate;                       // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateHungerTypeDelegate;                        // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateNickNameDelegate;                          // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateNickNameWithParameterDelegate;             // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateShieldMaxHPDelegate;                       // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateShieldHPDelegate;                          // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnShieldDamageDelegate;                            // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateSanityDelegate;                            // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateUnusedStatusPoint;                         // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateStatusPointDelegate;                       // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeBuffDelegate;                              // 0x0128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnConditionChangedDelegate;                        // 0x0138(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnWorkSuitabilityChangedDelegate;                  // 0x0148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGotStatusPointListChangedDelegate;               // 0x0158(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStatusRankChangedDelegate;                       // 0x0168(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInvaderTargetChanged;                            // 0x0178(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriedConsumeFoodDelegate;                        // 0x0188(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateGroupIdDelegate;                           // 0x0198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateReviveTimerDelegate;                       // 0x01A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateWorkSuitabilityOptionDelegate;             // 0x01B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTalentChangedDelegate;                           // 0x01C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEndMedicalBedDelegate;                           // 0x01D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRevivedDelegate;                                 // 0x01E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDeadBodyDelegate;                                // 0x01F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class APalCharacter*                          IndividualActor;                                   // 0x0208(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPalInstanceID                         IndividualId;                                      // 0x0210(0x0030)(Edit, Net, DisableEditOnTemplate, Transient, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, class APalCharacter*>             PhantomActorMap;                                   // 0x0240(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FPalPhantomReplicateInfo>       PhantomActorReplicateArray;                        // 0x0290(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, RepNotify, NativeAccessSpecifierPublic)
	struct FPalIndividualCharacterSaveParameter   SaveParameter;                                     // 0x02A0(0x0280)(Edit, Net, DisableEditOnTemplate, RepNotify, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C18[0x8];                                     // 0x0520(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnAddEquipWazaDelegate;                            // 0x0528(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeEquipWazaDelegate;                         // 0x0538(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeMasteredWazaDelegate;                      // 0x0548(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          IsWaitResponseWordFiltering;                       // 0x0558(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C19[0x7];                                     // 0x0559(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 WaitingFilterNickName;                             // 0x0560(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 NextFilterNickName;                                // 0x0570(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C1A[0x60];                                    // 0x0580(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFlagContainer                         DisableNaturalHealing;                             // 0x05E0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	struct FFloatContainer                        AdditionalNatureHealingRate;                       // 0x0630(0x0010)(Transient, NativeAccessSpecifierPrivate)
	struct FPalIndividualCharacterSaveParameter   SaveParameterMirror;                               // 0x0640(0x0280)(Transient, NativeAccessSpecifierPrivate)
	class UPalItemContainer*                      EquipItemContainer;                                // 0x08C0(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  BaseCampId;                                        // 0x08C8(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 Debug_CurrentAIActionName;                         // 0x08D8(0x0010)(Net, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void AddEquipWaza(EPalWazaID WazaID);
	void AddEquipWazaDelegate__DelegateSignature(EPalWazaID WazaID);
	void AddExpDelegate__DelegateSignature(int32 AddExp, int32 NowExp);
	void AddHP(const struct FFixedPoint64& PlusHP);
	void AddPassiveSkill(class FName AddSkill, class FName OverrideSkill);
	void ChangeBuffStatusDelegate__DelegateSignature();
	void ChangeEquipWazaDelegate__DelegateSignature(class UPalIndividualCharacterParameter* IndividualParameter);
	void ChangeMasteredWazaDelegate__DelegateSignature(class UPalIndividualCharacterParameter* IndividualParameter, EPalWazaID WazaID);
	void ClearEquipWaza();
	void ConditionChangedDelegate__DelegateSignature();
	void DeadBodyDelegate__DelegateSignature(class UPalIndividualCharacterHandle* IndividualHandle);
	void DecreaseShieldHPByDamage(int32 Damage);
	void DecrementUnusedStatusPoint();
	void EndMedicalBedDelegate__DelegateSignature();
	void EndRecuperatingInMedicalBed();
	void FullRecoveryHP();
	TSoftClassPtr<class UClass> GetCharacterClass();
	const TArray<class FName> GetPassiveSkillList();
	struct FFixedPoint64 GetShieldHP();
	struct FFixedPoint64 GetShieldMaxHP();
	void GotStatusPointListChangedDelegate__DelegateSignature();
	bool HasGenusCategory(EPalGenusCategoryType Category);
	bool HasMasteredWaza(EPalWazaID WazaID);
	void InvaderTargetChangedDelegate__DelegateSignature();
	bool IsHPFullRecovered();
	bool IsRarePal();
	bool IsStatusPointAddable(class FName StatusName, int32* AddablePoint);
	bool IsStatusPointAllMax();
	void NaturalUpdateSaveParameter(const EPalCharacterNaturalUpdateType Type);
	void OnReceivedWordFilteringResult(const class FString& ResponseBody, bool bResponseOK, int32 ResponseCode);
	void OnRep_IndividualActor();
	void OnRep_PhantomActorReplicateArray();
	void OnRep_SaveParameter();
	void OnRevivedDelegate__DelegateSignature(class UPalIndividualCharacterParameter* IndividualParameter);
	void PartyPalMealInventoryFood();
	void RemoveDecreaseFullStomachRates(const class FName Param_Name);
	void RemoveEquipWaza(EPalWazaID WazaID);
	void ResetLastJumpedLocation();
	void SetDecreaseFullStomachRates(const class FName Param_Name, float Rate);
	void SetDisableNaturalHealing(class FName Key, bool Disable);
	void SetExStatusPoint(class FName StatusName, int32 Point);
	void SetInvaderData(EPalInvaderType InvaderType, const struct FGuid& InBaseCampId);
	void SetLastJumpedLocation(const struct FVector& Location);
	void SetNoFallDamageHeightLastJumpedLocation();
	void SetPhysicalHealth(EPalStatusPhysicalHealthType PhysicalHealth);
	void SetShieldHP(const struct FFixedPoint64& NextSheildHP);
	void SetShieldMaxHP(const struct FFixedPoint64& NextSheildMaxHP);
	void SetStatusPoint(class FName StatusName, int32 Point);
	void ShieldDamageDelegate__DelegateSignature(int32 Damage, bool IsShieldBroken);
	void StartRecuperatingInMedicalBed();
	void StartRemainderOfLifeTimer();
	void StatusRankChangedDelegate__DelegateSignature();
	void StoreIndividualActorInfoToSaveParameter();
	void TalentChangedDelegate__DelegateSignature();
	void TriedConsumeFoodDelegate__DelegateSignature();
	bool TryFindEatItem(const struct FPalContainerId& ContainerId, int32* SlotIndex);
	void UpdateFullStomachDelegate__DelegateSignature(float Current, float Last);
	void UpdateGroupIdDelegate__DelegateSignature(const struct FGuid& NewGroupId);
	void UpdateHPDelegate__DelegateSignature(const struct FFixedPoint64& NowHP, const struct FFixedPoint64& NowMaxHP);
	void UpdateHungerTypeDelegate__DelegateSignature(EPalStatusHungerType Current, EPalStatusHungerType Last);
	void UpdateLevelDelegate__DelegateSignature(int32 AddLevel, int32 NowLevel);
	void UpdateNickNameDelegate__DelegateSignature(const class FString& NewNickName);
	void UpdateNickNameWithParameterDelegate__DelegateSignature(class UPalIndividualCharacterParameter* IndividualParameter, const class FString& NewNickName);
	void UpdateRankDelegate__DelegateSignature(int32 NowRank, int32 OldRank);
	void UpdateRankUpExpDelegate__DelegateSignature(int32 NowRankUpExp, int32 OldRankUpExp);
	void UpdateReviveTimerDelegate__DelegateSignature(float NowReviveTimer);
	void UpdateSanityDelegate__DelegateSignature(float NowSanity, float OldSanity);
	void UpdateShieldHPDelegate__DelegateSignature(const struct FFixedPoint64& NowShieldMaxHP, const struct FFixedPoint64& NowShieldHP);
	void UpdateShieldMaxHPDelegate__DelegateSignature(const struct FFixedPoint64& NowShieldMaxHP);
	void UpdateSPDelegate__DelegateSignature(const struct FFixedPoint64& NowSP, const struct FFixedPoint64& NowMaxSP, bool IsOverHeated);
	void UpdateStatusPointDelegate__DelegateSignature(class FName StatusName, int32 PrevPoint, int32 NewPoint);
	void UpdateUnusedStatusPointDelegate__DelegateSignature(int32 UnusedPoint);
	void UpdateWorkSuitabilityOptionDelegate__DelegateSignature(const struct FPalWorkSuitabilityPreferenceInfo& NewWorkSuitabilityOption);
	void UseItemInSlot(const struct FPalItemSlotIdAndNum& SlotIdAndNum);
	void WorkSuitabilityChangedDelegate__DelegateSignature();

	bool CanAddTalentByItem(class FName ItemName) const;
	float GetAffectSanityValue() const;
	int32 GetAttackRank() const;
	const struct FGuid GetBaseCampId() const;
	EPalBaseCampWorkerEventType GetBaseCampWorkerEventType() const;
	class FName GetCharacterID() const;
	int32 GetCraftSpeed() const;
	int32 GetCraftSpeed_withBuff() const;
	int32 GetCraftSpeed_withBuff_WorkSuitability(const EPalWorkSuitability Suitability) const;
	float GetCraftSpeedBuffRate() const;
	int32 GetCraftSpeedByWorkSuitability(const EPalWorkSuitability WorkSuitability) const;
	float GetCraftSpeedSickRate() const;
	EPalWorkSuitability GetCurrentWorkSuitability() const;
	int32 GetDefenceRank() const;
	int32 GetDefense() const;
	int32 GetDefense_withBuff() const;
	class FName GetEffectFoodName() const;
	float GetEffectFoodTimeRate() const;
	TArray<EPalWazaID> GetEquipableWaza() const;
	struct FPalIndividualCharacterEquipItemContainerHandler GetEquipItemContainerHandler() const;
	const struct FPalContainerId GetEquipItemContainerId() const;
	TArray<EPalWazaID> GetEquipWaza() const;
	int32 GetExp() const;
	int32 GetExStatusPoint(class FName StatusName) const;
	float GetFoodStatusRate(EPalFoodStatusEffectType EffectType) const;
	float GetFullStomach() const;
	float GetFullStomachDecreasingRate() const;
	float GetFullStomachRate() const;
	EPalGenderType GetGenderType() const;
	const struct FGuid GetGroupId() const;
	struct FFixedPoint64 GetHP() const;
	int32 GetHPRank() const;
	EPalStatusHungerType GetHungerType() const;
	const struct FVector GetLastJumpedLocation() const;
	int32 GetLevel() const;
	TArray<EPalWazaID> GetMasteredWaza() const;
	float GetMaxFullStomach() const;
	int32 GetMaxHP() const;
	struct FFixedPoint64 GetMaxHP_withBuff() const;
	float GetMaxSanityValue() const;
	int32 GetMeleeAttack() const;
	int32 GetMeleeAttack_withBuff() const;
	void GetNickname(class FString* OutName) const;
	int32 GetPalSoulRank() const;
	EPalStatusPhysicalHealthType GetPhysicalHealth() const;
	int32 GetRank() const;
	int32 GetRankUpExp() const;
	float GetRatePartnerSkill(EPalPassiveSkillEffectType EffectType) const;
	float GetRatePassiveSkill(EPalPassiveSkillEffectType EffectType) const;
	struct FPalFoodRegeneInfo GetRegeneItemName() const;
	float GetSanityRate() const;
	float GetSanityValue() const;
	const struct FPalIndividualCharacterSaveParameter GetSaveParameter() const;
	int32 GetShotAttack() const;
	int32 GetShotAttack_withBuff() const;
	int32 GetStatusPoint(class FName StatusName) const;
	void GetStatusPointList(TArray<struct FPalGotStatusPoint>* OutPointList) const;
	int32 GetTotalStatusPoint(class FName StatusName) const;
	EPalTribeID GetTribeID() const;
	int32 GetUnusedStatusPoint() const;
	EPalBaseCampWorkerSickType GetWorkerSick() const;
	int32 GetWorkSpeedRank() const;
	int32 GetWorkSuitabilityRank(const EPalWorkSuitability InWorkSuitability) const;
	TMap<EPalWorkSuitability, int32> GetWorkSuitabilityRanksWithCharacterRank() const;
	int32 GetWorkSuitabilityRankWithCharacterRank(const EPalWorkSuitability WorkSuitability) const;
	bool HasWorkSuitability(const EPalWorkSuitability InWorkSuitability) const;
	bool HasWorkSuitabilityRank(const EPalWorkSuitability InWorkSuitability, const int32 SuitabilityRank) const;
	float HungerParameterRate() const;
	bool IsDead() const;
	bool IsLevelMax() const;
	bool IsNocturnal() const;
	bool IsNoFallDamageLastJumpedLocation() const;
	bool IsSleeping() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalIndividualCharacterParameter">();
	}
	static class UPalIndividualCharacterParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalIndividualCharacterParameter>();
	}
};
static_assert(alignof(UPalIndividualCharacterParameter) == 0x000008, "Wrong alignment on UPalIndividualCharacterParameter");
static_assert(sizeof(UPalIndividualCharacterParameter) == 0x0008E8, "Wrong size on UPalIndividualCharacterParameter");
static_assert(offsetof(UPalIndividualCharacterParameter, OnUpdateLevelDelegate) == 0x000028, "Member 'UPalIndividualCharacterParameter::OnUpdateLevelDelegate' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterParameter, OnUpdateRankDelegate) == 0x000038, "Member 'UPalIndividualCharacterParameter::OnUpdateRankDelegate' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterParameter, OnUpdateRankUpExpDelegate) == 0x000048, "Member 'UPalIndividualCharacterParameter::OnUpdateRankUpExpDelegate' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterParameter, OnAddExpDelegate) == 0x000058, "Member 'UPalIndividualCharacterParameter::OnAddExpDelegate' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterParameter, OnUpdateHPDelegate) == 0x000068, "Member 'UPalIndividualCharacterParameter::OnUpdateHPDelegate' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterParameter, OnUpdateSPDelegate) == 0x000078, "Member 'UPalIndividualCharacterParameter::OnUpdateSPDelegate' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterParameter, OnUpdateFullStomachDelegate) == 0x000088, "Member 'UPalIndividualCharacterParameter::OnUpdateFullStomachDelegate' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterParameter, OnUpdateHungerTypeDelegate) == 0x000098, "Member 'UPalIndividualCharacterParameter::OnUpdateHungerTypeDelegate' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterParameter, OnUpdateNickNameDelegate) == 0x0000A8, "Member 'UPalIndividualCharacterParameter::OnUpdateNickNameDelegate' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterParameter, OnUpdateNickNameWithParameterDelegate) == 0x0000B8, "Member 'UPalIndividualCharacterParameter::OnUpdateNickNameWithParameterDelegate' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterParameter, OnUpdateShieldMaxHPDelegate) == 0x0000C8, "Member 'UPalIndividualCharacterParameter::OnUpdateShieldMaxHPDelegate' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterParameter, OnUpdateShieldHPDelegate) == 0x0000D8, "Member 'UPalIndividualCharacterParameter::OnUpdateShieldHPDelegate' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterParameter, OnShieldDamageDelegate) == 0x0000E8, "Member 'UPalIndividualCharacterParameter::OnShieldDamageDelegate' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterParameter, OnUpdateSanityDelegate) == 0x0000F8, "Member 'UPalIndividualCharacterParameter::OnUpdateSanityDelegate' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterParameter, OnUpdateUnusedStatusPoint) == 0x000108, "Member 'UPalIndividualCharacterParameter::OnUpdateUnusedStatusPoint' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterParameter, OnUpdateStatusPointDelegate) == 0x000118, "Member 'UPalIndividualCharacterParameter::OnUpdateStatusPointDelegate' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterParameter, OnChangeBuffDelegate) == 0x000128, "Member 'UPalIndividualCharacterParameter::OnChangeBuffDelegate' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterParameter, OnConditionChangedDelegate) == 0x000138, "Member 'UPalIndividualCharacterParameter::OnConditionChangedDelegate' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterParameter, OnWorkSuitabilityChangedDelegate) == 0x000148, "Member 'UPalIndividualCharacterParameter::OnWorkSuitabilityChangedDelegate' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterParameter, OnGotStatusPointListChangedDelegate) == 0x000158, "Member 'UPalIndividualCharacterParameter::OnGotStatusPointListChangedDelegate' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterParameter, OnStatusRankChangedDelegate) == 0x000168, "Member 'UPalIndividualCharacterParameter::OnStatusRankChangedDelegate' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterParameter, OnInvaderTargetChanged) == 0x000178, "Member 'UPalIndividualCharacterParameter::OnInvaderTargetChanged' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterParameter, OnTriedConsumeFoodDelegate) == 0x000188, "Member 'UPalIndividualCharacterParameter::OnTriedConsumeFoodDelegate' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterParameter, OnUpdateGroupIdDelegate) == 0x000198, "Member 'UPalIndividualCharacterParameter::OnUpdateGroupIdDelegate' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterParameter, OnUpdateReviveTimerDelegate) == 0x0001A8, "Member 'UPalIndividualCharacterParameter::OnUpdateReviveTimerDelegate' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterParameter, OnUpdateWorkSuitabilityOptionDelegate) == 0x0001B8, "Member 'UPalIndividualCharacterParameter::OnUpdateWorkSuitabilityOptionDelegate' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterParameter, OnTalentChangedDelegate) == 0x0001C8, "Member 'UPalIndividualCharacterParameter::OnTalentChangedDelegate' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterParameter, OnEndMedicalBedDelegate) == 0x0001D8, "Member 'UPalIndividualCharacterParameter::OnEndMedicalBedDelegate' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterParameter, OnRevivedDelegate) == 0x0001E8, "Member 'UPalIndividualCharacterParameter::OnRevivedDelegate' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterParameter, OnDeadBodyDelegate) == 0x0001F8, "Member 'UPalIndividualCharacterParameter::OnDeadBodyDelegate' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterParameter, IndividualActor) == 0x000208, "Member 'UPalIndividualCharacterParameter::IndividualActor' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterParameter, IndividualId) == 0x000210, "Member 'UPalIndividualCharacterParameter::IndividualId' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterParameter, PhantomActorMap) == 0x000240, "Member 'UPalIndividualCharacterParameter::PhantomActorMap' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterParameter, PhantomActorReplicateArray) == 0x000290, "Member 'UPalIndividualCharacterParameter::PhantomActorReplicateArray' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterParameter, SaveParameter) == 0x0002A0, "Member 'UPalIndividualCharacterParameter::SaveParameter' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterParameter, OnAddEquipWazaDelegate) == 0x000528, "Member 'UPalIndividualCharacterParameter::OnAddEquipWazaDelegate' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterParameter, OnChangeEquipWazaDelegate) == 0x000538, "Member 'UPalIndividualCharacterParameter::OnChangeEquipWazaDelegate' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterParameter, OnChangeMasteredWazaDelegate) == 0x000548, "Member 'UPalIndividualCharacterParameter::OnChangeMasteredWazaDelegate' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterParameter, IsWaitResponseWordFiltering) == 0x000558, "Member 'UPalIndividualCharacterParameter::IsWaitResponseWordFiltering' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterParameter, WaitingFilterNickName) == 0x000560, "Member 'UPalIndividualCharacterParameter::WaitingFilterNickName' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterParameter, NextFilterNickName) == 0x000570, "Member 'UPalIndividualCharacterParameter::NextFilterNickName' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterParameter, DisableNaturalHealing) == 0x0005E0, "Member 'UPalIndividualCharacterParameter::DisableNaturalHealing' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterParameter, AdditionalNatureHealingRate) == 0x000630, "Member 'UPalIndividualCharacterParameter::AdditionalNatureHealingRate' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterParameter, SaveParameterMirror) == 0x000640, "Member 'UPalIndividualCharacterParameter::SaveParameterMirror' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterParameter, EquipItemContainer) == 0x0008C0, "Member 'UPalIndividualCharacterParameter::EquipItemContainer' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterParameter, BaseCampId) == 0x0008C8, "Member 'UPalIndividualCharacterParameter::BaseCampId' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterParameter, Debug_CurrentAIActionName) == 0x0008D8, "Member 'UPalIndividualCharacterParameter::Debug_CurrentAIActionName' has a wrong offset!");

// Class Pal.PalIndividualCharacterParameterUtility
// 0x0000 (0x0028 - 0x0028)
class UPalIndividualCharacterParameterUtility final : public UBlueprintFunctionLibrary
{
public:
	static int32 CraftSpeed(class UPalIndividualCharacterParameter* Parameter);
	static int32 CraftSpeedWorkSuitability(const EPalWorkSuitability WorkSuitability, class UPalIndividualCharacterParameter* Parameter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalIndividualCharacterParameterUtility">();
	}
	static class UPalIndividualCharacterParameterUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalIndividualCharacterParameterUtility>();
	}
};
static_assert(alignof(UPalIndividualCharacterParameterUtility) == 0x000008, "Wrong alignment on UPalIndividualCharacterParameterUtility");
static_assert(sizeof(UPalIndividualCharacterParameterUtility) == 0x000028, "Wrong size on UPalIndividualCharacterParameterUtility");

// Class Pal.PalMapObjectHatchingEggModel
// 0x02D8 (0x04F0 - 0x0218)
class UPalMapObjectHatchingEggModel final : public UPalMapObjectConcreteModelBase
{
public:
	uint8                                         Pad_2C30[0x8];                                     // 0x0218(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnUpdateHatchedCharacterDelegate;                  // 0x0220(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateHatchTemperaturDelegate;                   // 0x0230(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateWorkableDelegate;                          // 0x0240(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FPalIndividualCharacterSaveParameter   HatchedCharacterSaveParameter;                     // 0x0250(0x0280)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnTemplate, Transient, EditConst, RepNotify, Protected, NativeAccessSpecifierProtected)
	bool                                          bWorkable;                                         // 0x04D0(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C31[0x7];                                     // 0x04D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UPalUserWidgetOverlayUI>    MenuUIWidgetClass;                                 // 0x04D8(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CurrentPalEggTemperatureDiff;                      // 0x04E0(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C32[0x4];                                     // 0x04E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalDynamicPalEggItemDataBase*          HatchedPalEggData;                                 // 0x04E8(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool GetPalEggRankInfo(struct FPalEggRankInfo* OutPalEggRankInfo);
	int32 GetTemperatureDiff();
	void ObtainHatchedCharacter_ServerInternal(const int32 RequestPlayerId);
	void OnFinishWorkInServer(class UPalWorkBase* Work);
	void OnRep_HatchedCharacterSaveParameter();
	void OnRep_HatchTemperatureDiff();
	void OnUpdateContainerContentInServer(class UPalItemContainer* Container);
	void OnUpdateEnergyModuleState(class UPalMapObjectEnergyModule* EnergyModule);
	void SetTemperatureDiff(int32 TemperatureDiff);
	void UpdateHatchedCharacterDelegate__DelegateSignature(class UPalMapObjectHatchingEggModel* Model);
	void UpdateHatchTemperatureDelegate__DelegateSignature(int32 Temperature);
	void UpdateWorkableDelegate__DelegateSignature(bool Workable);
	void UpdateWorkAmountBySec(const float NewWorkAmountBySec);

	bool IsWorkable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectHatchingEggModel">();
	}
	static class UPalMapObjectHatchingEggModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectHatchingEggModel>();
	}
};
static_assert(alignof(UPalMapObjectHatchingEggModel) == 0x000008, "Wrong alignment on UPalMapObjectHatchingEggModel");
static_assert(sizeof(UPalMapObjectHatchingEggModel) == 0x0004F0, "Wrong size on UPalMapObjectHatchingEggModel");
static_assert(offsetof(UPalMapObjectHatchingEggModel, OnUpdateHatchedCharacterDelegate) == 0x000220, "Member 'UPalMapObjectHatchingEggModel::OnUpdateHatchedCharacterDelegate' has a wrong offset!");
static_assert(offsetof(UPalMapObjectHatchingEggModel, OnUpdateHatchTemperaturDelegate) == 0x000230, "Member 'UPalMapObjectHatchingEggModel::OnUpdateHatchTemperaturDelegate' has a wrong offset!");
static_assert(offsetof(UPalMapObjectHatchingEggModel, OnUpdateWorkableDelegate) == 0x000240, "Member 'UPalMapObjectHatchingEggModel::OnUpdateWorkableDelegate' has a wrong offset!");
static_assert(offsetof(UPalMapObjectHatchingEggModel, HatchedCharacterSaveParameter) == 0x000250, "Member 'UPalMapObjectHatchingEggModel::HatchedCharacterSaveParameter' has a wrong offset!");
static_assert(offsetof(UPalMapObjectHatchingEggModel, bWorkable) == 0x0004D0, "Member 'UPalMapObjectHatchingEggModel::bWorkable' has a wrong offset!");
static_assert(offsetof(UPalMapObjectHatchingEggModel, MenuUIWidgetClass) == 0x0004D8, "Member 'UPalMapObjectHatchingEggModel::MenuUIWidgetClass' has a wrong offset!");
static_assert(offsetof(UPalMapObjectHatchingEggModel, CurrentPalEggTemperatureDiff) == 0x0004E0, "Member 'UPalMapObjectHatchingEggModel::CurrentPalEggTemperatureDiff' has a wrong offset!");
static_assert(offsetof(UPalMapObjectHatchingEggModel, HatchedPalEggData) == 0x0004E8, "Member 'UPalMapObjectHatchingEggModel::HatchedPalEggData' has a wrong offset!");

// Class Pal.PalIndividualCharacterReferenceSlot
// 0x0040 (0x00F8 - 0x00B8)
class UPalIndividualCharacterReferenceSlot final : public UPalIndividualCharacterSlot
{
public:
	FMulticastInlineDelegateProperty_             OnUpdateSlotReferenceHandleDelegate;               // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FPalInstanceID                         IndividualId;                                      // 0x00C8(0x0030)(Edit, DisableEditOnTemplate, Transient, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalIndividualCharacterReferenceSlot">();
	}
	static class UPalIndividualCharacterReferenceSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalIndividualCharacterReferenceSlot>();
	}
};
static_assert(alignof(UPalIndividualCharacterReferenceSlot) == 0x000008, "Wrong alignment on UPalIndividualCharacterReferenceSlot");
static_assert(sizeof(UPalIndividualCharacterReferenceSlot) == 0x0000F8, "Wrong size on UPalIndividualCharacterReferenceSlot");
static_assert(offsetof(UPalIndividualCharacterReferenceSlot, OnUpdateSlotReferenceHandleDelegate) == 0x0000B8, "Member 'UPalIndividualCharacterReferenceSlot::OnUpdateSlotReferenceHandleDelegate' has a wrong offset!");
static_assert(offsetof(UPalIndividualCharacterReferenceSlot, IndividualId) == 0x0000C8, "Member 'UPalIndividualCharacterReferenceSlot::IndividualId' has a wrong offset!");

// Class Pal.PalInflictDamageNotifyInterface
// 0x0000 (0x0028 - 0x0028)
class IPalInflictDamageNotifyInterface final : public IInterface
{
public:
	void OnDefeatCharacter(const struct FPalDeadInfo& DeadInfo);
	void OnInflictDamage(const struct FPalDamageResult& DamageResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalInflictDamageNotifyInterface">();
	}
	static class IPalInflictDamageNotifyInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPalInflictDamageNotifyInterface>();
	}
};
static_assert(alignof(IPalInflictDamageNotifyInterface) == 0x000008, "Wrong alignment on IPalInflictDamageNotifyInterface");
static_assert(sizeof(IPalInflictDamageNotifyInterface) == 0x000028, "Wrong size on IPalInflictDamageNotifyInterface");

// Class Pal.PalInteractComponent
// 0x0140 (0x01E0 - 0x00A0)
class UPalInteractComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnStartInteractiveObjectDelegate;                  // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEndInteractiveObjectDelegate;                    // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateInteractiveObjectDelegate;                 // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<TScriptInterface<class IPalInteractiveObjectComponentInterface>> InteractiveObjects;                                // 0x00D0(0x0010)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, EditConst, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<class UObject*, struct FPalInteractComponentOverlapComponentSet> InteractComponentOverlapMap;                       // 0x00E0(0x0050)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TScriptInterface<class IPalInteractiveObjectComponentInterface> TargetInteractiveObject;                           // 0x0130(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TScriptInterface<class IPalInteractiveObjectComponentInterface> LastInteractingObject;                             // 0x0140(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C34[0x40];                                    // 0x0150(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFlagContainer                         InteractDisableFlags;                              // 0x0190(0x0050)(NativeAccessSpecifierPrivate)

public:
	void EndInteractiveObjectDelegate__DelegateSignature();
	void EndTriggerInteract(EPalInteractiveObjectActionType ActionType);
	void OnEnableInteract(TScriptInterface<class IPalInteractiveObjectComponentInterface> Component);
	void SetEnableInteract(const bool bEnable, const bool bTerminateInteractIfDisable);
	void SetEnableInteractByFlagName(const class FName& FlagName, const bool bEnable, const bool bTerminateInteractIfDisable);
	void StartInteractiveObjectDelegate__DelegateSignature(TScriptInterface<class IPalInteractiveObjectComponentInterface> InteractiveObject);
	void StartTriggerInteract(EPalInteractiveObjectActionType ActionType, bool IsToggle);
	void TerminateInteract();
	void UpdateInteractiveObjectDelegate__DelegateSignature(TScriptInterface<class IPalInteractiveObjectComponentInterface> InteractiveObject);

	EPalInteractiveObjectActionType GetTriggeringActionType() const;
	bool IsEnableInteract() const;
	bool IsInteracting() const;
	bool IsToggleInteracting() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalInteractComponent">();
	}
	static class UPalInteractComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalInteractComponent>();
	}
};
static_assert(alignof(UPalInteractComponent) == 0x000008, "Wrong alignment on UPalInteractComponent");
static_assert(sizeof(UPalInteractComponent) == 0x0001E0, "Wrong size on UPalInteractComponent");
static_assert(offsetof(UPalInteractComponent, OnStartInteractiveObjectDelegate) == 0x0000A0, "Member 'UPalInteractComponent::OnStartInteractiveObjectDelegate' has a wrong offset!");
static_assert(offsetof(UPalInteractComponent, OnEndInteractiveObjectDelegate) == 0x0000B0, "Member 'UPalInteractComponent::OnEndInteractiveObjectDelegate' has a wrong offset!");
static_assert(offsetof(UPalInteractComponent, OnUpdateInteractiveObjectDelegate) == 0x0000C0, "Member 'UPalInteractComponent::OnUpdateInteractiveObjectDelegate' has a wrong offset!");
static_assert(offsetof(UPalInteractComponent, InteractiveObjects) == 0x0000D0, "Member 'UPalInteractComponent::InteractiveObjects' has a wrong offset!");
static_assert(offsetof(UPalInteractComponent, InteractComponentOverlapMap) == 0x0000E0, "Member 'UPalInteractComponent::InteractComponentOverlapMap' has a wrong offset!");
static_assert(offsetof(UPalInteractComponent, TargetInteractiveObject) == 0x000130, "Member 'UPalInteractComponent::TargetInteractiveObject' has a wrong offset!");
static_assert(offsetof(UPalInteractComponent, LastInteractingObject) == 0x000140, "Member 'UPalInteractComponent::LastInteractingObject' has a wrong offset!");
static_assert(offsetof(UPalInteractComponent, InteractDisableFlags) == 0x000190, "Member 'UPalInteractComponent::InteractDisableFlags' has a wrong offset!");

// Class Pal.PalMapObjectBaseCampPassiveEffectParameterComponentBase
// 0x0000 (0x00A0 - 0x00A0)
class UPalMapObjectBaseCampPassiveEffectParameterComponentBase : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectBaseCampPassiveEffectParameterComponentBase">();
	}
	static class UPalMapObjectBaseCampPassiveEffectParameterComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectBaseCampPassiveEffectParameterComponentBase>();
	}
};
static_assert(alignof(UPalMapObjectBaseCampPassiveEffectParameterComponentBase) == 0x000008, "Wrong alignment on UPalMapObjectBaseCampPassiveEffectParameterComponentBase");
static_assert(sizeof(UPalMapObjectBaseCampPassiveEffectParameterComponentBase) == 0x0000A0, "Wrong size on UPalMapObjectBaseCampPassiveEffectParameterComponentBase");

// Class Pal.PalInteractiveObjectCapsuleComponent
// 0x0070 (0x05D0 - 0x0560)
class UPalInteractiveObjectCapsuleComponent final : public UCapsuleComponent
{
public:
	uint8                                         Pad_2C36[0x10];                                    // 0x0560(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalInteractDelegates*                  InteractDelegates;                                 // 0x0570(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsEnableTriggerInteract;                          // 0x0578(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsImplementedTriggerInteract;                     // 0x0579(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsEnableInteractingTick;                          // 0x057A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsEnableInteractingTickInClientOnly;              // 0x057B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C37[0x4];                                     // 0x057C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FComponentReference                    IndicatorOriginRef;                                // 0x0580(0x0028)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsAdjustIndicatorLocationZForPlayer;              // 0x05A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C38[0x7];                                     // 0x05A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TScriptInterface<class IPalInteractiveObjectIndicatorInterface> IndicatorInterface;                                // 0x05B0(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnCreateInteractDelegatesDelegate;                 // 0x05C0(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPrivate)

public:
	void CallOrRegisterOnCreateInteractDelegates(TDelegate<void(class UPalInteractDelegates* InteractDelegates)> Delegate);
	void OnCreateInteractsDelegates__DelegateSignature(class UPalInteractDelegates* Param_InteractDelegates);
	void EnableTriggerInteract();
	struct FVector GetIndicatorLocation(bool bNoShapeOffset);
	void OnCreateInteractDelegatesMultiCast__DelegateSignature(class UPalInteractDelegates* Param_InteractDelegates);
	void OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnOverlapEnd(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void SetIndicatorInterface(TScriptInterface<class IPalInteractiveObjectIndicatorInterface> InIndicatorInterface);

	class UPalInteractDelegates* Delegates() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalInteractiveObjectCapsuleComponent">();
	}
	static class UPalInteractiveObjectCapsuleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalInteractiveObjectCapsuleComponent>();
	}
};
static_assert(alignof(UPalInteractiveObjectCapsuleComponent) == 0x000010, "Wrong alignment on UPalInteractiveObjectCapsuleComponent");
static_assert(sizeof(UPalInteractiveObjectCapsuleComponent) == 0x0005D0, "Wrong size on UPalInteractiveObjectCapsuleComponent");
static_assert(offsetof(UPalInteractiveObjectCapsuleComponent, InteractDelegates) == 0x000570, "Member 'UPalInteractiveObjectCapsuleComponent::InteractDelegates' has a wrong offset!");
static_assert(offsetof(UPalInteractiveObjectCapsuleComponent, bIsEnableTriggerInteract) == 0x000578, "Member 'UPalInteractiveObjectCapsuleComponent::bIsEnableTriggerInteract' has a wrong offset!");
static_assert(offsetof(UPalInteractiveObjectCapsuleComponent, bIsImplementedTriggerInteract) == 0x000579, "Member 'UPalInteractiveObjectCapsuleComponent::bIsImplementedTriggerInteract' has a wrong offset!");
static_assert(offsetof(UPalInteractiveObjectCapsuleComponent, bIsEnableInteractingTick) == 0x00057A, "Member 'UPalInteractiveObjectCapsuleComponent::bIsEnableInteractingTick' has a wrong offset!");
static_assert(offsetof(UPalInteractiveObjectCapsuleComponent, bIsEnableInteractingTickInClientOnly) == 0x00057B, "Member 'UPalInteractiveObjectCapsuleComponent::bIsEnableInteractingTickInClientOnly' has a wrong offset!");
static_assert(offsetof(UPalInteractiveObjectCapsuleComponent, IndicatorOriginRef) == 0x000580, "Member 'UPalInteractiveObjectCapsuleComponent::IndicatorOriginRef' has a wrong offset!");
static_assert(offsetof(UPalInteractiveObjectCapsuleComponent, bIsAdjustIndicatorLocationZForPlayer) == 0x0005A8, "Member 'UPalInteractiveObjectCapsuleComponent::bIsAdjustIndicatorLocationZForPlayer' has a wrong offset!");
static_assert(offsetof(UPalInteractiveObjectCapsuleComponent, IndicatorInterface) == 0x0005B0, "Member 'UPalInteractiveObjectCapsuleComponent::IndicatorInterface' has a wrong offset!");
static_assert(offsetof(UPalInteractiveObjectCapsuleComponent, OnCreateInteractDelegatesDelegate) == 0x0005C0, "Member 'UPalInteractiveObjectCapsuleComponent::OnCreateInteractDelegatesDelegate' has a wrong offset!");

// Class Pal.PalInteractiveObjectIndicatorTypeUtility
// 0x0000 (0x0028 - 0x0028)
class UPalInteractiveObjectIndicatorTypeUtility final : public UObject
{
public:
	static const class FText ToText(const class UObject* WorldObjectContext, const EPalInteractiveObjectIndicatorType Type);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalInteractiveObjectIndicatorTypeUtility">();
	}
	static class UPalInteractiveObjectIndicatorTypeUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalInteractiveObjectIndicatorTypeUtility>();
	}
};
static_assert(alignof(UPalInteractiveObjectIndicatorTypeUtility) == 0x000008, "Wrong alignment on UPalInteractiveObjectIndicatorTypeUtility");
static_assert(sizeof(UPalInteractiveObjectIndicatorTypeUtility) == 0x000028, "Wrong size on UPalInteractiveObjectIndicatorTypeUtility");

// Class Pal.PalMapObjectBaseCampPassiveEffectModel
// 0x0000 (0x0218 - 0x0218)
class UPalMapObjectBaseCampPassiveEffectModel : public UPalMapObjectConcreteModelBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectBaseCampPassiveEffectModel">();
	}
	static class UPalMapObjectBaseCampPassiveEffectModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectBaseCampPassiveEffectModel>();
	}
};
static_assert(alignof(UPalMapObjectBaseCampPassiveEffectModel) == 0x000008, "Wrong alignment on UPalMapObjectBaseCampPassiveEffectModel");
static_assert(sizeof(UPalMapObjectBaseCampPassiveEffectModel) == 0x000218, "Wrong size on UPalMapObjectBaseCampPassiveEffectModel");

// Class Pal.PalMapObjectBaseCampPassiveWorkHardModel
// 0x0000 (0x0218 - 0x0218)
class UPalMapObjectBaseCampPassiveWorkHardModel final : public UPalMapObjectBaseCampPassiveEffectModel
{
public:
	void RequestUpdateWorkHardType(const EPalBaseCampPassiveEffectWorkHardType Type);
	void RequestUpdateWorkHardType_ServerInternal(const int32 RequestPlayerId, const int32 TypeInt);

	class UPalBaseCampPassiveEffect_WorkHard* GetPassiveEffectWorkHard() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectBaseCampPassiveWorkHardModel">();
	}
	static class UPalMapObjectBaseCampPassiveWorkHardModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectBaseCampPassiveWorkHardModel>();
	}
};
static_assert(alignof(UPalMapObjectBaseCampPassiveWorkHardModel) == 0x000008, "Wrong alignment on UPalMapObjectBaseCampPassiveWorkHardModel");
static_assert(sizeof(UPalMapObjectBaseCampPassiveWorkHardModel) == 0x000218, "Wrong size on UPalMapObjectBaseCampPassiveWorkHardModel");

// Class Pal.PalInteractDelegates
// 0x0080 (0x00A8 - 0x0028)
class UPalInteractDelegates final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnEnableTriggerInteract;                           // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInteractBegin;                                   // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInteractEnd;                                     // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInteracting;                                     // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerInteract;                                 // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStartTriggerInteract;                            // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEndTriggerInteract;                              // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggeringInteract;                              // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalInteractDelegates">();
	}
	static class UPalInteractDelegates* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalInteractDelegates>();
	}
};
static_assert(alignof(UPalInteractDelegates) == 0x000008, "Wrong alignment on UPalInteractDelegates");
static_assert(sizeof(UPalInteractDelegates) == 0x0000A8, "Wrong size on UPalInteractDelegates");
static_assert(offsetof(UPalInteractDelegates, OnEnableTriggerInteract) == 0x000028, "Member 'UPalInteractDelegates::OnEnableTriggerInteract' has a wrong offset!");
static_assert(offsetof(UPalInteractDelegates, OnInteractBegin) == 0x000038, "Member 'UPalInteractDelegates::OnInteractBegin' has a wrong offset!");
static_assert(offsetof(UPalInteractDelegates, OnInteractEnd) == 0x000048, "Member 'UPalInteractDelegates::OnInteractEnd' has a wrong offset!");
static_assert(offsetof(UPalInteractDelegates, OnInteracting) == 0x000058, "Member 'UPalInteractDelegates::OnInteracting' has a wrong offset!");
static_assert(offsetof(UPalInteractDelegates, OnTriggerInteract) == 0x000068, "Member 'UPalInteractDelegates::OnTriggerInteract' has a wrong offset!");
static_assert(offsetof(UPalInteractDelegates, OnStartTriggerInteract) == 0x000078, "Member 'UPalInteractDelegates::OnStartTriggerInteract' has a wrong offset!");
static_assert(offsetof(UPalInteractDelegates, OnEndTriggerInteract) == 0x000088, "Member 'UPalInteractDelegates::OnEndTriggerInteract' has a wrong offset!");
static_assert(offsetof(UPalInteractDelegates, OnTriggeringInteract) == 0x000098, "Member 'UPalInteractDelegates::OnTriggeringInteract' has a wrong offset!");

// Class Pal.PalInteractiveObjectComponentInterface
// 0x0000 (0x0028 - 0x0028)
class IPalInteractiveObjectComponentInterface final : public IPalInteractiveInterface
{
public:
	void EnableTriggerInteract();
	struct FVector GetIndicatorLocation(bool bNoShapeOffset);
	void SetIndicatorInterface(TScriptInterface<class IPalInteractiveObjectIndicatorInterface> InIndicatorInterface);

	class UPalInteractDelegates* Delegates() const;
	void GetIndicatorInfo(struct FPalInteractiveObjectActionInfoSet* ActionInfo, const struct FPalInteractiveObjectActionBy& SituationInfo) const;
	class FText GetIndicatorText(const class UObject* WorldContextObject, EPalInteractiveObjectIndicatorType IndicatorType) const;
	const class UObject* Self() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalInteractiveObjectComponentInterface">();
	}
	static class IPalInteractiveObjectComponentInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPalInteractiveObjectComponentInterface>();
	}
};
static_assert(alignof(IPalInteractiveObjectComponentInterface) == 0x000008, "Wrong alignment on IPalInteractiveObjectComponentInterface");
static_assert(sizeof(IPalInteractiveObjectComponentInterface) == 0x000028, "Wrong size on IPalInteractiveObjectComponentInterface");

// Class Pal.PalMapObjectBreedFarmParameterComponent
// 0x0020 (0x00C0 - 0x00A0)
class UPalMapObjectBreedFarmParameterComponent final : public UActorComponent
{
public:
	float                                         BreedRequiredRealTime;                             // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExistPalEggMaxNum;                                 // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotNum;                                           // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C3F[0x4];                                     // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPalDataTableRowName_ItemData>  TargetItemIds;                                     // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectBreedFarmParameterComponent">();
	}
	static class UPalMapObjectBreedFarmParameterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectBreedFarmParameterComponent>();
	}
};
static_assert(alignof(UPalMapObjectBreedFarmParameterComponent) == 0x000008, "Wrong alignment on UPalMapObjectBreedFarmParameterComponent");
static_assert(sizeof(UPalMapObjectBreedFarmParameterComponent) == 0x0000C0, "Wrong size on UPalMapObjectBreedFarmParameterComponent");
static_assert(offsetof(UPalMapObjectBreedFarmParameterComponent, BreedRequiredRealTime) == 0x0000A0, "Member 'UPalMapObjectBreedFarmParameterComponent::BreedRequiredRealTime' has a wrong offset!");
static_assert(offsetof(UPalMapObjectBreedFarmParameterComponent, ExistPalEggMaxNum) == 0x0000A4, "Member 'UPalMapObjectBreedFarmParameterComponent::ExistPalEggMaxNum' has a wrong offset!");
static_assert(offsetof(UPalMapObjectBreedFarmParameterComponent, SlotNum) == 0x0000A8, "Member 'UPalMapObjectBreedFarmParameterComponent::SlotNum' has a wrong offset!");
static_assert(offsetof(UPalMapObjectBreedFarmParameterComponent, TargetItemIds) == 0x0000B0, "Member 'UPalMapObjectBreedFarmParameterComponent::TargetItemIds' has a wrong offset!");

// Class Pal.PalInvaderBaseCampObserver
// 0x0028 (0x0050 - 0x0028)
class UPalInvaderBaseCampObserver final : public UObject
{
public:
	class UPalBaseCampModel*                      TargetBaseCamp;                                    // 0x0028(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  TargetBaseCampID;                                  // 0x0030(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsInvading;                                       // 0x0040(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsCoolTime;                                       // 0x0041(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C40[0x2];                                     // 0x0042(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CoolTimeFinish;                                    // 0x0044(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CoolTimeElapsed;                                   // 0x0048(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PlayerInBaseCampTimer;                             // 0x004C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalInvaderBaseCampObserver">();
	}
	static class UPalInvaderBaseCampObserver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalInvaderBaseCampObserver>();
	}
};
static_assert(alignof(UPalInvaderBaseCampObserver) == 0x000008, "Wrong alignment on UPalInvaderBaseCampObserver");
static_assert(sizeof(UPalInvaderBaseCampObserver) == 0x000050, "Wrong size on UPalInvaderBaseCampObserver");
static_assert(offsetof(UPalInvaderBaseCampObserver, TargetBaseCamp) == 0x000028, "Member 'UPalInvaderBaseCampObserver::TargetBaseCamp' has a wrong offset!");
static_assert(offsetof(UPalInvaderBaseCampObserver, TargetBaseCampID) == 0x000030, "Member 'UPalInvaderBaseCampObserver::TargetBaseCampID' has a wrong offset!");
static_assert(offsetof(UPalInvaderBaseCampObserver, bIsInvading) == 0x000040, "Member 'UPalInvaderBaseCampObserver::bIsInvading' has a wrong offset!");
static_assert(offsetof(UPalInvaderBaseCampObserver, bIsCoolTime) == 0x000041, "Member 'UPalInvaderBaseCampObserver::bIsCoolTime' has a wrong offset!");
static_assert(offsetof(UPalInvaderBaseCampObserver, CoolTimeFinish) == 0x000044, "Member 'UPalInvaderBaseCampObserver::CoolTimeFinish' has a wrong offset!");
static_assert(offsetof(UPalInvaderBaseCampObserver, CoolTimeElapsed) == 0x000048, "Member 'UPalInvaderBaseCampObserver::CoolTimeElapsed' has a wrong offset!");
static_assert(offsetof(UPalInvaderBaseCampObserver, PlayerInBaseCampTimer) == 0x00004C, "Member 'UPalInvaderBaseCampObserver::PlayerInBaseCampTimer' has a wrong offset!");

// Class Pal.PalInvaderManager
// 0x01A8 (0x0218 - 0x0070)
class UPalInvaderManager : public UPalWorldSubsystem
{
public:
	uint8                                         Pad_2C41[0x18];                                    // 0x0070(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(const struct FTransform& Transform)> SpawnDummyNavInvokerDelegate;                      // 0x0088(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInvaderStartDelegate;                            // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInvaderEndDelegate;                              // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInvaderArrivedDelegate;                          // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<struct FGuid, struct FPalInvaderStartPointInfo> InvadeStartLocationList;                           // 0x00C8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<struct FGuid, class UPalInvaderBaseCampObserver*> Observers;                                         // 0x0118(0x0050)(NativeAccessSpecifierPrivate)
	TMap<struct FGuid, class UPalInvaderIncidentBase*> Incidents;                                         // 0x0168(0x0050)(NativeAccessSpecifierPrivate)
	struct FGuid                                  StartInvaderLogId;                                 // 0x01B8(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<struct FGuid, struct FPalInvaderSaveData> InvaderSaveDataMapCache;                           // 0x01C8(0x0050)(NativeAccessSpecifierPrivate)

public:
	void InvaderEndDelegate__DelegateSignature(const struct FPalIncidentBroadcastParameter& Parameter);
	void InvaderOnArrivedDelegate__DelegateSignature(const struct FPalIncidentBroadcastParameter& Parameter);
	void InvaderStartDelegate__DelegateSignature(const struct FPalIncidentBroadcastParameter& Parameter);
	void RemoveInvaderIncident(class UPalIncidentBase* Incident);
	bool RequestIncidentInvaderEnemy(const struct FGuid& Guid, class UPalInvaderBaseCampObserver* Observer);
	class UPalInvaderIncidentBase* RequestIncidentInvaderEnemy_BP(class UObject* OccuredBaseCamp, class UPalIncidentDynamicParameterInvader* Parameter);
	bool RequestIncidentVisitorNPC(const struct FGuid& Guid, class UPalInvaderBaseCampObserver* Observer);
	class UPalInvaderIncidentBase* RequestIncidentVisitorNPC_BP(class UObject* OccuredBaseCamp, class UPalIncidentDynamicParameterInvader* Parameter);
	class AActor* SpawnDummyNavInvoker(const struct FTransform& Transform);
	class AActor* SpawnDummyNavInvokerDelegate__DelegateSignature(const struct FTransform& Transform);
	void StartInvaderMarchAll();
	void StartInvaderMarchRandom();
	void VisitorTravelLog(EPalLogType LogType);
	void VisitorTravelTest();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalInvaderManager">();
	}
	static class UPalInvaderManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalInvaderManager>();
	}
};
static_assert(alignof(UPalInvaderManager) == 0x000008, "Wrong alignment on UPalInvaderManager");
static_assert(sizeof(UPalInvaderManager) == 0x000218, "Wrong size on UPalInvaderManager");
static_assert(offsetof(UPalInvaderManager, SpawnDummyNavInvokerDelegate) == 0x000088, "Member 'UPalInvaderManager::SpawnDummyNavInvokerDelegate' has a wrong offset!");
static_assert(offsetof(UPalInvaderManager, OnInvaderStartDelegate) == 0x000098, "Member 'UPalInvaderManager::OnInvaderStartDelegate' has a wrong offset!");
static_assert(offsetof(UPalInvaderManager, OnInvaderEndDelegate) == 0x0000A8, "Member 'UPalInvaderManager::OnInvaderEndDelegate' has a wrong offset!");
static_assert(offsetof(UPalInvaderManager, OnInvaderArrivedDelegate) == 0x0000B8, "Member 'UPalInvaderManager::OnInvaderArrivedDelegate' has a wrong offset!");
static_assert(offsetof(UPalInvaderManager, InvadeStartLocationList) == 0x0000C8, "Member 'UPalInvaderManager::InvadeStartLocationList' has a wrong offset!");
static_assert(offsetof(UPalInvaderManager, Observers) == 0x000118, "Member 'UPalInvaderManager::Observers' has a wrong offset!");
static_assert(offsetof(UPalInvaderManager, Incidents) == 0x000168, "Member 'UPalInvaderManager::Incidents' has a wrong offset!");
static_assert(offsetof(UPalInvaderManager, StartInvaderLogId) == 0x0001B8, "Member 'UPalInvaderManager::StartInvaderLogId' has a wrong offset!");
static_assert(offsetof(UPalInvaderManager, InvaderSaveDataMapCache) == 0x0001C8, "Member 'UPalInvaderManager::InvaderSaveDataMapCache' has a wrong offset!");

// Class Pal.PalWorkOnlyJoin
// 0x0000 (0x0320 - 0x0320)
class UPalWorkOnlyJoin final : public UPalWorkBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorkOnlyJoin">();
	}
	static class UPalWorkOnlyJoin* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWorkOnlyJoin>();
	}
};
static_assert(alignof(UPalWorkOnlyJoin) == 0x000010, "Wrong alignment on UPalWorkOnlyJoin");
static_assert(sizeof(UPalWorkOnlyJoin) == 0x000320, "Wrong size on UPalWorkOnlyJoin");

// Class Pal.PalInvaderStartPoint
// 0x0018 (0x02A8 - 0x0290)
class APalInvaderStartPoint final : public AActor
{
public:
	uint8                                         Pad_2C46[0x10];                                    // 0x0290(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	EPalBiomeType                                 BiomeType;                                         // 0x02A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C47[0x7];                                     // 0x02A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalInvaderStartPoint">();
	}
	static class APalInvaderStartPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalInvaderStartPoint>();
	}
};
static_assert(alignof(APalInvaderStartPoint) == 0x000008, "Wrong alignment on APalInvaderStartPoint");
static_assert(sizeof(APalInvaderStartPoint) == 0x0002A8, "Wrong size on APalInvaderStartPoint");
static_assert(offsetof(APalInvaderStartPoint, BiomeType) == 0x0002A0, "Member 'APalInvaderStartPoint::BiomeType' has a wrong offset!");

// Class Pal.PalIncidentDynamicParameterInvader
// 0x0010 (0x0040 - 0x0030)
class UPalIncidentDynamicParameterInvader final : public UPalIncidentDynamicParameter
{
public:
	struct FGuid                                  TargetBaseCampID;                                  // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalIncidentDynamicParameterInvader">();
	}
	static class UPalIncidentDynamicParameterInvader* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalIncidentDynamicParameterInvader>();
	}
};
static_assert(alignof(UPalIncidentDynamicParameterInvader) == 0x000008, "Wrong alignment on UPalIncidentDynamicParameterInvader");
static_assert(sizeof(UPalIncidentDynamicParameterInvader) == 0x000040, "Wrong size on UPalIncidentDynamicParameterInvader");
static_assert(offsetof(UPalIncidentDynamicParameterInvader, TargetBaseCampID) == 0x000030, "Member 'UPalIncidentDynamicParameterInvader::TargetBaseCampID' has a wrong offset!");

// Class Pal.PalItemContainer
// 0x0098 (0x00E8 - 0x0050)
class UPalItemContainer final : public UPalContainerBase
{
public:
	FMulticastInlineDelegateProperty_             OnUpdateContentsDelegate;                          // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateFilterPreferenceDelegate;                  // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UPalItemSlot*>                   ItemSlotArray;                                     // 0x0070(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, RepNotify, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FPalItemPermission                     Permission;                                        // 0x0080(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnTemplate, EditConst, RepNotify, Protected, NativeAccessSpecifierProtected)
	float                                         CorruptionMultiplier;                              // 0x00B0(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C48[0x4];                                     // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPalItemContainerFilter                FilterPreference;                                  // 0x00B8(0x0010)(Edit, Net, DisableEditOnTemplate, Transient, EditConst, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FPalItemContainerBelongInfo            BelongInfo;                                        // 0x00C8(0x0020)(Edit, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	void OnRep_FilterPreference();
	void OnRep_ItemSlotArray();
	void OnRep_Permission();
	void OnUpdateSlotContent(class UPalItemSlot* Slot);
	void UpdateContentsDelegate__DelegateSignature(class UPalItemContainer* Container);

	class UPalItemSlot* Get(const int32 Param_Index) const;
	TArray<class FName> GetFilterOffList() const;
	const struct FPalItemContainerFilter GetFilterPreference() const;
	int32 GetItemStackCount(const class FName StaticItemId) const;
	const struct FPalItemPermission GetPermission() const;
	int32 Num() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalItemContainer">();
	}
	static class UPalItemContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalItemContainer>();
	}
};
static_assert(alignof(UPalItemContainer) == 0x000008, "Wrong alignment on UPalItemContainer");
static_assert(sizeof(UPalItemContainer) == 0x0000E8, "Wrong size on UPalItemContainer");
static_assert(offsetof(UPalItemContainer, OnUpdateContentsDelegate) == 0x000050, "Member 'UPalItemContainer::OnUpdateContentsDelegate' has a wrong offset!");
static_assert(offsetof(UPalItemContainer, OnUpdateFilterPreferenceDelegate) == 0x000060, "Member 'UPalItemContainer::OnUpdateFilterPreferenceDelegate' has a wrong offset!");
static_assert(offsetof(UPalItemContainer, ItemSlotArray) == 0x000070, "Member 'UPalItemContainer::ItemSlotArray' has a wrong offset!");
static_assert(offsetof(UPalItemContainer, Permission) == 0x000080, "Member 'UPalItemContainer::Permission' has a wrong offset!");
static_assert(offsetof(UPalItemContainer, CorruptionMultiplier) == 0x0000B0, "Member 'UPalItemContainer::CorruptionMultiplier' has a wrong offset!");
static_assert(offsetof(UPalItemContainer, FilterPreference) == 0x0000B8, "Member 'UPalItemContainer::FilterPreference' has a wrong offset!");
static_assert(offsetof(UPalItemContainer, BelongInfo) == 0x0000C8, "Member 'UPalItemContainer::BelongInfo' has a wrong offset!");

// Class Pal.PalItemContainerManager
// 0x0170 (0x01E0 - 0x0070)
class UPalItemContainerManager : public UPalWorldSubsystem
{
public:
	uint8                                         Pad_2C4A[0x10];                                    // 0x0070(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnItemOperationMoveDelegate;                       // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<struct FPalContainerId, class UPalItemContainer*> ItemContainerMap_InServer;                         // 0x0090(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C4B[0x50];                                    // 0x00E0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FPalContainerId, struct FPalItemContainerBelongInfo> ItemContainerBelongInfo;                           // 0x0130(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	TSet<struct FPalContainerId>                  LoadedContainerIDs;                                // 0x0180(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C4C[0x10];                                    // 0x01D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static const struct FGuid GetGroupIdByItemContainerId(const class UObject* WorldContextObject, const struct FPalContainerId& ContainerId);
	static const struct FGuid GetGroupIdByItemSlotId(const class UObject* WorldContextObject, const struct FPalItemSlotId& SlotID);

	void ItemOperationMoveDelegate__DelegateSignature(const TArray<struct FPalItemOperationInfo_Move>& OperationInfoSet);

	class UPalItemContainer* GetContainer(const struct FPalContainerId& ContainerId) const;
	bool TryGetContainer(const struct FPalContainerId& ContainerId, class UPalItemContainer** Container) const;
	bool TryGetSlot(const struct FPalItemSlotId& SlotID, class UPalItemSlot** Slot) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalItemContainerManager">();
	}
	static class UPalItemContainerManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalItemContainerManager>();
	}
};
static_assert(alignof(UPalItemContainerManager) == 0x000008, "Wrong alignment on UPalItemContainerManager");
static_assert(sizeof(UPalItemContainerManager) == 0x0001E0, "Wrong size on UPalItemContainerManager");
static_assert(offsetof(UPalItemContainerManager, OnItemOperationMoveDelegate) == 0x000080, "Member 'UPalItemContainerManager::OnItemOperationMoveDelegate' has a wrong offset!");
static_assert(offsetof(UPalItemContainerManager, ItemContainerMap_InServer) == 0x000090, "Member 'UPalItemContainerManager::ItemContainerMap_InServer' has a wrong offset!");
static_assert(offsetof(UPalItemContainerManager, ItemContainerBelongInfo) == 0x000130, "Member 'UPalItemContainerManager::ItemContainerBelongInfo' has a wrong offset!");
static_assert(offsetof(UPalItemContainerManager, LoadedContainerIDs) == 0x000180, "Member 'UPalItemContainerManager::LoadedContainerIDs' has a wrong offset!");

// Class Pal.PalMapObjectModelEffect_AccumulateTrigger
// 0x0018 (0x0058 - 0x0040)
class UPalMapObjectModelEffect_AccumulateTrigger : public UPalMapObjectModelEffectBase
{
public:
	uint8                                         Pad_2C51[0x10];                                    // 0x0040(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AccumulateValue;                                   // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C52[0x4];                                     // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectModelEffect_AccumulateTrigger">();
	}
	static class UPalMapObjectModelEffect_AccumulateTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectModelEffect_AccumulateTrigger>();
	}
};
static_assert(alignof(UPalMapObjectModelEffect_AccumulateTrigger) == 0x000008, "Wrong alignment on UPalMapObjectModelEffect_AccumulateTrigger");
static_assert(sizeof(UPalMapObjectModelEffect_AccumulateTrigger) == 0x000058, "Wrong size on UPalMapObjectModelEffect_AccumulateTrigger");
static_assert(offsetof(UPalMapObjectModelEffect_AccumulateTrigger, AccumulateValue) == 0x000050, "Member 'UPalMapObjectModelEffect_AccumulateTrigger::AccumulateValue' has a wrong offset!");

// Class Pal.PalMapObjectModelEffect_Burn
// 0x0010 (0x0068 - 0x0058)
class UPalMapObjectModelEffect_Burn final : public UPalMapObjectModelEffect_AccumulateTrigger
{
public:
	bool                                          bBurning;                                          // 0x0058(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C53[0x3];                                     // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PersistenceValue;                                  // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APalHitCollisionBox*                    HitCollisionBox;                                   // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnHitCollisionBox(class UPrimitiveComponent* MyHitComponent, class AActor* OtherHitActor, class UPrimitiveComponent* OtherHitComponent, const TArray<int32>& FoliageIndex, const struct FVector& HitLocation, int32 HitCount);
	void OnRep_Burning(bool bLastValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectModelEffect_Burn">();
	}
	static class UPalMapObjectModelEffect_Burn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectModelEffect_Burn>();
	}
};
static_assert(alignof(UPalMapObjectModelEffect_Burn) == 0x000008, "Wrong alignment on UPalMapObjectModelEffect_Burn");
static_assert(sizeof(UPalMapObjectModelEffect_Burn) == 0x000068, "Wrong size on UPalMapObjectModelEffect_Burn");
static_assert(offsetof(UPalMapObjectModelEffect_Burn, bBurning) == 0x000058, "Member 'UPalMapObjectModelEffect_Burn::bBurning' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModelEffect_Burn, PersistenceValue) == 0x00005C, "Member 'UPalMapObjectModelEffect_Burn::PersistenceValue' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModelEffect_Burn, HitCollisionBox) == 0x000060, "Member 'UPalMapObjectModelEffect_Burn::HitCollisionBox' has a wrong offset!");

// Class Pal.PalItemContainerMultiHelper
// 0x0020 (0x0048 - 0x0028)
class UPalItemContainerMultiHelper final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnUpdateContentDelegate;                           // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UPalItemContainer*>              Containers;                                        // 0x0038(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, RepNotify, NativeAccessSpecifierPrivate)

public:
	void FindByStaticItemId(const class FName StaticItemId, struct FPalStaticItemIdAndNum* StaticItemInfo);
	void FindByStaticItemIds(const TArray<class FName>& StaticItemIds, TArray<struct FPalStaticItemIdAndNum>* StaticItemInfos);
	bool IsExistItems(const TArray<struct FPalStaticItemIdAndNum>& StaticItemInfos);
	void OnRep_Containers();
	void OnUpdateContainerContent(class UPalItemContainer* Container);
	void UpdateContentDelegate__DelegateSignature(class UPalItemContainerMultiHelper* Self);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalItemContainerMultiHelper">();
	}
	static class UPalItemContainerMultiHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalItemContainerMultiHelper>();
	}
};
static_assert(alignof(UPalItemContainerMultiHelper) == 0x000008, "Wrong alignment on UPalItemContainerMultiHelper");
static_assert(sizeof(UPalItemContainerMultiHelper) == 0x000048, "Wrong size on UPalItemContainerMultiHelper");
static_assert(offsetof(UPalItemContainerMultiHelper, OnUpdateContentDelegate) == 0x000028, "Member 'UPalItemContainerMultiHelper::OnUpdateContentDelegate' has a wrong offset!");
static_assert(offsetof(UPalItemContainerMultiHelper, Containers) == 0x000038, "Member 'UPalItemContainerMultiHelper::Containers' has a wrong offset!");

// Class Pal.PalItemFlowSplineComponent
// 0x0020 (0x0660 - 0x0640)
class UPalItemFlowSplineComponent final : public USplineComponent
{
public:
	float                                         ItemSpawnInterval;                                 // 0x0638(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FlowSpeedRate;                                     // 0x063C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFloatCounter                          FlowingItemSpawnTimer;                             // 0x0640(0x0008)(Edit, DisableEditOnTemplate, Transient, EditConst, NoDestructor, NativeAccessSpecifierPrivate)
	TSubclassOf<class AActor>                     ItemVisualBlueprintClass;                          // 0x0648(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FPalItemFlowInSplineInfo>       FlowingItemInfos;                                  // 0x0650(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)

public:
	void UpdateIsFlowing(const bool bOn);
	void UpdateTargetItem(const class FName InStaticItemId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalItemFlowSplineComponent">();
	}
	static class UPalItemFlowSplineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalItemFlowSplineComponent>();
	}
};
static_assert(alignof(UPalItemFlowSplineComponent) == 0x000010, "Wrong alignment on UPalItemFlowSplineComponent");
static_assert(sizeof(UPalItemFlowSplineComponent) == 0x000660, "Wrong size on UPalItemFlowSplineComponent");
static_assert(offsetof(UPalItemFlowSplineComponent, ItemSpawnInterval) == 0x000638, "Member 'UPalItemFlowSplineComponent::ItemSpawnInterval' has a wrong offset!");
static_assert(offsetof(UPalItemFlowSplineComponent, FlowSpeedRate) == 0x00063C, "Member 'UPalItemFlowSplineComponent::FlowSpeedRate' has a wrong offset!");
static_assert(offsetof(UPalItemFlowSplineComponent, FlowingItemSpawnTimer) == 0x000640, "Member 'UPalItemFlowSplineComponent::FlowingItemSpawnTimer' has a wrong offset!");
static_assert(offsetof(UPalItemFlowSplineComponent, ItemVisualBlueprintClass) == 0x000648, "Member 'UPalItemFlowSplineComponent::ItemVisualBlueprintClass' has a wrong offset!");
static_assert(offsetof(UPalItemFlowSplineComponent, FlowingItemInfos) == 0x000650, "Member 'UPalItemFlowSplineComponent::FlowingItemInfos' has a wrong offset!");

// Class Pal.PalWorkMonsterFarm
// 0x0020 (0x0340 - 0x0320)
class UPalWorkMonsterFarm final : public UPalWorkBase
{
public:
	struct FFloatInterval                         ActionIntervalSeconds;                             // 0x0318(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C56[0x20];                                    // 0x0320(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorkMonsterFarm">();
	}
	static class UPalWorkMonsterFarm* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWorkMonsterFarm>();
	}
};
static_assert(alignof(UPalWorkMonsterFarm) == 0x000010, "Wrong alignment on UPalWorkMonsterFarm");
static_assert(sizeof(UPalWorkMonsterFarm) == 0x000340, "Wrong size on UPalWorkMonsterFarm");
static_assert(offsetof(UPalWorkMonsterFarm, ActionIntervalSeconds) == 0x000318, "Member 'UPalWorkMonsterFarm::ActionIntervalSeconds' has a wrong offset!");

// Class Pal.PalItemIDManager
// 0x0030 (0x0058 - 0x0028)
class UPalItemIDManager : public UObject
{
public:
	class UPalStaticItemDataAsset*                StaticItemDataAsset;                               // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPalDataTableRowName_ItemData          WoodItemRowName;                                   // 0x0030(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPalDataTableRowName_ItemData          EggItemRowName;                                    // 0x0038(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPalDataTableRowName_ItemData          PalUpgradeStoneItemRowName;                        // 0x0040(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPalDataTableRowName_ItemData          MoneyItemRowName;                                  // 0x0048(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalStaticItemDataTable*                StaticItemDataTable;                               // 0x0050(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	const struct FPalItemData GetItemData(const struct FPalItemId& ItemId) const;
	class UPalStaticItemDataBase* GetStaticItemData(const class FName StaticItemId) const;
	class FName GetStaticItemIdPalEgg(const class UObject* WorldContextObject, const class FName CharacterID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalItemIDManager">();
	}
	static class UPalItemIDManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalItemIDManager>();
	}
};
static_assert(alignof(UPalItemIDManager) == 0x000008, "Wrong alignment on UPalItemIDManager");
static_assert(sizeof(UPalItemIDManager) == 0x000058, "Wrong size on UPalItemIDManager");
static_assert(offsetof(UPalItemIDManager, StaticItemDataAsset) == 0x000028, "Member 'UPalItemIDManager::StaticItemDataAsset' has a wrong offset!");
static_assert(offsetof(UPalItemIDManager, WoodItemRowName) == 0x000030, "Member 'UPalItemIDManager::WoodItemRowName' has a wrong offset!");
static_assert(offsetof(UPalItemIDManager, EggItemRowName) == 0x000038, "Member 'UPalItemIDManager::EggItemRowName' has a wrong offset!");
static_assert(offsetof(UPalItemIDManager, PalUpgradeStoneItemRowName) == 0x000040, "Member 'UPalItemIDManager::PalUpgradeStoneItemRowName' has a wrong offset!");
static_assert(offsetof(UPalItemIDManager, MoneyItemRowName) == 0x000048, "Member 'UPalItemIDManager::MoneyItemRowName' has a wrong offset!");
static_assert(offsetof(UPalItemIDManager, StaticItemDataTable) == 0x000050, "Member 'UPalItemIDManager::StaticItemDataTable' has a wrong offset!");

// Class Pal.PalMapObjectModelInitializeExtraParameterSpawnedBy
// 0x0010 (0x0038 - 0x0028)
class UPalMapObjectModelInitializeExtraParameterSpawnedBy final : public UPalMapObjectModelInitializeExtraParameterBase
{
public:
	struct FGuid                                  ByMapObjectModelInstanceId;                        // 0x0028(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectModelInitializeExtraParameterSpawnedBy">();
	}
	static class UPalMapObjectModelInitializeExtraParameterSpawnedBy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectModelInitializeExtraParameterSpawnedBy>();
	}
};
static_assert(alignof(UPalMapObjectModelInitializeExtraParameterSpawnedBy) == 0x000008, "Wrong alignment on UPalMapObjectModelInitializeExtraParameterSpawnedBy");
static_assert(sizeof(UPalMapObjectModelInitializeExtraParameterSpawnedBy) == 0x000038, "Wrong size on UPalMapObjectModelInitializeExtraParameterSpawnedBy");
static_assert(offsetof(UPalMapObjectModelInitializeExtraParameterSpawnedBy, ByMapObjectModelInstanceId) == 0x000028, "Member 'UPalMapObjectModelInitializeExtraParameterSpawnedBy::ByMapObjectModelInstanceId' has a wrong offset!");

// Class Pal.PalWorkProgressTransformBase
// 0x0008 (0x0030 - 0x0028)
class UPalWorkProgressTransformBase : public UObject
{
public:
	uint8                                         Pad_2C57[0x8];                                     // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorkProgressTransformBase">();
	}
	static class UPalWorkProgressTransformBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWorkProgressTransformBase>();
	}
};
static_assert(alignof(UPalWorkProgressTransformBase) == 0x000008, "Wrong alignment on UPalWorkProgressTransformBase");
static_assert(sizeof(UPalWorkProgressTransformBase) == 0x000030, "Wrong size on UPalWorkProgressTransformBase");

// Class Pal.PalWorkProgressTransformCharacter
// 0x0090 (0x00C0 - 0x0030)
class UPalWorkProgressTransformCharacter final : public UPalWorkProgressTransformBase
{
public:
	struct FPalInstanceID                         IndividualId;                                      // 0x0030(0x0030)(Edit, Net, DisableEditOnTemplate, Transient, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             TransformCache;                                    // 0x0060(0x0060)(Edit, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorkProgressTransformCharacter">();
	}
	static class UPalWorkProgressTransformCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWorkProgressTransformCharacter>();
	}
};
static_assert(alignof(UPalWorkProgressTransformCharacter) == 0x000010, "Wrong alignment on UPalWorkProgressTransformCharacter");
static_assert(sizeof(UPalWorkProgressTransformCharacter) == 0x0000C0, "Wrong size on UPalWorkProgressTransformCharacter");
static_assert(offsetof(UPalWorkProgressTransformCharacter, IndividualId) == 0x000030, "Member 'UPalWorkProgressTransformCharacter::IndividualId' has a wrong offset!");
static_assert(offsetof(UPalWorkProgressTransformCharacter, TransformCache) == 0x000060, "Member 'UPalWorkProgressTransformCharacter::TransformCache' has a wrong offset!");

// Class Pal.PalItemSelectorComponent
// 0x0060 (0x0100 - 0x00A0)
class UPalItemSelectorComponent : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnChangeSelectedIndex;                             // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<EPalPlayerInventoryType, struct FPalPlayerInventorySelectData> ItemSelectDataMap;                                 // 0x00B0(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	bool AddTargetInventoryType(EPalPlayerInventoryType TargetInventoryType);
	void ChangeSelectedIndexDelegate__DelegateSignature(EPalPlayerInventoryType InventoryType, int32 Param_Index);
	bool RemoveTargetInventoryType(EPalPlayerInventoryType TargetInventoryType);
	void SelectItem(EPalPlayerInventoryType TargetInventory, int32 Param_Index);
	void SelectNextItem(EPalPlayerInventoryType TargetInventory);
	void SelectPrevItem(EPalPlayerInventoryType TargetInventory);

	class UPalItemContainer* GetContainer(EPalPlayerInventoryType TargetInventory) const;
	int32 GetNowSelectedIndex(EPalPlayerInventoryType TargetInventory) const;
	class UPalItemSlot* GetNowSelectedItemSlot(EPalPlayerInventoryType TargetInventory) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalItemSelectorComponent">();
	}
	static class UPalItemSelectorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalItemSelectorComponent>();
	}
};
static_assert(alignof(UPalItemSelectorComponent) == 0x000008, "Wrong alignment on UPalItemSelectorComponent");
static_assert(sizeof(UPalItemSelectorComponent) == 0x000100, "Wrong size on UPalItemSelectorComponent");
static_assert(offsetof(UPalItemSelectorComponent, OnChangeSelectedIndex) == 0x0000A0, "Member 'UPalItemSelectorComponent::OnChangeSelectedIndex' has a wrong offset!");
static_assert(offsetof(UPalItemSelectorComponent, ItemSelectDataMap) == 0x0000B0, "Member 'UPalItemSelectorComponent::ItemSelectDataMap' has a wrong offset!");

// Class Pal.PalItemSlot
// 0x0158 (0x0180 - 0x0028)
class UPalItemSlot final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnUpdateSlotContentDelegate;                       // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLiftedSlotContentDelegate;                       // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFinishLiftedContentDelegate;                     // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateSlotContentDurabilityDelegate;             // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateSlotCorruptionDelegate;                    // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<int32, bool>                             DirtyMap;                                          // 0x0078(0x0050)(NativeAccessSpecifierPublic)
	int32                                         SlotIndex;                                         // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPalContainerId                        ContainerId;                                       // 0x00CC(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnTemplate, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPalItemId                             ItemId;                                            // 0x00DC(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnTemplate, EditConst, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         StackCount;                                        // 0x0104(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CorruptionProgressValue;                           // 0x0108(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C5D[0x4];                                     // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPalItemPermission                     Permission;                                        // 0x0110(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnTemplate, EditConst, RepNotify, Protected, NativeAccessSpecifierProtected)
	class UPalDynamicItemDataBase*                DynamicItemData;                                   // 0x0140(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C5E[0x10];                                    // 0x0148(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPalItemId                             LastItemId_Client;                                 // 0x0158(0x0028)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void FinishLiftedContentDelegate__DelegateSignature();
	void LiftedSlotContentDelegate__DelegateSignature(const int32 LiftItemNum);
	void OnRep_CorruptionProgressValue();
	void OnRep_DynamicItemData();
	void OnRep_ItemId();
	void OnRep_Permission();
	void OnRep_StackCount();
	void OnUpdateSlotContentDurability(float OldDurability, float NewDurability);
	bool TryGetDynamicItemData(class UPalDynamicItemDataBase** OutDynamicItemData);
	bool TryGetStaticItemData(class UPalStaticItemDataBase** OutStaticItemData);
	void UpdateSlotContentDelegate__DelegateSignature(class UPalItemSlot* Slot);
	void UpdateSlotContentDurabilityDelegate__DelegateSignature(float OldDurability, float NewDurability);

	float GetCorruptionProgressRate() const;
	class FText GetCorruptionRemainTimeText() const;
	const struct FPalItemId GetItemId() const;
	const struct FPalItemPermission GetPermission() const;
	struct FPalItemSlotId GetSlotId() const;
	int32 GetStackCount() const;
	bool IsEmpty() const;
	bool IsMaxStack() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalItemSlot">();
	}
	static class UPalItemSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalItemSlot>();
	}
};
static_assert(alignof(UPalItemSlot) == 0x000008, "Wrong alignment on UPalItemSlot");
static_assert(sizeof(UPalItemSlot) == 0x000180, "Wrong size on UPalItemSlot");
static_assert(offsetof(UPalItemSlot, OnUpdateSlotContentDelegate) == 0x000028, "Member 'UPalItemSlot::OnUpdateSlotContentDelegate' has a wrong offset!");
static_assert(offsetof(UPalItemSlot, OnLiftedSlotContentDelegate) == 0x000038, "Member 'UPalItemSlot::OnLiftedSlotContentDelegate' has a wrong offset!");
static_assert(offsetof(UPalItemSlot, OnFinishLiftedContentDelegate) == 0x000048, "Member 'UPalItemSlot::OnFinishLiftedContentDelegate' has a wrong offset!");
static_assert(offsetof(UPalItemSlot, OnUpdateSlotContentDurabilityDelegate) == 0x000058, "Member 'UPalItemSlot::OnUpdateSlotContentDurabilityDelegate' has a wrong offset!");
static_assert(offsetof(UPalItemSlot, OnUpdateSlotCorruptionDelegate) == 0x000068, "Member 'UPalItemSlot::OnUpdateSlotCorruptionDelegate' has a wrong offset!");
static_assert(offsetof(UPalItemSlot, DirtyMap) == 0x000078, "Member 'UPalItemSlot::DirtyMap' has a wrong offset!");
static_assert(offsetof(UPalItemSlot, SlotIndex) == 0x0000C8, "Member 'UPalItemSlot::SlotIndex' has a wrong offset!");
static_assert(offsetof(UPalItemSlot, ContainerId) == 0x0000CC, "Member 'UPalItemSlot::ContainerId' has a wrong offset!");
static_assert(offsetof(UPalItemSlot, ItemId) == 0x0000DC, "Member 'UPalItemSlot::ItemId' has a wrong offset!");
static_assert(offsetof(UPalItemSlot, StackCount) == 0x000104, "Member 'UPalItemSlot::StackCount' has a wrong offset!");
static_assert(offsetof(UPalItemSlot, CorruptionProgressValue) == 0x000108, "Member 'UPalItemSlot::CorruptionProgressValue' has a wrong offset!");
static_assert(offsetof(UPalItemSlot, Permission) == 0x000110, "Member 'UPalItemSlot::Permission' has a wrong offset!");
static_assert(offsetof(UPalItemSlot, DynamicItemData) == 0x000140, "Member 'UPalItemSlot::DynamicItemData' has a wrong offset!");
static_assert(offsetof(UPalItemSlot, LastItemId_Client) == 0x000158, "Member 'UPalItemSlot::LastItemId_Client' has a wrong offset!");

// Class Pal.PalItemOperationResultUtility
// 0x0000 (0x0028 - 0x0028)
class UPalItemOperationResultUtility final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalItemOperationResultUtility">();
	}
	static class UPalItemOperationResultUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalItemOperationResultUtility>();
	}
};
static_assert(alignof(UPalItemOperationResultUtility) == 0x000008, "Wrong alignment on UPalItemOperationResultUtility");
static_assert(sizeof(UPalItemOperationResultUtility) == 0x000028, "Wrong size on UPalItemOperationResultUtility");

// Class Pal.PalItemUtility
// 0x0000 (0x0028 - 0x0028)
class UPalItemUtility final : public UBlueprintFunctionLibrary
{
public:
	static bool CanItemLevelUp(const class UPalStaticItemDataBase* ItemData, class UPalIndividualCharacterParameter* TargetParameter);
	static bool CanUseHealItem(const class UObject* WorldContextObject, class FName StaticItemName, class UPalIndividualCharacterParameter* TargetParameter);
	static void CollectLocalPlayerControllableItemInfos(const class UObject* WorldContextObject, const TArray<class FName>& StaticItemIds, TArray<struct FPalStaticItemIdAndNum>* OutItemInfos, const bool bIncludeInRangeBaseCamp);
	static class UPalItemSlot* CreateLocalItemSlot(class UObject* WorldContextObject, const class FName StaticItemId, const int32 Stack);
	static const int32 GetRecipeMaterialKindCount(const struct FPalItemRecipe& Recipe);
	static const bool IsEmpty(const struct FPalItemAndNum& ItemInfo);
	static bool IsRepairableItem(class UObject* WorldContextObject, const struct FPalItemId& TargetItemId);
	static bool IsStatusPointResetItem(const class UPalStaticItemDataBase* ItemData);
	static const bool IsValid(const struct FPalItemRecipe& Recipe);
	static void MaterialInfos(const struct FPalItemRecipe& Recipe, TArray<struct FPalStaticItemIdAndNum>* Param_MaterialInfos);
	static void RestoreWithItem(const class UObject* WorldContextObject, class FName StaticItemName, class UPalIndividualCharacterParameter* TargetParameter);
	static bool TryGetItemVisualBlueprintClass(const class UObject* WorldContextObject, const class FName StaticItemId, TSoftClassPtr<class UClass>* VisualBlueprintClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalItemUtility">();
	}
	static class UPalItemUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalItemUtility>();
	}
};
static_assert(alignof(UPalItemUtility) == 0x000008, "Wrong alignment on UPalItemUtility");
static_assert(sizeof(UPalItemUtility) == 0x000028, "Wrong size on UPalItemUtility");

// Class Pal.PalMapObjectModelInitializeExtraParameterDropItem
// 0x0030 (0x0058 - 0x0028)
class UPalMapObjectModelInitializeExtraParameterDropItem final : public UPalMapObjectModelInitializeExtraParameterBase
{
public:
	struct FPalContainerId                        TempContainerID;                                   // 0x0028(0x0010)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReleaseDirection;                                  // 0x0038(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoPickup;                                       // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C6B[0x7];                                     // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectModelInitializeExtraParameterDropItem">();
	}
	static class UPalMapObjectModelInitializeExtraParameterDropItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectModelInitializeExtraParameterDropItem>();
	}
};
static_assert(alignof(UPalMapObjectModelInitializeExtraParameterDropItem) == 0x000008, "Wrong alignment on UPalMapObjectModelInitializeExtraParameterDropItem");
static_assert(sizeof(UPalMapObjectModelInitializeExtraParameterDropItem) == 0x000058, "Wrong size on UPalMapObjectModelInitializeExtraParameterDropItem");
static_assert(offsetof(UPalMapObjectModelInitializeExtraParameterDropItem, TempContainerID) == 0x000028, "Member 'UPalMapObjectModelInitializeExtraParameterDropItem::TempContainerID' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModelInitializeExtraParameterDropItem, ReleaseDirection) == 0x000038, "Member 'UPalMapObjectModelInitializeExtraParameterDropItem::ReleaseDirection' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModelInitializeExtraParameterDropItem, bAutoPickup) == 0x000050, "Member 'UPalMapObjectModelInitializeExtraParameterDropItem::bAutoPickup' has a wrong offset!");

// Class Pal.PalLavaBoxComponent
// 0x0000 (0x0580 - 0x0580)
class UPalLavaBoxComponent final : public UBoxComponent
{
public:
	void BeginOverlapEvent(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void EndOverlapEvent(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLavaBoxComponent">();
	}
	static class UPalLavaBoxComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalLavaBoxComponent>();
	}
};
static_assert(alignof(UPalLavaBoxComponent) == 0x000010, "Wrong alignment on UPalLavaBoxComponent");
static_assert(sizeof(UPalLavaBoxComponent) == 0x000580, "Wrong size on UPalLavaBoxComponent");

// Class Pal.PalLevelInstance
// 0x0010 (0x0330 - 0x0320)
class APalLevelInstance final : public ALevelInstance
{
public:
	uint8                                         Pad_2C6E[0x10];                                    // 0x0320(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLevelInstance">();
	}
	static class APalLevelInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalLevelInstance>();
	}
};
static_assert(alignof(APalLevelInstance) == 0x000008, "Wrong alignment on APalLevelInstance");
static_assert(sizeof(APalLevelInstance) == 0x000330, "Wrong size on APalLevelInstance");

// Class Pal.PalWorkProgressTransformStatic
// 0x0060 (0x0090 - 0x0030)
class UPalWorkProgressTransformStatic final : public UPalWorkProgressTransformBase
{
public:
	struct FTransform                             Transform;                                         // 0x0030(0x0060)(Edit, Net, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorkProgressTransformStatic">();
	}
	static class UPalWorkProgressTransformStatic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWorkProgressTransformStatic>();
	}
};
static_assert(alignof(UPalWorkProgressTransformStatic) == 0x000010, "Wrong alignment on UPalWorkProgressTransformStatic");
static_assert(sizeof(UPalWorkProgressTransformStatic) == 0x000090, "Wrong size on UPalWorkProgressTransformStatic");
static_assert(offsetof(UPalWorkProgressTransformStatic, Transform) == 0x000030, "Member 'UPalWorkProgressTransformStatic::Transform' has a wrong offset!");

// Class Pal.PalLevelObjectInterface
// 0x0000 (0x0028 - 0x0028)
class IPalLevelObjectInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLevelObjectInterface">();
	}
	static class IPalLevelObjectInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPalLevelObjectInterface>();
	}
};
static_assert(alignof(IPalLevelObjectInterface) == 0x000008, "Wrong alignment on IPalLevelObjectInterface");
static_assert(sizeof(IPalLevelObjectInterface) == 0x000028, "Wrong size on IPalLevelObjectInterface");

// Class Pal.PalLevelObjectInterfaceUtility
// 0x0000 (0x0028 - 0x0028)
class UPalLevelObjectInterfaceUtility final : public UObject
{
public:
	static const struct FGuid BP_GetLevelObjectInstanceId(TScriptInterface<class IPalLevelObjectInterface> Target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLevelObjectInterfaceUtility">();
	}
	static class UPalLevelObjectInterfaceUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalLevelObjectInterfaceUtility>();
	}
};
static_assert(alignof(UPalLevelObjectInterfaceUtility) == 0x000008, "Wrong alignment on UPalLevelObjectInterfaceUtility");
static_assert(sizeof(UPalLevelObjectInterfaceUtility) == 0x000028, "Wrong size on UPalLevelObjectInterfaceUtility");

// Class Pal.PalMasterDataTableAccess_FarmCropData
// 0x0000 (0x0030 - 0x0030)
class UPalMasterDataTableAccess_FarmCropData final : public UPalMasterDataTableAccessBase
{
public:
	void BPExec_FindRow(class FName RowName, EPalMasterDataExecPinType* ExecType, struct FPalMapObjectFarmCropData* OutData);
	void BPExec_FindRowByCropItemId(class FName CropItemId, EPalMasterDataExecPinType* ExecType, struct FPalMapObjectFarmCropData* OutData);

	struct FPalMapObjectFarmCropData BP_FindRow(class FName RowName, bool* bResult) const;
	struct FPalMapObjectFarmCropData BP_FindRowByCropItemId(class FName CropItemId, bool* bResult) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMasterDataTableAccess_FarmCropData">();
	}
	static class UPalMasterDataTableAccess_FarmCropData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMasterDataTableAccess_FarmCropData>();
	}
};
static_assert(alignof(UPalMasterDataTableAccess_FarmCropData) == 0x000008, "Wrong alignment on UPalMasterDataTableAccess_FarmCropData");
static_assert(sizeof(UPalMasterDataTableAccess_FarmCropData) == 0x000030, "Wrong size on UPalMasterDataTableAccess_FarmCropData");

// Class Pal.PalLevelObjectCharacterStatusOperator
// 0x0018 (0x02C0 - 0x02A8)
class APalLevelObjectCharacterStatusOperator final : public APalLevelObjectActor
{
public:
	uint8                                         Pad_2C73[0x8];                                     // 0x02A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TScriptInterface<class IPalInteractiveObjectComponentInterface> InteractComp;                                      // 0x02B0(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnTriggerInteract(class AActor* Other, EPalInteractiveObjectIndicatorType IndicatorType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLevelObjectCharacterStatusOperator">();
	}
	static class APalLevelObjectCharacterStatusOperator* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalLevelObjectCharacterStatusOperator>();
	}
};
static_assert(alignof(APalLevelObjectCharacterStatusOperator) == 0x000008, "Wrong alignment on APalLevelObjectCharacterStatusOperator");
static_assert(sizeof(APalLevelObjectCharacterStatusOperator) == 0x0002C0, "Wrong size on APalLevelObjectCharacterStatusOperator");
static_assert(offsetof(APalLevelObjectCharacterStatusOperator, InteractComp) == 0x0002B0, "Member 'APalLevelObjectCharacterStatusOperator::InteractComp' has a wrong offset!");

// Class Pal.PalLevelObjectObtainable
// 0x0060 (0x0308 - 0x02A8)
class APalLevelObjectObtainable : public APalLevelObjectActor
{
public:
	uint8                                         Pad_2C75[0x8];                                     // 0x02A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnUpdatePickupStatusInClient;                      // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UNiagaraSystem>          ObtainFXSoftObj;                                   // 0x02C0(0x0030)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TScriptInterface<class IPalInteractiveObjectComponentInterface> InteractComp;                                      // 0x02F0(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPickedInClient;                                   // 0x0300(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C76[0x7];                                     // 0x0301(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCompleteSyncPlayer(class APalPlayerState* PlayerState);
	void OnTriggerInteract(class AActor* Other, EPalInteractiveObjectIndicatorType IndicatorType);
	void OnUpdateFlagMapRecord(const class FName Key, const bool bFlag);
	void ReturnSelfDelegate__DelegateSignature(class APalLevelObjectObtainable* Self);

	struct FVector GetObtainFXLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLevelObjectObtainable">();
	}
	static class APalLevelObjectObtainable* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalLevelObjectObtainable>();
	}
};
static_assert(alignof(APalLevelObjectObtainable) == 0x000008, "Wrong alignment on APalLevelObjectObtainable");
static_assert(sizeof(APalLevelObjectObtainable) == 0x000308, "Wrong size on APalLevelObjectObtainable");
static_assert(offsetof(APalLevelObjectObtainable, OnUpdatePickupStatusInClient) == 0x0002B0, "Member 'APalLevelObjectObtainable::OnUpdatePickupStatusInClient' has a wrong offset!");
static_assert(offsetof(APalLevelObjectObtainable, ObtainFXSoftObj) == 0x0002C0, "Member 'APalLevelObjectObtainable::ObtainFXSoftObj' has a wrong offset!");
static_assert(offsetof(APalLevelObjectObtainable, InteractComp) == 0x0002F0, "Member 'APalLevelObjectObtainable::InteractComp' has a wrong offset!");
static_assert(offsetof(APalLevelObjectObtainable, bPickedInClient) == 0x000300, "Member 'APalLevelObjectObtainable::bPickedInClient' has a wrong offset!");

// Class Pal.PalLevelObjectNote
// 0x0008 (0x0310 - 0x0308)
class APalLevelObjectNote final : public APalLevelObjectObtainable
{
public:
	struct FPalDataTableRowName_NoteData          NoteRowName;                                       // 0x0308(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLevelObjectNote">();
	}
	static class APalLevelObjectNote* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalLevelObjectNote>();
	}
};
static_assert(alignof(APalLevelObjectNote) == 0x000008, "Wrong alignment on APalLevelObjectNote");
static_assert(sizeof(APalLevelObjectNote) == 0x000310, "Wrong size on APalLevelObjectNote");
static_assert(offsetof(APalLevelObjectNote, NoteRowName) == 0x000308, "Member 'APalLevelObjectNote::NoteRowName' has a wrong offset!");

// Class Pal.PalLevelObjectRelic
// 0x0000 (0x0308 - 0x0308)
class APalLevelObjectRelic final : public APalLevelObjectObtainable
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLevelObjectRelic">();
	}
	static class APalLevelObjectRelic* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalLevelObjectRelic>();
	}
};
static_assert(alignof(APalLevelObjectRelic) == 0x000008, "Wrong alignment on APalLevelObjectRelic");
static_assert(sizeof(APalLevelObjectRelic) == 0x000308, "Wrong size on APalLevelObjectRelic");

// Class Pal.PalMasterDataTableAccess_ItemProductData
// 0x0000 (0x0030 - 0x0030)
class UPalMasterDataTableAccess_ItemProductData final : public UPalMasterDataTableAccessBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMasterDataTableAccess_ItemProductData">();
	}
	static class UPalMasterDataTableAccess_ItemProductData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMasterDataTableAccess_ItemProductData>();
	}
};
static_assert(alignof(UPalMasterDataTableAccess_ItemProductData) == 0x000008, "Wrong alignment on UPalMasterDataTableAccess_ItemProductData");
static_assert(sizeof(UPalMasterDataTableAccess_ItemProductData) == 0x000030, "Wrong size on UPalMasterDataTableAccess_ItemProductData");

// Class Pal.PalLevelObjectRespawnPoint
// 0x0008 (0x02B0 - 0x02A8)
class APalLevelObjectRespawnPoint final : public APalLevelObjectActor
{
public:
	class FName                                   RespawnPointID;                                    // 0x02A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLevelObjectRespawnPoint">();
	}
	static class APalLevelObjectRespawnPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalLevelObjectRespawnPoint>();
	}
};
static_assert(alignof(APalLevelObjectRespawnPoint) == 0x000008, "Wrong alignment on APalLevelObjectRespawnPoint");
static_assert(sizeof(APalLevelObjectRespawnPoint) == 0x0002B0, "Wrong size on APalLevelObjectRespawnPoint");
static_assert(offsetof(APalLevelObjectRespawnPoint, RespawnPointID) == 0x0002A8, "Member 'APalLevelObjectRespawnPoint::RespawnPointID' has a wrong offset!");

// Class Pal.PalLevelObjectUnlockableFastTravelPoint
// 0x0038 (0x02E0 - 0x02A8)
class APalLevelObjectUnlockableFastTravelPoint final : public APalLevelObjectActor
{
public:
	uint8                                         Pad_2C79[0x8];                                     // 0x02A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnUpdateUnlockStateDelegate;                       // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TScriptInterface<class IPalInteractiveObjectComponentInterface> InteractComp;                                      // 0x02C0(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUnlocked;                                         // 0x02D0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          EnableRequestUnlock;                               // 0x02D1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C7A[0x2];                                     // 0x02D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FastTravelPointID;                                 // 0x02D4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C7B[0x4];                                     // 0x02DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UAkAudioEvent* GetUnlockAkAudioEvent();
	void OnCompleteSyncPlayer(class APalPlayerState* PlayerState);
	void OnTriggerInteract(class AActor* Other, EPalInteractiveObjectIndicatorType IndicatorType);
	void OnUpdateFlagMapRecord(const class FName Key, const bool bFlag);
	void ReturnSelfDelegate__DelegateSignature(class APalLevelObjectUnlockableFastTravelPoint* Self);

	bool IsUnlocked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLevelObjectUnlockableFastTravelPoint">();
	}
	static class APalLevelObjectUnlockableFastTravelPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalLevelObjectUnlockableFastTravelPoint>();
	}
};
static_assert(alignof(APalLevelObjectUnlockableFastTravelPoint) == 0x000008, "Wrong alignment on APalLevelObjectUnlockableFastTravelPoint");
static_assert(sizeof(APalLevelObjectUnlockableFastTravelPoint) == 0x0002E0, "Wrong size on APalLevelObjectUnlockableFastTravelPoint");
static_assert(offsetof(APalLevelObjectUnlockableFastTravelPoint, OnUpdateUnlockStateDelegate) == 0x0002B0, "Member 'APalLevelObjectUnlockableFastTravelPoint::OnUpdateUnlockStateDelegate' has a wrong offset!");
static_assert(offsetof(APalLevelObjectUnlockableFastTravelPoint, InteractComp) == 0x0002C0, "Member 'APalLevelObjectUnlockableFastTravelPoint::InteractComp' has a wrong offset!");
static_assert(offsetof(APalLevelObjectUnlockableFastTravelPoint, bUnlocked) == 0x0002D0, "Member 'APalLevelObjectUnlockableFastTravelPoint::bUnlocked' has a wrong offset!");
static_assert(offsetof(APalLevelObjectUnlockableFastTravelPoint, EnableRequestUnlock) == 0x0002D1, "Member 'APalLevelObjectUnlockableFastTravelPoint::EnableRequestUnlock' has a wrong offset!");
static_assert(offsetof(APalLevelObjectUnlockableFastTravelPoint, FastTravelPointID) == 0x0002D4, "Member 'APalLevelObjectUnlockableFastTravelPoint::FastTravelPointID' has a wrong offset!");

// Class Pal.PalLightingVolumeController
// 0x00D0 (0x0360 - 0x0290)
class APalLightingVolumeController final : public AActor
{
public:
	class APPSkyCreator*                          PPSkyCreator;                                      // 0x0290(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APalSkyCreatorLightingVolume*           CurrentVolume;                                     // 0x0298(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C7E[0x40];                                    // 0x02A0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APalSkyCreatorLightingVolume*>   Volumes;                                           // 0x02E0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C7F[0x70];                                    // 0x02F0(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLightingVolumeController">();
	}
	static class APalLightingVolumeController* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalLightingVolumeController>();
	}
};
static_assert(alignof(APalLightingVolumeController) == 0x000008, "Wrong alignment on APalLightingVolumeController");
static_assert(sizeof(APalLightingVolumeController) == 0x000360, "Wrong size on APalLightingVolumeController");
static_assert(offsetof(APalLightingVolumeController, PPSkyCreator) == 0x000290, "Member 'APalLightingVolumeController::PPSkyCreator' has a wrong offset!");
static_assert(offsetof(APalLightingVolumeController, CurrentVolume) == 0x000298, "Member 'APalLightingVolumeController::CurrentVolume' has a wrong offset!");
static_assert(offsetof(APalLightingVolumeController, Volumes) == 0x0002E0, "Member 'APalLightingVolumeController::Volumes' has a wrong offset!");

// Class Pal.PalLimitVolumeInterface
// 0x0000 (0x0028 - 0x0028)
class IPalLimitVolumeInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLimitVolumeInterface">();
	}
	static class IPalLimitVolumeInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPalLimitVolumeInterface>();
	}
};
static_assert(alignof(IPalLimitVolumeInterface) == 0x000008, "Wrong alignment on IPalLimitVolumeInterface");
static_assert(sizeof(IPalLimitVolumeInterface) == 0x000028, "Wrong size on IPalLimitVolumeInterface");

// Class Pal.PalMasterDataTableAccess_DungeonEnemySpawnerData
// 0x0000 (0x0030 - 0x0030)
class UPalMasterDataTableAccess_DungeonEnemySpawnerData final : public UPalMasterDataTableAccessBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMasterDataTableAccess_DungeonEnemySpawnerData">();
	}
	static class UPalMasterDataTableAccess_DungeonEnemySpawnerData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMasterDataTableAccess_DungeonEnemySpawnerData>();
	}
};
static_assert(alignof(UPalMasterDataTableAccess_DungeonEnemySpawnerData) == 0x000008, "Wrong alignment on UPalMasterDataTableAccess_DungeonEnemySpawnerData");
static_assert(sizeof(UPalMasterDataTableAccess_DungeonEnemySpawnerData) == 0x000030, "Wrong size on UPalMasterDataTableAccess_DungeonEnemySpawnerData");

// Class Pal.PalLimitVolumeBoxComponent
// 0x0010 (0x0590 - 0x0580)
class UPalLimitVolumeBoxComponent final : public UBoxComponent
{
public:
	uint8                                         Pad_2C80[0x8];                                     // 0x0578(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LimitFlags;                                        // 0x0580(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C81[0xC];                                     // 0x0584(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLimitVolumeBoxComponent">();
	}
	static class UPalLimitVolumeBoxComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalLimitVolumeBoxComponent>();
	}
};
static_assert(alignof(UPalLimitVolumeBoxComponent) == 0x000010, "Wrong alignment on UPalLimitVolumeBoxComponent");
static_assert(sizeof(UPalLimitVolumeBoxComponent) == 0x000590, "Wrong size on UPalLimitVolumeBoxComponent");
static_assert(offsetof(UPalLimitVolumeBoxComponent, LimitFlags) == 0x000580, "Member 'UPalLimitVolumeBoxComponent::LimitFlags' has a wrong offset!");

// Class Pal.PalLimitVolumeSphereComponent
// 0x0010 (0x0570 - 0x0560)
class UPalLimitVolumeSphereComponent final : public USphereComponent
{
public:
	uint8                                         Pad_2C82[0x8];                                     // 0x0560(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LimitFlags;                                        // 0x0568(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C83[0x4];                                     // 0x056C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLimitVolumeSphereComponent">();
	}
	static class UPalLimitVolumeSphereComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalLimitVolumeSphereComponent>();
	}
};
static_assert(alignof(UPalLimitVolumeSphereComponent) == 0x000010, "Wrong alignment on UPalLimitVolumeSphereComponent");
static_assert(sizeof(UPalLimitVolumeSphereComponent) == 0x000570, "Wrong size on UPalLimitVolumeSphereComponent");
static_assert(offsetof(UPalLimitVolumeSphereComponent, LimitFlags) == 0x000568, "Member 'UPalLimitVolumeSphereComponent::LimitFlags' has a wrong offset!");

// Class Pal.PalLoadingScreenWidgetBase
// 0x0000 (0x0408 - 0x0408)
class UPalLoadingScreenWidgetBase : public UPalUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLoadingScreenWidgetBase">();
	}
	static class UPalLoadingScreenWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalLoadingScreenWidgetBase>();
	}
};
static_assert(alignof(UPalLoadingScreenWidgetBase) == 0x000008, "Wrong alignment on UPalLoadingScreenWidgetBase");
static_assert(sizeof(UPalLoadingScreenWidgetBase) == 0x000408, "Wrong size on UPalLoadingScreenWidgetBase");

// Class Pal.PalLoadoutSelectorComponent
// 0x0138 (0x0238 - 0x0100)
class UPalLoadoutSelectorComponent final : public UPalItemSelectorComponent
{
public:
	TSoftClassPtr<class UClass>                   ThrowOtomoPalWeaponClass;                          // 0x0100(0x0030)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class APalWeaponBase>             DummyBallWeaponClass;                              // 0x0130(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnEquipmentItemDelegate;                           // 0x0138(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRemoveItemDelegate;                              // 0x0148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EPalPlayerInventoryType                       PrimaryTargetInventoryType;                        // 0x0158(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C84[0x3];                                     // 0x0159(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentItemSlotIndex;                              // 0x015C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   NowEquipBallItemID;                                // 0x0160(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APalWeaponBase*                         ThrowOtomoPalWeapon;                               // 0x0168(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class APalWeaponBase*>                 SpawnedWeaponsArray;                               // 0x0170(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	TMap<class FName, class APalWeaponBase*>      SpawnedBallMap;                                    // 0x0180(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	class APalWeaponBase*                         DummyBall;                                         // 0x01D0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C85[0x60];                                    // 0x01D8(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AttachSpawnOtomoPalThrowWeapon_ToAll(int32 IssuerID, bool IsAttach, bool ShouldEquipDummyWeapon);
	void AttachSpawnOtomoPalThrowWeapon_ToServer(int32 IssuerID, bool IsAttach, bool ShouldEquipDummyWeapon);
	void ChangeNextBallLoadout();
	void ChangeNextBallLoadout_Internal();
	void ChangeNextWeaponLoadout();
	void ChangeNextWeaponLoadout_Internal();
	void ChangePrevBallLoadout();
	void ChangePrevBallLoadout_Internal();
	void ChangePrevWeaponLoadout();
	void ChangePrevWeaponLoadout_Internal();
	void ChangePrimiryInventoryType(EPalPlayerInventoryType TargetInventory);
	void ChangeWeaponByReplicated();
	void CheckRespawnWeaponActor(const TArray<struct FPalLoadoutSynchronalizedData>& SynchroData, const TArray<class APalWeaponBase*>& WeaponActorList, EPalPlayerInventoryType InventoryType);
	void EquipmentItem__DelegateSignature(EPalPlayerInventoryType InventoryType, int32 Param_Index);
	TMap<class FName, class APalWeaponBase*> GetPalSphereActorMap();
	EPalPlayerInventoryType GetPrimaryInventoryType();
	void OnEquipItem(EPalPlayerInventoryType InventoryType, int32 Param_Index);
	void OnEquipItem_ByTransmitter(EPalPlayerInventoryType InventoryType, int32 Param_Index);
	void OnRemoveEquipItem(EPalPlayerInventoryType InventoryType, int32 Param_Index);
	void OnRemoveEquipItem_ByTransmitter();
	void OnUpdateInventorySlot(class UPalItemSlot* ItemSlot);
	void OnUpdateWeaponLoadoutSlot(class UPalItemSlot* ItemSlot);
	void RemoveItem__DelegateSignature(EPalPlayerInventoryType InventoryType, int32 Param_Index);
	void RequestChangeNowEquipBallItemID_ToServer(class FName NextBallID);
	void SetBallLoadoutIndex(int32 Param_Index);
	void SetBallLoadoutIndex_Internal(int32 Param_Index);
	void SetupItemContainer();
	void SetWeaponLoadoutIndex(int32 Param_Index);
	void SetWeaponLoadoutIndex_Internal(int32 Param_Index);
	bool TryEquipNowSelectedWeapon();
	void TryEquipNowSelectedWeapon_ToAll();

	void GetNowEquipedBallItemID(class FName* OutBallItemID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLoadoutSelectorComponent">();
	}
	static class UPalLoadoutSelectorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalLoadoutSelectorComponent>();
	}
};
static_assert(alignof(UPalLoadoutSelectorComponent) == 0x000008, "Wrong alignment on UPalLoadoutSelectorComponent");
static_assert(sizeof(UPalLoadoutSelectorComponent) == 0x000238, "Wrong size on UPalLoadoutSelectorComponent");
static_assert(offsetof(UPalLoadoutSelectorComponent, ThrowOtomoPalWeaponClass) == 0x000100, "Member 'UPalLoadoutSelectorComponent::ThrowOtomoPalWeaponClass' has a wrong offset!");
static_assert(offsetof(UPalLoadoutSelectorComponent, DummyBallWeaponClass) == 0x000130, "Member 'UPalLoadoutSelectorComponent::DummyBallWeaponClass' has a wrong offset!");
static_assert(offsetof(UPalLoadoutSelectorComponent, OnEquipmentItemDelegate) == 0x000138, "Member 'UPalLoadoutSelectorComponent::OnEquipmentItemDelegate' has a wrong offset!");
static_assert(offsetof(UPalLoadoutSelectorComponent, OnRemoveItemDelegate) == 0x000148, "Member 'UPalLoadoutSelectorComponent::OnRemoveItemDelegate' has a wrong offset!");
static_assert(offsetof(UPalLoadoutSelectorComponent, PrimaryTargetInventoryType) == 0x000158, "Member 'UPalLoadoutSelectorComponent::PrimaryTargetInventoryType' has a wrong offset!");
static_assert(offsetof(UPalLoadoutSelectorComponent, CurrentItemSlotIndex) == 0x00015C, "Member 'UPalLoadoutSelectorComponent::CurrentItemSlotIndex' has a wrong offset!");
static_assert(offsetof(UPalLoadoutSelectorComponent, NowEquipBallItemID) == 0x000160, "Member 'UPalLoadoutSelectorComponent::NowEquipBallItemID' has a wrong offset!");
static_assert(offsetof(UPalLoadoutSelectorComponent, ThrowOtomoPalWeapon) == 0x000168, "Member 'UPalLoadoutSelectorComponent::ThrowOtomoPalWeapon' has a wrong offset!");
static_assert(offsetof(UPalLoadoutSelectorComponent, SpawnedWeaponsArray) == 0x000170, "Member 'UPalLoadoutSelectorComponent::SpawnedWeaponsArray' has a wrong offset!");
static_assert(offsetof(UPalLoadoutSelectorComponent, SpawnedBallMap) == 0x000180, "Member 'UPalLoadoutSelectorComponent::SpawnedBallMap' has a wrong offset!");
static_assert(offsetof(UPalLoadoutSelectorComponent, DummyBall) == 0x0001D0, "Member 'UPalLoadoutSelectorComponent::DummyBall' has a wrong offset!");

// Class Pal.PalMasterDataTableAccess_PlayerStatusRankData
// 0x0008 (0x0038 - 0x0030)
class UPalMasterDataTableAccess_PlayerStatusRankData final : public UPalMasterDataTableAccessBase
{
public:
	uint8                                         Pad_2C8E[0x8];                                     // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetMaxRank();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMasterDataTableAccess_PlayerStatusRankData">();
	}
	static class UPalMasterDataTableAccess_PlayerStatusRankData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMasterDataTableAccess_PlayerStatusRankData>();
	}
};
static_assert(alignof(UPalMasterDataTableAccess_PlayerStatusRankData) == 0x000008, "Wrong alignment on UPalMasterDataTableAccess_PlayerStatusRankData");
static_assert(sizeof(UPalMasterDataTableAccess_PlayerStatusRankData) == 0x000038, "Wrong size on UPalMasterDataTableAccess_PlayerStatusRankData");

// Class Pal.PalLocalPlayer
// 0x0000 (0x02E8 - 0x02E8)
class UPalLocalPlayer final : public UCommonLocalPlayer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLocalPlayer">();
	}
	static class UPalLocalPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalLocalPlayer>();
	}
};
static_assert(alignof(UPalLocalPlayer) == 0x000008, "Wrong alignment on UPalLocalPlayer");
static_assert(sizeof(UPalLocalPlayer) == 0x0002E8, "Wrong size on UPalLocalPlayer");

// Class Pal.PalLocationCreateParameter
// 0x0028 (0x0050 - 0x0028)
class UPalLocationCreateParameter : public UObject
{
public:
	uint8                                         Pad_2C8F[0x28];                                    // 0x0028(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLocationCreateParameter">();
	}
	static class UPalLocationCreateParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalLocationCreateParameter>();
	}
};
static_assert(alignof(UPalLocationCreateParameter) == 0x000008, "Wrong alignment on UPalLocationCreateParameter");
static_assert(sizeof(UPalLocationCreateParameter) == 0x000050, "Wrong size on UPalLocationCreateParameter");

// Class Pal.PalLocationBase
// 0x0028 (0x0050 - 0x0028)
class UPalLocationBase : public UObject
{
public:
	struct FGuid                                  CalledPlayerUId;                                   // 0x0028(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  ID;                                                // 0x0038(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShouldDisplay;                                    // 0x0048(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShowInMap;                                        // 0x0049(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShowInCompass;                                    // 0x004A(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C90[0x5];                                     // 0x004B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsRequestedPlayer(const struct FGuid& LocalPlayerUId);
	class UPalLocationPoint* LocationPoint();

	const struct FGuid GetLocationId() const;
	EPalLocationType GetType() const;
	bool IsShowInCompass() const;
	bool IsShowInMap() const;
	bool ShouldDisplay() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLocationBase">();
	}
	static class UPalLocationBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalLocationBase>();
	}
};
static_assert(alignof(UPalLocationBase) == 0x000008, "Wrong alignment on UPalLocationBase");
static_assert(sizeof(UPalLocationBase) == 0x000050, "Wrong size on UPalLocationBase");
static_assert(offsetof(UPalLocationBase, CalledPlayerUId) == 0x000028, "Member 'UPalLocationBase::CalledPlayerUId' has a wrong offset!");
static_assert(offsetof(UPalLocationBase, ID) == 0x000038, "Member 'UPalLocationBase::ID' has a wrong offset!");
static_assert(offsetof(UPalLocationBase, bShouldDisplay) == 0x000048, "Member 'UPalLocationBase::bShouldDisplay' has a wrong offset!");
static_assert(offsetof(UPalLocationBase, bShowInMap) == 0x000049, "Member 'UPalLocationBase::bShowInMap' has a wrong offset!");
static_assert(offsetof(UPalLocationBase, bShowInCompass) == 0x00004A, "Member 'UPalLocationBase::bShowInCompass' has a wrong offset!");

// Class Pal.PalLocationManager
// 0x00A8 (0x0118 - 0x0070)
class UPalLocationManager : public UPalWorldSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnAddedLocation;                                   // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRemoveLocation;                                  // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAddedLocationForCompass;                         // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRemoveLocationForCompass;                        // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<struct FGuid, class UPalLocationBase*>   LocationMap;                                       // 0x00B0(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class UPalLocationPoint_Custom*>       CustomLocations;                                   // 0x0100(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C92[0x8];                                     // 0x0110(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FGuid AddLocalCustomLocation(const struct FVector& IconLocation, int32 IconType);
	int32 GetLocalCustomLocationCount();
	void LocationDelegate__DelegateSignature(const struct FGuid& LocationId, class UPalLocationBase* Location);
	void RemoveLocalCustomLocation(const struct FGuid& LocationId);

	class UPalLocationBase* GetLocation(const struct FGuid& ID) const;
	TMap<struct FGuid, class UPalLocationBase*> GetLocationMap() const;
	class UPalLocationPoint* GetLocationPoint(const struct FGuid& ID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLocationManager">();
	}
	static class UPalLocationManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalLocationManager>();
	}
};
static_assert(alignof(UPalLocationManager) == 0x000008, "Wrong alignment on UPalLocationManager");
static_assert(sizeof(UPalLocationManager) == 0x000118, "Wrong size on UPalLocationManager");
static_assert(offsetof(UPalLocationManager, OnAddedLocation) == 0x000070, "Member 'UPalLocationManager::OnAddedLocation' has a wrong offset!");
static_assert(offsetof(UPalLocationManager, OnRemoveLocation) == 0x000080, "Member 'UPalLocationManager::OnRemoveLocation' has a wrong offset!");
static_assert(offsetof(UPalLocationManager, OnAddedLocationForCompass) == 0x000090, "Member 'UPalLocationManager::OnAddedLocationForCompass' has a wrong offset!");
static_assert(offsetof(UPalLocationManager, OnRemoveLocationForCompass) == 0x0000A0, "Member 'UPalLocationManager::OnRemoveLocationForCompass' has a wrong offset!");
static_assert(offsetof(UPalLocationManager, LocationMap) == 0x0000B0, "Member 'UPalLocationManager::LocationMap' has a wrong offset!");
static_assert(offsetof(UPalLocationManager, CustomLocations) == 0x000100, "Member 'UPalLocationManager::CustomLocations' has a wrong offset!");

// Class Pal.PalWorldSecurityUtility
// 0x0000 (0x0028 - 0x0028)
class UPalWorldSecurityUtility final : public UBlueprintFunctionLibrary
{
public:
	static bool FindCriminalsInSight(class APalCharacter* Target, TArray<class APalCharacter*>* Criminals);
	static bool IsCriminalCharacter(class APalCharacter* Target);
	static bool IsWantedCharacter(class APalCharacter* Target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorldSecurityUtility">();
	}
	static class UPalWorldSecurityUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWorldSecurityUtility>();
	}
};
static_assert(alignof(UPalWorldSecurityUtility) == 0x000008, "Wrong alignment on UPalWorldSecurityUtility");
static_assert(sizeof(UPalWorldSecurityUtility) == 0x000028, "Wrong size on UPalWorldSecurityUtility");

// Class Pal.PalLocationPoint
// 0x0000 (0x0050 - 0x0050)
class UPalLocationPoint : public UPalLocationBase
{
public:
	void InvokeFastTravel();

	struct FVector GetLocation() const;
	void GetLocationAndRotationZ(struct FVector* OutLocation, float* OutRotationZ) const;
	struct FQuat GetRotation() const;
	float GetRotationZ() const;
	bool IsEnableFastTravel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLocationPoint">();
	}
	static class UPalLocationPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalLocationPoint>();
	}
};
static_assert(alignof(UPalLocationPoint) == 0x000008, "Wrong alignment on UPalLocationPoint");
static_assert(sizeof(UPalLocationPoint) == 0x000050, "Wrong size on UPalLocationPoint");

// Class Pal.PalLocationPointStaticCreateParameter
// 0x0020 (0x0070 - 0x0050)
class UPalLocationPointStaticCreateParameter : public UPalLocationCreateParameter
{
public:
	uint8                                         Pad_2C98[0x20];                                    // 0x0050(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLocationPointStaticCreateParameter">();
	}
	static class UPalLocationPointStaticCreateParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalLocationPointStaticCreateParameter>();
	}
};
static_assert(alignof(UPalLocationPointStaticCreateParameter) == 0x000008, "Wrong alignment on UPalLocationPointStaticCreateParameter");
static_assert(sizeof(UPalLocationPointStaticCreateParameter) == 0x000070, "Wrong size on UPalLocationPointStaticCreateParameter");

// Class Pal.PalLocationPointStatic
// 0x0020 (0x0070 - 0x0050)
class UPalLocationPointStatic : public UPalLocationPoint
{
public:
	struct FVector                                Location;                                          // 0x0050(0x0018)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RotationZ;                                         // 0x0068(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C99[0x4];                                     // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLocationPointStatic">();
	}
	static class UPalLocationPointStatic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalLocationPointStatic>();
	}
};
static_assert(alignof(UPalLocationPointStatic) == 0x000008, "Wrong alignment on UPalLocationPointStatic");
static_assert(sizeof(UPalLocationPointStatic) == 0x000070, "Wrong size on UPalLocationPointStatic");
static_assert(offsetof(UPalLocationPointStatic, Location) == 0x000050, "Member 'UPalLocationPointStatic::Location' has a wrong offset!");
static_assert(offsetof(UPalLocationPointStatic, RotationZ) == 0x000068, "Member 'UPalLocationPointStatic::RotationZ' has a wrong offset!");

// Class Pal.PalLocationPointCreateParameter_BaseCamp
// 0x0010 (0x0080 - 0x0070)
class UPalLocationPointCreateParameter_BaseCamp final : public UPalLocationPointStaticCreateParameter
{
public:
	uint8                                         Pad_2C9A[0x10];                                    // 0x0070(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLocationPointCreateParameter_BaseCamp">();
	}
	static class UPalLocationPointCreateParameter_BaseCamp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalLocationPointCreateParameter_BaseCamp>();
	}
};
static_assert(alignof(UPalLocationPointCreateParameter_BaseCamp) == 0x000008, "Wrong alignment on UPalLocationPointCreateParameter_BaseCamp");
static_assert(sizeof(UPalLocationPointCreateParameter_BaseCamp) == 0x000080, "Wrong size on UPalLocationPointCreateParameter_BaseCamp");

// Class Pal.PalMapObjectProductItemModel
// 0x0028 (0x0240 - 0x0218)
class UPalMapObjectProductItemModel final : public UPalMapObjectConcreteModelBase
{
public:
	uint8                                         Pad_2C9B[0x8];                                     // 0x0218(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnFinishProductOneLoopDelegate;                    // 0x0220(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsWorkable;                                       // 0x0230(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C9C[0x3];                                     // 0x0231(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ProductItemId;                                     // 0x0234(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WorkSpeedAdditionalRate;                           // 0x023C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnFinishWorkInServer(class UPalWorkBase* Work);
	void OnUpdateContainerContent(class UPalItemContainer* Container);
	void PickupItem_ServerInternal(const int32 PlayerId);
	void ReceivePickupItemResult_Client(const struct FPalNetArchive& Archive);
	void SimpleDelegate__DelegateSignature(class UPalMapObjectProductItemModel* Model);

	float CalcRequiredAmount(const float BaseRequiredAmount) const;
	class UPalItemContainer* GetItemContainer() const;
	class FName GetProductItemId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectProductItemModel">();
	}
	static class UPalMapObjectProductItemModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectProductItemModel>();
	}
};
static_assert(alignof(UPalMapObjectProductItemModel) == 0x000008, "Wrong alignment on UPalMapObjectProductItemModel");
static_assert(sizeof(UPalMapObjectProductItemModel) == 0x000240, "Wrong size on UPalMapObjectProductItemModel");
static_assert(offsetof(UPalMapObjectProductItemModel, OnFinishProductOneLoopDelegate) == 0x000220, "Member 'UPalMapObjectProductItemModel::OnFinishProductOneLoopDelegate' has a wrong offset!");
static_assert(offsetof(UPalMapObjectProductItemModel, bIsWorkable) == 0x000230, "Member 'UPalMapObjectProductItemModel::bIsWorkable' has a wrong offset!");
static_assert(offsetof(UPalMapObjectProductItemModel, ProductItemId) == 0x000234, "Member 'UPalMapObjectProductItemModel::ProductItemId' has a wrong offset!");
static_assert(offsetof(UPalMapObjectProductItemModel, WorkSpeedAdditionalRate) == 0x00023C, "Member 'UPalMapObjectProductItemModel::WorkSpeedAdditionalRate' has a wrong offset!");

// Class Pal.PalLocationPointBaseCamp
// 0x0018 (0x0088 - 0x0070)
class UPalLocationPointBaseCamp final : public UPalLocationPointStatic
{
public:
	struct FGuid                                  BaseCampId;                                        // 0x0070(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsAvailable;                                      // 0x0080(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C9D[0x7];                                     // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDisposeTarget(class UPalBaseCampModel* Model);
	void SetAvailable();

	const struct FGuid GetBaseCampId() const;
	bool IsSameGuildWithPlayer(const struct FGuid& PlayerUId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLocationPointBaseCamp">();
	}
	static class UPalLocationPointBaseCamp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalLocationPointBaseCamp>();
	}
};
static_assert(alignof(UPalLocationPointBaseCamp) == 0x000008, "Wrong alignment on UPalLocationPointBaseCamp");
static_assert(sizeof(UPalLocationPointBaseCamp) == 0x000088, "Wrong size on UPalLocationPointBaseCamp");
static_assert(offsetof(UPalLocationPointBaseCamp, BaseCampId) == 0x000070, "Member 'UPalLocationPointBaseCamp::BaseCampId' has a wrong offset!");
static_assert(offsetof(UPalLocationPointBaseCamp, bIsAvailable) == 0x000080, "Member 'UPalLocationPointBaseCamp::bIsAvailable' has a wrong offset!");

// Class Pal.PalLocationPointCreateParameter_BossTower
// 0x0008 (0x0078 - 0x0070)
class UPalLocationPointCreateParameter_BossTower final : public UPalLocationPointStaticCreateParameter
{
public:
	uint8                                         Pad_2C9F[0x8];                                     // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLocationPointCreateParameter_BossTower">();
	}
	static class UPalLocationPointCreateParameter_BossTower* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalLocationPointCreateParameter_BossTower>();
	}
};
static_assert(alignof(UPalLocationPointCreateParameter_BossTower) == 0x000008, "Wrong alignment on UPalLocationPointCreateParameter_BossTower");
static_assert(sizeof(UPalLocationPointCreateParameter_BossTower) == 0x000078, "Wrong size on UPalLocationPointCreateParameter_BossTower");

// Class Pal.PalLawUtility
// 0x0000 (0x0028 - 0x0028)
class UPalLawUtility final : public UBlueprintFunctionLibrary
{
public:
	static bool ExistOtherGroupFromSlotIds(const class UObject* WorldContextObject, const struct FPalInstanceID& IndividualId, const TArray<struct FPalItemSlotId>& SlotIds, const bool IgnoreNoBelongSlot, struct FGuid* OutGroupId);
	static bool IsEqualsGroupIndividualIdAndSlotIds(const class UObject* WorldContextObject, const struct FPalInstanceID& IndividualId, const TArray<struct FPalItemSlotId>& SlotIds, const bool IgnoreNoBelongSlot);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLawUtility">();
	}
	static class UPalLawUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalLawUtility>();
	}
};
static_assert(alignof(UPalLawUtility) == 0x000008, "Wrong alignment on UPalLawUtility");
static_assert(sizeof(UPalLawUtility) == 0x000028, "Wrong size on UPalLawUtility");

// Class Pal.PalLocationPoint_BossTower
// 0x0008 (0x0078 - 0x0070)
class UPalLocationPoint_BossTower final : public UPalLocationPointStatic
{
public:
	class APalBossTower*                          BossTower;                                         // 0x0070(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class APalBossTower* GetBossTower() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLocationPoint_BossTower">();
	}
	static class UPalLocationPoint_BossTower* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalLocationPoint_BossTower>();
	}
};
static_assert(alignof(UPalLocationPoint_BossTower) == 0x000008, "Wrong alignment on UPalLocationPoint_BossTower");
static_assert(sizeof(UPalLocationPoint_BossTower) == 0x000078, "Wrong size on UPalLocationPoint_BossTower");
static_assert(offsetof(UPalLocationPoint_BossTower, BossTower) == 0x000070, "Member 'UPalLocationPoint_BossTower::BossTower' has a wrong offset!");

// Class Pal.PalLocationPointCreateParameter_Character
// 0x0048 (0x0098 - 0x0050)
class UPalLocationPointCreateParameter_Character final : public UPalLocationCreateParameter
{
public:
	uint8                                         Pad_2CA3[0x48];                                    // 0x0050(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLocationPointCreateParameter_Character">();
	}
	static class UPalLocationPointCreateParameter_Character* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalLocationPointCreateParameter_Character>();
	}
};
static_assert(alignof(UPalLocationPointCreateParameter_Character) == 0x000008, "Wrong alignment on UPalLocationPointCreateParameter_Character");
static_assert(sizeof(UPalLocationPointCreateParameter_Character) == 0x000098, "Wrong size on UPalLocationPointCreateParameter_Character");

// Class Pal.PalMapObjectRecoverOtomoModel
// 0x0018 (0x0230 - 0x0218)
class UPalMapObjectRecoverOtomoModel final : public UPalMapObjectConcreteModelBase
{
public:
	uint8                                         Pad_2CA4[0x8];                                     // 0x0218(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RecoverAmountBySec;                                // 0x0220(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CA5[0x4];                                     // 0x0224(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UPalUserWidgetOverlayUI>    MenuUIWidgetClass;                                 // 0x0228(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ObtainAll_ServerInternal(const int32 RequestPlayerId);
	void OnUpdateCharacterContainer(class UPalIndividualCharacterContainer* Container);
	void RequestRecoverAllOtomo_ServerInternal(const int32 RequestPlayerId);
	void StoreAllOtomo_ServerInternal(const int32 RequestPlayerId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectRecoverOtomoModel">();
	}
	static class UPalMapObjectRecoverOtomoModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectRecoverOtomoModel>();
	}
};
static_assert(alignof(UPalMapObjectRecoverOtomoModel) == 0x000008, "Wrong alignment on UPalMapObjectRecoverOtomoModel");
static_assert(sizeof(UPalMapObjectRecoverOtomoModel) == 0x000230, "Wrong size on UPalMapObjectRecoverOtomoModel");
static_assert(offsetof(UPalMapObjectRecoverOtomoModel, RecoverAmountBySec) == 0x000220, "Member 'UPalMapObjectRecoverOtomoModel::RecoverAmountBySec' has a wrong offset!");
static_assert(offsetof(UPalMapObjectRecoverOtomoModel, MenuUIWidgetClass) == 0x000228, "Member 'UPalMapObjectRecoverOtomoModel::MenuUIWidgetClass' has a wrong offset!");

// Class Pal.PalLocationPoint_Character
// 0x0050 (0x00A0 - 0x0050)
class UPalLocationPoint_Character final : public UPalLocationPoint
{
public:
	struct FPalInstanceID                         IndividualId;                                      // 0x0050(0x0030)(Edit, Net, DisableEditOnTemplate, Transient, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPalCharacterLocationType                     CharacterLocationType;                             // 0x0080(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CA6[0x3];                                     // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  TargetBaseCampID;                                  // 0x0084(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   CharacterID;                                       // 0x0094(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CA7[0x4];                                     // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDeadTarget(const struct FPalDeadInfo& Info);
	void OnDestroyedTarget(class AActor* Target);

	class FName GetCharacterID() const;
	EPalCharacterLocationType GetCharacterLocationType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLocationPoint_Character">();
	}
	static class UPalLocationPoint_Character* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalLocationPoint_Character>();
	}
};
static_assert(alignof(UPalLocationPoint_Character) == 0x000008, "Wrong alignment on UPalLocationPoint_Character");
static_assert(sizeof(UPalLocationPoint_Character) == 0x0000A0, "Wrong size on UPalLocationPoint_Character");
static_assert(offsetof(UPalLocationPoint_Character, IndividualId) == 0x000050, "Member 'UPalLocationPoint_Character::IndividualId' has a wrong offset!");
static_assert(offsetof(UPalLocationPoint_Character, CharacterLocationType) == 0x000080, "Member 'UPalLocationPoint_Character::CharacterLocationType' has a wrong offset!");
static_assert(offsetof(UPalLocationPoint_Character, TargetBaseCampID) == 0x000084, "Member 'UPalLocationPoint_Character::TargetBaseCampID' has a wrong offset!");
static_assert(offsetof(UPalLocationPoint_Character, CharacterID) == 0x000094, "Member 'UPalLocationPoint_Character::CharacterID' has a wrong offset!");

// Class Pal.PalLocationPointCreateParameter_CustomMarker
// 0x0018 (0x0088 - 0x0070)
class UPalLocationPointCreateParameter_CustomMarker final : public UPalLocationPointStaticCreateParameter
{
public:
	uint8                                         Pad_2CA8[0x18];                                    // 0x0070(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLocationPointCreateParameter_CustomMarker">();
	}
	static class UPalLocationPointCreateParameter_CustomMarker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalLocationPointCreateParameter_CustomMarker>();
	}
};
static_assert(alignof(UPalLocationPointCreateParameter_CustomMarker) == 0x000008, "Wrong alignment on UPalLocationPointCreateParameter_CustomMarker");
static_assert(sizeof(UPalLocationPointCreateParameter_CustomMarker) == 0x000088, "Wrong size on UPalLocationPointCreateParameter_CustomMarker");

// Class Pal.PalLocationPoint_Custom
// 0x0028 (0x0098 - 0x0070)
class UPalLocationPoint_Custom final : public UPalLocationPointStatic
{
public:
	FMulticastInlineDelegateProperty_             OnIconTypeChanged;                                 // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CA9[0x18];                                    // 0x0080(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnIconTypeChangedDelegate__DelegateSignature(int32 NewType);
	void SetIconType(int32 Param_Index);

	int32 GetIconType() const;
	struct FGuid GetOwnerPlayerId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLocationPoint_Custom">();
	}
	static class UPalLocationPoint_Custom* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalLocationPoint_Custom>();
	}
};
static_assert(alignof(UPalLocationPoint_Custom) == 0x000008, "Wrong alignment on UPalLocationPoint_Custom");
static_assert(sizeof(UPalLocationPoint_Custom) == 0x000098, "Wrong size on UPalLocationPoint_Custom");
static_assert(offsetof(UPalLocationPoint_Custom, OnIconTypeChanged) == 0x000070, "Member 'UPalLocationPoint_Custom::OnIconTypeChanged' has a wrong offset!");

// Class Pal.PalLocationPointCreateParameter_DroppedCharacter
// 0x0020 (0x0090 - 0x0070)
class UPalLocationPointCreateParameter_DroppedCharacter final : public UPalLocationPointStaticCreateParameter
{
public:
	uint8                                         Pad_2CAA[0x20];                                    // 0x0070(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLocationPointCreateParameter_DroppedCharacter">();
	}
	static class UPalLocationPointCreateParameter_DroppedCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalLocationPointCreateParameter_DroppedCharacter>();
	}
};
static_assert(alignof(UPalLocationPointCreateParameter_DroppedCharacter) == 0x000008, "Wrong alignment on UPalLocationPointCreateParameter_DroppedCharacter");
static_assert(sizeof(UPalLocationPointCreateParameter_DroppedCharacter) == 0x000090, "Wrong size on UPalLocationPointCreateParameter_DroppedCharacter");

// Class Pal.PalMapObjectRespawnPointModel
// 0x0010 (0x0228 - 0x0218)
class UPalMapObjectRespawnPointModel final : public UPalMapObjectConcreteModelBase
{
public:
	struct FGuid                                  LocationId;                                        // 0x0218(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectRespawnPointModel">();
	}
	static class UPalMapObjectRespawnPointModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectRespawnPointModel>();
	}
};
static_assert(alignof(UPalMapObjectRespawnPointModel) == 0x000008, "Wrong alignment on UPalMapObjectRespawnPointModel");
static_assert(sizeof(UPalMapObjectRespawnPointModel) == 0x000228, "Wrong size on UPalMapObjectRespawnPointModel");
static_assert(offsetof(UPalMapObjectRespawnPointModel, LocationId) == 0x000218, "Member 'UPalMapObjectRespawnPointModel::LocationId' has a wrong offset!");

// Class Pal.PalLocationPoint_DroppedCharacter
// 0x0020 (0x0090 - 0x0070)
class UPalLocationPoint_DroppedCharacter final : public UPalLocationPointStatic
{
public:
	struct FGuid                                  MapObjectConcreteModelId;                          // 0x0070(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  OwnerPlayerUId;                                    // 0x0080(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UPalMapObjectPickableCharacterModelBase* GetMapObjectConcreteModel() const;
	struct FGuid GetOwnerPlayerUId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLocationPoint_DroppedCharacter">();
	}
	static class UPalLocationPoint_DroppedCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalLocationPoint_DroppedCharacter>();
	}
};
static_assert(alignof(UPalLocationPoint_DroppedCharacter) == 0x000008, "Wrong alignment on UPalLocationPoint_DroppedCharacter");
static_assert(sizeof(UPalLocationPoint_DroppedCharacter) == 0x000090, "Wrong size on UPalLocationPoint_DroppedCharacter");
static_assert(offsetof(UPalLocationPoint_DroppedCharacter, MapObjectConcreteModelId) == 0x000070, "Member 'UPalLocationPoint_DroppedCharacter::MapObjectConcreteModelId' has a wrong offset!");
static_assert(offsetof(UPalLocationPoint_DroppedCharacter, OwnerPlayerUId) == 0x000080, "Member 'UPalLocationPoint_DroppedCharacter::OwnerPlayerUId' has a wrong offset!");

// Class Pal.PalLocationPointCreateParameter_DroppedChest
// 0x0010 (0x0080 - 0x0070)
class UPalLocationPointCreateParameter_DroppedChest final : public UPalLocationPointStaticCreateParameter
{
public:
	uint8                                         Pad_2CAB[0x10];                                    // 0x0070(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLocationPointCreateParameter_DroppedChest">();
	}
	static class UPalLocationPointCreateParameter_DroppedChest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalLocationPointCreateParameter_DroppedChest>();
	}
};
static_assert(alignof(UPalLocationPointCreateParameter_DroppedChest) == 0x000008, "Wrong alignment on UPalLocationPointCreateParameter_DroppedChest");
static_assert(sizeof(UPalLocationPointCreateParameter_DroppedChest) == 0x000080, "Wrong size on UPalLocationPointCreateParameter_DroppedChest");

// Class Pal.SequentialProcessHandle
// 0x0048 (0x0070 - 0x0028)
class USequentialProcessHandle final : public UObject
{
public:
	uint8                                         Pad_2CAC[0x30];                                    // 0x0028(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USequentialProcessHandle*>       ChildProcessHandles;                               // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CAD[0x8];                                     // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SequentialProcessHandle">();
	}
	static class USequentialProcessHandle* GetDefaultObj()
	{
		return GetDefaultObjImpl<USequentialProcessHandle>();
	}
};
static_assert(alignof(USequentialProcessHandle) == 0x000008, "Wrong alignment on USequentialProcessHandle");
static_assert(sizeof(USequentialProcessHandle) == 0x000070, "Wrong size on USequentialProcessHandle");
static_assert(offsetof(USequentialProcessHandle, ChildProcessHandles) == 0x000058, "Member 'USequentialProcessHandle::ChildProcessHandles' has a wrong offset!");

// Class Pal.PalLocationPoint_DroppedChest
// 0x0010 (0x0080 - 0x0070)
class UPalLocationPoint_DroppedChest final : public UPalLocationPointStatic
{
public:
	struct FGuid                                  OwnerPlayerUId;                                    // 0x0070(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	struct FGuid GetOwnerPlayerUId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLocationPoint_DroppedChest">();
	}
	static class UPalLocationPoint_DroppedChest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalLocationPoint_DroppedChest>();
	}
};
static_assert(alignof(UPalLocationPoint_DroppedChest) == 0x000008, "Wrong alignment on UPalLocationPoint_DroppedChest");
static_assert(sizeof(UPalLocationPoint_DroppedChest) == 0x000080, "Wrong size on UPalLocationPoint_DroppedChest");
static_assert(offsetof(UPalLocationPoint_DroppedChest, OwnerPlayerUId) == 0x000070, "Member 'UPalLocationPoint_DroppedChest::OwnerPlayerUId' has a wrong offset!");

// Class Pal.PalLocationPointCreateParameter_DungeonPortal
// 0x0000 (0x0070 - 0x0070)
class UPalLocationPointCreateParameter_DungeonPortal final : public UPalLocationPointStaticCreateParameter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLocationPointCreateParameter_DungeonPortal">();
	}
	static class UPalLocationPointCreateParameter_DungeonPortal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalLocationPointCreateParameter_DungeonPortal>();
	}
};
static_assert(alignof(UPalLocationPointCreateParameter_DungeonPortal) == 0x000008, "Wrong alignment on UPalLocationPointCreateParameter_DungeonPortal");
static_assert(sizeof(UPalLocationPointCreateParameter_DungeonPortal) == 0x000070, "Wrong size on UPalLocationPointCreateParameter_DungeonPortal");

// Class Pal.PalMapObjectItemStorageModel
// 0x0008 (0x0220 - 0x0218)
class UPalMapObjectItemStorageModel : public UPalMapObjectConcreteModelBase
{
public:
	bool                                          bAutoDestroyIfEmpty;                               // 0x0218(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CAE[0x7];                                     // 0x0219(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnUpdateContainerContentInServer(class UPalItemContainer* Container);
	void RequestSortContainer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectItemStorageModel">();
	}
	static class UPalMapObjectItemStorageModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectItemStorageModel>();
	}
};
static_assert(alignof(UPalMapObjectItemStorageModel) == 0x000008, "Wrong alignment on UPalMapObjectItemStorageModel");
static_assert(sizeof(UPalMapObjectItemStorageModel) == 0x000220, "Wrong size on UPalMapObjectItemStorageModel");
static_assert(offsetof(UPalMapObjectItemStorageModel, bAutoDestroyIfEmpty) == 0x000218, "Member 'UPalMapObjectItemStorageModel::bAutoDestroyIfEmpty' has a wrong offset!");

// Class Pal.PalMapObjectItemChestModel
// 0x0008 (0x0228 - 0x0220)
class UPalMapObjectItemChestModel : public UPalMapObjectItemStorageModel
{
public:
	uint8                                         Pad_2CAF[0x8];                                     // 0x0220(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnUpdateLocalPlayerPasswordLockInfo(const struct FPalMapObjectPasswordLockPlayerInfo& OldLocalPlayerInfo, const struct FPalMapObjectPasswordLockPlayerInfo& NewLocalPlayerInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectItemChestModel">();
	}
	static class UPalMapObjectItemChestModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectItemChestModel>();
	}
};
static_assert(alignof(UPalMapObjectItemChestModel) == 0x000008, "Wrong alignment on UPalMapObjectItemChestModel");
static_assert(sizeof(UPalMapObjectItemChestModel) == 0x000228, "Wrong size on UPalMapObjectItemChestModel");

// Class Pal.PalWordFilterSubsystem
// 0x0000 (0x0030 - 0x0030)
class UPalWordFilterSubsystem final : public UGameInstanceSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWordFilterSubsystem">();
	}
	static class UPalWordFilterSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWordFilterSubsystem>();
	}
};
static_assert(alignof(UPalWordFilterSubsystem) == 0x000008, "Wrong alignment on UPalWordFilterSubsystem");
static_assert(sizeof(UPalWordFilterSubsystem) == 0x000030, "Wrong size on UPalWordFilterSubsystem");

// Class Pal.PalLocationPointDungeonPortal
// 0x0000 (0x0070 - 0x0070)
class UPalLocationPointDungeonPortal final : public UPalLocationPointStatic
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLocationPointDungeonPortal">();
	}
	static class UPalLocationPointDungeonPortal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalLocationPointDungeonPortal>();
	}
};
static_assert(alignof(UPalLocationPointDungeonPortal) == 0x000008, "Wrong alignment on UPalLocationPointDungeonPortal");
static_assert(sizeof(UPalLocationPointDungeonPortal) == 0x000070, "Wrong size on UPalLocationPointDungeonPortal");

// Class Pal.PalLocationPointCreateParameter_FastTravel
// 0x0020 (0x0090 - 0x0070)
class UPalLocationPointCreateParameter_FastTravel final : public UPalLocationPointStaticCreateParameter
{
public:
	uint8                                         Pad_2CB0[0x20];                                    // 0x0070(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLocationPointCreateParameter_FastTravel">();
	}
	static class UPalLocationPointCreateParameter_FastTravel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalLocationPointCreateParameter_FastTravel>();
	}
};
static_assert(alignof(UPalLocationPointCreateParameter_FastTravel) == 0x000008, "Wrong alignment on UPalLocationPointCreateParameter_FastTravel");
static_assert(sizeof(UPalLocationPointCreateParameter_FastTravel) == 0x000090, "Wrong size on UPalLocationPointCreateParameter_FastTravel");

// Class Pal.PalLocationPointFastTravel
// 0x0020 (0x0090 - 0x0070)
class UPalLocationPointFastTravel final : public UPalLocationPointStatic
{
public:
	struct FGuid                                  LocationId;                                        // 0x0070(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ShouldUnlockFlag;                                  // 0x0080(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CB1[0x3];                                     // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FastTravelPointID;                                 // 0x0084(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CB2[0x4];                                     // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLocationPointFastTravel">();
	}
	static class UPalLocationPointFastTravel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalLocationPointFastTravel>();
	}
};
static_assert(alignof(UPalLocationPointFastTravel) == 0x000008, "Wrong alignment on UPalLocationPointFastTravel");
static_assert(sizeof(UPalLocationPointFastTravel) == 0x000090, "Wrong size on UPalLocationPointFastTravel");
static_assert(offsetof(UPalLocationPointFastTravel, LocationId) == 0x000070, "Member 'UPalLocationPointFastTravel::LocationId' has a wrong offset!");
static_assert(offsetof(UPalLocationPointFastTravel, ShouldUnlockFlag) == 0x000080, "Member 'UPalLocationPointFastTravel::ShouldUnlockFlag' has a wrong offset!");
static_assert(offsetof(UPalLocationPointFastTravel, FastTravelPointID) == 0x000084, "Member 'UPalLocationPointFastTravel::FastTravelPointID' has a wrong offset!");

// Class Pal.PalLocationPointCreateParameter_MapObject
// 0x0010 (0x0060 - 0x0050)
class UPalLocationPointCreateParameter_MapObject final : public UPalLocationCreateParameter
{
public:
	uint8                                         Pad_2CB3[0x10];                                    // 0x0050(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLocationPointCreateParameter_MapObject">();
	}
	static class UPalLocationPointCreateParameter_MapObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalLocationPointCreateParameter_MapObject>();
	}
};
static_assert(alignof(UPalLocationPointCreateParameter_MapObject) == 0x000008, "Wrong alignment on UPalLocationPointCreateParameter_MapObject");
static_assert(sizeof(UPalLocationPointCreateParameter_MapObject) == 0x000060, "Wrong size on UPalLocationPointCreateParameter_MapObject");

// Class Pal.PalMapObjectItemConverterParameterComponent
// 0x0030 (0x00D0 - 0x00A0)
class UPalMapObjectItemConverterParameterComponent final : public UActorComponent
{
public:
	TArray<EPalItemTypeA>                         TargetTypesA;                                      // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EPalItemTypeB>                         TargetTypesB;                                      // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         TargetRankMax;                                     // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoWorkAmountBySec;                               // 0x00C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorkSpeedAdditionalRate;                           // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CB4[0x4];                                     // 0x00CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectItemConverterParameterComponent">();
	}
	static class UPalMapObjectItemConverterParameterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectItemConverterParameterComponent>();
	}
};
static_assert(alignof(UPalMapObjectItemConverterParameterComponent) == 0x000008, "Wrong alignment on UPalMapObjectItemConverterParameterComponent");
static_assert(sizeof(UPalMapObjectItemConverterParameterComponent) == 0x0000D0, "Wrong size on UPalMapObjectItemConverterParameterComponent");
static_assert(offsetof(UPalMapObjectItemConverterParameterComponent, TargetTypesA) == 0x0000A0, "Member 'UPalMapObjectItemConverterParameterComponent::TargetTypesA' has a wrong offset!");
static_assert(offsetof(UPalMapObjectItemConverterParameterComponent, TargetTypesB) == 0x0000B0, "Member 'UPalMapObjectItemConverterParameterComponent::TargetTypesB' has a wrong offset!");
static_assert(offsetof(UPalMapObjectItemConverterParameterComponent, TargetRankMax) == 0x0000C0, "Member 'UPalMapObjectItemConverterParameterComponent::TargetRankMax' has a wrong offset!");
static_assert(offsetof(UPalMapObjectItemConverterParameterComponent, AutoWorkAmountBySec) == 0x0000C4, "Member 'UPalMapObjectItemConverterParameterComponent::AutoWorkAmountBySec' has a wrong offset!");
static_assert(offsetof(UPalMapObjectItemConverterParameterComponent, WorkSpeedAdditionalRate) == 0x0000C8, "Member 'UPalMapObjectItemConverterParameterComponent::WorkSpeedAdditionalRate' has a wrong offset!");

// Class Pal.PalLocationPoint_MapObject
// 0x0028 (0x0078 - 0x0050)
class UPalLocationPoint_MapObject final : public UPalLocationPoint
{
public:
	struct FGuid                                  MapObjectModelId;                                  // 0x0050(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                InitialLocationCache;                              // 0x0060(0x0018)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnDisposeTarget(class UPalMapObjectModel* Model, const struct FPalMapObjectDisposeOptions& Options);

	bool GetMapObjectName(class FName* MapObjectName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLocationPoint_MapObject">();
	}
	static class UPalLocationPoint_MapObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalLocationPoint_MapObject>();
	}
};
static_assert(alignof(UPalLocationPoint_MapObject) == 0x000008, "Wrong alignment on UPalLocationPoint_MapObject");
static_assert(sizeof(UPalLocationPoint_MapObject) == 0x000078, "Wrong size on UPalLocationPoint_MapObject");
static_assert(offsetof(UPalLocationPoint_MapObject, MapObjectModelId) == 0x000050, "Member 'UPalLocationPoint_MapObject::MapObjectModelId' has a wrong offset!");
static_assert(offsetof(UPalLocationPoint_MapObject, InitialLocationCache) == 0x000060, "Member 'UPalLocationPoint_MapObject::InitialLocationCache' has a wrong offset!");

// Class Pal.PalLocationPointCreateParameter_Respawn
// 0x0008 (0x0078 - 0x0070)
class UPalLocationPointCreateParameter_Respawn final : public UPalLocationPointStaticCreateParameter
{
public:
	uint8                                         Pad_2CB6[0x8];                                     // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLocationPointCreateParameter_Respawn">();
	}
	static class UPalLocationPointCreateParameter_Respawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalLocationPointCreateParameter_Respawn>();
	}
};
static_assert(alignof(UPalLocationPointCreateParameter_Respawn) == 0x000008, "Wrong alignment on UPalLocationPointCreateParameter_Respawn");
static_assert(sizeof(UPalLocationPointCreateParameter_Respawn) == 0x000078, "Wrong size on UPalLocationPointCreateParameter_Respawn");

// Class Pal.PalWildSpawnerDataTable
// 0x0000 (0x0028 - 0x0028)
class UPalWildSpawnerDataTable final : public UObject
{
public:
	TArray<struct FPalSpawnerGroupInfo> CreateGroupList(const TArray<struct FPalWildSpawnerDatabaseRow>& DataList);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWildSpawnerDataTable">();
	}
	static class UPalWildSpawnerDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWildSpawnerDataTable>();
	}
};
static_assert(alignof(UPalWildSpawnerDataTable) == 0x000008, "Wrong alignment on UPalWildSpawnerDataTable");
static_assert(sizeof(UPalWildSpawnerDataTable) == 0x000028, "Wrong size on UPalWildSpawnerDataTable");

// Class Pal.PalLocationPoint_Respawn
// 0x0008 (0x0078 - 0x0070)
class UPalLocationPoint_Respawn final : public UPalLocationPointStatic
{
public:
	class FName                                   RespawnPointID;                                    // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLocationPoint_Respawn">();
	}
	static class UPalLocationPoint_Respawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalLocationPoint_Respawn>();
	}
};
static_assert(alignof(UPalLocationPoint_Respawn) == 0x000008, "Wrong alignment on UPalLocationPoint_Respawn");
static_assert(sizeof(UPalLocationPoint_Respawn) == 0x000078, "Wrong size on UPalLocationPoint_Respawn");
static_assert(offsetof(UPalLocationPoint_Respawn, RespawnPointID) == 0x000070, "Member 'UPalLocationPoint_Respawn::RespawnPointID' has a wrong offset!");

// Class Pal.PalLocationReplicator
// 0x0198 (0x01C0 - 0x0028)
class UPalLocationReplicator final : public UPalGameStateReplicatorBase
{
public:
	struct FFastPalLocationRepInfoArray           RepInfoArray;                                      // 0x0028(0x0148)(Edit, Net, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CB7[0x50];                                    // 0x0170(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLocationReplicator">();
	}
	static class UPalLocationReplicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalLocationReplicator>();
	}
};
static_assert(alignof(UPalLocationReplicator) == 0x000008, "Wrong alignment on UPalLocationReplicator");
static_assert(sizeof(UPalLocationReplicator) == 0x0001C0, "Wrong size on UPalLocationReplicator");
static_assert(offsetof(UPalLocationReplicator, RepInfoArray) == 0x000028, "Member 'UPalLocationReplicator::RepInfoArray' has a wrong offset!");

// Class Pal.PalMapObjectLauncherControlInterface
// 0x0000 (0x0028 - 0x0028)
class IPalMapObjectLauncherControlInterface final : public IInterface
{
public:
	void SetEnableTrigger(bool EnableTrigger);
	void SetOwnerCharacter(const class APalCharacter* OwnerCharacter);
	void TurnToTarget(const class AActor* TargetActor, float DeltaTime);

	const struct FVector GetCharacterLocation() const;
	const struct FRotator GetCharacterRotation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectLauncherControlInterface">();
	}
	static class IPalMapObjectLauncherControlInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPalMapObjectLauncherControlInterface>();
	}
};
static_assert(alignof(IPalMapObjectLauncherControlInterface) == 0x000008, "Wrong alignment on IPalMapObjectLauncherControlInterface");
static_assert(sizeof(IPalMapObjectLauncherControlInterface) == 0x000028, "Wrong size on IPalMapObjectLauncherControlInterface");

// Class Pal.PalAIActionWorkerInterruptInterface
// 0x0000 (0x0028 - 0x0028)
class IPalAIActionWorkerInterruptInterface final : public IInterface
{
public:
	bool IsInterruptibleByRecoverHungry() const;
	bool IsInterruptibleBySleep() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalAIActionWorkerInterruptInterface">();
	}
	static class IPalAIActionWorkerInterruptInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPalAIActionWorkerInterruptInterface>();
	}
};
static_assert(alignof(IPalAIActionWorkerInterruptInterface) == 0x000008, "Wrong alignment on IPalAIActionWorkerInterruptInterface");
static_assert(sizeof(IPalAIActionWorkerInterruptInterface) == 0x000028, "Wrong size on IPalAIActionWorkerInterruptInterface");

// Class Pal.PalLoginPlayer
// 0x0048 (0x0070 - 0x0028)
class UPalLoginPlayer final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnNotifyObtainNewInServerDelegate;                 // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNotifyRemovedFromPalBoxInServerDelegate;         // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGuid                                  PlayerUId;                                         // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                RegisteredRespawnLocation;                         // 0x0058(0x0018)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLoginPlayer">();
	}
	static class UPalLoginPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalLoginPlayer>();
	}
};
static_assert(alignof(UPalLoginPlayer) == 0x000008, "Wrong alignment on UPalLoginPlayer");
static_assert(sizeof(UPalLoginPlayer) == 0x000070, "Wrong size on UPalLoginPlayer");
static_assert(offsetof(UPalLoginPlayer, OnNotifyObtainNewInServerDelegate) == 0x000028, "Member 'UPalLoginPlayer::OnNotifyObtainNewInServerDelegate' has a wrong offset!");
static_assert(offsetof(UPalLoginPlayer, OnNotifyRemovedFromPalBoxInServerDelegate) == 0x000038, "Member 'UPalLoginPlayer::OnNotifyRemovedFromPalBoxInServerDelegate' has a wrong offset!");
static_assert(offsetof(UPalLoginPlayer, PlayerUId) == 0x000048, "Member 'UPalLoginPlayer::PlayerUId' has a wrong offset!");
static_assert(offsetof(UPalLoginPlayer, RegisteredRespawnLocation) == 0x000058, "Member 'UPalLoginPlayer::RegisteredRespawnLocation' has a wrong offset!");

// Class Pal.PalLogManager
// 0x00C8 (0x0138 - 0x0070)
class UPalLogManager : public UPalWorldSubsystem
{
public:
	float                                         NormalLogDisplayTime;                              // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImportantLogDisplayTime;                           // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VeryImportantLogDisplayTime;                       // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeathLogShortDisplayTime;                          // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeathLogLongDisplayTime;                           // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CB9[0x4];                                     // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGuid, struct FPalLogDataSet>     VeryImportantLogMap;                               // 0x0088(0x0050)(Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UPalStaticLogCollector>     StaticLogCollectorClass;                           // 0x00D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalStaticLogCollector*                 StaticLogCollector;                                // 0x00E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnAddedNormalLogDelegate;                          // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAddedImportantLogDelegate;                       // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAddedVeryImportantLogDelegate;                   // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRemovedVeryImportantLogDelegate;                 // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAddedDeathLogDelegate;                           // 0x0128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	void AddDeathLog(const class FText& LogText, const TSoftObjectPtr<class UTexture2D> Icon);
	void AddedDeathLogDelegate__DelegateSignature(const class FText& LogText, const TSoftObjectPtr<class UTexture2D> Icon);
	void AddedImportantLogDelegate__DelegateSignature(const class FText& LogText, const struct FPalLogAdditionalData& LogAdditionalData);
	void AddedNormalLogDelegate__DelegateSignature(const class FText& LogText, const struct FPalLogAdditionalData& LogAdditionalData);
	void AddedVeryImportantLogDelegate__DelegateSignature(const struct FGuid& LogId, const class FText& LogText, const struct FPalLogAdditionalData& LogAdditionalData);
	struct FGuid AddLog(EPalLogPriority LogPriority, const class FText& LogText, const struct FPalLogAdditionalData& LogAdditionalData);
	void RemovedVeryImportantLogDelegate__DelegateSignature(const struct FGuid& LogId);
	bool RemoveVeryImportantLog(const struct FGuid& TargetLogId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLogManager">();
	}
	static class UPalLogManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalLogManager>();
	}
};
static_assert(alignof(UPalLogManager) == 0x000008, "Wrong alignment on UPalLogManager");
static_assert(sizeof(UPalLogManager) == 0x000138, "Wrong size on UPalLogManager");
static_assert(offsetof(UPalLogManager, NormalLogDisplayTime) == 0x000070, "Member 'UPalLogManager::NormalLogDisplayTime' has a wrong offset!");
static_assert(offsetof(UPalLogManager, ImportantLogDisplayTime) == 0x000074, "Member 'UPalLogManager::ImportantLogDisplayTime' has a wrong offset!");
static_assert(offsetof(UPalLogManager, VeryImportantLogDisplayTime) == 0x000078, "Member 'UPalLogManager::VeryImportantLogDisplayTime' has a wrong offset!");
static_assert(offsetof(UPalLogManager, DeathLogShortDisplayTime) == 0x00007C, "Member 'UPalLogManager::DeathLogShortDisplayTime' has a wrong offset!");
static_assert(offsetof(UPalLogManager, DeathLogLongDisplayTime) == 0x000080, "Member 'UPalLogManager::DeathLogLongDisplayTime' has a wrong offset!");
static_assert(offsetof(UPalLogManager, VeryImportantLogMap) == 0x000088, "Member 'UPalLogManager::VeryImportantLogMap' has a wrong offset!");
static_assert(offsetof(UPalLogManager, StaticLogCollectorClass) == 0x0000D8, "Member 'UPalLogManager::StaticLogCollectorClass' has a wrong offset!");
static_assert(offsetof(UPalLogManager, StaticLogCollector) == 0x0000E0, "Member 'UPalLogManager::StaticLogCollector' has a wrong offset!");
static_assert(offsetof(UPalLogManager, OnAddedNormalLogDelegate) == 0x0000E8, "Member 'UPalLogManager::OnAddedNormalLogDelegate' has a wrong offset!");
static_assert(offsetof(UPalLogManager, OnAddedImportantLogDelegate) == 0x0000F8, "Member 'UPalLogManager::OnAddedImportantLogDelegate' has a wrong offset!");
static_assert(offsetof(UPalLogManager, OnAddedVeryImportantLogDelegate) == 0x000108, "Member 'UPalLogManager::OnAddedVeryImportantLogDelegate' has a wrong offset!");
static_assert(offsetof(UPalLogManager, OnRemovedVeryImportantLogDelegate) == 0x000118, "Member 'UPalLogManager::OnRemovedVeryImportantLogDelegate' has a wrong offset!");
static_assert(offsetof(UPalLogManager, OnAddedDeathLogDelegate) == 0x000128, "Member 'UPalLogManager::OnAddedDeathLogDelegate' has a wrong offset!");

// Class Pal.PalLogUtility
// 0x0000 (0x0028 - 0x0028)
class UPalLogUtility final : public UBlueprintFunctionLibrary
{
public:
	static void AddDeathLog(const class UObject* WorldContextObject, const class UPalIndividualCharacterHandle* CharacterHandle);
	static void AddDropPalLog(const class UObject* WorldContextObject, const struct FPalLogInfo_DropPal& LogInfo);
	static void AddItemGetLog(const class UObject* WorldContextObject, const struct FPalStaticItemIdAndNum& ItemIDAndNum);
	static void AddItemsGetLog(const class UObject* WorldContextObject, const TArray<struct FPalItemAndNum>& ItemAndNumArray);
	static void AddMealLog(const class UObject* WorldContextObject, const struct FPalMealLogDisplayData& DisplayData);
	static void AddSkillLog(const class UObject* WorldContextObject, EPalLogType LogType, const struct FPalLogInfo_Skill& Info);
	static void AddWorkerCompleteBuildLog(const class UObject* WorldContextObject, const class UPalIndividualCharacterHandle* WorkerHandle, const class FName& buildedMapObjectName);
	static void AddWorkerCompleteItemConvertLog(const class UObject* WorldContextObject, const class UPalIndividualCharacterHandle* WorkerHandle, const struct FPalItemId& ItemId, const int32 Num);
	static void AddWorkerStartBuilding(const class UObject* WorldContextObject, const class UPalIndividualCharacterHandle* WorkerHandle, const class FName& buildedMapObjectName);
	static void AddWorkerStartRepairing(const class UObject* WorldContextObject, const class UPalIndividualCharacterHandle* WorkerHandle, const class FName& buildedMapObjectName);
	static void AddWorkerStartWorking(const class UObject* WorldContextObject, const class UPalIndividualCharacterHandle* WorkerHandle, const EPalWorkType WorkType);
	static void AddWorkerStartWorking_CollectResource(const class UObject* WorldContextObject, const class UPalIndividualCharacterHandle* WorkerHandle, const class FName StaticItemId);
	static void AddWorkerStartWorking_ProductResource_Deforest(const class UObject* WorldContextObject, const class UPalIndividualCharacterHandle* WorkerHandle);
	static void AddWorkerStartWorking_ProductResource_Mining(const class UObject* WorldContextObject, const class UPalIndividualCharacterHandle* WorkerHandle, const class FName MapObjectId);
	static class FText CreateItemGetLogText(const class UObject* WorldContextObject, const struct FPalStaticItemIdAndNum& ItemIDAndNum);
	static void CreateLogText(const class UObject* WorldContextObject, EPalLogType LogType, class FText* OutText);
	static void SetTextureToAdditionalDataFromCharacterID(const class UObject* WorldContextObject, struct FPalLogAdditionalData& TargetData, const class FName CharacterID);
	static void SetTextureToAdditionalDataFromHandle(const class UObject* WorldContextObject, struct FPalLogAdditionalData& TargetData, const class UPalIndividualCharacterHandle* TargetHandle);
	static void SetTextureToAdditionalDataFromHandles(const class UObject* WorldContextObject, struct FPalLogAdditionalData& TargetData, const TArray<class UPalIndividualCharacterHandle*>& TargetHandles);
	static void SetTextureToAdditionalDataFromStaticItemID(const class UObject* WorldContextObject, struct FPalLogAdditionalData& TargetData, const class FName& StaticItemId);
	static void SetTextureToAdditionalDataFromStaticItemIDs(const class UObject* WorldContextObject, struct FPalLogAdditionalData& TargetData, const TArray<class FName>& StaticItemIds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLogUtility">();
	}
	static class UPalLogUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalLogUtility>();
	}
};
static_assert(alignof(UPalLogUtility) == 0x000008, "Wrong alignment on UPalLogUtility");
static_assert(sizeof(UPalLogUtility) == 0x000028, "Wrong size on UPalLogUtility");

// Class Pal.PalLogWidget
// 0x0000 (0x0408 - 0x0408)
class UPalLogWidget final : public UPalUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLogWidget">();
	}
	static class UPalLogWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalLogWidget>();
	}
};
static_assert(alignof(UPalLogWidget) == 0x000008, "Wrong alignment on UPalLogWidget");
static_assert(sizeof(UPalLogWidget) == 0x000408, "Wrong size on UPalLogWidget");

// Class Pal.PalMapObjectMedicalPalBedModel
// 0x0078 (0x0290 - 0x0218)
class UPalMapObjectMedicalPalBedModel final : public UPalMapObjectConcreteModelBase
{
public:
	uint8                                         Pad_2CC2[0x28];                                    // 0x0218(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnUpdateSleepingCharacterDelegate;                 // 0x0240(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UPalIndividualCharacterHandle*          SleepingCharacterHandle;                           // 0x0250(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                SleepLocationOffset;                               // 0x0258(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                RemovedSleepLocationOffset;                        // 0x0270(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AdditionalHealingRate;                             // 0x0288(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AffectSanityRate;                                  // 0x028C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ClearSleepingCharacterHandle();
	void OnFinishSleepAction(class UPalAIActionBase* Action);
	void OnInteractBegin(class AActor* Other, TScriptInterface<class IPalInteractiveObjectComponentInterface> Component);
	void SimpleDelegate__DelegateSignature(class UPalMapObjectMedicalPalBedModel* Model);

	class UPalIndividualCharacterHandle* GetSleepingHandle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectMedicalPalBedModel">();
	}
	static class UPalMapObjectMedicalPalBedModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectMedicalPalBedModel>();
	}
};
static_assert(alignof(UPalMapObjectMedicalPalBedModel) == 0x000008, "Wrong alignment on UPalMapObjectMedicalPalBedModel");
static_assert(sizeof(UPalMapObjectMedicalPalBedModel) == 0x000290, "Wrong size on UPalMapObjectMedicalPalBedModel");
static_assert(offsetof(UPalMapObjectMedicalPalBedModel, OnUpdateSleepingCharacterDelegate) == 0x000240, "Member 'UPalMapObjectMedicalPalBedModel::OnUpdateSleepingCharacterDelegate' has a wrong offset!");
static_assert(offsetof(UPalMapObjectMedicalPalBedModel, SleepingCharacterHandle) == 0x000250, "Member 'UPalMapObjectMedicalPalBedModel::SleepingCharacterHandle' has a wrong offset!");
static_assert(offsetof(UPalMapObjectMedicalPalBedModel, SleepLocationOffset) == 0x000258, "Member 'UPalMapObjectMedicalPalBedModel::SleepLocationOffset' has a wrong offset!");
static_assert(offsetof(UPalMapObjectMedicalPalBedModel, RemovedSleepLocationOffset) == 0x000270, "Member 'UPalMapObjectMedicalPalBedModel::RemovedSleepLocationOffset' has a wrong offset!");
static_assert(offsetof(UPalMapObjectMedicalPalBedModel, AdditionalHealingRate) == 0x000288, "Member 'UPalMapObjectMedicalPalBedModel::AdditionalHealingRate' has a wrong offset!");
static_assert(offsetof(UPalMapObjectMedicalPalBedModel, AffectSanityRate) == 0x00028C, "Member 'UPalMapObjectMedicalPalBedModel::AffectSanityRate' has a wrong offset!");

// Class Pal.PalLogWidgetBase
// 0x0018 (0x0420 - 0x0408)
class UPalLogWidgetBase final : public UPalUserWidget
{
public:
	float                                         DestroyTime;                                       // 0x0408(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ElapsedTime;                                       // 0x040C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPalLogWidgetState                            LogState;                                          // 0x0410(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CC3[0x3];                                     // 0x0411(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPalStaticItemIdAndNum                 ItemIDAndNum;                                      // 0x0414(0x000C)(BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	void RequestInAnime();
	void RequestOutAnime();
	void SetAdditionalData(const struct FPalLogAdditionalData& InAdditionalData);
	void SetLogText(const class FText& InText);
	void SetState(EPalLogWidgetState ChangeState);
	void StartDisplayLog(float InDestroyTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLogWidgetBase">();
	}
	static class UPalLogWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalLogWidgetBase>();
	}
};
static_assert(alignof(UPalLogWidgetBase) == 0x000008, "Wrong alignment on UPalLogWidgetBase");
static_assert(sizeof(UPalLogWidgetBase) == 0x000420, "Wrong size on UPalLogWidgetBase");
static_assert(offsetof(UPalLogWidgetBase, DestroyTime) == 0x000408, "Member 'UPalLogWidgetBase::DestroyTime' has a wrong offset!");
static_assert(offsetof(UPalLogWidgetBase, ElapsedTime) == 0x00040C, "Member 'UPalLogWidgetBase::ElapsedTime' has a wrong offset!");
static_assert(offsetof(UPalLogWidgetBase, LogState) == 0x000410, "Member 'UPalLogWidgetBase::LogState' has a wrong offset!");
static_assert(offsetof(UPalLogWidgetBase, ItemIDAndNum) == 0x000414, "Member 'UPalLogWidgetBase::ItemIDAndNum' has a wrong offset!");

// Class Pal.PalLongPressObject
// 0x0158 (0x0180 - 0x0028)
class UPalLongPressObject final : public UObject
{
public:
	uint8                                         Pad_2CC4[0x158];                                   // 0x0028(0x0158)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void LongPressCallback();
	void PressCallback();
	void ReleaseCallback();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLongPressObject">();
	}
	static class UPalLongPressObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalLongPressObject>();
	}
};
static_assert(alignof(UPalLongPressObject) == 0x000008, "Wrong alignment on UPalLongPressObject");
static_assert(sizeof(UPalLongPressObject) == 0x000180, "Wrong size on UPalLongPressObject");

// Class Pal.PalWorkDefine
// 0x0000 (0x0028 - 0x0028)
class UPalWorkDefine final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorkDefine">();
	}
	static class UPalWorkDefine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWorkDefine>();
	}
};
static_assert(alignof(UPalWorkDefine) == 0x000008, "Wrong alignment on UPalWorkDefine");
static_assert(sizeof(UPalWorkDefine) == 0x000028, "Wrong size on UPalWorkDefine");

// Class Pal.PalLookAtComponent
// 0x00C0 (0x0160 - 0x00A0)
class UPalLookAtComponent final : public UActorComponent
{
public:
	struct FVector                                LookAtTargetLocation;                              // 0x00A0(0x0018)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                LookAtTargetLocation_forActor;                     // 0x00B8(0x0018)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 LookAtTargetActor;                                 // 0x00D0(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                LookAtTargetLocation_Interpolated;                 // 0x00D8(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   LookAtTargetBoneName;                              // 0x00F0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LookAtInInterpTime;                                // 0x00F8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LookAtOutInterpTime;                               // 0x00FC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsEnableLookAt;                                   // 0x0100(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CC5[0x7];                                     // 0x0101(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFlagContainer                         LookAtDisableFlag;                                 // 0x0108(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	float                                         InterpolatedSpeed;                                 // 0x0158(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsShowDebugImage;                                 // 0x015C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CC6[0x3];                                     // 0x015D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChangeShootState(bool IsAim, bool IsShooting);
	void SetLookAtDisable(class FName FlagName, bool bIsDisable);
	void StartLookAt(const struct FVector& LookAtTarget, float InterpTime);
	void StartLookAtForActor(class AActor* Actor, class FName BoneName, float InterpTime);
	void StopLookAt(float InterpTime);

	float GetLookAtInInterpTime() const;
	float GetLookAtOutInterpTime() const;
	struct FVector GetLookAtTarget() const;
	bool IsEnableLookAt() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLookAtComponent">();
	}
	static class UPalLookAtComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalLookAtComponent>();
	}
};
static_assert(alignof(UPalLookAtComponent) == 0x000008, "Wrong alignment on UPalLookAtComponent");
static_assert(sizeof(UPalLookAtComponent) == 0x000160, "Wrong size on UPalLookAtComponent");
static_assert(offsetof(UPalLookAtComponent, LookAtTargetLocation) == 0x0000A0, "Member 'UPalLookAtComponent::LookAtTargetLocation' has a wrong offset!");
static_assert(offsetof(UPalLookAtComponent, LookAtTargetLocation_forActor) == 0x0000B8, "Member 'UPalLookAtComponent::LookAtTargetLocation_forActor' has a wrong offset!");
static_assert(offsetof(UPalLookAtComponent, LookAtTargetActor) == 0x0000D0, "Member 'UPalLookAtComponent::LookAtTargetActor' has a wrong offset!");
static_assert(offsetof(UPalLookAtComponent, LookAtTargetLocation_Interpolated) == 0x0000D8, "Member 'UPalLookAtComponent::LookAtTargetLocation_Interpolated' has a wrong offset!");
static_assert(offsetof(UPalLookAtComponent, LookAtTargetBoneName) == 0x0000F0, "Member 'UPalLookAtComponent::LookAtTargetBoneName' has a wrong offset!");
static_assert(offsetof(UPalLookAtComponent, LookAtInInterpTime) == 0x0000F8, "Member 'UPalLookAtComponent::LookAtInInterpTime' has a wrong offset!");
static_assert(offsetof(UPalLookAtComponent, LookAtOutInterpTime) == 0x0000FC, "Member 'UPalLookAtComponent::LookAtOutInterpTime' has a wrong offset!");
static_assert(offsetof(UPalLookAtComponent, bIsEnableLookAt) == 0x000100, "Member 'UPalLookAtComponent::bIsEnableLookAt' has a wrong offset!");
static_assert(offsetof(UPalLookAtComponent, LookAtDisableFlag) == 0x000108, "Member 'UPalLookAtComponent::LookAtDisableFlag' has a wrong offset!");
static_assert(offsetof(UPalLookAtComponent, InterpolatedSpeed) == 0x000158, "Member 'UPalLookAtComponent::InterpolatedSpeed' has a wrong offset!");
static_assert(offsetof(UPalLookAtComponent, bIsShowDebugImage) == 0x00015C, "Member 'UPalLookAtComponent::bIsShowDebugImage' has a wrong offset!");

// Class Pal.PalMapObjectAmusementParameterComponent
// 0x0010 (0x00B0 - 0x00A0)
class UPalMapObjectAmusementParameterComponent final : public UActorComponent
{
public:
	float                                         AffectSanityRate;                                  // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CCA[0x4];                                     // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UPalAIActionBaseCampInUsingAmusement> AIActionClass;                                     // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectAmusementParameterComponent">();
	}
	static class UPalMapObjectAmusementParameterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectAmusementParameterComponent>();
	}
};
static_assert(alignof(UPalMapObjectAmusementParameterComponent) == 0x000008, "Wrong alignment on UPalMapObjectAmusementParameterComponent");
static_assert(sizeof(UPalMapObjectAmusementParameterComponent) == 0x0000B0, "Wrong size on UPalMapObjectAmusementParameterComponent");
static_assert(offsetof(UPalMapObjectAmusementParameterComponent, AffectSanityRate) == 0x0000A0, "Member 'UPalMapObjectAmusementParameterComponent::AffectSanityRate' has a wrong offset!");
static_assert(offsetof(UPalMapObjectAmusementParameterComponent, AIActionClass) == 0x0000A8, "Member 'UPalMapObjectAmusementParameterComponent::AIActionClass' has a wrong offset!");

// Class Pal.PalMapObjectBaseCampPassiveEffectWorkSpeedParameterComponent
// 0x0010 (0x00B0 - 0x00A0)
class UPalMapObjectBaseCampPassiveEffectWorkSpeedParameterComponent final : public UPalMapObjectBaseCampPassiveEffectParameterComponentBase
{
public:
	int32                                         AffectMaxNum;                                      // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPalWorkSuitability                           TargetWorkSuitability;                             // 0x00A4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CCB[0x3];                                     // 0x00A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WorkSpeedAdditionalRate;                           // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CCC[0x4];                                     // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectBaseCampPassiveEffectWorkSpeedParameterComponent">();
	}
	static class UPalMapObjectBaseCampPassiveEffectWorkSpeedParameterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectBaseCampPassiveEffectWorkSpeedParameterComponent>();
	}
};
static_assert(alignof(UPalMapObjectBaseCampPassiveEffectWorkSpeedParameterComponent) == 0x000008, "Wrong alignment on UPalMapObjectBaseCampPassiveEffectWorkSpeedParameterComponent");
static_assert(sizeof(UPalMapObjectBaseCampPassiveEffectWorkSpeedParameterComponent) == 0x0000B0, "Wrong size on UPalMapObjectBaseCampPassiveEffectWorkSpeedParameterComponent");
static_assert(offsetof(UPalMapObjectBaseCampPassiveEffectWorkSpeedParameterComponent, AffectMaxNum) == 0x0000A0, "Member 'UPalMapObjectBaseCampPassiveEffectWorkSpeedParameterComponent::AffectMaxNum' has a wrong offset!");
static_assert(offsetof(UPalMapObjectBaseCampPassiveEffectWorkSpeedParameterComponent, TargetWorkSuitability) == 0x0000A4, "Member 'UPalMapObjectBaseCampPassiveEffectWorkSpeedParameterComponent::TargetWorkSuitability' has a wrong offset!");
static_assert(offsetof(UPalMapObjectBaseCampPassiveEffectWorkSpeedParameterComponent, WorkSpeedAdditionalRate) == 0x0000A8, "Member 'UPalMapObjectBaseCampPassiveEffectWorkSpeedParameterComponent::WorkSpeedAdditionalRate' has a wrong offset!");

// Class Pal.PalMapObjectBaseCampPassiveEffectWorkHardParameterComponent
// 0x0000 (0x00A0 - 0x00A0)
class UPalMapObjectBaseCampPassiveEffectWorkHardParameterComponent final : public UPalMapObjectBaseCampPassiveEffectParameterComponentBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectBaseCampPassiveEffectWorkHardParameterComponent">();
	}
	static class UPalMapObjectBaseCampPassiveEffectWorkHardParameterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectBaseCampPassiveEffectWorkHardParameterComponent>();
	}
};
static_assert(alignof(UPalMapObjectBaseCampPassiveEffectWorkHardParameterComponent) == 0x000008, "Wrong alignment on UPalMapObjectBaseCampPassiveEffectWorkHardParameterComponent");
static_assert(sizeof(UPalMapObjectBaseCampPassiveEffectWorkHardParameterComponent) == 0x0000A0, "Wrong size on UPalMapObjectBaseCampPassiveEffectWorkHardParameterComponent");

// Class Pal.PalMapObjectBaseCampWorkerDirectorModel
// 0x0018 (0x0230 - 0x0218)
class UPalMapObjectBaseCampWorkerDirectorModel final : public UPalMapObjectConcreteModelBase
{
public:
	FMulticastInlineDelegateProperty_             OnNotifiedChangeBaseCampBattleTypeDelegate;        // 0x0218(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EPalBaseCampWorkerDirectionBattleType         BaseCampBattleTypeForClientRead;                   // 0x0228(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CCD[0x7];                                     // 0x0229(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NotifyChangeBaseCampBattleType_ClientInternal();
	void OnRep_BaseCampBattleTypeForClientRead();
	void RequestUpdateBaseCampBattleType_ServerInternal(const int32 RequestPlayerId, const int32 BattleTypeInt);
	void ReturnSelfDelegate__DelegateSignature(class UPalMapObjectBaseCampWorkerDirectorModel* Model);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectBaseCampWorkerDirectorModel">();
	}
	static class UPalMapObjectBaseCampWorkerDirectorModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectBaseCampWorkerDirectorModel>();
	}
};
static_assert(alignof(UPalMapObjectBaseCampWorkerDirectorModel) == 0x000008, "Wrong alignment on UPalMapObjectBaseCampWorkerDirectorModel");
static_assert(sizeof(UPalMapObjectBaseCampWorkerDirectorModel) == 0x000230, "Wrong size on UPalMapObjectBaseCampWorkerDirectorModel");
static_assert(offsetof(UPalMapObjectBaseCampWorkerDirectorModel, OnNotifiedChangeBaseCampBattleTypeDelegate) == 0x000218, "Member 'UPalMapObjectBaseCampWorkerDirectorModel::OnNotifiedChangeBaseCampBattleTypeDelegate' has a wrong offset!");
static_assert(offsetof(UPalMapObjectBaseCampWorkerDirectorModel, BaseCampBattleTypeForClientRead) == 0x000228, "Member 'UPalMapObjectBaseCampWorkerDirectorModel::BaseCampBattleTypeForClientRead' has a wrong offset!");

// Class Pal.PalMapObjectCharacterContainerModule
// 0x0008 (0x0038 - 0x0030)
class UPalMapObjectCharacterContainerModule final : public UPalMapObjectConcreteModelModuleBase
{
public:
	class UPalIndividualCharacterContainer*       TargetContainer;                                   // 0x0030(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_TargetContainer();

	class UPalIndividualCharacterContainer* GetContainer() const;
	const struct FPalContainerId GetContainerId() const;
	bool IsCompleteSetup() const;
	bool TryGetContainer(class UPalIndividualCharacterContainer** OutContainer) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectCharacterContainerModule">();
	}
	static class UPalMapObjectCharacterContainerModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectCharacterContainerModule>();
	}
};
static_assert(alignof(UPalMapObjectCharacterContainerModule) == 0x000008, "Wrong alignment on UPalMapObjectCharacterContainerModule");
static_assert(sizeof(UPalMapObjectCharacterContainerModule) == 0x000038, "Wrong size on UPalMapObjectCharacterContainerModule");
static_assert(offsetof(UPalMapObjectCharacterContainerModule, TargetContainer) == 0x000030, "Member 'UPalMapObjectCharacterContainerModule::TargetContainer' has a wrong offset!");

// Class Pal.PalMapObjectCollectResourceParameterComponent
// 0x0020 (0x00C0 - 0x00A0)
class UPalMapObjectCollectResourceParameterComponent final : public UActorComponent
{
public:
	int32                                         SlotNum;                                           // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CCF[0x4];                                     // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPalDataTableRowName_ItemData>  TargetItemIds;                                     // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         AdditionalRangeOutOfBaseCamp;                      // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CD0[0x4];                                     // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectCollectResourceParameterComponent">();
	}
	static class UPalMapObjectCollectResourceParameterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectCollectResourceParameterComponent>();
	}
};
static_assert(alignof(UPalMapObjectCollectResourceParameterComponent) == 0x000008, "Wrong alignment on UPalMapObjectCollectResourceParameterComponent");
static_assert(sizeof(UPalMapObjectCollectResourceParameterComponent) == 0x0000C0, "Wrong size on UPalMapObjectCollectResourceParameterComponent");
static_assert(offsetof(UPalMapObjectCollectResourceParameterComponent, SlotNum) == 0x0000A0, "Member 'UPalMapObjectCollectResourceParameterComponent::SlotNum' has a wrong offset!");
static_assert(offsetof(UPalMapObjectCollectResourceParameterComponent, TargetItemIds) == 0x0000A8, "Member 'UPalMapObjectCollectResourceParameterComponent::TargetItemIds' has a wrong offset!");
static_assert(offsetof(UPalMapObjectCollectResourceParameterComponent, AdditionalRangeOutOfBaseCamp) == 0x0000B8, "Member 'UPalMapObjectCollectResourceParameterComponent::AdditionalRangeOutOfBaseCamp' has a wrong offset!");

// Class Pal.PalMapObjectConcreteModelModuleItemHolderInterface
// 0x0000 (0x0028 - 0x0028)
class IPalMapObjectConcreteModelModuleItemHolderInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectConcreteModelModuleItemHolderInterface">();
	}
	static class IPalMapObjectConcreteModelModuleItemHolderInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPalMapObjectConcreteModelModuleItemHolderInterface>();
	}
};
static_assert(alignof(IPalMapObjectConcreteModelModuleItemHolderInterface) == 0x000008, "Wrong alignment on IPalMapObjectConcreteModelModuleItemHolderInterface");
static_assert(sizeof(IPalMapObjectConcreteModelModuleItemHolderInterface) == 0x000028, "Wrong size on IPalMapObjectConcreteModelModuleItemHolderInterface");

// Class Pal.PalMapObjectConvertItemModel
// 0x00B8 (0x02D0 - 0x0218)
class UPalMapObjectConvertItemModel final : public UPalMapObjectConcreteModelBase
{
public:
	uint8                                         Pad_2CD1[0x20];                                    // 0x0218(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnUpdateRecipeDelegate;                            // 0x0238(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFinishConvertDelegate;                           // 0x0248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRecieveUpdateRecipeRequestResultDelegate;        // 0x0258(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateSettingDelegate;                           // 0x0268(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FName                                   CurrentRecipeId;                                   // 0x0278(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         RequestedProductNum;                               // 0x0280(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         RemainProductNum;                                  // 0x0284(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsWorkable;                                       // 0x0288(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CD2[0x7];                                     // 0x0289(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           RecipeIds;                                         // 0x0290(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	float                                         WorkSpeedAdditionalRate;                           // 0x02A0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CurrentRecipeRequestPlayerId;                      // 0x02A4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<EPalItemTypeA>                         TargetTypesA;                                      // 0x02A8(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	TArray<EPalItemTypeB>                         TargetTypesB;                                      // 0x02B8(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	int32                                         TargetRankMax;                                     // 0x02C8(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsPickUpInteractable;                              // 0x02CC(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCanTransportOutProduct;                           // 0x02CD(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CD3[0x2];                                     // 0x02CE(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool IsProductNumInfinite(const int32 ProductNum);

	void AddConvertItemResultLog(const struct FPalNetArchive& Archive);
	void Cancel_ServerInternal(const int32 RequestPlayerId);
	void ChangeRecipe_ServerInternal(const int32 RequestPlayerId, const struct FPalNetArchive& Archive);
	void FinishConvertDelegate__DelegateSignature(class UPalMapObjectConvertItemModel* Model);
	const TArray<class FName> GetRecipes();
	void OnEndWorkAnyone_ServerInternal(class UPalWorkBase* Work, const struct FPalInstanceID& WorkerIndividualId);
	void OnFinishWorkInServer(class UPalWorkBase* Work);
	void OnRep_CurrentRecipeId();
	void OnRep_IsWorkable();
	void OnRep_RemainProductNum();
	void OnRep_RequestedProductNum();
	void OnStartWorkAnyone_ServerInternal(class UPalWorkBase* Work, const struct FPalInstanceID& WorkerIndividualId);
	void OnUpdateContainerContentInServer(class UPalItemContainer* Container);
	void OnUpdateEnergyModuleState(class UPalMapObjectEnergyModule* EnergyModule);
	void PickupProduct_ServerInternal(const int32 RequestPlayerId);
	void ReceivedPickProductResult(class UPalItemSlot* Slot);
	void ReceivePickupProductResult_Client(const struct FPalNetArchive& Archive);
	void RecieveUpdateRecipeRequestResultDelegate__DelegateSignature(EPalMapObjectConvertItemModelRequestResult Result);
	void UpdateRecipeDelegate__DelegateSignature(class UPalMapObjectConvertItemModel* Model);
	void UpdateSettingDelegate__DelegateSignature(class UPalMapObjectConvertItemModel* Model);

	float CalcRequiredAmount(const float BaseRequiredAmount) const;
	struct FPalItemRecipe GetCurrentRecipe() const;
	class FName GetCurrentRecipeId() const;
	class UPalItemSlot* GetProductSlot() const;
	int32 GetRemainCreateNum() const;
	TArray<int32> GetSlotIndexesMaterialInput() const;
	int32 GetSlotIndexProductOut() const;
	class UPalItemSlot* GetSlotInjectableMaterial(const class FName StaticItemId) const;
	bool IsTransportToStorage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectConvertItemModel">();
	}
	static class UPalMapObjectConvertItemModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectConvertItemModel>();
	}
};
static_assert(alignof(UPalMapObjectConvertItemModel) == 0x000008, "Wrong alignment on UPalMapObjectConvertItemModel");
static_assert(sizeof(UPalMapObjectConvertItemModel) == 0x0002D0, "Wrong size on UPalMapObjectConvertItemModel");
static_assert(offsetof(UPalMapObjectConvertItemModel, OnUpdateRecipeDelegate) == 0x000238, "Member 'UPalMapObjectConvertItemModel::OnUpdateRecipeDelegate' has a wrong offset!");
static_assert(offsetof(UPalMapObjectConvertItemModel, OnFinishConvertDelegate) == 0x000248, "Member 'UPalMapObjectConvertItemModel::OnFinishConvertDelegate' has a wrong offset!");
static_assert(offsetof(UPalMapObjectConvertItemModel, OnRecieveUpdateRecipeRequestResultDelegate) == 0x000258, "Member 'UPalMapObjectConvertItemModel::OnRecieveUpdateRecipeRequestResultDelegate' has a wrong offset!");
static_assert(offsetof(UPalMapObjectConvertItemModel, OnUpdateSettingDelegate) == 0x000268, "Member 'UPalMapObjectConvertItemModel::OnUpdateSettingDelegate' has a wrong offset!");
static_assert(offsetof(UPalMapObjectConvertItemModel, CurrentRecipeId) == 0x000278, "Member 'UPalMapObjectConvertItemModel::CurrentRecipeId' has a wrong offset!");
static_assert(offsetof(UPalMapObjectConvertItemModel, RequestedProductNum) == 0x000280, "Member 'UPalMapObjectConvertItemModel::RequestedProductNum' has a wrong offset!");
static_assert(offsetof(UPalMapObjectConvertItemModel, RemainProductNum) == 0x000284, "Member 'UPalMapObjectConvertItemModel::RemainProductNum' has a wrong offset!");
static_assert(offsetof(UPalMapObjectConvertItemModel, bIsWorkable) == 0x000288, "Member 'UPalMapObjectConvertItemModel::bIsWorkable' has a wrong offset!");
static_assert(offsetof(UPalMapObjectConvertItemModel, RecipeIds) == 0x000290, "Member 'UPalMapObjectConvertItemModel::RecipeIds' has a wrong offset!");
static_assert(offsetof(UPalMapObjectConvertItemModel, WorkSpeedAdditionalRate) == 0x0002A0, "Member 'UPalMapObjectConvertItemModel::WorkSpeedAdditionalRate' has a wrong offset!");
static_assert(offsetof(UPalMapObjectConvertItemModel, CurrentRecipeRequestPlayerId) == 0x0002A4, "Member 'UPalMapObjectConvertItemModel::CurrentRecipeRequestPlayerId' has a wrong offset!");
static_assert(offsetof(UPalMapObjectConvertItemModel, TargetTypesA) == 0x0002A8, "Member 'UPalMapObjectConvertItemModel::TargetTypesA' has a wrong offset!");
static_assert(offsetof(UPalMapObjectConvertItemModel, TargetTypesB) == 0x0002B8, "Member 'UPalMapObjectConvertItemModel::TargetTypesB' has a wrong offset!");
static_assert(offsetof(UPalMapObjectConvertItemModel, TargetRankMax) == 0x0002C8, "Member 'UPalMapObjectConvertItemModel::TargetRankMax' has a wrong offset!");
static_assert(offsetof(UPalMapObjectConvertItemModel, IsPickUpInteractable) == 0x0002CC, "Member 'UPalMapObjectConvertItemModel::IsPickUpInteractable' has a wrong offset!");
static_assert(offsetof(UPalMapObjectConvertItemModel, bCanTransportOutProduct) == 0x0002CD, "Member 'UPalMapObjectConvertItemModel::bCanTransportOutProduct' has a wrong offset!");

// Class Pal.PalMapObjectPickableCharacterModelBase
// 0x02A8 (0x04C0 - 0x0218)
class UPalMapObjectPickableCharacterModelBase : public UPalMapObjectConcreteModelBase
{
public:
	struct FPalCharacterStoredParameterId         StoredParameterId;                                 // 0x0218(0x0010)(Edit, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPalIndividualCharacterSaveParameter   ForRead_CharacterSaveParameter;                    // 0x0228(0x0280)(Edit, Net, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	struct FGuid                                  LocationId;                                        // 0x04A8(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CD6[0x8];                                     // 0x04B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDisappearTimeAt();
	void OnRemovedStoredCharacter_ServerInternal(const struct FPalCharacterStoredParameterId& RemovedID);
	void RequestPickup();
	void RequestPickup_ServerInternal(const int32 RequestPlayerId);

	const struct FPalIndividualCharacterSaveParameter GetCharacterSaveParameter() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectPickableCharacterModelBase">();
	}
	static class UPalMapObjectPickableCharacterModelBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectPickableCharacterModelBase>();
	}
};
static_assert(alignof(UPalMapObjectPickableCharacterModelBase) == 0x000008, "Wrong alignment on UPalMapObjectPickableCharacterModelBase");
static_assert(sizeof(UPalMapObjectPickableCharacterModelBase) == 0x0004C0, "Wrong size on UPalMapObjectPickableCharacterModelBase");
static_assert(offsetof(UPalMapObjectPickableCharacterModelBase, StoredParameterId) == 0x000218, "Member 'UPalMapObjectPickableCharacterModelBase::StoredParameterId' has a wrong offset!");
static_assert(offsetof(UPalMapObjectPickableCharacterModelBase, ForRead_CharacterSaveParameter) == 0x000228, "Member 'UPalMapObjectPickableCharacterModelBase::ForRead_CharacterSaveParameter' has a wrong offset!");
static_assert(offsetof(UPalMapObjectPickableCharacterModelBase, LocationId) == 0x0004A8, "Member 'UPalMapObjectPickableCharacterModelBase::LocationId' has a wrong offset!");

// Class Pal.PalMapObjectDeathDroppedCharacterModel
// 0x0020 (0x04E0 - 0x04C0)
class UPalMapObjectDeathDroppedCharacterModel final : public UPalMapObjectPickableCharacterModelBase
{
public:
	FMulticastInlineDelegateProperty_             OnNotifiedGuildUpdateInClientDelegate;             // 0x04C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGuid                                  OwnerPlayerUId;                                    // 0x04D0(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnChangedPlayerInfoInLocalPlayerGuild_ClientInternal(class APalPlayerState* LocalPlayerState);
	void ReturnSelfDelegate__DelegateSignature(class UPalMapObjectDeathDroppedCharacterModel* Model);

	bool IsSameGuildInLocalPlayer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectDeathDroppedCharacterModel">();
	}
	static class UPalMapObjectDeathDroppedCharacterModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectDeathDroppedCharacterModel>();
	}
};
static_assert(alignof(UPalMapObjectDeathDroppedCharacterModel) == 0x000008, "Wrong alignment on UPalMapObjectDeathDroppedCharacterModel");
static_assert(sizeof(UPalMapObjectDeathDroppedCharacterModel) == 0x0004E0, "Wrong size on UPalMapObjectDeathDroppedCharacterModel");
static_assert(offsetof(UPalMapObjectDeathDroppedCharacterModel, OnNotifiedGuildUpdateInClientDelegate) == 0x0004C0, "Member 'UPalMapObjectDeathDroppedCharacterModel::OnNotifiedGuildUpdateInClientDelegate' has a wrong offset!");
static_assert(offsetof(UPalMapObjectDeathDroppedCharacterModel, OwnerPlayerUId) == 0x0004D0, "Member 'UPalMapObjectDeathDroppedCharacterModel::OwnerPlayerUId' has a wrong offset!");

// Class Pal.PalMapObjectDeathPenaltyStorageModel
// 0x0040 (0x0260 - 0x0220)
class UPalMapObjectDeathPenaltyStorageModel final : public UPalMapObjectItemStorageModel
{
public:
	FMulticastInlineDelegateProperty_             OnNotifiedGuildUpdateInClientDelegate;             // 0x0220(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGuid                                  OwnerPlayerUId;                                    // 0x0230(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  LocationId;                                        // 0x0240(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDateTime                              CreatedAtRealTime;                                 // 0x0250(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanOpenByProgressTime;                            // 0x0258(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CD7[0x7];                                     // 0x0259(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChangedPlayerInfoInLocalPlayerGuild_ClientInternal(class APalPlayerState* LocalPlayerState);
	void ReturnSelfDelegate__DelegateSignature(class UPalMapObjectDeathPenaltyStorageModel* Model);

	bool IsSameGuildInLocalPlayer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectDeathPenaltyStorageModel">();
	}
	static class UPalMapObjectDeathPenaltyStorageModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectDeathPenaltyStorageModel>();
	}
};
static_assert(alignof(UPalMapObjectDeathPenaltyStorageModel) == 0x000008, "Wrong alignment on UPalMapObjectDeathPenaltyStorageModel");
static_assert(sizeof(UPalMapObjectDeathPenaltyStorageModel) == 0x000260, "Wrong size on UPalMapObjectDeathPenaltyStorageModel");
static_assert(offsetof(UPalMapObjectDeathPenaltyStorageModel, OnNotifiedGuildUpdateInClientDelegate) == 0x000220, "Member 'UPalMapObjectDeathPenaltyStorageModel::OnNotifiedGuildUpdateInClientDelegate' has a wrong offset!");
static_assert(offsetof(UPalMapObjectDeathPenaltyStorageModel, OwnerPlayerUId) == 0x000230, "Member 'UPalMapObjectDeathPenaltyStorageModel::OwnerPlayerUId' has a wrong offset!");
static_assert(offsetof(UPalMapObjectDeathPenaltyStorageModel, LocationId) == 0x000240, "Member 'UPalMapObjectDeathPenaltyStorageModel::LocationId' has a wrong offset!");
static_assert(offsetof(UPalMapObjectDeathPenaltyStorageModel, CreatedAtRealTime) == 0x000250, "Member 'UPalMapObjectDeathPenaltyStorageModel::CreatedAtRealTime' has a wrong offset!");
static_assert(offsetof(UPalMapObjectDeathPenaltyStorageModel, bCanOpenByProgressTime) == 0x000258, "Member 'UPalMapObjectDeathPenaltyStorageModel::bCanOpenByProgressTime' has a wrong offset!");

// Class Pal.PalMapObjectOperationResultUtility
// 0x0000 (0x0028 - 0x0028)
class UPalMapObjectOperationResultUtility final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectOperationResultUtility">();
	}
	static class UPalMapObjectOperationResultUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectOperationResultUtility>();
	}
};
static_assert(alignof(UPalMapObjectOperationResultUtility) == 0x000008, "Wrong alignment on UPalMapObjectOperationResultUtility");
static_assert(sizeof(UPalMapObjectOperationResultUtility) == 0x000028, "Wrong size on UPalMapObjectOperationResultUtility");

// Class Pal.PalMapObjectInteractRestrictTypeUtility
// 0x0000 (0x0028 - 0x0028)
class UPalMapObjectInteractRestrictTypeUtility final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectInteractRestrictTypeUtility">();
	}
	static class UPalMapObjectInteractRestrictTypeUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectInteractRestrictTypeUtility>();
	}
};
static_assert(alignof(UPalMapObjectInteractRestrictTypeUtility) == 0x000008, "Wrong alignment on UPalMapObjectInteractRestrictTypeUtility");
static_assert(sizeof(UPalMapObjectInteractRestrictTypeUtility) == 0x000028, "Wrong size on UPalMapObjectInteractRestrictTypeUtility");

// Class Pal.PalMapObjectModelInterface
// 0x0000 (0x0028 - 0x0028)
class IPalMapObjectModelInterface final : public IInterface
{
public:
	const struct FGuid GetModelId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectModelInterface">();
	}
	static class IPalMapObjectModelInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPalMapObjectModelInterface>();
	}
};
static_assert(alignof(IPalMapObjectModelInterface) == 0x000008, "Wrong alignment on IPalMapObjectModelInterface");
static_assert(sizeof(IPalMapObjectModelInterface) == 0x000028, "Wrong size on IPalMapObjectModelInterface");

// Class Pal.PalMapObjectWorkerAvailableFacilityInterface
// 0x0000 (0x0028 - 0x0028)
class IPalMapObjectWorkerAvailableFacilityInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectWorkerAvailableFacilityInterface">();
	}
	static class IPalMapObjectWorkerAvailableFacilityInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPalMapObjectWorkerAvailableFacilityInterface>();
	}
};
static_assert(alignof(IPalMapObjectWorkerAvailableFacilityInterface) == 0x000008, "Wrong alignment on IPalMapObjectWorkerAvailableFacilityInterface");
static_assert(sizeof(IPalMapObjectWorkerAvailableFacilityInterface) == 0x000028, "Wrong size on IPalMapObjectWorkerAvailableFacilityInterface");

// Class Pal.PalMapObjectDisplayCharacterModel
// 0x00D8 (0x02F0 - 0x0218)
class UPalMapObjectDisplayCharacterModel final : public UPalMapObjectConcreteModelBase
{
public:
	float                                         RecoverAmountBySec;                                // 0x0218(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CD8[0x4];                                     // 0x021C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             CharacterSpawnLocalTransform;                      // 0x0220(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AController>                ControllerClass;                                   // 0x0280(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UPalUserWidgetOverlayUI>    MenuUIWidgetClass;                                 // 0x0288(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalIndividualCharacterSlotsObserver*   CharacterSlotsObserver;                            // 0x0290(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CD9[0x58];                                    // 0x0298(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetDisplaySlots(TArray<class UPalIndividualCharacterSlot*>* Slots);
	void OnSpawnedPhantomCharacter_ServerInternal(const struct FPalInstanceID& IndividualId, const int32 PhantomId);
	void OnUpdateCharacterContainer_ServerInternal();
	void TryMoveToDisplayCage(class UPalIndividualCharacterSlot* FromSlot);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectDisplayCharacterModel">();
	}
	static class UPalMapObjectDisplayCharacterModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectDisplayCharacterModel>();
	}
};
static_assert(alignof(UPalMapObjectDisplayCharacterModel) == 0x000010, "Wrong alignment on UPalMapObjectDisplayCharacterModel");
static_assert(sizeof(UPalMapObjectDisplayCharacterModel) == 0x0002F0, "Wrong size on UPalMapObjectDisplayCharacterModel");
static_assert(offsetof(UPalMapObjectDisplayCharacterModel, RecoverAmountBySec) == 0x000218, "Member 'UPalMapObjectDisplayCharacterModel::RecoverAmountBySec' has a wrong offset!");
static_assert(offsetof(UPalMapObjectDisplayCharacterModel, CharacterSpawnLocalTransform) == 0x000220, "Member 'UPalMapObjectDisplayCharacterModel::CharacterSpawnLocalTransform' has a wrong offset!");
static_assert(offsetof(UPalMapObjectDisplayCharacterModel, ControllerClass) == 0x000280, "Member 'UPalMapObjectDisplayCharacterModel::ControllerClass' has a wrong offset!");
static_assert(offsetof(UPalMapObjectDisplayCharacterModel, MenuUIWidgetClass) == 0x000288, "Member 'UPalMapObjectDisplayCharacterModel::MenuUIWidgetClass' has a wrong offset!");
static_assert(offsetof(UPalMapObjectDisplayCharacterModel, CharacterSlotsObserver) == 0x000290, "Member 'UPalMapObjectDisplayCharacterModel::CharacterSlotsObserver' has a wrong offset!");

// Class Pal.PalMapObjectDisplayCharacterParameterComponent
// 0x0080 (0x0120 - 0x00A0)
class UPalMapObjectDisplayCharacterParameterComponent final : public UActorComponent
{
public:
	int32                                         SlotNum;                                           // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoverAmountBySec;                                // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CDC[0x8];                                     // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             CharacterSpawnLocalTransform;                      // 0x00B0(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AController>                ControllerClass;                                   // 0x0110(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalUserWidgetOverlayUI>    MenuUIWidgetClass;                                 // 0x0118(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectDisplayCharacterParameterComponent">();
	}
	static class UPalMapObjectDisplayCharacterParameterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectDisplayCharacterParameterComponent>();
	}
};
static_assert(alignof(UPalMapObjectDisplayCharacterParameterComponent) == 0x000010, "Wrong alignment on UPalMapObjectDisplayCharacterParameterComponent");
static_assert(sizeof(UPalMapObjectDisplayCharacterParameterComponent) == 0x000120, "Wrong size on UPalMapObjectDisplayCharacterParameterComponent");
static_assert(offsetof(UPalMapObjectDisplayCharacterParameterComponent, SlotNum) == 0x0000A0, "Member 'UPalMapObjectDisplayCharacterParameterComponent::SlotNum' has a wrong offset!");
static_assert(offsetof(UPalMapObjectDisplayCharacterParameterComponent, RecoverAmountBySec) == 0x0000A4, "Member 'UPalMapObjectDisplayCharacterParameterComponent::RecoverAmountBySec' has a wrong offset!");
static_assert(offsetof(UPalMapObjectDisplayCharacterParameterComponent, CharacterSpawnLocalTransform) == 0x0000B0, "Member 'UPalMapObjectDisplayCharacterParameterComponent::CharacterSpawnLocalTransform' has a wrong offset!");
static_assert(offsetof(UPalMapObjectDisplayCharacterParameterComponent, ControllerClass) == 0x000110, "Member 'UPalMapObjectDisplayCharacterParameterComponent::ControllerClass' has a wrong offset!");
static_assert(offsetof(UPalMapObjectDisplayCharacterParameterComponent, MenuUIWidgetClass) == 0x000118, "Member 'UPalMapObjectDisplayCharacterParameterComponent::MenuUIWidgetClass' has a wrong offset!");

// Class Pal.PalMapObjectPickableItemModelBase
// 0x0028 (0x0240 - 0x0218)
class UPalMapObjectPickableItemModelBase : public UPalMapObjectConcreteModelBase
{
public:
	uint8                                         Pad_2CDD[0x18];                                    // 0x0218(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAutoPickedUp;                                     // 0x0230(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CDE[0x7];                                     // 0x0231(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           RemovePickupGuardTimerHandle;                      // 0x0238(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnTimer_RemovePickupGuard();
	void RequestPickup();
	void RequestPickup_ServerInternal(const int32 RequestPlayerId);

	TArray<struct FPalItemAndNum> CreatePickupItemInfo() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectPickableItemModelBase">();
	}
	static class UPalMapObjectPickableItemModelBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectPickableItemModelBase>();
	}
};
static_assert(alignof(UPalMapObjectPickableItemModelBase) == 0x000008, "Wrong alignment on UPalMapObjectPickableItemModelBase");
static_assert(sizeof(UPalMapObjectPickableItemModelBase) == 0x000240, "Wrong size on UPalMapObjectPickableItemModelBase");
static_assert(offsetof(UPalMapObjectPickableItemModelBase, bAutoPickedUp) == 0x000230, "Member 'UPalMapObjectPickableItemModelBase::bAutoPickedUp' has a wrong offset!");
static_assert(offsetof(UPalMapObjectPickableItemModelBase, RemovePickupGuardTimerHandle) == 0x000238, "Member 'UPalMapObjectPickableItemModelBase::RemovePickupGuardTimerHandle' has a wrong offset!");

// Class Pal.PalMapObjectDropItemModel
// 0x0058 (0x0298 - 0x0240)
class UPalMapObjectDropItemModel final : public UPalMapObjectPickableItemModelBase
{
public:
	uint8                                         Pad_2CDF[0x8];                                     // 0x0240(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPalItemId                             ItemId;                                            // 0x0248(0x0028)(BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ReleaseDirection;                                  // 0x0270(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableInteract;                                   // 0x0288(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CE0[0xF];                                     // 0x0289(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEnableTriggerInteract(TScriptInterface<class IPalInteractiveObjectComponentInterface> Component);
	void OnInteractBegin(class AActor* Other, TScriptInterface<class IPalInteractiveObjectComponentInterface> Component);
	void OnInteractEnd(class AActor* Other, TScriptInterface<class IPalInteractiveObjectComponentInterface> Component);
	void OnInteracting(float DeltaTime);
	void OnUpdateItemContainerContentInServer(class UPalItemContainer* Container);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectDropItemModel">();
	}
	static class UPalMapObjectDropItemModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectDropItemModel>();
	}
};
static_assert(alignof(UPalMapObjectDropItemModel) == 0x000008, "Wrong alignment on UPalMapObjectDropItemModel");
static_assert(sizeof(UPalMapObjectDropItemModel) == 0x000298, "Wrong size on UPalMapObjectDropItemModel");
static_assert(offsetof(UPalMapObjectDropItemModel, ItemId) == 0x000248, "Member 'UPalMapObjectDropItemModel::ItemId' has a wrong offset!");
static_assert(offsetof(UPalMapObjectDropItemModel, ReleaseDirection) == 0x000270, "Member 'UPalMapObjectDropItemModel::ReleaseDirection' has a wrong offset!");
static_assert(offsetof(UPalMapObjectDropItemModel, bEnableInteract) == 0x000288, "Member 'UPalMapObjectDropItemModel::bEnableInteract' has a wrong offset!");

// Class Pal.PalMapObjectFarmBlockV2Model
// 0x0068 (0x0280 - 0x0218)
class UPalMapObjectFarmBlockV2Model final : public UPalMapObjectConcreteModelBase
{
public:
	uint8                                         Pad_2CE1[0x8];                                     // 0x0218(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnUpdateStateDelegate;                             // 0x0220(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FReactivePropertyFloat                 CropProgressRate;                                  // 0x0230(0x0018)(BlueprintVisible, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FReactivePropertyFloat                 WaterStackRate;                                    // 0x0248(0x0018)(BlueprintVisible, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalMapObjectFarmBlockV2ModelStateBehaviourMachine* StateBehaviourMachine;                             // 0x0260(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CurrentCropDataId;                                 // 0x0268(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPalFarmCropState                             CurrentState;                                      // 0x0270(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CE2[0x3];                                     // 0x0271(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CropProgressRateValue;                             // 0x0274(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WaterStackRateValue;                               // 0x0278(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CE3[0x4];                                     // 0x027C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NotifySimpleDelegate__DelegateSignature();
	void OnRep_CropProgressRateValue();
	void OnRep_CurrentState();
	void OnRep_WaterStackRateValue();
	void OnUpdateCropProgressRate(const float ProgressRate);
	void OnUpdateWaterStackRate(const float UpdatedRate);
	void UpdateStateDelegate__DelegateSignature(EPalFarmCropState LastState, EPalFarmCropState NextState);

	class FName GetCurrentCropDataId() const;
	EPalFarmCropState GetCurrentState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectFarmBlockV2Model">();
	}
	static class UPalMapObjectFarmBlockV2Model* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectFarmBlockV2Model>();
	}
};
static_assert(alignof(UPalMapObjectFarmBlockV2Model) == 0x000008, "Wrong alignment on UPalMapObjectFarmBlockV2Model");
static_assert(sizeof(UPalMapObjectFarmBlockV2Model) == 0x000280, "Wrong size on UPalMapObjectFarmBlockV2Model");
static_assert(offsetof(UPalMapObjectFarmBlockV2Model, OnUpdateStateDelegate) == 0x000220, "Member 'UPalMapObjectFarmBlockV2Model::OnUpdateStateDelegate' has a wrong offset!");
static_assert(offsetof(UPalMapObjectFarmBlockV2Model, CropProgressRate) == 0x000230, "Member 'UPalMapObjectFarmBlockV2Model::CropProgressRate' has a wrong offset!");
static_assert(offsetof(UPalMapObjectFarmBlockV2Model, WaterStackRate) == 0x000248, "Member 'UPalMapObjectFarmBlockV2Model::WaterStackRate' has a wrong offset!");
static_assert(offsetof(UPalMapObjectFarmBlockV2Model, StateBehaviourMachine) == 0x000260, "Member 'UPalMapObjectFarmBlockV2Model::StateBehaviourMachine' has a wrong offset!");
static_assert(offsetof(UPalMapObjectFarmBlockV2Model, CurrentCropDataId) == 0x000268, "Member 'UPalMapObjectFarmBlockV2Model::CurrentCropDataId' has a wrong offset!");
static_assert(offsetof(UPalMapObjectFarmBlockV2Model, CurrentState) == 0x000270, "Member 'UPalMapObjectFarmBlockV2Model::CurrentState' has a wrong offset!");
static_assert(offsetof(UPalMapObjectFarmBlockV2Model, CropProgressRateValue) == 0x000274, "Member 'UPalMapObjectFarmBlockV2Model::CropProgressRateValue' has a wrong offset!");
static_assert(offsetof(UPalMapObjectFarmBlockV2Model, WaterStackRateValue) == 0x000278, "Member 'UPalMapObjectFarmBlockV2Model::WaterStackRateValue' has a wrong offset!");

// Class Pal.PalMapObjectFarmBlockV2ModelStateBehaviourHarvestable
// 0x0018 (0x0048 - 0x0030)
class UPalMapObjectFarmBlockV2ModelStateBehaviourHarvestable final : public UPalMapObjectFarmBlockV2ModelStateBehaviourBase
{
public:
	uint8                                         Pad_2CE4[0x18];                                    // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFinishWorkInServer(class UPalWorkBase* Work);
	void OnProgressWork(class UPalWorkProgress* WorkProgress);
	void OnWorkStarted(class UPalWorkBase* Work, const struct FPalInstanceID& IndividualId);
	void UpdateHarvestProgressRateDelegate__DelegateSignature(float ProgressRate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectFarmBlockV2ModelStateBehaviourHarvestable">();
	}
	static class UPalMapObjectFarmBlockV2ModelStateBehaviourHarvestable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectFarmBlockV2ModelStateBehaviourHarvestable>();
	}
};
static_assert(alignof(UPalMapObjectFarmBlockV2ModelStateBehaviourHarvestable) == 0x000008, "Wrong alignment on UPalMapObjectFarmBlockV2ModelStateBehaviourHarvestable");
static_assert(sizeof(UPalMapObjectFarmBlockV2ModelStateBehaviourHarvestable) == 0x000048, "Wrong size on UPalMapObjectFarmBlockV2ModelStateBehaviourHarvestable");

// Class Pal.PalMapObjectFarmCrop
// 0x0010 (0x02A0 - 0x0290)
class APalMapObjectFarmCrop final : public AActor
{
public:
	TArray<struct FPalFarmCropGrowupProcessSet>   GrowupProcessSets;                                 // 0x0290(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectFarmCrop">();
	}
	static class APalMapObjectFarmCrop* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalMapObjectFarmCrop>();
	}
};
static_assert(alignof(APalMapObjectFarmCrop) == 0x000008, "Wrong alignment on APalMapObjectFarmCrop");
static_assert(sizeof(APalMapObjectFarmCrop) == 0x0002A0, "Wrong size on APalMapObjectFarmCrop");
static_assert(offsetof(APalMapObjectFarmCrop, GrowupProcessSets) == 0x000290, "Member 'APalMapObjectFarmCrop::GrowupProcessSets' has a wrong offset!");

// Class Pal.PalMapObjectFastTravelPointModel
// 0x0010 (0x0228 - 0x0218)
class UPalMapObjectFastTravelPointModel final : public UPalMapObjectConcreteModelBase
{
public:
	struct FGuid                                  LocationInstanceId;                                // 0x0218(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectFastTravelPointModel">();
	}
	static class UPalMapObjectFastTravelPointModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectFastTravelPointModel>();
	}
};
static_assert(alignof(UPalMapObjectFastTravelPointModel) == 0x000008, "Wrong alignment on UPalMapObjectFastTravelPointModel");
static_assert(sizeof(UPalMapObjectFastTravelPointModel) == 0x000228, "Wrong size on UPalMapObjectFastTravelPointModel");
static_assert(offsetof(UPalMapObjectFastTravelPointModel, LocationInstanceId) == 0x000218, "Member 'UPalMapObjectFastTravelPointModel::LocationInstanceId' has a wrong offset!");

// Class Pal.PalMapObjectFoliage
// 0x0118 (0x0140 - 0x0028)
class UPalMapObjectFoliage final : public UObject
{
public:
	uint8                                         Pad_2CE5[0x10];                                    // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalFoliagePresetDataSet*               PresetDataSet;                                     // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FName, class UPalFoliageType_InstancedStaticMesh*> UsedPalFoliageTypeMap;                             // 0x0040(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	TSet<EPalFoliagePresetType>                   LoadedPresetTypeSet;                               // 0x0090(0x0050)(Transient, NativeAccessSpecifierPrivate)
	int32                                         GridSize;                                          // 0x00E0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CE6[0x4];                                     // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FPalCellCoord, class UPalFoliageGridModel*> GridModelMap;                                      // 0x00E8(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CE7[0x8];                                     // 0x0138(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectFoliage">();
	}
	static class UPalMapObjectFoliage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectFoliage>();
	}
};
static_assert(alignof(UPalMapObjectFoliage) == 0x000008, "Wrong alignment on UPalMapObjectFoliage");
static_assert(sizeof(UPalMapObjectFoliage) == 0x000140, "Wrong size on UPalMapObjectFoliage");
static_assert(offsetof(UPalMapObjectFoliage, PresetDataSet) == 0x000038, "Member 'UPalMapObjectFoliage::PresetDataSet' has a wrong offset!");
static_assert(offsetof(UPalMapObjectFoliage, UsedPalFoliageTypeMap) == 0x000040, "Member 'UPalMapObjectFoliage::UsedPalFoliageTypeMap' has a wrong offset!");
static_assert(offsetof(UPalMapObjectFoliage, LoadedPresetTypeSet) == 0x000090, "Member 'UPalMapObjectFoliage::LoadedPresetTypeSet' has a wrong offset!");
static_assert(offsetof(UPalMapObjectFoliage, GridSize) == 0x0000E0, "Member 'UPalMapObjectFoliage::GridSize' has a wrong offset!");
static_assert(offsetof(UPalMapObjectFoliage, GridModelMap) == 0x0000E8, "Member 'UPalMapObjectFoliage::GridModelMap' has a wrong offset!");

// Class Pal.PalMapObjectGateModel
// 0x0058 (0x0270 - 0x0218)
class UPalMapObjectGateModel final : public UPalMapObjectConcreteModelBase
{
public:
	struct FGameDateTime                          UnlockDateTime;                                    // 0x0218(0x0008)(Edit, Net, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FPalInstanceID, TWeakObjectPtr<class UPalIndividualCharacterParameter>> WeakInteractingCharacterParameters;                // 0x0220(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	void OnInteractBegin(class AActor* Other, TScriptInterface<class IPalInteractiveObjectComponentInterface> Component);
	void OnInteractEnd(class AActor* Other, TScriptInterface<class IPalInteractiveObjectComponentInterface> Component);
	void RequestTrigger_ServerInternal(const int32 RequestPlayerId, const int32 ToStateInt);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectGateModel">();
	}
	static class UPalMapObjectGateModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectGateModel>();
	}
};
static_assert(alignof(UPalMapObjectGateModel) == 0x000008, "Wrong alignment on UPalMapObjectGateModel");
static_assert(sizeof(UPalMapObjectGateModel) == 0x000270, "Wrong size on UPalMapObjectGateModel");
static_assert(offsetof(UPalMapObjectGateModel, UnlockDateTime) == 0x000218, "Member 'UPalMapObjectGateModel::UnlockDateTime' has a wrong offset!");
static_assert(offsetof(UPalMapObjectGateModel, WeakInteractingCharacterParameters) == 0x000220, "Member 'UPalMapObjectGateModel::WeakInteractingCharacterParameters' has a wrong offset!");

// Class Pal.PalMapObjectGenerateEnergyModel
// 0x0030 (0x0248 - 0x0218)
class UPalMapObjectGenerateEnergyModel final : public UPalMapObjectConcreteModelBase
{
public:
	uint8                                         Pad_2CE8[0x8];                                     // 0x0218(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnUpdateStoredEnergyAmountDelegate;                // 0x0220(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EPalEnergyType                                EnergyType;                                        // 0x0230(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CE9[0x3];                                     // 0x0231(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GenerateEnergyRateByWorker;                        // 0x0234(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxEnergyStorage;                                  // 0x0238(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StoredEnergyAmount;                                // 0x023C(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ConsumeEnergySpeed;                                // 0x0240(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CEA[0x4];                                     // 0x0244(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_StoredEnergyAmount();
	void OnUpdateAssignedCharacter_ServerInternal(class UPalWorkBase* Work);
	void UpdateEnergyAmountDelegate__DelegateSignature(class UPalMapObjectGenerateEnergyModel* Model);

	EPalEnergyType GetEnergyType() const;
	float GetMaxEnergyStorage() const;
	float GetStoredEnergyAmount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectGenerateEnergyModel">();
	}
	static class UPalMapObjectGenerateEnergyModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectGenerateEnergyModel>();
	}
};
static_assert(alignof(UPalMapObjectGenerateEnergyModel) == 0x000008, "Wrong alignment on UPalMapObjectGenerateEnergyModel");
static_assert(sizeof(UPalMapObjectGenerateEnergyModel) == 0x000248, "Wrong size on UPalMapObjectGenerateEnergyModel");
static_assert(offsetof(UPalMapObjectGenerateEnergyModel, OnUpdateStoredEnergyAmountDelegate) == 0x000220, "Member 'UPalMapObjectGenerateEnergyModel::OnUpdateStoredEnergyAmountDelegate' has a wrong offset!");
static_assert(offsetof(UPalMapObjectGenerateEnergyModel, EnergyType) == 0x000230, "Member 'UPalMapObjectGenerateEnergyModel::EnergyType' has a wrong offset!");
static_assert(offsetof(UPalMapObjectGenerateEnergyModel, GenerateEnergyRateByWorker) == 0x000234, "Member 'UPalMapObjectGenerateEnergyModel::GenerateEnergyRateByWorker' has a wrong offset!");
static_assert(offsetof(UPalMapObjectGenerateEnergyModel, MaxEnergyStorage) == 0x000238, "Member 'UPalMapObjectGenerateEnergyModel::MaxEnergyStorage' has a wrong offset!");
static_assert(offsetof(UPalMapObjectGenerateEnergyModel, StoredEnergyAmount) == 0x00023C, "Member 'UPalMapObjectGenerateEnergyModel::StoredEnergyAmount' has a wrong offset!");
static_assert(offsetof(UPalMapObjectGenerateEnergyModel, ConsumeEnergySpeed) == 0x000240, "Member 'UPalMapObjectGenerateEnergyModel::ConsumeEnergySpeed' has a wrong offset!");

// Class Pal.PalMapObjectGenerateEnergyParameterComponent
// 0x0010 (0x00B0 - 0x00A0)
class UPalMapObjectGenerateEnergyParameterComponent final : public UActorComponent
{
public:
	EPalEnergyType                                GenerateEnergyType;                                // 0x00A0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CEB[0x3];                                     // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GenerateEnergyRateByWorker;                        // 0x00A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxEnergyStorage;                                  // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CEC[0x4];                                     // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectGenerateEnergyParameterComponent">();
	}
	static class UPalMapObjectGenerateEnergyParameterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectGenerateEnergyParameterComponent>();
	}
};
static_assert(alignof(UPalMapObjectGenerateEnergyParameterComponent) == 0x000008, "Wrong alignment on UPalMapObjectGenerateEnergyParameterComponent");
static_assert(sizeof(UPalMapObjectGenerateEnergyParameterComponent) == 0x0000B0, "Wrong size on UPalMapObjectGenerateEnergyParameterComponent");
static_assert(offsetof(UPalMapObjectGenerateEnergyParameterComponent, GenerateEnergyType) == 0x0000A0, "Member 'UPalMapObjectGenerateEnergyParameterComponent::GenerateEnergyType' has a wrong offset!");
static_assert(offsetof(UPalMapObjectGenerateEnergyParameterComponent, GenerateEnergyRateByWorker) == 0x0000A4, "Member 'UPalMapObjectGenerateEnergyParameterComponent::GenerateEnergyRateByWorker' has a wrong offset!");
static_assert(offsetof(UPalMapObjectGenerateEnergyParameterComponent, MaxEnergyStorage) == 0x0000A8, "Member 'UPalMapObjectGenerateEnergyParameterComponent::MaxEnergyStorage' has a wrong offset!");

// Class Pal.PalHUDDispatchParameter_HatchingEgg
// 0x0008 (0x0040 - 0x0038)
class UPalHUDDispatchParameter_HatchingEgg final : public UPalHUDDispatchParameterBase
{
public:
	class UPalMapObjectHatchingEggModel*          HatchingEggModel;                                  // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalHUDDispatchParameter_HatchingEgg">();
	}
	static class UPalHUDDispatchParameter_HatchingEgg* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalHUDDispatchParameter_HatchingEgg>();
	}
};
static_assert(alignof(UPalHUDDispatchParameter_HatchingEgg) == 0x000008, "Wrong alignment on UPalHUDDispatchParameter_HatchingEgg");
static_assert(sizeof(UPalHUDDispatchParameter_HatchingEgg) == 0x000040, "Wrong size on UPalHUDDispatchParameter_HatchingEgg");
static_assert(offsetof(UPalHUDDispatchParameter_HatchingEgg, HatchingEggModel) == 0x000038, "Member 'UPalHUDDispatchParameter_HatchingEgg::HatchingEggModel' has a wrong offset!");

// Class Pal.PalMapObjectHatchingEggParameterComponent
// 0x0010 (0x00B0 - 0x00A0)
class UPalMapObjectHatchingEggParameterComponent final : public UActorComponent
{
public:
	float                                         AutoWorkAmountBySec;                               // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CED[0x4];                                     // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UPalUserWidgetOverlayUI>    MenuUIWidgetClass;                                 // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	float GetDefaultAutoWorkAmountBySec();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectHatchingEggParameterComponent">();
	}
	static class UPalMapObjectHatchingEggParameterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectHatchingEggParameterComponent>();
	}
};
static_assert(alignof(UPalMapObjectHatchingEggParameterComponent) == 0x000008, "Wrong alignment on UPalMapObjectHatchingEggParameterComponent");
static_assert(sizeof(UPalMapObjectHatchingEggParameterComponent) == 0x0000B0, "Wrong size on UPalMapObjectHatchingEggParameterComponent");
static_assert(offsetof(UPalMapObjectHatchingEggParameterComponent, AutoWorkAmountBySec) == 0x0000A0, "Member 'UPalMapObjectHatchingEggParameterComponent::AutoWorkAmountBySec' has a wrong offset!");
static_assert(offsetof(UPalMapObjectHatchingEggParameterComponent, MenuUIWidgetClass) == 0x0000A8, "Member 'UPalMapObjectHatchingEggParameterComponent::MenuUIWidgetClass' has a wrong offset!");

// Class Pal.PalMapObjectHeatSourceModel
// 0x0000 (0x0218 - 0x0218)
class UPalMapObjectHeatSourceModel final : public UPalMapObjectConcreteModelBase
{
public:
	void OnUpdateAssignedCharacter_ServerInternal(class UPalWorkBase* Work);
	void OnUpdateEnergyModuleState_ServerInternal(class UPalMapObjectEnergyModule* EnergyModule);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectHeatSourceModel">();
	}
	static class UPalMapObjectHeatSourceModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectHeatSourceModel>();
	}
};
static_assert(alignof(UPalMapObjectHeatSourceModel) == 0x000008, "Wrong alignment on UPalMapObjectHeatSourceModel");
static_assert(sizeof(UPalMapObjectHeatSourceModel) == 0x000218, "Wrong size on UPalMapObjectHeatSourceModel");

// Class Pal.PalMapObjectItemChest_AffectCorruption
// 0x0000 (0x0228 - 0x0228)
class UPalMapObjectItemChest_AffectCorruption final : public UPalMapObjectItemChestModel
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectItemChest_AffectCorruption">();
	}
	static class UPalMapObjectItemChest_AffectCorruption* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectItemChest_AffectCorruption>();
	}
};
static_assert(alignof(UPalMapObjectItemChest_AffectCorruption) == 0x000008, "Wrong alignment on UPalMapObjectItemChest_AffectCorruption");
static_assert(sizeof(UPalMapObjectItemChest_AffectCorruption) == 0x000228, "Wrong size on UPalMapObjectItemChest_AffectCorruption");

// Class Pal.PalMapObjectItemContainerModule
// 0x00F0 (0x0120 - 0x0030)
class alignas(0x10) UPalMapObjectItemContainerModule final : public UPalMapObjectConcreteModelModuleBase
{
public:
	uint8                                         Pad_2CEE[0x30];                                    // 0x0030(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalItemContainer*                      TargetContainer;                                   // 0x0060(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDropItemAtDisposed;                               // 0x0068(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CEF[0x7];                                     // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPalMapObjectItemContainerModuleSlotIndexes> SlotAttributeIndexes;                              // 0x0070(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	TArray<EPalMapObjectItemContainerSlotAttribute> AllSlotAttribute;                                  // 0x0080(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CF0[0x80];                                    // 0x0090(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	EPalContainerUsageType                        UsageType;                                         // 0x0110(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CF1[0xF];                                     // 0x0111(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindUpdateContents(TDelegate<void(class UPalMapObjectItemContainerModule* Module)> Delegate);
	void UpdateContentsDelegate__DelegateSignature(class UPalMapObjectItemContainerModule* Module);
	void OnRep_TargetContainer();
	void OnUpdateContents(class UPalItemContainer* Container);
	void OnUpdateFilterPreference(class UPalItemContainer* Container);
	void RequestChangeAllFilterCheck_ServerInternal();
	void RequestChangeAllFilterUncheck_ServerInternal();
	void RequestChangeFilter_ServerInternal(const int32 RequestPlayerId, const struct FPalNetArchive& Archive);
	void RequestSortContainer();
	void RequestSortContainer_ServerInternal();
	void UnbindUpdateContents(TDelegate<void(class UPalMapObjectItemContainerModule* Module)> Delegate);
	void UpdateContentsMulticastDelegate__DelegateSignature(class UPalMapObjectItemContainerModule* Module);

	class UPalItemContainer* GetContainer() const;
	const struct FPalContainerId GetContainerId() const;
	TArray<class FName> GetFilterOffList() const;
	bool TryGetContainer(class UPalItemContainer** OutContainer) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectItemContainerModule">();
	}
	static class UPalMapObjectItemContainerModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectItemContainerModule>();
	}
};
static_assert(alignof(UPalMapObjectItemContainerModule) == 0x000010, "Wrong alignment on UPalMapObjectItemContainerModule");
static_assert(sizeof(UPalMapObjectItemContainerModule) == 0x000120, "Wrong size on UPalMapObjectItemContainerModule");
static_assert(offsetof(UPalMapObjectItemContainerModule, TargetContainer) == 0x000060, "Member 'UPalMapObjectItemContainerModule::TargetContainer' has a wrong offset!");
static_assert(offsetof(UPalMapObjectItemContainerModule, bDropItemAtDisposed) == 0x000068, "Member 'UPalMapObjectItemContainerModule::bDropItemAtDisposed' has a wrong offset!");
static_assert(offsetof(UPalMapObjectItemContainerModule, SlotAttributeIndexes) == 0x000070, "Member 'UPalMapObjectItemContainerModule::SlotAttributeIndexes' has a wrong offset!");
static_assert(offsetof(UPalMapObjectItemContainerModule, AllSlotAttribute) == 0x000080, "Member 'UPalMapObjectItemContainerModule::AllSlotAttribute' has a wrong offset!");
static_assert(offsetof(UPalMapObjectItemContainerModule, UsageType) == 0x000110, "Member 'UPalMapObjectItemContainerModule::UsageType' has a wrong offset!");

// Class Pal.PalMapObjectItemSimpleProductParameterComponent
// 0x0018 (0x00B8 - 0x00A0)
class UPalMapObjectItemSimpleProductParameterComponent final : public UActorComponent
{
public:
	struct FPalDataTableRowName_ItemProductData   ItemProductId;                                     // 0x00A0(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotNum;                                           // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorkSpeedAdditionalRate;                           // 0x00AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsGainExp;                                        // 0x00B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CF4[0x7];                                     // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectItemSimpleProductParameterComponent">();
	}
	static class UPalMapObjectItemSimpleProductParameterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectItemSimpleProductParameterComponent>();
	}
};
static_assert(alignof(UPalMapObjectItemSimpleProductParameterComponent) == 0x000008, "Wrong alignment on UPalMapObjectItemSimpleProductParameterComponent");
static_assert(sizeof(UPalMapObjectItemSimpleProductParameterComponent) == 0x0000B8, "Wrong size on UPalMapObjectItemSimpleProductParameterComponent");
static_assert(offsetof(UPalMapObjectItemSimpleProductParameterComponent, ItemProductId) == 0x0000A0, "Member 'UPalMapObjectItemSimpleProductParameterComponent::ItemProductId' has a wrong offset!");
static_assert(offsetof(UPalMapObjectItemSimpleProductParameterComponent, SlotNum) == 0x0000A8, "Member 'UPalMapObjectItemSimpleProductParameterComponent::SlotNum' has a wrong offset!");
static_assert(offsetof(UPalMapObjectItemSimpleProductParameterComponent, WorkSpeedAdditionalRate) == 0x0000AC, "Member 'UPalMapObjectItemSimpleProductParameterComponent::WorkSpeedAdditionalRate' has a wrong offset!");
static_assert(offsetof(UPalMapObjectItemSimpleProductParameterComponent, bIsGainExp) == 0x0000B0, "Member 'UPalMapObjectItemSimpleProductParameterComponent::bIsGainExp' has a wrong offset!");

// Class Pal.PalMapObjectLocationComponent
// 0x0010 (0x00B0 - 0x00A0)
class UPalMapObjectLocationComponent final : public UActorComponent
{
public:
	struct FGuid                                  LocationId;                                        // 0x00A0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SetLocationId();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectLocationComponent">();
	}
	static class UPalMapObjectLocationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectLocationComponent>();
	}
};
static_assert(alignof(UPalMapObjectLocationComponent) == 0x000008, "Wrong alignment on UPalMapObjectLocationComponent");
static_assert(sizeof(UPalMapObjectLocationComponent) == 0x0000B0, "Wrong size on UPalMapObjectLocationComponent");
static_assert(offsetof(UPalMapObjectLocationComponent, LocationId) == 0x0000A0, "Member 'UPalMapObjectLocationComponent::LocationId' has a wrong offset!");

// Class Pal.PalMapObjectSpawnRequestHandler
// 0x00A8 (0x00D0 - 0x0028)
class UPalMapObjectSpawnRequestHandler final : public UObject
{
public:
	uint8                                         Pad_2CF5[0x68];                                    // 0x0028(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPalMapObjectModelInitializeExtraParameters ExtraParameters;                                   // 0x0090(0x0028)(NativeAccessSpecifierPublic)
	uint8                                         Pad_2CF6[0x18];                                    // 0x00B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectSpawnRequestHandler">();
	}
	static class UPalMapObjectSpawnRequestHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectSpawnRequestHandler>();
	}
};
static_assert(alignof(UPalMapObjectSpawnRequestHandler) == 0x000008, "Wrong alignment on UPalMapObjectSpawnRequestHandler");
static_assert(sizeof(UPalMapObjectSpawnRequestHandler) == 0x0000D0, "Wrong size on UPalMapObjectSpawnRequestHandler");
static_assert(offsetof(UPalMapObjectSpawnRequestHandler, ExtraParameters) == 0x000090, "Member 'UPalMapObjectSpawnRequestHandler::ExtraParameters' has a wrong offset!");

// Class Pal.PalMapObjectManager
// 0x0738 (0x07A8 - 0x0070)
class UPalMapObjectManager : public UPalWorldSubsystem
{
public:
	uint8                                         Pad_2CF7[0x48];                                    // 0x0070(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnCreateMapObjectModelInServerDelegate;            // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepMapObjectModelDelegate;                       // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSpawnedMapObjectModelByInServerDelegate;         // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CF8[0x18];                                    // 0x00E8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TScriptInterface<class IPalBuildObjectSpawnValidationCheckInterface>> BuildSpawnValidationCheckers;                      // 0x0100(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	class UDataTable*                             BuildObjectDataTable;                              // 0x0110(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             BuildObjectNameTable;                              // 0x0118(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             BuildObjectDescTable;                              // 0x0120(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             MapObjectAssignTable;                              // 0x0128(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBuildingSurfaceMaterialSet            BuildingSurfaceMaterialSet;                        // 0x0130(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UPalFoliagePresetDataSet*               FoliagePresetDataSet;                              // 0x0168(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class APalFoliageModelChunk>      FoliageModelChunkClass;                            // 0x0170(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FoliageGridSize;                                   // 0x0178(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CF9[0x4];                                     // 0x017C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalMapObjectFoliage*                   Foliage;                                           // 0x0180(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalBuildOperator*                      BuildOperator;                                     // 0x0188(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalMapObjectWorldDisposer*             WorldDisposerForServer;                            // 0x0190(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FGuid, class UPalMapObjectModel*> MapObjectModelMapForServer;                        // 0x0198(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGuid, class UPalMapObjectConcreteModelBase*> MapObjectConcreteModelMapForServer;                // 0x01E8(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CFA[0xF0];                                    // 0x0238(0x00F0)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FPalMapObjectModelStaticData> MapObjectModelStaticDataCacheMap;                  // 0x0328(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	struct FPalMapObjectStaticData                StaticData;                                        // 0x0378(0x0048)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   DropItemMapObjectId;                               // 0x03C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BuildObjectId_PalStorage;                          // 0x03C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<EObjectTypeQuery>                      SearchObjectTypes;                                 // 0x03D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CFB[0x8];                                     // 0x03E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EPalMapObjectDestroyFXType, class UNiagaraSystem*> DestroyEffectMap;                                  // 0x03E8(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FName                                   MapObjectDestroyFXUserParamName_BoxSize;           // 0x0438(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MapObjectDestroyFXUserParamName_BoxSurfaceArea;    // 0x0440(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         BuildStartEffect;                                  // 0x0448(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         BuildCompleteEffect;                               // 0x0450(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BuildFXUserParamName_BoxCenter;                    // 0x0458(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BuildFXUserParamName_BoxSize;                      // 0x0460(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BuildFXUserParamName_BoxSurfaceArea;               // 0x0468(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          BuildCompleteSE;                                   // 0x0470(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         RepairEffect;                                      // 0x0478(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         DamageEffect;                                      // 0x0480(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DamageFXUserParamName_Alpha;                       // 0x0488(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DamageFXUserParamName_Rate;                        // 0x0490(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DamageFXUserParamName_Scale;                       // 0x0498(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DamageFXUserParamName_RadiusScale;                 // 0x04A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DamageFXUserParamName_AddRate;                     // 0x04A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DamageFXUserParamName_EndAlpha;                    // 0x04B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageParam_MaxRate;                               // 0x04B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageParam_MaxAddRate;                            // 0x04BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageParam_MaxScale;                              // 0x04C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageParam_MaxRadiusScale;                        // 0x04C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageParam_RadiusScaleMultiplier;                 // 0x04C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageFX_StartHPRate;                              // 0x04CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageFX_DefaultBoundsSphereRadius;                // 0x04D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CFC[0x4];                                     // 0x04D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DamageFX_SpanwLocationOffset;                      // 0x04D8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageFX_EndFadeTime;                              // 0x04F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DropItemSpawnLocationFromActorBounds;              // 0x04F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DropItemSpawnDirectionZ;                           // 0x04F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CFD[0x4];                                     // 0x04FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                FoliageDropItemSpawnOffset;                        // 0x0500(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                DropItemReleaseDirectionRelative;                  // 0x0518(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                FoliageDestroyFXExtentsDefault;                    // 0x0530(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UPalHitEffectSlot>          HitEffectSlotClass;                                // 0x0548(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EPalMapObjectChangeMeshFXType, class UNiagaraSystem*> ChangeMeshEffectMap;                               // 0x0550(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FPalMapObjectVisualEffectAssets        VisualEffectAssets;                                // 0x05A0(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<EPalMapObjectTreasureGradeType, struct FPalDataTableRowName_ItemData> TreasureBoxOpenRequiredItemMap;                    // 0x05F0(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGuid, class UPalMapObjectModel*> MapObjectModelHandlingMap;                         // 0x0640(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CFE[0x10];                                    // 0x0690(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APalMapObject*>                  LevelMapObjectsToRegister;                         // 0x06A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class APalTestMapObjectRegistrationToManager* Registrator;                                       // 0x06B0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CFF[0x8];                                     // 0x06B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGuid, class UPalMapObjectSpawnRequestHandler*> SpawnRequestHandlerMap;                            // 0x06C0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D00[0x48];                                    // 0x0710(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InDoorCheckProcessIndex_AnyThread;                 // 0x0758(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         InDoorCheckMaxNumPerFrame_AnyThread;               // 0x075C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class APalMapObjectSpawnerBase*>       SpawnedSpawners;                                   // 0x0760(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class UObject>>         SkeletalLODComponentArrayExec;                     // 0x0770(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class UObject>>         SkeletalLODComponentArrayWait;                     // 0x0780(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D01[0x8];                                     // 0x0790(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class UObject>>         PointLightComponents;                              // 0x0798(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	void MapObjectModelDynamicDelegate__DelegateSignature(class UPalMapObjectModel* MapObjectModel);
	void MapObjectModelInterfaceDelegate__DelegateSignature(TScriptInterface<class IPalMapObjectModelInterface> MapObjectModel);
	void MapObjectModelSpawnedByDelegate__DelegateSignature(class UPalMapObjectModel* MapObjectModel, class UPalMapObjectModelInitializeExtraParameterSpawnedBy* SpawnedBy);
	void MapObjectModelWithVectorDelegate__DelegateSignature(class UPalMapObjectModel* MapObjectModel, const struct FVector& Vector);
	void RecalcPointLightOverlap();
	void RequestDismantleObject_OnResponseDialog(const bool bResult, class UPalDialogParameterBase* DialogParameter);
	void ResisterPointLightComponent(class UObject* InComponent);
	void ResisterSkeletalMeshComponentForLOD(class UObject* InComponent);
	void UnResisterPointLightComponent(class UObject* InComponent);
	void UnResisterSkeletalMeshComponentForLOD(class UObject* InComponent);
	void UpdatePointLightComponentForCulling();
	void UpdateSkeletalMeshComponentForLOD(int32 InExecuteCount);

	class UPalMapObjectConcreteModelBase* FindConcreteModel(const struct FGuid& InstanceId) const;
	class UPalMapObjectModel* FindModel(const struct FGuid& InstanceId) const;
	class UPalBuildOperator* GetBuildOperator() const;
	class UPalMapObjectFoliage* GetFoliage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectManager">();
	}
	static class UPalMapObjectManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectManager>();
	}
};
static_assert(alignof(UPalMapObjectManager) == 0x000008, "Wrong alignment on UPalMapObjectManager");
static_assert(sizeof(UPalMapObjectManager) == 0x0007A8, "Wrong size on UPalMapObjectManager");
static_assert(offsetof(UPalMapObjectManager, OnCreateMapObjectModelInServerDelegate) == 0x0000B8, "Member 'UPalMapObjectManager::OnCreateMapObjectModelInServerDelegate' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, OnRepMapObjectModelDelegate) == 0x0000C8, "Member 'UPalMapObjectManager::OnRepMapObjectModelDelegate' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, OnSpawnedMapObjectModelByInServerDelegate) == 0x0000D8, "Member 'UPalMapObjectManager::OnSpawnedMapObjectModelByInServerDelegate' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, BuildSpawnValidationCheckers) == 0x000100, "Member 'UPalMapObjectManager::BuildSpawnValidationCheckers' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, BuildObjectDataTable) == 0x000110, "Member 'UPalMapObjectManager::BuildObjectDataTable' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, BuildObjectNameTable) == 0x000118, "Member 'UPalMapObjectManager::BuildObjectNameTable' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, BuildObjectDescTable) == 0x000120, "Member 'UPalMapObjectManager::BuildObjectDescTable' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, MapObjectAssignTable) == 0x000128, "Member 'UPalMapObjectManager::MapObjectAssignTable' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, BuildingSurfaceMaterialSet) == 0x000130, "Member 'UPalMapObjectManager::BuildingSurfaceMaterialSet' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, FoliagePresetDataSet) == 0x000168, "Member 'UPalMapObjectManager::FoliagePresetDataSet' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, FoliageModelChunkClass) == 0x000170, "Member 'UPalMapObjectManager::FoliageModelChunkClass' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, FoliageGridSize) == 0x000178, "Member 'UPalMapObjectManager::FoliageGridSize' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, Foliage) == 0x000180, "Member 'UPalMapObjectManager::Foliage' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, BuildOperator) == 0x000188, "Member 'UPalMapObjectManager::BuildOperator' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, WorldDisposerForServer) == 0x000190, "Member 'UPalMapObjectManager::WorldDisposerForServer' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, MapObjectModelMapForServer) == 0x000198, "Member 'UPalMapObjectManager::MapObjectModelMapForServer' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, MapObjectConcreteModelMapForServer) == 0x0001E8, "Member 'UPalMapObjectManager::MapObjectConcreteModelMapForServer' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, MapObjectModelStaticDataCacheMap) == 0x000328, "Member 'UPalMapObjectManager::MapObjectModelStaticDataCacheMap' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, StaticData) == 0x000378, "Member 'UPalMapObjectManager::StaticData' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, DropItemMapObjectId) == 0x0003C0, "Member 'UPalMapObjectManager::DropItemMapObjectId' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, BuildObjectId_PalStorage) == 0x0003C8, "Member 'UPalMapObjectManager::BuildObjectId_PalStorage' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, SearchObjectTypes) == 0x0003D0, "Member 'UPalMapObjectManager::SearchObjectTypes' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, DestroyEffectMap) == 0x0003E8, "Member 'UPalMapObjectManager::DestroyEffectMap' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, MapObjectDestroyFXUserParamName_BoxSize) == 0x000438, "Member 'UPalMapObjectManager::MapObjectDestroyFXUserParamName_BoxSize' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, MapObjectDestroyFXUserParamName_BoxSurfaceArea) == 0x000440, "Member 'UPalMapObjectManager::MapObjectDestroyFXUserParamName_BoxSurfaceArea' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, BuildStartEffect) == 0x000448, "Member 'UPalMapObjectManager::BuildStartEffect' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, BuildCompleteEffect) == 0x000450, "Member 'UPalMapObjectManager::BuildCompleteEffect' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, BuildFXUserParamName_BoxCenter) == 0x000458, "Member 'UPalMapObjectManager::BuildFXUserParamName_BoxCenter' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, BuildFXUserParamName_BoxSize) == 0x000460, "Member 'UPalMapObjectManager::BuildFXUserParamName_BoxSize' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, BuildFXUserParamName_BoxSurfaceArea) == 0x000468, "Member 'UPalMapObjectManager::BuildFXUserParamName_BoxSurfaceArea' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, BuildCompleteSE) == 0x000470, "Member 'UPalMapObjectManager::BuildCompleteSE' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, RepairEffect) == 0x000478, "Member 'UPalMapObjectManager::RepairEffect' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, DamageEffect) == 0x000480, "Member 'UPalMapObjectManager::DamageEffect' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, DamageFXUserParamName_Alpha) == 0x000488, "Member 'UPalMapObjectManager::DamageFXUserParamName_Alpha' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, DamageFXUserParamName_Rate) == 0x000490, "Member 'UPalMapObjectManager::DamageFXUserParamName_Rate' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, DamageFXUserParamName_Scale) == 0x000498, "Member 'UPalMapObjectManager::DamageFXUserParamName_Scale' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, DamageFXUserParamName_RadiusScale) == 0x0004A0, "Member 'UPalMapObjectManager::DamageFXUserParamName_RadiusScale' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, DamageFXUserParamName_AddRate) == 0x0004A8, "Member 'UPalMapObjectManager::DamageFXUserParamName_AddRate' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, DamageFXUserParamName_EndAlpha) == 0x0004B0, "Member 'UPalMapObjectManager::DamageFXUserParamName_EndAlpha' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, DamageParam_MaxRate) == 0x0004B8, "Member 'UPalMapObjectManager::DamageParam_MaxRate' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, DamageParam_MaxAddRate) == 0x0004BC, "Member 'UPalMapObjectManager::DamageParam_MaxAddRate' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, DamageParam_MaxScale) == 0x0004C0, "Member 'UPalMapObjectManager::DamageParam_MaxScale' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, DamageParam_MaxRadiusScale) == 0x0004C4, "Member 'UPalMapObjectManager::DamageParam_MaxRadiusScale' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, DamageParam_RadiusScaleMultiplier) == 0x0004C8, "Member 'UPalMapObjectManager::DamageParam_RadiusScaleMultiplier' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, DamageFX_StartHPRate) == 0x0004CC, "Member 'UPalMapObjectManager::DamageFX_StartHPRate' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, DamageFX_DefaultBoundsSphereRadius) == 0x0004D0, "Member 'UPalMapObjectManager::DamageFX_DefaultBoundsSphereRadius' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, DamageFX_SpanwLocationOffset) == 0x0004D8, "Member 'UPalMapObjectManager::DamageFX_SpanwLocationOffset' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, DamageFX_EndFadeTime) == 0x0004F0, "Member 'UPalMapObjectManager::DamageFX_EndFadeTime' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, DropItemSpawnLocationFromActorBounds) == 0x0004F4, "Member 'UPalMapObjectManager::DropItemSpawnLocationFromActorBounds' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, DropItemSpawnDirectionZ) == 0x0004F8, "Member 'UPalMapObjectManager::DropItemSpawnDirectionZ' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, FoliageDropItemSpawnOffset) == 0x000500, "Member 'UPalMapObjectManager::FoliageDropItemSpawnOffset' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, DropItemReleaseDirectionRelative) == 0x000518, "Member 'UPalMapObjectManager::DropItemReleaseDirectionRelative' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, FoliageDestroyFXExtentsDefault) == 0x000530, "Member 'UPalMapObjectManager::FoliageDestroyFXExtentsDefault' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, HitEffectSlotClass) == 0x000548, "Member 'UPalMapObjectManager::HitEffectSlotClass' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, ChangeMeshEffectMap) == 0x000550, "Member 'UPalMapObjectManager::ChangeMeshEffectMap' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, VisualEffectAssets) == 0x0005A0, "Member 'UPalMapObjectManager::VisualEffectAssets' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, TreasureBoxOpenRequiredItemMap) == 0x0005F0, "Member 'UPalMapObjectManager::TreasureBoxOpenRequiredItemMap' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, MapObjectModelHandlingMap) == 0x000640, "Member 'UPalMapObjectManager::MapObjectModelHandlingMap' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, LevelMapObjectsToRegister) == 0x0006A0, "Member 'UPalMapObjectManager::LevelMapObjectsToRegister' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, Registrator) == 0x0006B0, "Member 'UPalMapObjectManager::Registrator' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, SpawnRequestHandlerMap) == 0x0006C0, "Member 'UPalMapObjectManager::SpawnRequestHandlerMap' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, InDoorCheckProcessIndex_AnyThread) == 0x000758, "Member 'UPalMapObjectManager::InDoorCheckProcessIndex_AnyThread' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, InDoorCheckMaxNumPerFrame_AnyThread) == 0x00075C, "Member 'UPalMapObjectManager::InDoorCheckMaxNumPerFrame_AnyThread' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, SpawnedSpawners) == 0x000760, "Member 'UPalMapObjectManager::SpawnedSpawners' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, SkeletalLODComponentArrayExec) == 0x000770, "Member 'UPalMapObjectManager::SkeletalLODComponentArrayExec' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, SkeletalLODComponentArrayWait) == 0x000780, "Member 'UPalMapObjectManager::SkeletalLODComponentArrayWait' has a wrong offset!");
static_assert(offsetof(UPalMapObjectManager, PointLightComponents) == 0x000798, "Member 'UPalMapObjectManager::PointLightComponents' has a wrong offset!");

// Class Pal.PalMapObjectMedicalPalBedParameterComponent
// 0x0008 (0x00A8 - 0x00A0)
class UPalMapObjectMedicalPalBedParameterComponent final : public UActorComponent
{
public:
	float                                         AdditionalHealingRate;                             // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AffectSanityRate;                                  // 0x00A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectMedicalPalBedParameterComponent">();
	}
	static class UPalMapObjectMedicalPalBedParameterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectMedicalPalBedParameterComponent>();
	}
};
static_assert(alignof(UPalMapObjectMedicalPalBedParameterComponent) == 0x000008, "Wrong alignment on UPalMapObjectMedicalPalBedParameterComponent");
static_assert(sizeof(UPalMapObjectMedicalPalBedParameterComponent) == 0x0000A8, "Wrong size on UPalMapObjectMedicalPalBedParameterComponent");
static_assert(offsetof(UPalMapObjectMedicalPalBedParameterComponent, AdditionalHealingRate) == 0x0000A0, "Member 'UPalMapObjectMedicalPalBedParameterComponent::AdditionalHealingRate' has a wrong offset!");
static_assert(offsetof(UPalMapObjectMedicalPalBedParameterComponent, AffectSanityRate) == 0x0000A4, "Member 'UPalMapObjectMedicalPalBedParameterComponent::AffectSanityRate' has a wrong offset!");

// Class Pal.PalMapObjectModel
// 0x0348 (0x0370 - 0x0028)
class UPalMapObjectModel final : public UObject
{
public:
	uint8                                         Pad_2D03[0x10];                                    // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnDamageInServerDelegate;                          // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDamageDelegate;                                  // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateHp;                                        // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDestroyDelegate;                                 // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDisposeDelegateInServer;                         // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdatedEnableTickDelegate;                       // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateBaseCampIdBelongToInServerDelegate;        // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateGroupIdBelongToInServerDelegate;           // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepBuildPlayerUIdDelegate_Client;                // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D04[0x30];                                    // 0x00C8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  InstanceId;                                        // 0x00F8(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   MapObjectMasterDataId;                             // 0x0108(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPalBoundsTransform                    WorkableBounds;                                    // 0x0110(0x0080)(Edit, DisableEditOnTemplate, Transient, EditConst, NoDestructor, NativeAccessSpecifierPrivate)
	struct FBox                                   MeshBoxBounds;                                     // 0x0190(0x0038)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGuid                                  ConcreteModelInstanceId;                           // 0x01C8(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalMapObjectConcreteModelBase*         ConcreteModel;                                     // 0x01D8(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  BaseCampIdBelongTo;                                // 0x01E0(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  GroupIdBelongTo;                                   // 0x01F0(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   BuildObjectId;                                     // 0x0200(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalBuildProcess*                       BuildProcess;                                      // 0x0208(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPalMapObjectDamagableType                    DamagableType;                                     // 0x0210(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D05[0x3];                                     // 0x0211(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPalMapObjectStatusValue               HP;                                                // 0x0214(0x0008)(Edit, Net, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D06[0x4];                                     // 0x021C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             InitialTransformCache;                             // 0x0220(0x0060)(Edit, Net, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalMapObjectModelConnectorBase*        Connector;                                         // 0x0280(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalMapObjectModelEffect*               Effect;                                            // 0x0288(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  RepairWorkId;                                      // 0x0290(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  OwnerSpawnerLevelObjectInstanceId;                 // 0x02A0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  OwnerInstanceId;                                   // 0x02B0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  BuildPlayerUId;                                    // 0x02C0(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bInDoor;                                           // 0x02D0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPalMapObjectInteractRestrictType             InteractRestrictType;                              // 0x02D1(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D07[0x6];                                     // 0x02D2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameDateTime                          CreatedAt;                                         // 0x02D8(0x0008)(Edit, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D08[0x4];                                     // 0x02E0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DeteriorationDamage;                               // 0x02E4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DeteriorationTotalDamage;                          // 0x02E8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIgnoredSave;                                      // 0x02EC(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D09[0x3];                                     // 0x02ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  DungeonInstanceIdBelongTo;                         // 0x02F0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPalStageInstanceId                    StageInstanceIdBelongTo;                           // 0x0300(0x0014)(Edit, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D0A[0x4];                                     // 0x0314(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFlagContainer                         TickFlagContainer;                                 // 0x0318(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D0B[0x8];                                     // 0x0368(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAssignWorkRepairBuildObject(class UPalWorkBase* Work, const struct FPalInstanceID& IndividualId);
	void OnEndTriggerInteract(class AActor* Other, EPalInteractiveObjectIndicatorType IndicatorType);
	void OnRep_BuildPlayerUId();
	void OnRep_ConcreteModel();
	void OnRep_Effect();
	void OnStartTriggerInteract(class AActor* Other, EPalInteractiveObjectIndicatorType IndicatorType);
	void OnTriggeringInteract(class AActor* Other, EPalInteractiveObjectIndicatorType IndicatorType, float DeltaTime);
	void OnTriggerInteract(class AActor* Other, EPalInteractiveObjectIndicatorType IndicatorType);
	void OnUnassignWorkRepairBuildObject(class UPalWorkBase* Work, const struct FPalInstanceID& IndividualId);
	void OnUpdateBuildProcess_ServerInternal(class UPalBuildProcess* TargetBuildProcess);
	void RequestRepairByPlayer_ToServer_ServerInternal(const struct FGuid& RequestPlayerUId);

	const struct FPalMapObjectStatusValue GetHP() const;
	bool IsDamaged() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectModel">();
	}
	static class UPalMapObjectModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectModel>();
	}
};
static_assert(alignof(UPalMapObjectModel) == 0x000010, "Wrong alignment on UPalMapObjectModel");
static_assert(sizeof(UPalMapObjectModel) == 0x000370, "Wrong size on UPalMapObjectModel");
static_assert(offsetof(UPalMapObjectModel, OnDamageInServerDelegate) == 0x000038, "Member 'UPalMapObjectModel::OnDamageInServerDelegate' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModel, OnDamageDelegate) == 0x000048, "Member 'UPalMapObjectModel::OnDamageDelegate' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModel, OnUpdateHp) == 0x000058, "Member 'UPalMapObjectModel::OnUpdateHp' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModel, OnDestroyDelegate) == 0x000068, "Member 'UPalMapObjectModel::OnDestroyDelegate' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModel, OnDisposeDelegateInServer) == 0x000078, "Member 'UPalMapObjectModel::OnDisposeDelegateInServer' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModel, OnUpdatedEnableTickDelegate) == 0x000088, "Member 'UPalMapObjectModel::OnUpdatedEnableTickDelegate' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModel, OnUpdateBaseCampIdBelongToInServerDelegate) == 0x000098, "Member 'UPalMapObjectModel::OnUpdateBaseCampIdBelongToInServerDelegate' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModel, OnUpdateGroupIdBelongToInServerDelegate) == 0x0000A8, "Member 'UPalMapObjectModel::OnUpdateGroupIdBelongToInServerDelegate' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModel, OnRepBuildPlayerUIdDelegate_Client) == 0x0000B8, "Member 'UPalMapObjectModel::OnRepBuildPlayerUIdDelegate_Client' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModel, InstanceId) == 0x0000F8, "Member 'UPalMapObjectModel::InstanceId' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModel, MapObjectMasterDataId) == 0x000108, "Member 'UPalMapObjectModel::MapObjectMasterDataId' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModel, WorkableBounds) == 0x000110, "Member 'UPalMapObjectModel::WorkableBounds' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModel, MeshBoxBounds) == 0x000190, "Member 'UPalMapObjectModel::MeshBoxBounds' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModel, ConcreteModelInstanceId) == 0x0001C8, "Member 'UPalMapObjectModel::ConcreteModelInstanceId' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModel, ConcreteModel) == 0x0001D8, "Member 'UPalMapObjectModel::ConcreteModel' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModel, BaseCampIdBelongTo) == 0x0001E0, "Member 'UPalMapObjectModel::BaseCampIdBelongTo' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModel, GroupIdBelongTo) == 0x0001F0, "Member 'UPalMapObjectModel::GroupIdBelongTo' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModel, BuildObjectId) == 0x000200, "Member 'UPalMapObjectModel::BuildObjectId' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModel, BuildProcess) == 0x000208, "Member 'UPalMapObjectModel::BuildProcess' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModel, DamagableType) == 0x000210, "Member 'UPalMapObjectModel::DamagableType' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModel, HP) == 0x000214, "Member 'UPalMapObjectModel::HP' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModel, InitialTransformCache) == 0x000220, "Member 'UPalMapObjectModel::InitialTransformCache' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModel, Connector) == 0x000280, "Member 'UPalMapObjectModel::Connector' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModel, Effect) == 0x000288, "Member 'UPalMapObjectModel::Effect' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModel, RepairWorkId) == 0x000290, "Member 'UPalMapObjectModel::RepairWorkId' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModel, OwnerSpawnerLevelObjectInstanceId) == 0x0002A0, "Member 'UPalMapObjectModel::OwnerSpawnerLevelObjectInstanceId' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModel, OwnerInstanceId) == 0x0002B0, "Member 'UPalMapObjectModel::OwnerInstanceId' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModel, BuildPlayerUId) == 0x0002C0, "Member 'UPalMapObjectModel::BuildPlayerUId' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModel, bInDoor) == 0x0002D0, "Member 'UPalMapObjectModel::bInDoor' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModel, InteractRestrictType) == 0x0002D1, "Member 'UPalMapObjectModel::InteractRestrictType' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModel, CreatedAt) == 0x0002D8, "Member 'UPalMapObjectModel::CreatedAt' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModel, DeteriorationDamage) == 0x0002E4, "Member 'UPalMapObjectModel::DeteriorationDamage' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModel, DeteriorationTotalDamage) == 0x0002E8, "Member 'UPalMapObjectModel::DeteriorationTotalDamage' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModel, bIgnoredSave) == 0x0002EC, "Member 'UPalMapObjectModel::bIgnoredSave' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModel, DungeonInstanceIdBelongTo) == 0x0002F0, "Member 'UPalMapObjectModel::DungeonInstanceIdBelongTo' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModel, StageInstanceIdBelongTo) == 0x000300, "Member 'UPalMapObjectModel::StageInstanceIdBelongTo' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModel, TickFlagContainer) == 0x000318, "Member 'UPalMapObjectModel::TickFlagContainer' has a wrong offset!");

// Class Pal.PalMapObjectModelEffectGrantParameter_Burn
// 0x0000 (0x0038 - 0x0038)
class UPalMapObjectModelEffectGrantParameter_Burn final : public UPalMapObjectModelEffectGrantParameter_AccumulateTrigger
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectModelEffectGrantParameter_Burn">();
	}
	static class UPalMapObjectModelEffectGrantParameter_Burn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectModelEffectGrantParameter_Burn>();
	}
};
static_assert(alignof(UPalMapObjectModelEffectGrantParameter_Burn) == 0x000008, "Wrong alignment on UPalMapObjectModelEffectGrantParameter_Burn");
static_assert(sizeof(UPalMapObjectModelEffectGrantParameter_Burn) == 0x000038, "Wrong size on UPalMapObjectModelEffectGrantParameter_Burn");

// Class Pal.PalMapObjectModelInitializeExtraParameterSpawner
// 0x0028 (0x0050 - 0x0028)
class UPalMapObjectModelInitializeExtraParameterSpawner final : public UPalMapObjectModelInitializeExtraParameterBase
{
public:
	struct FGuid                                  OwnerSpawnerLevelObjectInstanceId;                 // 0x0028(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPalStageInstanceId                    OwnerSpawnerStageInstanceId;                       // 0x0038(0x0014)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D10[0x4];                                     // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectModelInitializeExtraParameterSpawner">();
	}
	static class UPalMapObjectModelInitializeExtraParameterSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectModelInitializeExtraParameterSpawner>();
	}
};
static_assert(alignof(UPalMapObjectModelInitializeExtraParameterSpawner) == 0x000008, "Wrong alignment on UPalMapObjectModelInitializeExtraParameterSpawner");
static_assert(sizeof(UPalMapObjectModelInitializeExtraParameterSpawner) == 0x000050, "Wrong size on UPalMapObjectModelInitializeExtraParameterSpawner");
static_assert(offsetof(UPalMapObjectModelInitializeExtraParameterSpawner, OwnerSpawnerLevelObjectInstanceId) == 0x000028, "Member 'UPalMapObjectModelInitializeExtraParameterSpawner::OwnerSpawnerLevelObjectInstanceId' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModelInitializeExtraParameterSpawner, OwnerSpawnerStageInstanceId) == 0x000038, "Member 'UPalMapObjectModelInitializeExtraParameterSpawner::OwnerSpawnerStageInstanceId' has a wrong offset!");

// Class Pal.PalMapObjectModelInitializeExtraParameterItem
// 0x0010 (0x0038 - 0x0028)
class UPalMapObjectModelInitializeExtraParameterItem final : public UPalMapObjectModelInitializeExtraParameterBase
{
public:
	TArray<struct FPalItemAndNum>                 ItemInfos;                                         // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectModelInitializeExtraParameterItem">();
	}
	static class UPalMapObjectModelInitializeExtraParameterItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectModelInitializeExtraParameterItem>();
	}
};
static_assert(alignof(UPalMapObjectModelInitializeExtraParameterItem) == 0x000008, "Wrong alignment on UPalMapObjectModelInitializeExtraParameterItem");
static_assert(sizeof(UPalMapObjectModelInitializeExtraParameterItem) == 0x000038, "Wrong size on UPalMapObjectModelInitializeExtraParameterItem");
static_assert(offsetof(UPalMapObjectModelInitializeExtraParameterItem, ItemInfos) == 0x000028, "Member 'UPalMapObjectModelInitializeExtraParameterItem::ItemInfos' has a wrong offset!");

// Class Pal.PalMapObjectModelInitializeExtraParameterInitialItem
// 0x0010 (0x0038 - 0x0028)
class UPalMapObjectModelInitializeExtraParameterInitialItem final : public UPalMapObjectModelInitializeExtraParameterBase
{
public:
	TArray<struct FPalItemAndNum>                 ItemInfos;                                         // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectModelInitializeExtraParameterInitialItem">();
	}
	static class UPalMapObjectModelInitializeExtraParameterInitialItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectModelInitializeExtraParameterInitialItem>();
	}
};
static_assert(alignof(UPalMapObjectModelInitializeExtraParameterInitialItem) == 0x000008, "Wrong alignment on UPalMapObjectModelInitializeExtraParameterInitialItem");
static_assert(sizeof(UPalMapObjectModelInitializeExtraParameterInitialItem) == 0x000038, "Wrong size on UPalMapObjectModelInitializeExtraParameterInitialItem");
static_assert(offsetof(UPalMapObjectModelInitializeExtraParameterInitialItem, ItemInfos) == 0x000028, "Member 'UPalMapObjectModelInitializeExtraParameterInitialItem::ItemInfos' has a wrong offset!");

// Class Pal.PalMapObjectModelInitializeExtraParameterInitialCharacter
// 0x0288 (0x02B0 - 0x0028)
class UPalMapObjectModelInitializeExtraParameterInitialCharacter final : public UPalMapObjectModelInitializeExtraParameterBase
{
public:
	struct FPalIndividualCharacterSaveParameter   CharacterSaveParameter;                            // 0x0028(0x0280)(NativeAccessSpecifierPublic)
	bool                                          CreateLocationPoint;                               // 0x02A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D11[0x7];                                     // 0x02A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectModelInitializeExtraParameterInitialCharacter">();
	}
	static class UPalMapObjectModelInitializeExtraParameterInitialCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectModelInitializeExtraParameterInitialCharacter>();
	}
};
static_assert(alignof(UPalMapObjectModelInitializeExtraParameterInitialCharacter) == 0x000008, "Wrong alignment on UPalMapObjectModelInitializeExtraParameterInitialCharacter");
static_assert(sizeof(UPalMapObjectModelInitializeExtraParameterInitialCharacter) == 0x0002B0, "Wrong size on UPalMapObjectModelInitializeExtraParameterInitialCharacter");
static_assert(offsetof(UPalMapObjectModelInitializeExtraParameterInitialCharacter, CharacterSaveParameter) == 0x000028, "Member 'UPalMapObjectModelInitializeExtraParameterInitialCharacter::CharacterSaveParameter' has a wrong offset!");
static_assert(offsetof(UPalMapObjectModelInitializeExtraParameterInitialCharacter, CreateLocationPoint) == 0x0002A8, "Member 'UPalMapObjectModelInitializeExtraParameterInitialCharacter::CreateLocationPoint' has a wrong offset!");

// Class Pal.PalMapObjectModelInitializeExtraParameterNote
// 0x0008 (0x0030 - 0x0028)
class UPalMapObjectModelInitializeExtraParameterNote final : public UPalMapObjectModelInitializeExtraParameterBase
{
public:
	class FName                                   NoteRowName;                                       // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectModelInitializeExtraParameterNote">();
	}
	static class UPalMapObjectModelInitializeExtraParameterNote* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectModelInitializeExtraParameterNote>();
	}
};
static_assert(alignof(UPalMapObjectModelInitializeExtraParameterNote) == 0x000008, "Wrong alignment on UPalMapObjectModelInitializeExtraParameterNote");
static_assert(sizeof(UPalMapObjectModelInitializeExtraParameterNote) == 0x000030, "Wrong size on UPalMapObjectModelInitializeExtraParameterNote");
static_assert(offsetof(UPalMapObjectModelInitializeExtraParameterNote, NoteRowName) == 0x000028, "Member 'UPalMapObjectModelInitializeExtraParameterNote::NoteRowName' has a wrong offset!");

// Class Pal.PalMapObjectModelInitializeExtraParameterInteract
// 0x0008 (0x0030 - 0x0028)
class UPalMapObjectModelInitializeExtraParameterInteract final : public UPalMapObjectModelInitializeExtraParameterBase
{
public:
	EPalMapObjectInteractRestrictType             RestrictType;                                      // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D12[0x7];                                     // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectModelInitializeExtraParameterInteract">();
	}
	static class UPalMapObjectModelInitializeExtraParameterInteract* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectModelInitializeExtraParameterInteract>();
	}
};
static_assert(alignof(UPalMapObjectModelInitializeExtraParameterInteract) == 0x000008, "Wrong alignment on UPalMapObjectModelInitializeExtraParameterInteract");
static_assert(sizeof(UPalMapObjectModelInitializeExtraParameterInteract) == 0x000030, "Wrong size on UPalMapObjectModelInitializeExtraParameterInteract");
static_assert(offsetof(UPalMapObjectModelInitializeExtraParameterInteract, RestrictType) == 0x000028, "Member 'UPalMapObjectModelInitializeExtraParameterInteract::RestrictType' has a wrong offset!");

// Class Pal.PalMapObjectMonsterFarmParameterComponent
// 0x0008 (0x00A8 - 0x00A0)
class UPalMapObjectMonsterFarmParameterComponent final : public UActorComponent
{
public:
	struct FFloatInterval                         ActionIntervalSeconds;                             // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectMonsterFarmParameterComponent">();
	}
	static class UPalMapObjectMonsterFarmParameterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectMonsterFarmParameterComponent>();
	}
};
static_assert(alignof(UPalMapObjectMonsterFarmParameterComponent) == 0x000008, "Wrong alignment on UPalMapObjectMonsterFarmParameterComponent");
static_assert(sizeof(UPalMapObjectMonsterFarmParameterComponent) == 0x0000A8, "Wrong size on UPalMapObjectMonsterFarmParameterComponent");
static_assert(offsetof(UPalMapObjectMonsterFarmParameterComponent, ActionIntervalSeconds) == 0x0000A0, "Member 'UPalMapObjectMonsterFarmParameterComponent::ActionIntervalSeconds' has a wrong offset!");

// Class Pal.PalMapObjectNoteObjectParameterComponent
// 0x0008 (0x00A8 - 0x00A0)
class UPalMapObjectNoteObjectParameterComponent final : public UActorComponent
{
public:
	struct FPalDataTableRowName_NoteData          NoteRowName;                                       // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectNoteObjectParameterComponent">();
	}
	static class UPalMapObjectNoteObjectParameterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectNoteObjectParameterComponent>();
	}
};
static_assert(alignof(UPalMapObjectNoteObjectParameterComponent) == 0x000008, "Wrong alignment on UPalMapObjectNoteObjectParameterComponent");
static_assert(sizeof(UPalMapObjectNoteObjectParameterComponent) == 0x0000A8, "Wrong size on UPalMapObjectNoteObjectParameterComponent");
static_assert(offsetof(UPalMapObjectNoteObjectParameterComponent, NoteRowName) == 0x0000A0, "Member 'UPalMapObjectNoteObjectParameterComponent::NoteRowName' has a wrong offset!");

// Class Pal.PalMapObjectPickupItemOnLevelModel
// 0x0010 (0x0250 - 0x0240)
class UPalMapObjectPickupItemOnLevelModel : public UPalMapObjectPickableItemModelBase
{
public:
	uint8                                         Pad_2D13[0x8];                                     // 0x0240(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   VisualStaticItemId;                                // 0x0248(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnUpdateItemContainerContents(class UPalItemContainer* Container);

	class FName GetVisualStaticItemId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectPickupItemOnLevelModel">();
	}
	static class UPalMapObjectPickupItemOnLevelModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectPickupItemOnLevelModel>();
	}
};
static_assert(alignof(UPalMapObjectPickupItemOnLevelModel) == 0x000008, "Wrong alignment on UPalMapObjectPickupItemOnLevelModel");
static_assert(sizeof(UPalMapObjectPickupItemOnLevelModel) == 0x000250, "Wrong size on UPalMapObjectPickupItemOnLevelModel");
static_assert(offsetof(UPalMapObjectPickupItemOnLevelModel, VisualStaticItemId) == 0x000248, "Member 'UPalMapObjectPickupItemOnLevelModel::VisualStaticItemId' has a wrong offset!");

// Class Pal.PalMapObjectPalEggModel
// 0x0000 (0x0250 - 0x0250)
class UPalMapObjectPalEggModel final : public UPalMapObjectPickupItemOnLevelModel
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectPalEggModel">();
	}
	static class UPalMapObjectPalEggModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectPalEggModel>();
	}
};
static_assert(alignof(UPalMapObjectPalEggModel) == 0x000008, "Wrong alignment on UPalMapObjectPalEggModel");
static_assert(sizeof(UPalMapObjectPalEggModel) == 0x000250, "Wrong size on UPalMapObjectPalEggModel");

// Class Pal.PalMapObjectPasswordLockModule
// 0x0080 (0x00B0 - 0x0030)
class UPalMapObjectPasswordLockModule final : public UPalMapObjectConcreteModelModuleBase
{
public:
	FMulticastInlineDelegateProperty_             OnUpdateLockStateDelegate;                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D14[0x30];                                    // 0x0040(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnAuthenticationResultNotifyDelegate;              // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EPalMapObjectPasswordLockState                LockState;                                         // 0x0080(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D15[0x7];                                     // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Password;                                          // 0x0088(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FPalMapObjectPasswordLockPlayerInfo> PlayerInfos;                                       // 0x0098(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, RepNotify, NativeAccessSpecifierPrivate)
	int32                                         TryAuthenticateMaxNum;                             // 0x00A8(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D16[0x4];                                     // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NotifyAuthenticationResult(const bool Passed);
	void NotifyAuthenticationResultDelegate__DelegateSignature(bool Passed);
	void OnRep_PlayerInfos(const TArray<struct FPalMapObjectPasswordLockPlayerInfo>& OldValue);
	void OpenMenuSecuritySetting();
	void RequestAuthenticate(const class FString& InputPassword);
	void RequestAuthenticate_ServerInternal(const int32 RequestPlayerId, const struct FPalNetArchive& Archive);
	void RequestOpenUIPasswordSetting();
	void RequestUpdateLock(const EPalMapObjectPasswordLockState NewLockState);
	void RequestUpdatePassword(const class FString& NewPassword);
	void RequestUpdatePassword_ServerInternal(const int32 RequestPlayerId, const struct FPalNetArchive& Archive);
	void RequestUpdateUnlock_ServerInternal(const int32 RequestPlayerId);
	void ReturnPlayerInfoDelegate__DelegateSignature(const struct FPalMapObjectPasswordLockPlayerInfo& OldLocalPlayerInfo, const struct FPalMapObjectPasswordLockPlayerInfo& NewLocalPlayerInfo);
	void ReturnSelfAndPasswordMulticastDelegate__DelegateSignature(class UPalMapObjectPasswordLockModule* Module, const class FString& Param_Password);
	void ReturnSelfMulticastDelegate__DelegateSignature(class UPalMapObjectPasswordLockModule* Module);

	bool CanTryAuthenticateByPlayer(const struct FGuid& RequestPlayerUId) const;
	EPalMapObjectPasswordLockState GetLockState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectPasswordLockModule">();
	}
	static class UPalMapObjectPasswordLockModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectPasswordLockModule>();
	}
};
static_assert(alignof(UPalMapObjectPasswordLockModule) == 0x000008, "Wrong alignment on UPalMapObjectPasswordLockModule");
static_assert(sizeof(UPalMapObjectPasswordLockModule) == 0x0000B0, "Wrong size on UPalMapObjectPasswordLockModule");
static_assert(offsetof(UPalMapObjectPasswordLockModule, OnUpdateLockStateDelegate) == 0x000030, "Member 'UPalMapObjectPasswordLockModule::OnUpdateLockStateDelegate' has a wrong offset!");
static_assert(offsetof(UPalMapObjectPasswordLockModule, OnAuthenticationResultNotifyDelegate) == 0x000070, "Member 'UPalMapObjectPasswordLockModule::OnAuthenticationResultNotifyDelegate' has a wrong offset!");
static_assert(offsetof(UPalMapObjectPasswordLockModule, LockState) == 0x000080, "Member 'UPalMapObjectPasswordLockModule::LockState' has a wrong offset!");
static_assert(offsetof(UPalMapObjectPasswordLockModule, Password) == 0x000088, "Member 'UPalMapObjectPasswordLockModule::Password' has a wrong offset!");
static_assert(offsetof(UPalMapObjectPasswordLockModule, PlayerInfos) == 0x000098, "Member 'UPalMapObjectPasswordLockModule::PlayerInfos' has a wrong offset!");
static_assert(offsetof(UPalMapObjectPasswordLockModule, TryAuthenticateMaxNum) == 0x0000A8, "Member 'UPalMapObjectPasswordLockModule::TryAuthenticateMaxNum' has a wrong offset!");

// Class Pal.PalMapObjectPlayerBedModel
// 0x0030 (0x0248 - 0x0218)
class UPalMapObjectPlayerBedModel final : public UPalMapObjectConcreteModelBase
{
public:
	struct FVector                                RespawnLocationOffset;                             // 0x0218(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasAuthority;                                     // 0x0230(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D1A[0x7];                                     // 0x0231(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacter*                             SleepingCharacter;                                 // 0x0238(0x0008)(Net, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalAction_SleepPlayerBed*              SleepPlayerBedAction;                              // 0x0240(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void BP_OnTriggerInteract_SleepPlayerBed(class AActor* Other, EPalInteractiveObjectIndicatorType IndicatorType);
	void OnDamagePlayer(const struct FPalDamageResult& DamageResult);
	void OnDispose(class UPalMapObjectModel* MapObjectModel, const struct FPalMapObjectDisposeOptions& Options);
	void OnEndSleep();
	void OnGetupTrigger();
	void OnPlayerActionBegin(const class UPalActionBase* ActionBase);
	void PutPlayerToSleep(class UPalIndividualCharacterHandle* CharacterHandle);
	void ReceiveTriggerGetupPlayerBedSuccess(const int32 RequestPlayerId);
	void ReceiveTriggerSleepPlayerBedSuccess(const int32 RequestPlayerId);
	void RequestTriggerGetupPlayerBed_ToServer(const int32 RequestPlayerId);
	void RequestTriggerSleepPlayerBed_ToServer(const int32 RequestPlayerId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectPlayerBedModel">();
	}
	static class UPalMapObjectPlayerBedModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectPlayerBedModel>();
	}
};
static_assert(alignof(UPalMapObjectPlayerBedModel) == 0x000008, "Wrong alignment on UPalMapObjectPlayerBedModel");
static_assert(sizeof(UPalMapObjectPlayerBedModel) == 0x000248, "Wrong size on UPalMapObjectPlayerBedModel");
static_assert(offsetof(UPalMapObjectPlayerBedModel, RespawnLocationOffset) == 0x000218, "Member 'UPalMapObjectPlayerBedModel::RespawnLocationOffset' has a wrong offset!");
static_assert(offsetof(UPalMapObjectPlayerBedModel, bHasAuthority) == 0x000230, "Member 'UPalMapObjectPlayerBedModel::bHasAuthority' has a wrong offset!");
static_assert(offsetof(UPalMapObjectPlayerBedModel, SleepingCharacter) == 0x000238, "Member 'UPalMapObjectPlayerBedModel::SleepingCharacter' has a wrong offset!");
static_assert(offsetof(UPalMapObjectPlayerBedModel, SleepPlayerBedAction) == 0x000240, "Member 'UPalMapObjectPlayerBedModel::SleepPlayerBedAction' has a wrong offset!");

// Class Pal.PalMapObjectRaidBossSummonParameterComponent
// 0x0000 (0x00A0 - 0x00A0)
class UPalMapObjectRaidBossSummonParameterComponent final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectRaidBossSummonParameterComponent">();
	}
	static class UPalMapObjectRaidBossSummonParameterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectRaidBossSummonParameterComponent>();
	}
};
static_assert(alignof(UPalMapObjectRaidBossSummonParameterComponent) == 0x000008, "Wrong alignment on UPalMapObjectRaidBossSummonParameterComponent");
static_assert(sizeof(UPalMapObjectRaidBossSummonParameterComponent) == 0x0000A0, "Wrong size on UPalMapObjectRaidBossSummonParameterComponent");

// Class Pal.PalMapObjectRecoverOtomoParameterComponent
// 0x0010 (0x00B0 - 0x00A0)
class UPalMapObjectRecoverOtomoParameterComponent final : public UActorComponent
{
public:
	int32                                         SlotNum;                                           // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoverAmountBySec;                                // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalUserWidgetOverlayUI>    MenuUIWidgetClass;                                 // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectRecoverOtomoParameterComponent">();
	}
	static class UPalMapObjectRecoverOtomoParameterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectRecoverOtomoParameterComponent>();
	}
};
static_assert(alignof(UPalMapObjectRecoverOtomoParameterComponent) == 0x000008, "Wrong alignment on UPalMapObjectRecoverOtomoParameterComponent");
static_assert(sizeof(UPalMapObjectRecoverOtomoParameterComponent) == 0x0000B0, "Wrong size on UPalMapObjectRecoverOtomoParameterComponent");
static_assert(offsetof(UPalMapObjectRecoverOtomoParameterComponent, SlotNum) == 0x0000A0, "Member 'UPalMapObjectRecoverOtomoParameterComponent::SlotNum' has a wrong offset!");
static_assert(offsetof(UPalMapObjectRecoverOtomoParameterComponent, RecoverAmountBySec) == 0x0000A4, "Member 'UPalMapObjectRecoverOtomoParameterComponent::RecoverAmountBySec' has a wrong offset!");
static_assert(offsetof(UPalMapObjectRecoverOtomoParameterComponent, MenuUIWidgetClass) == 0x0000A8, "Member 'UPalMapObjectRecoverOtomoParameterComponent::MenuUIWidgetClass' has a wrong offset!");

// Class Pal.PalMapObjectRepairItemModel
// 0x0020 (0x0238 - 0x0218)
class UPalMapObjectRepairItemModel final : public UPalMapObjectConcreteModelBase
{
public:
	uint8                                         Pad_2D1C[0x10];                                    // 0x0218(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RequiredRepairItemRate;                            // 0x0228(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D1D[0x4];                                     // 0x022C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UPalUserWidgetOverlayUI>    WidgetClass;                                       // 0x0230(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void NotifyRepairResult(bool IsSuccess);
	void OnNotifyRepairResult__DelegateSignature(bool IsSuccess);
	void RepairItem_ServerInternal(const int32 RequestPlayerId, const struct FPalNetArchive& Archive);
	void RequestRepairItem(const TArray<struct FPalItemSlotId>& TargetItemSlotIdArray);

	void GetRequiredMaterials(const TArray<struct FPalItemId>& TargetRepairItemIdArray, TArray<struct FPalStaticItemIdAndNum>* OutRequiredMaterials) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectRepairItemModel">();
	}
	static class UPalMapObjectRepairItemModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectRepairItemModel>();
	}
};
static_assert(alignof(UPalMapObjectRepairItemModel) == 0x000008, "Wrong alignment on UPalMapObjectRepairItemModel");
static_assert(sizeof(UPalMapObjectRepairItemModel) == 0x000238, "Wrong size on UPalMapObjectRepairItemModel");
static_assert(offsetof(UPalMapObjectRepairItemModel, RequiredRepairItemRate) == 0x000228, "Member 'UPalMapObjectRepairItemModel::RequiredRepairItemRate' has a wrong offset!");
static_assert(offsetof(UPalMapObjectRepairItemModel, WidgetClass) == 0x000230, "Member 'UPalMapObjectRepairItemModel::WidgetClass' has a wrong offset!");

// Class Pal.PalMapObjectShippingItemModel
// 0x0010 (0x0228 - 0x0218)
class UPalMapObjectShippingItemModel final : public UPalMapObjectConcreteModelBase
{
public:
	TArray<int32>                                 ShippingHours;                                     // 0x0218(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)

public:
	void OnChangeTimeHoursInServer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectShippingItemModel">();
	}
	static class UPalMapObjectShippingItemModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectShippingItemModel>();
	}
};
static_assert(alignof(UPalMapObjectShippingItemModel) == 0x000008, "Wrong alignment on UPalMapObjectShippingItemModel");
static_assert(sizeof(UPalMapObjectShippingItemModel) == 0x000228, "Wrong size on UPalMapObjectShippingItemModel");
static_assert(offsetof(UPalMapObjectShippingItemModel, ShippingHours) == 0x000218, "Member 'UPalMapObjectShippingItemModel::ShippingHours' has a wrong offset!");

// Class Pal.PalMapObjectShippingItemParameterComponent
// 0x0018 (0x00B8 - 0x00A0)
class UPalMapObjectShippingItemParameterComponent final : public UActorComponent
{
public:
	int32                                         SlotNum;                                           // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D1F[0x4];                                     // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 ShippingHours;                                     // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectShippingItemParameterComponent">();
	}
	static class UPalMapObjectShippingItemParameterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectShippingItemParameterComponent>();
	}
};
static_assert(alignof(UPalMapObjectShippingItemParameterComponent) == 0x000008, "Wrong alignment on UPalMapObjectShippingItemParameterComponent");
static_assert(sizeof(UPalMapObjectShippingItemParameterComponent) == 0x0000B8, "Wrong size on UPalMapObjectShippingItemParameterComponent");
static_assert(offsetof(UPalMapObjectShippingItemParameterComponent, SlotNum) == 0x0000A0, "Member 'UPalMapObjectShippingItemParameterComponent::SlotNum' has a wrong offset!");
static_assert(offsetof(UPalMapObjectShippingItemParameterComponent, ShippingHours) == 0x0000A8, "Member 'UPalMapObjectShippingItemParameterComponent::ShippingHours' has a wrong offset!");

// Class Pal.PalHUDDispatchParameter_Signboard
// 0x0030 (0x0070 - 0x0040)
class UPalHUDDispatchParameter_Signboard final : public UPalHUDDispatchParameter_MapObject
{
public:
	class FString                                 InText;                                            // 0x0040(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OutText;                                           // 0x0050(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateTextDelegate;                              // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalHUDDispatchParameter_Signboard">();
	}
	static class UPalHUDDispatchParameter_Signboard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalHUDDispatchParameter_Signboard>();
	}
};
static_assert(alignof(UPalHUDDispatchParameter_Signboard) == 0x000008, "Wrong alignment on UPalHUDDispatchParameter_Signboard");
static_assert(sizeof(UPalHUDDispatchParameter_Signboard) == 0x000070, "Wrong size on UPalHUDDispatchParameter_Signboard");
static_assert(offsetof(UPalHUDDispatchParameter_Signboard, InText) == 0x000040, "Member 'UPalHUDDispatchParameter_Signboard::InText' has a wrong offset!");
static_assert(offsetof(UPalHUDDispatchParameter_Signboard, OutText) == 0x000050, "Member 'UPalHUDDispatchParameter_Signboard::OutText' has a wrong offset!");
static_assert(offsetof(UPalHUDDispatchParameter_Signboard, OnUpdateTextDelegate) == 0x000060, "Member 'UPalHUDDispatchParameter_Signboard::OnUpdateTextDelegate' has a wrong offset!");

// Class Pal.PalMapObjectSignboardParameterComponent
// 0x0008 (0x00A8 - 0x00A0)
class UPalMapObjectSignboardParameterComponent final : public UActorComponent
{
public:
	TSubclassOf<class UPalUserWidgetOverlayUI>    MenuUIWidgetClass;                                 // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectSignboardParameterComponent">();
	}
	static class UPalMapObjectSignboardParameterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectSignboardParameterComponent>();
	}
};
static_assert(alignof(UPalMapObjectSignboardParameterComponent) == 0x000008, "Wrong alignment on UPalMapObjectSignboardParameterComponent");
static_assert(sizeof(UPalMapObjectSignboardParameterComponent) == 0x0000A8, "Wrong size on UPalMapObjectSignboardParameterComponent");
static_assert(offsetof(UPalMapObjectSignboardParameterComponent, MenuUIWidgetClass) == 0x0000A0, "Member 'UPalMapObjectSignboardParameterComponent::MenuUIWidgetClass' has a wrong offset!");

// Class Pal.PalMapObjectSpawnerDamageReactionComponent
// 0x0018 (0x00B8 - 0x00A0)
class UPalMapObjectSpawnerDamageReactionComponent final : public UActorComponent
{
public:
	uint8                                         Pad_2D20[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDropItemOnDamaged;                                // 0x00A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D21[0x7];                                     // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalHitEffectSlot*                      EffectSlot;                                        // 0x00B0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectSpawnerDamageReactionComponent">();
	}
	static class UPalMapObjectSpawnerDamageReactionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectSpawnerDamageReactionComponent>();
	}
};
static_assert(alignof(UPalMapObjectSpawnerDamageReactionComponent) == 0x000008, "Wrong alignment on UPalMapObjectSpawnerDamageReactionComponent");
static_assert(sizeof(UPalMapObjectSpawnerDamageReactionComponent) == 0x0000B8, "Wrong size on UPalMapObjectSpawnerDamageReactionComponent");
static_assert(offsetof(UPalMapObjectSpawnerDamageReactionComponent, bDropItemOnDamaged) == 0x0000A8, "Member 'UPalMapObjectSpawnerDamageReactionComponent::bDropItemOnDamaged' has a wrong offset!");
static_assert(offsetof(UPalMapObjectSpawnerDamageReactionComponent, EffectSlot) == 0x0000B0, "Member 'UPalMapObjectSpawnerDamageReactionComponent::EffectSlot' has a wrong offset!");

// Class Pal.PalMapObjectSpawnerMultiItem
// 0x0060 (0x0330 - 0x02D0)
class APalMapObjectSpawnerMultiItem final : public APalMapObjectSpawnerBase
{
public:
	uint8                                         Pad_2D22[0x50];                                    // 0x02D0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPalDataTableRowName_FieldLotteryNameData FieldLotteryName;                                  // 0x0320(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RespawnTimeMinutesObtained;                        // 0x0328(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D23[0x4];                                     // 0x032C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectSpawnerMultiItem">();
	}
	static class APalMapObjectSpawnerMultiItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalMapObjectSpawnerMultiItem>();
	}
};
static_assert(alignof(APalMapObjectSpawnerMultiItem) == 0x000008, "Wrong alignment on APalMapObjectSpawnerMultiItem");
static_assert(sizeof(APalMapObjectSpawnerMultiItem) == 0x000330, "Wrong size on APalMapObjectSpawnerMultiItem");
static_assert(offsetof(APalMapObjectSpawnerMultiItem, FieldLotteryName) == 0x000320, "Member 'APalMapObjectSpawnerMultiItem::FieldLotteryName' has a wrong offset!");
static_assert(offsetof(APalMapObjectSpawnerMultiItem, RespawnTimeMinutesObtained) == 0x000328, "Member 'APalMapObjectSpawnerMultiItem::RespawnTimeMinutesObtained' has a wrong offset!");

// Class Pal.PalMapObjectSpawnerMultiItemLocationComponent
// 0x0000 (0x05F0 - 0x05F0)
class UPalMapObjectSpawnerMultiItemLocationComponent final : public UStaticMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectSpawnerMultiItemLocationComponent">();
	}
	static class UPalMapObjectSpawnerMultiItemLocationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectSpawnerMultiItemLocationComponent>();
	}
};
static_assert(alignof(UPalMapObjectSpawnerMultiItemLocationComponent) == 0x000010, "Wrong alignment on UPalMapObjectSpawnerMultiItemLocationComponent");
static_assert(sizeof(UPalMapObjectSpawnerMultiItemLocationComponent) == 0x0005F0, "Wrong size on UPalMapObjectSpawnerMultiItemLocationComponent");

// Class Pal.PalMapObjectSpawnerSimple
// 0x0008 (0x02D8 - 0x02D0)
class APalMapObjectSpawnerSimple final : public APalMapObjectSpawnerSingleBase
{
public:
	struct FPalDataTableRowName_MapObjectData     MapObjectId;                                       // 0x02D0(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnFinishedSpawningMapObjectModel(const struct FGuid& InstanceId, const EPalMapObjectOperationResult Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectSpawnerSimple">();
	}
	static class APalMapObjectSpawnerSimple* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalMapObjectSpawnerSimple>();
	}
};
static_assert(alignof(APalMapObjectSpawnerSimple) == 0x000008, "Wrong alignment on APalMapObjectSpawnerSimple");
static_assert(sizeof(APalMapObjectSpawnerSimple) == 0x0002D8, "Wrong size on APalMapObjectSpawnerSimple");
static_assert(offsetof(APalMapObjectSpawnerSimple, MapObjectId) == 0x0002D0, "Member 'APalMapObjectSpawnerSimple::MapObjectId' has a wrong offset!");

// Class Pal.PalMapObjectSpawnerTreasureBox
// 0x0018 (0x02E8 - 0x02D0)
class APalMapObjectSpawnerTreasureBox final : public APalMapObjectSpawnerSingleBase
{
public:
	struct FPalDataTableRowName_MapObjectData     SpawnMapObjectId;                                  // 0x02D0(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPalDataTableRowName_FieldLotteryNameData FieldLotteryName;                                  // 0x02D8(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RespawnTimeMinutesObtained;                        // 0x02E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRespawnableMulti;                                 // 0x02E4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D25[0x3];                                     // 0x02E5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFinishedSpawningMapObjectModel(const struct FGuid& InstanceId, const EPalMapObjectOperationResult Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectSpawnerTreasureBox">();
	}
	static class APalMapObjectSpawnerTreasureBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalMapObjectSpawnerTreasureBox>();
	}
};
static_assert(alignof(APalMapObjectSpawnerTreasureBox) == 0x000008, "Wrong alignment on APalMapObjectSpawnerTreasureBox");
static_assert(sizeof(APalMapObjectSpawnerTreasureBox) == 0x0002E8, "Wrong size on APalMapObjectSpawnerTreasureBox");
static_assert(offsetof(APalMapObjectSpawnerTreasureBox, SpawnMapObjectId) == 0x0002D0, "Member 'APalMapObjectSpawnerTreasureBox::SpawnMapObjectId' has a wrong offset!");
static_assert(offsetof(APalMapObjectSpawnerTreasureBox, FieldLotteryName) == 0x0002D8, "Member 'APalMapObjectSpawnerTreasureBox::FieldLotteryName' has a wrong offset!");
static_assert(offsetof(APalMapObjectSpawnerTreasureBox, RespawnTimeMinutesObtained) == 0x0002E0, "Member 'APalMapObjectSpawnerTreasureBox::RespawnTimeMinutesObtained' has a wrong offset!");
static_assert(offsetof(APalMapObjectSpawnerTreasureBox, bRespawnableMulti) == 0x0002E4, "Member 'APalMapObjectSpawnerTreasureBox::bRespawnableMulti' has a wrong offset!");

// Class Pal.PalBuildObjectSpawnValidationCheckInterface
// 0x0000 (0x0028 - 0x0028)
class IPalBuildObjectSpawnValidationCheckInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBuildObjectSpawnValidationCheckInterface">();
	}
	static class IPalBuildObjectSpawnValidationCheckInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPalBuildObjectSpawnValidationCheckInterface>();
	}
};
static_assert(alignof(IPalBuildObjectSpawnValidationCheckInterface) == 0x000008, "Wrong alignment on IPalBuildObjectSpawnValidationCheckInterface");
static_assert(sizeof(IPalBuildObjectSpawnValidationCheckInterface) == 0x000028, "Wrong size on IPalBuildObjectSpawnValidationCheckInterface");

// Class Pal.PalMapObjectStatusObserverModule
// 0x0010 (0x0040 - 0x0030)
class UPalMapObjectStatusObserverModule final : public UPalMapObjectConcreteModelModuleBase
{
public:
	FMulticastInlineDelegateProperty_             OnDamageInServerDelegate;                          // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void OnDamage_ServerInternal(class UPalMapObjectModel* Model, const struct FPalDamageInfo& DamageInfo, const int32 LastHp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectStatusObserverModule">();
	}
	static class UPalMapObjectStatusObserverModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectStatusObserverModule>();
	}
};
static_assert(alignof(UPalMapObjectStatusObserverModule) == 0x000008, "Wrong alignment on UPalMapObjectStatusObserverModule");
static_assert(sizeof(UPalMapObjectStatusObserverModule) == 0x000040, "Wrong size on UPalMapObjectStatusObserverModule");
static_assert(offsetof(UPalMapObjectStatusObserverModule, OnDamageInServerDelegate) == 0x000030, "Member 'UPalMapObjectStatusObserverModule::OnDamageInServerDelegate' has a wrong offset!");

// Class Pal.PalMapObjectSwitchModule
// 0x0018 (0x0048 - 0x0030)
class UPalMapObjectSwitchModule final : public UPalMapObjectConcreteModelModuleBase
{
public:
	FMulticastInlineDelegateProperty_             OnUpdateSwitchStateDelegate;                       // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EPalMapObjectSwitchState                      SwitchState;                                       // 0x0040(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D28[0x7];                                     // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_SwitchState();
	void ReturnSelfMulticastDelegate__DelegateSignature(class UPalMapObjectSwitchModule* Module);

	EPalMapObjectSwitchState GetSwitchState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectSwitchModule">();
	}
	static class UPalMapObjectSwitchModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectSwitchModule>();
	}
};
static_assert(alignof(UPalMapObjectSwitchModule) == 0x000008, "Wrong alignment on UPalMapObjectSwitchModule");
static_assert(sizeof(UPalMapObjectSwitchModule) == 0x000048, "Wrong size on UPalMapObjectSwitchModule");
static_assert(offsetof(UPalMapObjectSwitchModule, OnUpdateSwitchStateDelegate) == 0x000030, "Member 'UPalMapObjectSwitchModule::OnUpdateSwitchStateDelegate' has a wrong offset!");
static_assert(offsetof(UPalMapObjectSwitchModule, SwitchState) == 0x000040, "Member 'UPalMapObjectSwitchModule::SwitchState' has a wrong offset!");

// Class Pal.PalMapObjectTestFunctionModel
// 0x0008 (0x0220 - 0x0218)
class UPalMapObjectTestFunctionModel final : public UPalMapObjectConcreteModelBase
{
public:
	uint8                                         Pad_2D29[0x8];                                     // 0x0218(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRecieveCountUp(const int32 ReflectedCounter);
	void RequestCountUp(const int32 IncrementNum);
	void RequestCountUp_ServerInternal(const int32 RequestPlayerId, const int32 IncrementNum);
	void RequestCountUpSIngle_ServerInternal(const int32 RequestPlayerId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectTestFunctionModel">();
	}
	static class UPalMapObjectTestFunctionModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectTestFunctionModel>();
	}
};
static_assert(alignof(UPalMapObjectTestFunctionModel) == 0x000008, "Wrong alignment on UPalMapObjectTestFunctionModel");
static_assert(sizeof(UPalMapObjectTestFunctionModel) == 0x000220, "Wrong size on UPalMapObjectTestFunctionModel");

// Class Pal.PalMapObjectTestItemDestroyedDropModel
// 0x0010 (0x0228 - 0x0218)
class UPalMapObjectTestItemDestroyedDropModel final : public UPalMapObjectConcreteModelBase
{
public:
	TArray<struct FPalItemAndNum>                 DropItemInfos;                                     // 0x0218(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	void OnDestroy_ServerInternal(class UPalMapObjectModel* Model);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectTestItemDestroyedDropModel">();
	}
	static class UPalMapObjectTestItemDestroyedDropModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectTestItemDestroyedDropModel>();
	}
};
static_assert(alignof(UPalMapObjectTestItemDestroyedDropModel) == 0x000008, "Wrong alignment on UPalMapObjectTestItemDestroyedDropModel");
static_assert(sizeof(UPalMapObjectTestItemDestroyedDropModel) == 0x000228, "Wrong size on UPalMapObjectTestItemDestroyedDropModel");
static_assert(offsetof(UPalMapObjectTestItemDestroyedDropModel, DropItemInfos) == 0x000218, "Member 'UPalMapObjectTestItemDestroyedDropModel::DropItemInfos' has a wrong offset!");

// Class Pal.PalMapObjectTorchModel
// 0x0010 (0x0228 - 0x0218)
class UPalMapObjectTorchModel final : public UPalMapObjectConcreteModelBase
{
public:
	int32                                         IgnitionMinutes;                                   // 0x0218(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D2A[0x4];                                     // 0x021C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameDateTime                          ExtinctionDateTime;                                // 0x0220(0x0008)(Edit, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnWorkBootUp_ServerInternal(class UPalWorkBootUp* Work);
	void RequestTriggerIgnition_ToServer(const int32 RequestPlayerId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectTorchModel">();
	}
	static class UPalMapObjectTorchModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectTorchModel>();
	}
};
static_assert(alignof(UPalMapObjectTorchModel) == 0x000008, "Wrong alignment on UPalMapObjectTorchModel");
static_assert(sizeof(UPalMapObjectTorchModel) == 0x000228, "Wrong size on UPalMapObjectTorchModel");
static_assert(offsetof(UPalMapObjectTorchModel, IgnitionMinutes) == 0x000218, "Member 'UPalMapObjectTorchModel::IgnitionMinutes' has a wrong offset!");
static_assert(offsetof(UPalMapObjectTorchModel, ExtinctionDateTime) == 0x000220, "Member 'UPalMapObjectTorchModel::ExtinctionDateTime' has a wrong offset!");

// Class Pal.PalMapObjectTorchParameterComponent
// 0x0008 (0x00A8 - 0x00A0)
class UPalMapObjectTorchParameterComponent final : public UActorComponent
{
public:
	int32                                         IgnitionMinutes;                                   // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D2B[0x4];                                     // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectTorchParameterComponent">();
	}
	static class UPalMapObjectTorchParameterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectTorchParameterComponent>();
	}
};
static_assert(alignof(UPalMapObjectTorchParameterComponent) == 0x000008, "Wrong alignment on UPalMapObjectTorchParameterComponent");
static_assert(sizeof(UPalMapObjectTorchParameterComponent) == 0x0000A8, "Wrong size on UPalMapObjectTorchParameterComponent");
static_assert(offsetof(UPalMapObjectTorchParameterComponent, IgnitionMinutes) == 0x0000A0, "Member 'UPalMapObjectTorchParameterComponent::IgnitionMinutes' has a wrong offset!");

// Class Pal.PalMapObjectTreasureBoxModel
// 0x0038 (0x0250 - 0x0218)
class UPalMapObjectTreasureBoxModel final : public UPalMapObjectConcreteModelBase
{
public:
	uint8                                         Pad_2D2C[0x10];                                    // 0x0218(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	EPalMapObjectTreasureGradeType                TreasureGradeType;                                 // 0x0228(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D2D[0x7];                                     // 0x0229(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DropItemLocalLocation;                             // 0x0230(0x0018)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOpened;                                           // 0x0248(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D2E[0x7];                                     // 0x0249(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Debug_ReceiveObtainInfo_ClientInternal(const struct FPalNetArchive& Archive);
	void ReceiveOpenFailed_ClientInternal(const struct FPalNetArchive& Archive);
	void ReceiveOpenSuccess_ClientInternal(const struct FPalNetArchive& Archive);
	void RequestOpen_ServerInternal(const int32 RequestPlayerId);

	TArray<struct FPalItemAndNum> CreateItemInfo() const;
	EPalMapObjectTreasureGradeType GetTreasureGradeType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectTreasureBoxModel">();
	}
	static class UPalMapObjectTreasureBoxModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectTreasureBoxModel>();
	}
};
static_assert(alignof(UPalMapObjectTreasureBoxModel) == 0x000008, "Wrong alignment on UPalMapObjectTreasureBoxModel");
static_assert(sizeof(UPalMapObjectTreasureBoxModel) == 0x000250, "Wrong size on UPalMapObjectTreasureBoxModel");
static_assert(offsetof(UPalMapObjectTreasureBoxModel, TreasureGradeType) == 0x000228, "Member 'UPalMapObjectTreasureBoxModel::TreasureGradeType' has a wrong offset!");
static_assert(offsetof(UPalMapObjectTreasureBoxModel, DropItemLocalLocation) == 0x000230, "Member 'UPalMapObjectTreasureBoxModel::DropItemLocalLocation' has a wrong offset!");
static_assert(offsetof(UPalMapObjectTreasureBoxModel, bOpened) == 0x000248, "Member 'UPalMapObjectTreasureBoxModel::bOpened' has a wrong offset!");

// Class Pal.PalMapObjectUtility
// 0x0000 (0x0028 - 0x0028)
class UPalMapObjectUtility final : public UBlueprintFunctionLibrary
{
public:
	static void GetItemVisualModelFX(TSubclassOf<class AActor> ActorClass, TArray<struct FPalItemVisualModelFXInfo>* OutFXInfos);
	static bool IsContainsCollisionProfiles(const class UPrimitiveComponent* Component, const TArray<class FName>& CollisionProfiles);
	static class FString MapObjectOperationResultToString(const EPalMapObjectOperationResult Result);
	static EPalMapObjectOperationResult SelectPriorityResult(EPalMapObjectOperationResult Result1, EPalMapObjectOperationResult Result2);
	static const EPalMapObjectOperationResult ToMapObjectOperationResult(const int32 ResultIntValue);
	static bool TryGetItemVisualModelStaticMesh(TSubclassOf<class AActor> ActorClass, class UStaticMesh** OutStaticMesh, struct FTransform* OutComponentTransform, struct FVector* OutCenterOfMass, class UMaterialInterface** OutMaterialInterface);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectUtility">();
	}
	static class UPalMapObjectUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectUtility>();
	}
};
static_assert(alignof(UPalMapObjectUtility) == 0x000008, "Wrong alignment on UPalMapObjectUtility");
static_assert(sizeof(UPalMapObjectUtility) == 0x000028, "Wrong size on UPalMapObjectUtility");

// Class Pal.PalMapObjectVisualEffectComponent
// 0x0050 (0x00F0 - 0x00A0)
class UPalMapObjectVisualEffectComponent final : public UActorComponent
{
public:
	TMap<EPalMapObjectVisualEffectType, struct FPalMapObjectVisualEffectInstanceSet> SpawnedEffectMap;                                  // 0x00A0(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void OnGrantedEffect(class UPalMapObjectModel* Model, class UPalMapObjectModelEffectBase* Effect);
	void OnRemoveEffect(class UPalMapObjectModel* Model, class UPalMapObjectModelEffectBase* Effect, const EPalStatusID StatusId);
	void UpdateVisualByEffect(class UPalMapObjectModelEffectBase* Effect);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectVisualEffectComponent">();
	}
	static class UPalMapObjectVisualEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectVisualEffectComponent>();
	}
};
static_assert(alignof(UPalMapObjectVisualEffectComponent) == 0x000008, "Wrong alignment on UPalMapObjectVisualEffectComponent");
static_assert(sizeof(UPalMapObjectVisualEffectComponent) == 0x0000F0, "Wrong size on UPalMapObjectVisualEffectComponent");
static_assert(offsetof(UPalMapObjectVisualEffectComponent, SpawnedEffectMap) == 0x0000A0, "Member 'UPalMapObjectVisualEffectComponent::SpawnedEffectMap' has a wrong offset!");

// Class Pal.PalMapObjectWorkeeModule
// 0x0008 (0x0038 - 0x0030)
class UPalMapObjectWorkeeModule final : public UPalMapObjectConcreteModelModuleBase
{
public:
	class UPalWorkBase*                           TargetWork;                                        // 0x0030(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_TargetWork();

	class UPalWorkBase* GetWork() const;
	class UPalWorkProgress* GetWorkProgress() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectWorkeeModule">();
	}
	static class UPalMapObjectWorkeeModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectWorkeeModule>();
	}
};
static_assert(alignof(UPalMapObjectWorkeeModule) == 0x000008, "Wrong alignment on UPalMapObjectWorkeeModule");
static_assert(sizeof(UPalMapObjectWorkeeModule) == 0x000038, "Wrong size on UPalMapObjectWorkeeModule");
static_assert(offsetof(UPalMapObjectWorkeeModule, TargetWork) == 0x000030, "Member 'UPalMapObjectWorkeeModule::TargetWork' has a wrong offset!");

// Class Pal.PalMapObjectWorldDisposer
// 0x0010 (0x0038 - 0x0028)
class UPalMapObjectWorldDisposer final : public UObject
{
public:
	TArray<class UPalMapObjectWorldDisposerBase*> WorldDisposers;                                    // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapObjectWorldDisposer">();
	}
	static class UPalMapObjectWorldDisposer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapObjectWorldDisposer>();
	}
};
static_assert(alignof(UPalMapObjectWorldDisposer) == 0x000008, "Wrong alignment on UPalMapObjectWorldDisposer");
static_assert(sizeof(UPalMapObjectWorldDisposer) == 0x000038, "Wrong size on UPalMapObjectWorldDisposer");
static_assert(offsetof(UPalMapObjectWorldDisposer, WorldDisposers) == 0x000028, "Member 'UPalMapObjectWorldDisposer::WorldDisposers' has a wrong offset!");

// Class Pal.PalMasterDataTableAccess_LocalizeText
// 0x0000 (0x0030 - 0x0030)
class UPalMasterDataTableAccess_LocalizeText final : public UPalMasterDataTableAccessBase
{
public:
	class FText FindRow(class FName RowName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMasterDataTableAccess_LocalizeText">();
	}
	static class UPalMasterDataTableAccess_LocalizeText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMasterDataTableAccess_LocalizeText>();
	}
};
static_assert(alignof(UPalMasterDataTableAccess_LocalizeText) == 0x000008, "Wrong alignment on UPalMasterDataTableAccess_LocalizeText");
static_assert(sizeof(UPalMasterDataTableAccess_LocalizeText) == 0x000030, "Wrong size on UPalMasterDataTableAccess_LocalizeText");

// Class Pal.PalMasterDataTableAccess_WildSpawnerData
// 0x0000 (0x0030 - 0x0030)
class UPalMasterDataTableAccess_WildSpawnerData final : public UPalMasterDataTableAccessBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMasterDataTableAccess_WildSpawnerData">();
	}
	static class UPalMasterDataTableAccess_WildSpawnerData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMasterDataTableAccess_WildSpawnerData>();
	}
};
static_assert(alignof(UPalMasterDataTableAccess_WildSpawnerData) == 0x000008, "Wrong alignment on UPalMasterDataTableAccess_WildSpawnerData");
static_assert(sizeof(UPalMasterDataTableAccess_WildSpawnerData) == 0x000030, "Wrong size on UPalMasterDataTableAccess_WildSpawnerData");

// Class Pal.PalMasterDataTableAccess_ItemRecipe
// 0x0000 (0x0030 - 0x0030)
class UPalMasterDataTableAccess_ItemRecipe final : public UPalMasterDataTableAccessBase
{
public:
	void BPExec_FindRow(class FName RowName, EPalMasterDataExecPinType* ExecType, struct FPalItemRecipe* OutData);

	struct FPalItemRecipe BP_FindRow(class FName RowName, bool* bResult) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMasterDataTableAccess_ItemRecipe">();
	}
	static class UPalMasterDataTableAccess_ItemRecipe* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMasterDataTableAccess_ItemRecipe>();
	}
};
static_assert(alignof(UPalMasterDataTableAccess_ItemRecipe) == 0x000008, "Wrong alignment on UPalMasterDataTableAccess_ItemRecipe");
static_assert(sizeof(UPalMasterDataTableAccess_ItemRecipe) == 0x000030, "Wrong size on UPalMasterDataTableAccess_ItemRecipe");

// Class Pal.PalMasterDataTableAccess_BuildObjectData
// 0x0000 (0x0030 - 0x0030)
class UPalMasterDataTableAccess_BuildObjectData final : public UPalMasterDataTableAccessBase
{
public:
	void BPExec_FindRow(class FName RowName, EPalMasterDataExecPinType* ExecType, struct FPalBuildObjectData* OutData);
	void BPExec_FindRowByMapObjectId(class FName MapObjectId, EPalMasterDataExecPinType* ExecType, struct FPalBuildObjectData* OutData);

	struct FPalBuildObjectData BP_FindRow(class FName RowName, bool* bResult) const;
	struct FPalBuildObjectData BP_FindRowByMapObjectId(class FName MapObjectId, class FName* OutRowName, bool* bResult) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMasterDataTableAccess_BuildObjectData">();
	}
	static class UPalMasterDataTableAccess_BuildObjectData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMasterDataTableAccess_BuildObjectData>();
	}
};
static_assert(alignof(UPalMasterDataTableAccess_BuildObjectData) == 0x000008, "Wrong alignment on UPalMasterDataTableAccess_BuildObjectData");
static_assert(sizeof(UPalMasterDataTableAccess_BuildObjectData) == 0x000030, "Wrong size on UPalMasterDataTableAccess_BuildObjectData");

// Class Pal.PalMasterDataTableAccess_BaseCampLevelData
// 0x0008 (0x0038 - 0x0030)
class UPalMasterDataTableAccess_BaseCampLevelData final : public UPalMasterDataTableAccessBase
{
public:
	uint8                                         Pad_2D3A[0x8];                                     // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FPalBaseCampLevelMasterData GetLevelInfo(int32 Level);
	int32 GetMaxLevel();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMasterDataTableAccess_BaseCampLevelData">();
	}
	static class UPalMasterDataTableAccess_BaseCampLevelData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMasterDataTableAccess_BaseCampLevelData>();
	}
};
static_assert(alignof(UPalMasterDataTableAccess_BaseCampLevelData) == 0x000008, "Wrong alignment on UPalMasterDataTableAccess_BaseCampLevelData");
static_assert(sizeof(UPalMasterDataTableAccess_BaseCampLevelData) == 0x000038, "Wrong size on UPalMasterDataTableAccess_BaseCampLevelData");

// Class Pal.PalMasterDataTableAccess_DungeonSpawnAreaData
// 0x0000 (0x0030 - 0x0030)
class UPalMasterDataTableAccess_DungeonSpawnAreaData final : public UPalMasterDataTableAccessBase
{
public:
	struct FPalDungeonSpawnAreaData BP_FindRow(class FName RowName, bool* bResult) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMasterDataTableAccess_DungeonSpawnAreaData">();
	}
	static class UPalMasterDataTableAccess_DungeonSpawnAreaData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMasterDataTableAccess_DungeonSpawnAreaData>();
	}
};
static_assert(alignof(UPalMasterDataTableAccess_DungeonSpawnAreaData) == 0x000008, "Wrong alignment on UPalMasterDataTableAccess_DungeonSpawnAreaData");
static_assert(sizeof(UPalMasterDataTableAccess_DungeonSpawnAreaData) == 0x000030, "Wrong size on UPalMasterDataTableAccess_DungeonSpawnAreaData");

// Class Pal.PalMasterDataTableAccess_DungeonItemLotteryData
// 0x0000 (0x0030 - 0x0030)
class UPalMasterDataTableAccess_DungeonItemLotteryData final : public UPalMasterDataTableAccessBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMasterDataTableAccess_DungeonItemLotteryData">();
	}
	static class UPalMasterDataTableAccess_DungeonItemLotteryData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMasterDataTableAccess_DungeonItemLotteryData>();
	}
};
static_assert(alignof(UPalMasterDataTableAccess_DungeonItemLotteryData) == 0x000008, "Wrong alignment on UPalMasterDataTableAccess_DungeonItemLotteryData");
static_assert(sizeof(UPalMasterDataTableAccess_DungeonItemLotteryData) == 0x000030, "Wrong size on UPalMasterDataTableAccess_DungeonItemLotteryData");

// Class Pal.PalMasterDataTableAccess_FieldLotteryNameData
// 0x0000 (0x0030 - 0x0030)
class UPalMasterDataTableAccess_FieldLotteryNameData final : public UPalMasterDataTableAccessBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMasterDataTableAccess_FieldLotteryNameData">();
	}
	static class UPalMasterDataTableAccess_FieldLotteryNameData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMasterDataTableAccess_FieldLotteryNameData>();
	}
};
static_assert(alignof(UPalMasterDataTableAccess_FieldLotteryNameData) == 0x000008, "Wrong alignment on UPalMasterDataTableAccess_FieldLotteryNameData");
static_assert(sizeof(UPalMasterDataTableAccess_FieldLotteryNameData) == 0x000030, "Wrong size on UPalMasterDataTableAccess_FieldLotteryNameData");

// Class Pal.PalMasterDataTableAccess_UIInputActionData
// 0x0000 (0x0030 - 0x0030)
class UPalMasterDataTableAccess_UIInputActionData final : public UPalMasterDataTableAccessBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMasterDataTableAccess_UIInputActionData">();
	}
	static class UPalMasterDataTableAccess_UIInputActionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMasterDataTableAccess_UIInputActionData>();
	}
};
static_assert(alignof(UPalMasterDataTableAccess_UIInputActionData) == 0x000008, "Wrong alignment on UPalMasterDataTableAccess_UIInputActionData");
static_assert(sizeof(UPalMasterDataTableAccess_UIInputActionData) == 0x000030, "Wrong size on UPalMasterDataTableAccess_UIInputActionData");

// Class Pal.PalMasterDataTableAccess_ItemShop
// 0x0000 (0x0030 - 0x0030)
class UPalMasterDataTableAccess_ItemShop final : public UPalMasterDataTableAccessBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMasterDataTableAccess_ItemShop">();
	}
	static class UPalMasterDataTableAccess_ItemShop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMasterDataTableAccess_ItemShop>();
	}
};
static_assert(alignof(UPalMasterDataTableAccess_ItemShop) == 0x000008, "Wrong alignment on UPalMasterDataTableAccess_ItemShop");
static_assert(sizeof(UPalMasterDataTableAccess_ItemShop) == 0x000030, "Wrong size on UPalMasterDataTableAccess_ItemShop");

// Class Pal.PalMasterDataTableAccess_PalShop
// 0x0000 (0x0030 - 0x0030)
class UPalMasterDataTableAccess_PalShop final : public UPalMasterDataTableAccessBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMasterDataTableAccess_PalShop">();
	}
	static class UPalMasterDataTableAccess_PalShop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMasterDataTableAccess_PalShop>();
	}
};
static_assert(alignof(UPalMasterDataTableAccess_PalShop) == 0x000008, "Wrong alignment on UPalMasterDataTableAccess_PalShop");
static_assert(sizeof(UPalMasterDataTableAccess_PalShop) == 0x000030, "Wrong size on UPalMasterDataTableAccess_PalShop");

// Class Pal.PalMasterDataTables
// 0x0210 (0x0238 - 0x0028)
class UPalMasterDataTables : public UObject
{
public:
	class UDataTable*                             WildSpawnerDataTable;                              // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalMasterDataTableAccess_WildSpawnerData* Access_WildSpawnerDataTable;                       // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             ItemRecipeDataTable;                               // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalMasterDataTableAccess_ItemRecipe*   Access_ItemRecipeDataTable;                        // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             FarmCropDataTable;                                 // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalMasterDataTableAccess_FarmCropData* Access_FarmCropDataTable;                          // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             MapObjectDataTable;                                // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalMasterDataTableAccess_MapObjectMasterData* Access_MapObjectDataTable;                         // 0x0060(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             BuildObjectDataTable;                              // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalMasterDataTableAccess_BuildObjectData* Access_BuildObjectDataTable;                       // 0x0070(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             BuildObjectIconDataTable;                          // 0x0078(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalMasterDataTableAccess_BuildObjectIconData* Access_BuildObjectIconDataTable;                   // 0x0080(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             ItemProductDataTable;                              // 0x0088(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalMasterDataTableAccess_ItemProductData* Access_ItemProductDataTable;                       // 0x0090(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             BaseCampLevelDataTable;                            // 0x0098(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalMasterDataTableAccess_BaseCampLevelData* Access_BaseCampLevelDataTable;                     // 0x00A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             DungeonSpawnAreaDataTable;                         // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalMasterDataTableAccess_DungeonSpawnAreaData* Access_DungeonSpawnAreaDataTable;                  // 0x00B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             DungeonLevelDataTable;                             // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalMasterDataTableAccess_DungeonLevelData* Access_DungeonLevelDataTable;                      // 0x00C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             DungeonEnemySpawnerDataTable;                      // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalMasterDataTableAccess_DungeonEnemySpawnerData* Access_DungeonEnemySpawnerDataTable;               // 0x00D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             DungeonItemLotteryDataTable;                       // 0x00D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalMasterDataTableAccess_DungeonItemLotteryData* Access_DungeonItemLotteryDataTable;                // 0x00E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             FieldLotteryNameDataTable;                         // 0x00E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalMasterDataTableAccess_FieldLotteryNameData* Access_FieldLotteryNameDataTable;                  // 0x00F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             ItemLotteryDataTable;                              // 0x00F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalMasterDataTableAccess_ItemLotteryData* Access_ItemLotteryDataTable;                       // 0x0100(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             PlayerStatusRankDataTable;                         // 0x0108(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalMasterDataTableAccess_PlayerStatusRankData* Access_PlayerStatusRankDataTable;                  // 0x0110(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             CharacterUpgradeDataTable;                         // 0x0118(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalMasterDataTableAccess_CharacterUpgradeData* Access_CharacterUpgradeDataTable;                  // 0x0120(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalNoteDataAsset*                      NoteDataAsset;                                     // 0x0128(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalNoteDataAsset*                      HelpGuideDataAsset;                                // 0x0130(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EPalLocalizeTextCategory, class UDataTable*> LocalizeTextDataTableMap;                          // 0x0138(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<EPalLocalizeTextCategory, class UPalMasterDataTableAccess_LocalizeText*> Access_LocalizeTextDataTables;                     // 0x0188(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	class UDataTable*                             UIInputActionDataTable;                            // 0x01D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalMasterDataTableAccess_UIInputActionData* Access_UIInputActionDataTable;                     // 0x01E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPalTechnologyDataSet                  TechnologyDataSet;                                 // 0x01E8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UDataTable*                             WorldMapDataTable;                                 // 0x0200(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             ItemShopLotteryDataTable;                          // 0x0208(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalMasterDataTableAccess_ItemShopLottery* Access_ItemShopLotteryDataTable;                   // 0x0210(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             ItemShopDataTable;                                 // 0x0218(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalMasterDataTableAccess_ItemShop*     Access_ItemShopDataTable;                          // 0x0220(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             PalShopDataTable;                                  // 0x0228(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalMasterDataTableAccess_PalShop*      Access_PalShopDataTable;                           // 0x0230(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMasterDataTables">();
	}
	static class UPalMasterDataTables* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMasterDataTables>();
	}
};
static_assert(alignof(UPalMasterDataTables) == 0x000008, "Wrong alignment on UPalMasterDataTables");
static_assert(sizeof(UPalMasterDataTables) == 0x000238, "Wrong size on UPalMasterDataTables");
static_assert(offsetof(UPalMasterDataTables, WildSpawnerDataTable) == 0x000028, "Member 'UPalMasterDataTables::WildSpawnerDataTable' has a wrong offset!");
static_assert(offsetof(UPalMasterDataTables, Access_WildSpawnerDataTable) == 0x000030, "Member 'UPalMasterDataTables::Access_WildSpawnerDataTable' has a wrong offset!");
static_assert(offsetof(UPalMasterDataTables, ItemRecipeDataTable) == 0x000038, "Member 'UPalMasterDataTables::ItemRecipeDataTable' has a wrong offset!");
static_assert(offsetof(UPalMasterDataTables, Access_ItemRecipeDataTable) == 0x000040, "Member 'UPalMasterDataTables::Access_ItemRecipeDataTable' has a wrong offset!");
static_assert(offsetof(UPalMasterDataTables, FarmCropDataTable) == 0x000048, "Member 'UPalMasterDataTables::FarmCropDataTable' has a wrong offset!");
static_assert(offsetof(UPalMasterDataTables, Access_FarmCropDataTable) == 0x000050, "Member 'UPalMasterDataTables::Access_FarmCropDataTable' has a wrong offset!");
static_assert(offsetof(UPalMasterDataTables, MapObjectDataTable) == 0x000058, "Member 'UPalMasterDataTables::MapObjectDataTable' has a wrong offset!");
static_assert(offsetof(UPalMasterDataTables, Access_MapObjectDataTable) == 0x000060, "Member 'UPalMasterDataTables::Access_MapObjectDataTable' has a wrong offset!");
static_assert(offsetof(UPalMasterDataTables, BuildObjectDataTable) == 0x000068, "Member 'UPalMasterDataTables::BuildObjectDataTable' has a wrong offset!");
static_assert(offsetof(UPalMasterDataTables, Access_BuildObjectDataTable) == 0x000070, "Member 'UPalMasterDataTables::Access_BuildObjectDataTable' has a wrong offset!");
static_assert(offsetof(UPalMasterDataTables, BuildObjectIconDataTable) == 0x000078, "Member 'UPalMasterDataTables::BuildObjectIconDataTable' has a wrong offset!");
static_assert(offsetof(UPalMasterDataTables, Access_BuildObjectIconDataTable) == 0x000080, "Member 'UPalMasterDataTables::Access_BuildObjectIconDataTable' has a wrong offset!");
static_assert(offsetof(UPalMasterDataTables, ItemProductDataTable) == 0x000088, "Member 'UPalMasterDataTables::ItemProductDataTable' has a wrong offset!");
static_assert(offsetof(UPalMasterDataTables, Access_ItemProductDataTable) == 0x000090, "Member 'UPalMasterDataTables::Access_ItemProductDataTable' has a wrong offset!");
static_assert(offsetof(UPalMasterDataTables, BaseCampLevelDataTable) == 0x000098, "Member 'UPalMasterDataTables::BaseCampLevelDataTable' has a wrong offset!");
static_assert(offsetof(UPalMasterDataTables, Access_BaseCampLevelDataTable) == 0x0000A0, "Member 'UPalMasterDataTables::Access_BaseCampLevelDataTable' has a wrong offset!");
static_assert(offsetof(UPalMasterDataTables, DungeonSpawnAreaDataTable) == 0x0000A8, "Member 'UPalMasterDataTables::DungeonSpawnAreaDataTable' has a wrong offset!");
static_assert(offsetof(UPalMasterDataTables, Access_DungeonSpawnAreaDataTable) == 0x0000B0, "Member 'UPalMasterDataTables::Access_DungeonSpawnAreaDataTable' has a wrong offset!");
static_assert(offsetof(UPalMasterDataTables, DungeonLevelDataTable) == 0x0000B8, "Member 'UPalMasterDataTables::DungeonLevelDataTable' has a wrong offset!");
static_assert(offsetof(UPalMasterDataTables, Access_DungeonLevelDataTable) == 0x0000C0, "Member 'UPalMasterDataTables::Access_DungeonLevelDataTable' has a wrong offset!");
static_assert(offsetof(UPalMasterDataTables, DungeonEnemySpawnerDataTable) == 0x0000C8, "Member 'UPalMasterDataTables::DungeonEnemySpawnerDataTable' has a wrong offset!");
static_assert(offsetof(UPalMasterDataTables, Access_DungeonEnemySpawnerDataTable) == 0x0000D0, "Member 'UPalMasterDataTables::Access_DungeonEnemySpawnerDataTable' has a wrong offset!");
static_assert(offsetof(UPalMasterDataTables, DungeonItemLotteryDataTable) == 0x0000D8, "Member 'UPalMasterDataTables::DungeonItemLotteryDataTable' has a wrong offset!");
static_assert(offsetof(UPalMasterDataTables, Access_DungeonItemLotteryDataTable) == 0x0000E0, "Member 'UPalMasterDataTables::Access_DungeonItemLotteryDataTable' has a wrong offset!");
static_assert(offsetof(UPalMasterDataTables, FieldLotteryNameDataTable) == 0x0000E8, "Member 'UPalMasterDataTables::FieldLotteryNameDataTable' has a wrong offset!");
static_assert(offsetof(UPalMasterDataTables, Access_FieldLotteryNameDataTable) == 0x0000F0, "Member 'UPalMasterDataTables::Access_FieldLotteryNameDataTable' has a wrong offset!");
static_assert(offsetof(UPalMasterDataTables, ItemLotteryDataTable) == 0x0000F8, "Member 'UPalMasterDataTables::ItemLotteryDataTable' has a wrong offset!");
static_assert(offsetof(UPalMasterDataTables, Access_ItemLotteryDataTable) == 0x000100, "Member 'UPalMasterDataTables::Access_ItemLotteryDataTable' has a wrong offset!");
static_assert(offsetof(UPalMasterDataTables, PlayerStatusRankDataTable) == 0x000108, "Member 'UPalMasterDataTables::PlayerStatusRankDataTable' has a wrong offset!");
static_assert(offsetof(UPalMasterDataTables, Access_PlayerStatusRankDataTable) == 0x000110, "Member 'UPalMasterDataTables::Access_PlayerStatusRankDataTable' has a wrong offset!");
static_assert(offsetof(UPalMasterDataTables, CharacterUpgradeDataTable) == 0x000118, "Member 'UPalMasterDataTables::CharacterUpgradeDataTable' has a wrong offset!");
static_assert(offsetof(UPalMasterDataTables, Access_CharacterUpgradeDataTable) == 0x000120, "Member 'UPalMasterDataTables::Access_CharacterUpgradeDataTable' has a wrong offset!");
static_assert(offsetof(UPalMasterDataTables, NoteDataAsset) == 0x000128, "Member 'UPalMasterDataTables::NoteDataAsset' has a wrong offset!");
static_assert(offsetof(UPalMasterDataTables, HelpGuideDataAsset) == 0x000130, "Member 'UPalMasterDataTables::HelpGuideDataAsset' has a wrong offset!");
static_assert(offsetof(UPalMasterDataTables, LocalizeTextDataTableMap) == 0x000138, "Member 'UPalMasterDataTables::LocalizeTextDataTableMap' has a wrong offset!");
static_assert(offsetof(UPalMasterDataTables, Access_LocalizeTextDataTables) == 0x000188, "Member 'UPalMasterDataTables::Access_LocalizeTextDataTables' has a wrong offset!");
static_assert(offsetof(UPalMasterDataTables, UIInputActionDataTable) == 0x0001D8, "Member 'UPalMasterDataTables::UIInputActionDataTable' has a wrong offset!");
static_assert(offsetof(UPalMasterDataTables, Access_UIInputActionDataTable) == 0x0001E0, "Member 'UPalMasterDataTables::Access_UIInputActionDataTable' has a wrong offset!");
static_assert(offsetof(UPalMasterDataTables, TechnologyDataSet) == 0x0001E8, "Member 'UPalMasterDataTables::TechnologyDataSet' has a wrong offset!");
static_assert(offsetof(UPalMasterDataTables, WorldMapDataTable) == 0x000200, "Member 'UPalMasterDataTables::WorldMapDataTable' has a wrong offset!");
static_assert(offsetof(UPalMasterDataTables, ItemShopLotteryDataTable) == 0x000208, "Member 'UPalMasterDataTables::ItemShopLotteryDataTable' has a wrong offset!");
static_assert(offsetof(UPalMasterDataTables, Access_ItemShopLotteryDataTable) == 0x000210, "Member 'UPalMasterDataTables::Access_ItemShopLotteryDataTable' has a wrong offset!");
static_assert(offsetof(UPalMasterDataTables, ItemShopDataTable) == 0x000218, "Member 'UPalMasterDataTables::ItemShopDataTable' has a wrong offset!");
static_assert(offsetof(UPalMasterDataTables, Access_ItemShopDataTable) == 0x000220, "Member 'UPalMasterDataTables::Access_ItemShopDataTable' has a wrong offset!");
static_assert(offsetof(UPalMasterDataTables, PalShopDataTable) == 0x000228, "Member 'UPalMasterDataTables::PalShopDataTable' has a wrong offset!");
static_assert(offsetof(UPalMasterDataTables, Access_PalShopDataTable) == 0x000230, "Member 'UPalMasterDataTables::Access_PalShopDataTable' has a wrong offset!");

// Class Pal.PalMoneyData
// 0x0030 (0x0058 - 0x0028)
class UPalMoneyData final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnUpdatedMoneyDelegate;                            // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAddMoneyDelegate;                                // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UPalPlayerInventoryData*                ParentInventoryData;                               // 0x0048(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D3D[0x8];                                     // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddMoneyDelegate__DelegateSignature(int64 OldMoney, int64 AddMoney);
	void OnUpdateInventorylContainer(class UPalItemContainer* Container);
	void UpdatedMoneyDelegate__DelegateSignature(int64 NowMoney);

	int64 GetNowMoney() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMoneyData">();
	}
	static class UPalMoneyData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMoneyData>();
	}
};
static_assert(alignof(UPalMoneyData) == 0x000008, "Wrong alignment on UPalMoneyData");
static_assert(sizeof(UPalMoneyData) == 0x000058, "Wrong size on UPalMoneyData");
static_assert(offsetof(UPalMoneyData, OnUpdatedMoneyDelegate) == 0x000028, "Member 'UPalMoneyData::OnUpdatedMoneyDelegate' has a wrong offset!");
static_assert(offsetof(UPalMoneyData, OnAddMoneyDelegate) == 0x000038, "Member 'UPalMoneyData::OnAddMoneyDelegate' has a wrong offset!");
static_assert(offsetof(UPalMoneyData, ParentInventoryData) == 0x000048, "Member 'UPalMoneyData::ParentInventoryData' has a wrong offset!");

// Class Pal.PalNPC
// 0x0010 (0x0920 - 0x0910)
class APalNPC : public APalCharacter
{
public:
	class UPalNPCWeaponGenerator*                 WeaponGenerator;                                   // 0x0908(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEnableJumpEffect;                                // 0x0910(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D3E[0x3];                                     // 0x0911(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DefaultVoiceID;                                    // 0x0914(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D3F[0x8];                                     // 0x0918(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCompletedInitParam(class APalCharacter* InCharacter);
	void RemoveEnemyFromBattleManager(const struct FPalDeadInfo& DeadInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalNPC">();
	}
	static class APalNPC* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalNPC>();
	}
};
static_assert(alignof(APalNPC) == 0x000010, "Wrong alignment on APalNPC");
static_assert(sizeof(APalNPC) == 0x000920, "Wrong size on APalNPC");
static_assert(offsetof(APalNPC, WeaponGenerator) == 0x000908, "Member 'APalNPC::WeaponGenerator' has a wrong offset!");
static_assert(offsetof(APalNPC, IsEnableJumpEffect) == 0x000910, "Member 'APalNPC::IsEnableJumpEffect' has a wrong offset!");
static_assert(offsetof(APalNPC, DefaultVoiceID) == 0x000914, "Member 'APalNPC::DefaultVoiceID' has a wrong offset!");

// Class Pal.PalMonsterCharacter
// 0x0080 (0x09A0 - 0x0920)
class APalMonsterCharacter : public APalNPC
{
public:
	uint8                                         Pad_2D40[0x8];                                     // 0x0920(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TScriptInterface<class IPalInteractiveObjectComponentInterface> InteractiveObj;                                    // 0x0928(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalCharacterLiftupObjectComponent*     LiftupObjectComponent;                             // 0x0938(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D41[0x60];                                    // 0x0940(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MasterWazaSetup(class APalCharacter* InCharacter);
	void MasterWazaUpdateWhenLevelUp(int32 AddLevel, int32 NowLevel);
	void OnSelectedOrderWorkerRadialMenu(class UPalHUDDispatchParameterBase* Parameter);
	void OnTriggerInteract(class AActor* OtherActor, EPalInteractiveObjectIndicatorType IndicatorType);
	void SelectedFeedingItem(const struct FPalItemSlotId& ItemSlotId, const int32 Num);

	bool IsLiftupObject() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMonsterCharacter">();
	}
	static class APalMonsterCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalMonsterCharacter>();
	}
};
static_assert(alignof(APalMonsterCharacter) == 0x000010, "Wrong alignment on APalMonsterCharacter");
static_assert(sizeof(APalMonsterCharacter) == 0x0009A0, "Wrong size on APalMonsterCharacter");
static_assert(offsetof(APalMonsterCharacter, InteractiveObj) == 0x000928, "Member 'APalMonsterCharacter::InteractiveObj' has a wrong offset!");
static_assert(offsetof(APalMonsterCharacter, LiftupObjectComponent) == 0x000938, "Member 'APalMonsterCharacter::LiftupObjectComponent' has a wrong offset!");

// Class Pal.PalMonsterControllerBaseCampUtility
// 0x0000 (0x0028 - 0x0028)
class UPalMonsterControllerBaseCampUtility final : public UBlueprintFunctionLibrary
{
public:
	static struct FPalMonsterControllerBaseCampHungryParameter SetHungryParameterToDefault(const class UObject* WorldObjectContext, const struct FPalMonsterControllerBaseCampHungryParameter& Parameter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMonsterControllerBaseCampUtility">();
	}
	static class UPalMonsterControllerBaseCampUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMonsterControllerBaseCampUtility>();
	}
};
static_assert(alignof(UPalMonsterControllerBaseCampUtility) == 0x000008, "Wrong alignment on UPalMonsterControllerBaseCampUtility");
static_assert(sizeof(UPalMonsterControllerBaseCampUtility) == 0x000028, "Wrong size on UPalMonsterControllerBaseCampUtility");

// Class Pal.PalMonsterControllerBaseCampInterface
// 0x0000 (0x0028 - 0x0028)
class IPalMonsterControllerBaseCampInterface final : public IInterface
{
public:
	void InterruptPlayWorkerEventAction(class UPalAIActionBase* Action, const EAIRequestPriority Priority);
	void InterruptRecoverHungryAction(const struct FPalMonsterControllerBaseCampHungryParameter& Parameter);
	void InterruptReturnBackToBaseCamp();
	void InterruptSleepActivelyAction(const struct FPalAIActionBaseCampSleepActivelyParameter& Parameter);
	void NotifyOrderCommand(const EPalMapBaseCampWorkerOrderType OrderType);
	void SetBaseCampAction();
	class UPalAIActionBase* SetBaseCampActionByClass(TSubclassOf<class UPalAIActionBase> ActionClass);
	void SetBaseCampActionLift();
	class UPalAIActionBaseCampSleep* SetBaseCampActionSleep();
	void SetBaseCampActionSleepMedicalBed(const struct FGuid& TargetBedConcreteModelId);
	void SetBaseCampActionSpawningForWork();
	void SetBaseCampActionWithFixAssign(const struct FGuid& TargetWorkProgressId, const float DistanceFixAssignTargetting);
	void SetBaseCampFighterAction();
	void SetBaseCampFighterGunnerAction();
	void SetCapturedStorageAction();
	void SetDefaultPositionAction();
	void TerminateBaseCampActionByClass(TSubclassOf<class UPalAIActionBase> ActionClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMonsterControllerBaseCampInterface">();
	}
	static class IPalMonsterControllerBaseCampInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPalMonsterControllerBaseCampInterface>();
	}
};
static_assert(alignof(IPalMonsterControllerBaseCampInterface) == 0x000008, "Wrong alignment on IPalMonsterControllerBaseCampInterface");
static_assert(sizeof(IPalMonsterControllerBaseCampInterface) == 0x000028, "Wrong size on IPalMonsterControllerBaseCampInterface");

// Class Pal.PalMonsterControllerLogInterface
// 0x0000 (0x0028 - 0x0028)
class IPalMonsterControllerLogInterface final : public IInterface
{
public:
	void ShowBaseCampLog(const struct FPalMonsterControllerBaseCampLogContent& Content);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMonsterControllerLogInterface">();
	}
	static class IPalMonsterControllerLogInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPalMonsterControllerLogInterface>();
	}
};
static_assert(alignof(IPalMonsterControllerLogInterface) == 0x000008, "Wrong alignment on IPalMonsterControllerLogInterface");
static_assert(sizeof(IPalMonsterControllerLogInterface) == 0x000028, "Wrong size on IPalMonsterControllerLogInterface");

// Class Pal.PalMonsterEquipWeaponBase
// 0x0018 (0x0550 - 0x0538)
class APalMonsterEquipWeaponBase final : public APalWeaponBase
{
public:
	struct FVector                                BattleAimTargetLocation;                           // 0x0538(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	TSubclassOf<class APalBullet> GetBulletClass();
	float GetBulrAngle();
	struct FVector GetCommonTargetLocation();
	class UNiagaraSystem* GetMuzzleEffect();
	struct FVector GetMuzzleLocation();
	struct FRotator GetMuzzleRotation();
	class APalBullet* ShootOneBullet(TSubclassOf<class APalBullet> bulletClass, class UNiagaraSystem* MuzzleEffect, const struct FVector& MuzzleLocation, const struct FRotator& MuzzleRotate, float BulrAngle);
	class APalBullet* ShootOneBulletDefault();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMonsterEquipWeaponBase">();
	}
	static class APalMonsterEquipWeaponBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalMonsterEquipWeaponBase>();
	}
};
static_assert(alignof(APalMonsterEquipWeaponBase) == 0x000008, "Wrong alignment on APalMonsterEquipWeaponBase");
static_assert(sizeof(APalMonsterEquipWeaponBase) == 0x000550, "Wrong size on APalMonsterEquipWeaponBase");
static_assert(offsetof(APalMonsterEquipWeaponBase, BattleAimTargetLocation) == 0x000538, "Member 'APalMonsterEquipWeaponBase::BattleAimTargetLocation' has a wrong offset!");

// Class Pal.PalNavigationInvokerComponent
// 0x0068 (0x0110 - 0x00A8)
class UPalNavigationInvokerComponent final : public UNavigationInvokerComponent
{
public:
	uint8                                         Pad_2D45[0x8];                                     // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsAutoActivateInvoker;                            // 0x00B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsWaitWorldPartition;                             // 0x00B1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D46[0x2];                                     // 0x00B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FIntPoint                              AreaBelongTo;                                      // 0x00B4(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D47[0x4];                                     // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFlagContainer                         IsDisableInvorkerFlag;                             // 0x00C0(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	void ActivateInvoker();
	void SetDisableInvorkerFlag(class FName FlagName, bool IsDisable);

	bool IsDisableInvorker() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalNavigationInvokerComponent">();
	}
	static class UPalNavigationInvokerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalNavigationInvokerComponent>();
	}
};
static_assert(alignof(UPalNavigationInvokerComponent) == 0x000008, "Wrong alignment on UPalNavigationInvokerComponent");
static_assert(sizeof(UPalNavigationInvokerComponent) == 0x000110, "Wrong size on UPalNavigationInvokerComponent");
static_assert(offsetof(UPalNavigationInvokerComponent, bIsAutoActivateInvoker) == 0x0000B0, "Member 'UPalNavigationInvokerComponent::bIsAutoActivateInvoker' has a wrong offset!");
static_assert(offsetof(UPalNavigationInvokerComponent, bIsWaitWorldPartition) == 0x0000B1, "Member 'UPalNavigationInvokerComponent::bIsWaitWorldPartition' has a wrong offset!");
static_assert(offsetof(UPalNavigationInvokerComponent, AreaBelongTo) == 0x0000B4, "Member 'UPalNavigationInvokerComponent::AreaBelongTo' has a wrong offset!");
static_assert(offsetof(UPalNavigationInvokerComponent, IsDisableInvorkerFlag) == 0x0000C0, "Member 'UPalNavigationInvokerComponent::IsDisableInvorkerFlag' has a wrong offset!");

// Class Pal.PalNavigationSystemV1
// 0x0058 (0x1588 - 0x1530)
class UPalNavigationSystemV1 final : public UNavigationSystemV1
{
public:
	uint8                                         Pad_2D49[0x50];                                    // 0x1530(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UpdateInvokerCounter;                              // 0x1580(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D4A[0x4];                                     // 0x1584(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalNavigationSystemV1">();
	}
	static class UPalNavigationSystemV1* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalNavigationSystemV1>();
	}
};
static_assert(alignof(UPalNavigationSystemV1) == 0x000008, "Wrong alignment on UPalNavigationSystemV1");
static_assert(sizeof(UPalNavigationSystemV1) == 0x001588, "Wrong size on UPalNavigationSystemV1");
static_assert(offsetof(UPalNavigationSystemV1, UpdateInvokerCounter) == 0x001580, "Member 'UPalNavigationSystemV1::UpdateInvokerCounter' has a wrong offset!");

// Class Pal.PalUIInventoryModel
// 0x0078 (0x00A0 - 0x0028)
class UPalUIInventoryModel : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnUpdateContainerContentDelegate;                  // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFinishedItemTrashDelegate;                       // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFinishedItemDropDelegate;                        // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UPalItemContainerMultiHelper*           InventoryContainers;                               // 0x0058(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPalItemSlotId                         TmpLiftedItemSlotId;                               // 0x0060(0x0014)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPalItemAndNum                         TmpLiftedItemAndNum;                               // 0x0074(0x002C)(NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	bool CheckLiftItemTypeA(EPalItemTypeA CheckType);
	bool CheckLiftItemTypeB(EPalItemTypeB CheckType);
	void Dispose();
	void DropItemFromDropSlot();
	void DropLiftUpItem();
	void FinishedItemDropDelegate__DelegateSignature(bool Result);
	void FinishedItemTrashDelegate__DelegateSignature(bool Result);
	bool IsExistItems(const TArray<struct FPalStaticItemIdAndNum>& RequiredItems);
	void OnFinishedDropItem(bool Result);
	void OnFinishedTrashItemAlert(bool Result);
	void OnFinishedTrashItemDialog(bool Result);
	void OnUpdateContainerContent(class UPalItemContainer* Container);
	void RequestSortInventory();
	void ResetLiftItem();
	void SelectItemSlot(const struct FPalItemSlotId& SlotID, const EPalItemSlotPressType PressType);
	void Setup();
	void TrashItemFromDropSlot();
	void TrashLiftUpItem();
	void TryFillSlotToInventoryFromTargetContainer(const struct FPalContainerId& FromContainerId);
	void TryFillSlotToTargetContainerFromInventory(const struct FPalContainerId& ToContainerId);
	void TryMoveContainerToInventory(class UPalItemContainer* FromContainer, bool TryAutoEquip);
	void TryMoveSlotToInventory(class UPalItemSlot* FromSlot, bool TryAutoEquip);
	void UpdateContainerContentDelegate__DelegateSignature();

	const bool TryGetInventoryContainer(const EPalPlayerInventoryType Type, class UPalItemContainer** Container) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIInventoryModel">();
	}
	static class UPalUIInventoryModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIInventoryModel>();
	}
};
static_assert(alignof(UPalUIInventoryModel) == 0x000008, "Wrong alignment on UPalUIInventoryModel");
static_assert(sizeof(UPalUIInventoryModel) == 0x0000A0, "Wrong size on UPalUIInventoryModel");
static_assert(offsetof(UPalUIInventoryModel, OnUpdateContainerContentDelegate) == 0x000028, "Member 'UPalUIInventoryModel::OnUpdateContainerContentDelegate' has a wrong offset!");
static_assert(offsetof(UPalUIInventoryModel, OnFinishedItemTrashDelegate) == 0x000038, "Member 'UPalUIInventoryModel::OnFinishedItemTrashDelegate' has a wrong offset!");
static_assert(offsetof(UPalUIInventoryModel, OnFinishedItemDropDelegate) == 0x000048, "Member 'UPalUIInventoryModel::OnFinishedItemDropDelegate' has a wrong offset!");
static_assert(offsetof(UPalUIInventoryModel, InventoryContainers) == 0x000058, "Member 'UPalUIInventoryModel::InventoryContainers' has a wrong offset!");
static_assert(offsetof(UPalUIInventoryModel, TmpLiftedItemSlotId) == 0x000060, "Member 'UPalUIInventoryModel::TmpLiftedItemSlotId' has a wrong offset!");
static_assert(offsetof(UPalUIInventoryModel, TmpLiftedItemAndNum) == 0x000074, "Member 'UPalUIInventoryModel::TmpLiftedItemAndNum' has a wrong offset!");

// Class Pal.PalUIShopInventoryModel
// 0x0000 (0x00A0 - 0x00A0)
class UPalUIShopInventoryModel final : public UPalUIInventoryModel
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIShopInventoryModel">();
	}
	static class UPalUIShopInventoryModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIShopInventoryModel>();
	}
};
static_assert(alignof(UPalUIShopInventoryModel) == 0x000008, "Wrong alignment on UPalUIShopInventoryModel");
static_assert(sizeof(UPalUIShopInventoryModel) == 0x0000A0, "Wrong size on UPalUIShopInventoryModel");

// Class Pal.PalNetArchiveObject
// 0x0000 (0x0028 - 0x0028)
class UPalNetArchiveObject final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalNetArchiveObject">();
	}
	static class UPalNetArchiveObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalNetArchiveObject>();
	}
};
static_assert(alignof(UPalNetArchiveObject) == 0x000008, "Wrong alignment on UPalNetArchiveObject");
static_assert(sizeof(UPalNetArchiveObject) == 0x000028, "Wrong size on UPalNetArchiveObject");

// Class Pal.PalNetworkBossBattleComponent
// 0x0000 (0x00A0 - 0x00A0)
class UPalNetworkBossBattleComponent final : public UActorComponent
{
public:
	void ChangeSequence_ToClient(EPalBossType BossType, EPalBossBattleSequenceType NextSequence);
	void CombatResult_ToClient(EPalBossType BossType, EPalBossBattleCombatResult CombatResult);
	void NoticeSequenceEnd_ToServer(EPalBossType BossType, class APalPlayerCharacter* Player);
	void RemovePlayerFromRoom_ToClient(EPalBossType BossType, class APalPlayerCharacter* DeadPlayer);
	void RequestBossBattleEntry_ToServer(EPalBossType BossType, class APalPlayerCharacter* EntryPlayer);
	void RequestBossBattleStart_ToClient(bool IsSuccess, EPalBossType BossType, const struct FPalStageInstanceId& StageInstanceId, const TArray<class APalPlayerCharacter*>& JoinPlayers);
	void RequestBossBattleStart_ToServer(EPalBossType BossType, class APalPlayerCharacter* StartPlayer);
	void UnlockAchievement_ToClient(EPalBossType BossType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalNetworkBossBattleComponent">();
	}
	static class UPalNetworkBossBattleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalNetworkBossBattleComponent>();
	}
};
static_assert(alignof(UPalNetworkBossBattleComponent) == 0x000008, "Wrong alignment on UPalNetworkBossBattleComponent");
static_assert(sizeof(UPalNetworkBossBattleComponent) == 0x0000A0, "Wrong size on UPalNetworkBossBattleComponent");

// Class Pal.PalNetworkCharacterComponent
// 0x0000 (0x00A0 - 0x00A0)
class UPalNetworkCharacterComponent final : public UActorComponent
{
public:
	void ArenaSetup_ToClient();
	void ArenaStart_ToClient(const struct FPalArenaStartParameter& StartParam);
	void NotifyCustomFunction_ToServer(class APalPlayerCharacter* TalkPlayer, class APalCharacter* TargetNPC, const struct FPalNPCTalkNotifyInfo& TalkNotifyInfo);
	void NotifyTalkEnd_ToServer(class APalPlayerCharacter* TalkPlayer, class APalCharacter* TargetNPC);
	void NotifyTalkStart_ToServer(class APalPlayerCharacter* TalkPlayer, class APalCharacter* TargetNPC);
	void ReflectAction_ToClient(class APalCharacter* Character, const struct FActionDynamicParameter& Param, TSubclassOf<class UPalActionBase> ActionClass);
	void RequestReflectAction_ToServer(class APalCharacter* Character);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalNetworkCharacterComponent">();
	}
	static class UPalNetworkCharacterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalNetworkCharacterComponent>();
	}
};
static_assert(alignof(UPalNetworkCharacterComponent) == 0x000008, "Wrong alignment on UPalNetworkCharacterComponent");
static_assert(sizeof(UPalNetworkCharacterComponent) == 0x0000A0, "Wrong size on UPalNetworkCharacterComponent");

// Class Pal.PalNetworkCharacterContainerComponent
// 0x0050 (0x00F0 - 0x00A0)
class UPalNetworkCharacterContainerComponent final : public UActorComponent
{
public:
	TMap<struct FGuid, struct FPalNetworkCharacterContainerParameter> ContainerParamMap;                                 // 0x00A0(0x0050)(NativeAccessSpecifierPrivate)

public:
	void RecieveUnlockSlot_ToClient(const struct FPalCharacterSlotId& SlotID);
	void RecieveUnlockSlot_ToRequestClient(const struct FGuid& RequestID, const EPalCharacterContainerOperationResult Result);
	void RequestAddToContainer_ToServer_Rep(const struct FPalContainerId& ContainerId, const struct FPalInstanceID& IndividualId);
	void RequestEmptySlot_ToServer_Rep(const struct FPalCharacterSlotId& SlotID);
	void RequestSortContainer_ToServer(const struct FPalContainerId& ContainerId, const EPalCharacterContainerSortType SortType);
	void RequestSwap_ToServer_Rep(const struct FPalCharacterSlotId& SlotIdA, const struct FPalCharacterSlotId& SlotIdB);
	void RequestUnlockSlot_ToServer(const struct FGuid& RequestID, const struct FPalCharacterSlotId& SlotID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalNetworkCharacterContainerComponent">();
	}
	static class UPalNetworkCharacterContainerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalNetworkCharacterContainerComponent>();
	}
};
static_assert(alignof(UPalNetworkCharacterContainerComponent) == 0x000008, "Wrong alignment on UPalNetworkCharacterContainerComponent");
static_assert(sizeof(UPalNetworkCharacterContainerComponent) == 0x0000F0, "Wrong size on UPalNetworkCharacterContainerComponent");
static_assert(offsetof(UPalNetworkCharacterContainerComponent, ContainerParamMap) == 0x0000A0, "Member 'UPalNetworkCharacterContainerComponent::ContainerParamMap' has a wrong offset!");

// Class Pal.PalNetworkComponentUtility
// 0x0000 (0x0028 - 0x0028)
class UPalNetworkComponentUtility final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalNetworkComponentUtility">();
	}
	static class UPalNetworkComponentUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalNetworkComponentUtility>();
	}
};
static_assert(alignof(UPalNetworkComponentUtility) == 0x000008, "Wrong alignment on UPalNetworkComponentUtility");
static_assert(sizeof(UPalNetworkComponentUtility) == 0x000028, "Wrong size on UPalNetworkComponentUtility");

// Class Pal.PalNetworkIndividualComponent
// 0x0168 (0x0208 - 0x00A0)
class UPalNetworkIndividualComponent final : public UActorComponent
{
public:
	uint8                                         Pad_2D5A[0x168];                                   // 0x00A0(0x0168)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddEquipWaza_ToServer(const struct FPalInstanceID& ID, const EPalWazaID NewWaza);
	void AddHighPriorityList_ToServer(const struct FPalInstanceID& ID, class APalCharacter* TargetPlayer);
	void AddMasteredWaza_ToServer(const struct FPalInstanceID& ID, EPalWazaID WazaID);
	void AddPlayerCharacterStatusPoint_ToServer(const struct FPalInstanceID& ID, const TArray<struct FPalGotStatusPoint>& AddStatusPointArray);
	void AddRank_ToServer(const struct FPalInstanceID& ID, const class UPalStaticItemDataBase* ItemData);
	void AddTalent_ToServer(const struct FPalInstanceID& ID, const class UPalStaticItemDataBase* ItemData);
	void BroadcastChangeOwnerCharacter_ToAll(const struct FPalInstanceID& ID, const struct FGuid& PlayerUId, const struct FDateTime& OwnedTime);
	void CreateFixedIndividualID_ServerInternal(const struct FPalInstanceID& ID, const struct FPalIndividualCharacterSaveParameter& InitParameter, const struct FGuid& Guid, int32 RequestPlayerId);
	void CreateIndividualID_ServerInternal(const struct FPalIndividualCharacterSaveParameter& InitParameter, const struct FGuid& Guid, int32 RequestPlayerId);
	void CreateIndividualID_SyncCheck(const struct FPalInstanceID& ID, const struct FGuid& Guid);
	void CreateIndividualID_ToALL(const struct FPalIndividualCharacterSaveParameter& InitParameter, const struct FPalInstanceID& ID, const struct FGuid& Guid);
	void DespawnIndividualActor_ServerInternal(const struct FPalInstanceID& ID, const struct FGuid& Guid);
	void DespawnIndividualActor_SyncCheck(const struct FPalInstanceID& ID, const struct FGuid& Guid);
	void DespawnIndividualActor_ToALL(const struct FPalInstanceID& ID, const struct FGuid& Guid);
	void DespawnPhantomActor_ServerInternal(const struct FPalInstanceID& ID, int32 PhantomId, const struct FGuid& Guid);
	void DespawnPhantomActor_SyncCheck(const struct FPalInstanceID& ID, int32 PhantomId, const struct FGuid& Guid);
	void DespawnPhantomActor_ToALL(const struct FPalInstanceID& ID, int32 PhantomId, const struct FGuid& Guid);
	void DropToPhantomActor_ServerInternal(const struct FPalInstanceID& ID, const struct FGuid& Guid);
	void DropToPhantomActor_ToALL(const struct FPalInstanceID& ID, int32 PhantomId, const struct FGuid& Guid);
	void EatItem_ToServer(const struct FPalInstanceID& ID, const class UPalStaticConsumeItemData* ItemData, int32 Num);
	void GainExp_ToServer(const struct FPalInstanceID& ID, int32 Exp);
	void LevelUp_ToServer(const struct FPalInstanceID& ID, int32 Level);
	void NotifyAddedMasteredWaza_ToAll(const struct FPalInstanceID& ID, EPalWazaID WazaID);
	void RaiseToMainActor_ToALL(const struct FPalInstanceID& ID, int32 PhantomId, const struct FGuid& Guid);
	void RaiseToMainActor_ToServer(const struct FPalInstanceID& ID, int32 PhantomId, const struct FGuid& Guid);
	void RemoveEquipWaza_ToServer(const struct FPalInstanceID& ID, const EPalWazaID TargetWaza);
	void RemoveHighPriorityList_ToServer(const struct FPalInstanceID& ID, class APalCharacter* TargetPlayer);
	void ReplaceEquipWaza_ToServer(const struct FPalInstanceID& ID, const EPalWazaID OldWaza, const EPalWazaID NewWaza);
	void ResetStatusPoint_ToServer(const struct FPalInstanceID& ID);
	void SetWorkerSick_ToServer(const struct FPalInstanceID& ID, EPalBaseCampWorkerSickType SickType);
	void SpawnIndividualActor_ServerInternal(const struct FPalInstanceID& ID, const struct FNetworkActorSpawnParameters& SpawnParameter, const struct FGuid& Guid);
	void SpawnIndividualActor_SyncCheck(const struct FPalInstanceID& ID, const struct FGuid& Guid);
	void SpawnIndividualActor_ToALL(const struct FPalInstanceID& ID, class AActor* Actor, const struct FGuid& Guid);
	void SpawnPhantomActor_ServerInternal(const struct FPalInstanceID& ID, const struct FNetworkActorSpawnParameters& SpawnParameter, const struct FGuid& Guid);
	void SpawnPhantomActor_SyncCheck(const struct FPalInstanceID& ID, int32 PhantomId, const struct FGuid& Guid);
	void SpawnPhantomActor_ToALL(const struct FPalInstanceID& ID, int32 PhantomId, class AActor* Actor, const struct FGuid& Guid);
	void UpdateCharacterParameter_ServerInternal(const struct FPalInstanceID& ID, const struct FPalNetArchive& ParameterArchive, const struct FGuid& Guid);
	void UpdateCharacterParameter_ToAll(const struct FPalInstanceID& ID, const struct FPalNetArchive& ParameterArchive, const struct FGuid& Guid);
	void UseGainStatusPointsItem_ToServer(const struct FPalInstanceID& ID, const class FName ItemId, const int32 Num);
	void UseItemInSlotToCharacter_ToServer(const struct FPalInstanceID& ID, const struct FPalItemSlotIdAndNum& SlotAndNum);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalNetworkIndividualComponent">();
	}
	static class UPalNetworkIndividualComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalNetworkIndividualComponent>();
	}
};
static_assert(alignof(UPalNetworkIndividualComponent) == 0x000008, "Wrong alignment on UPalNetworkIndividualComponent");
static_assert(sizeof(UPalNetworkIndividualComponent) == 0x000208, "Wrong size on UPalNetworkIndividualComponent");

// Class Pal.PalUIWorkSuitabilitySelect
// 0x0008 (0x0438 - 0x0430)
class UPalUIWorkSuitabilitySelect final : public UPalUserWidgetOverlayUI
{
public:
	TWeakObjectPtr<class UPalHUDDispatchParameter_WorkSuitabilityPreference> MyHUDDispatchParameter;                            // 0x0430(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void RequestChangeBattleSetting(const class UPalIndividualCharacterSlot* TargetCharacterSlot, bool CanBattle);
	void RequestChangeSuitabilitySetting(const class UPalIndividualCharacterSlot* TargetCharacterSlot, EPalWorkSuitability SuitabilityType, bool IsOn);

	bool GetTargetCharacterContainer(class UPalIndividualCharacterContainer** OutContainer) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIWorkSuitabilitySelect">();
	}
	static class UPalUIWorkSuitabilitySelect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIWorkSuitabilitySelect>();
	}
};
static_assert(alignof(UPalUIWorkSuitabilitySelect) == 0x000008, "Wrong alignment on UPalUIWorkSuitabilitySelect");
static_assert(sizeof(UPalUIWorkSuitabilitySelect) == 0x000438, "Wrong size on UPalUIWorkSuitabilitySelect");
static_assert(offsetof(UPalUIWorkSuitabilitySelect, MyHUDDispatchParameter) == 0x000430, "Member 'UPalUIWorkSuitabilitySelect::MyHUDDispatchParameter' has a wrong offset!");

// Class Pal.PalNetworkInvaderComponent
// 0x0000 (0x00A0 - 0x00A0)
class UPalNetworkInvaderComponent final : public UActorComponent
{
public:
	void OnInvaderArrived(const struct FPalIncidentBroadcastParameter& Parameter);
	void OnInvaderEnd(const struct FPalIncidentBroadcastParameter& Parameter);
	void OnInvaderStart(const struct FPalIncidentBroadcastParameter& Parameter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalNetworkInvaderComponent">();
	}
	static class UPalNetworkInvaderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalNetworkInvaderComponent>();
	}
};
static_assert(alignof(UPalNetworkInvaderComponent) == 0x000008, "Wrong alignment on UPalNetworkInvaderComponent");
static_assert(sizeof(UPalNetworkInvaderComponent) == 0x0000A0, "Wrong size on UPalNetworkInvaderComponent");

// Class Pal.PalNetworkMapObjectComponent
// 0x00A0 (0x0140 - 0x00A0)
class UPalNetworkMapObjectComponent final : public UActorComponent
{
public:
	TMap<struct FGuid, struct FPalNetworkMapObjectSpawnRequestParameter> MapObjectSpawnRequestParameterMap;                 // 0x00A0(0x0050)(NativeAccessSpecifierPrivate)
	TMap<struct FGuid, class UPalMapObjectSpawnRequestHandler*> SpawnRequestHandlerMap;                            // 0x00F0(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	void NotifyConcreteModel_Multicast_bool(const struct FGuid& ConcreteModelInstanceId, const class FName FunctionName, bool Value);
	void NotifyConcreteModel_Multicast_FPalNetArchive(const struct FGuid& ConcreteModelInstanceId, const class FName FunctionName, const struct FPalNetArchive& Value);
	void NotifyConcreteModel_Multicast_FVector(const struct FGuid& ConcreteModelInstanceId, const class FName FunctionName, const struct FVector& Value);
	void NotifyConcreteModel_Multicast_int32(const struct FGuid& ConcreteModelInstanceId, const class FName FunctionName, int32 Value);
	void NotifyConcreteModel_Multicast_void(const struct FGuid& ConcreteModelInstanceId, const class FName FunctionName);
	void NotifyConcreteModel_RequestClient_bool(const struct FGuid& ConcreteModelInstanceId, const class FName FunctionName, bool Value);
	void NotifyConcreteModel_RequestClient_FPalNetArchive(const struct FGuid& ConcreteModelInstanceId, const class FName FunctionName, const struct FPalNetArchive& Value);
	void NotifyConcreteModel_RequestClient_FVector(const struct FGuid& ConcreteModelInstanceId, const class FName FunctionName, const struct FVector& Value);
	void NotifyConcreteModel_RequestClient_int32(const struct FGuid& ConcreteModelInstanceId, const class FName FunctionName, int32 Value);
	void NotifyConcreteModel_RequestClient_void(const struct FGuid& ConcreteModelInstanceId, const class FName FunctionName);
	void NotifyConcreteModel_ToMulticast_bool(const struct FGuid& ConcreteModelInstanceId, const class FName FunctionName, bool Value);
	void NotifyConcreteModel_ToMulticast_FPalNetArchive(const struct FGuid& ConcreteModelInstanceId, const class FName FunctionName, const struct FPalNetArchive& Value);
	void NotifyConcreteModel_ToMulticast_FVector(const struct FGuid& ConcreteModelInstanceId, const class FName FunctionName, const struct FVector& Value);
	void NotifyConcreteModel_ToMulticast_int32(const struct FGuid& ConcreteModelInstanceId, const class FName FunctionName, int32 Value);
	void NotifyConcreteModel_ToMulticast_void(const struct FGuid& ConcreteModelInstanceId, const class FName FunctionName);
	void NotifyConcreteModel_ToRequestClient_bool(const struct FGuid& ConcreteModelInstanceId, const int32 RequestPlayerId, const class FName FunctionName, bool Value);
	void NotifyConcreteModel_ToRequestClient_FPalNetArchive(const struct FGuid& ConcreteModelInstanceId, const int32 RequestPlayerId, const class FName FunctionName, const struct FPalNetArchive& Value);
	void NotifyConcreteModel_ToRequestClient_FVector(const struct FGuid& ConcreteModelInstanceId, const int32 RequestPlayerId, const class FName FunctionName, const struct FVector& Value);
	void NotifyConcreteModel_ToRequestClient_int32(const struct FGuid& ConcreteModelInstanceId, const int32 RequestPlayerId, const class FName FunctionName, int32 Value);
	void NotifyConcreteModel_ToRequestClient_void(const struct FGuid& ConcreteModelInstanceId, const int32 RequestPlayerId, const class FName FunctionName);
	void NotifyConcreteModelModule_Multicast_bool(const struct FGuid& ConcreteModelInstanceId, const EPalMapObjectConcreteModelModuleType ModuleType, const class FName FunctionName, bool Value);
	void NotifyConcreteModelModule_Multicast_FPalNetArchive(const struct FGuid& ConcreteModelInstanceId, const EPalMapObjectConcreteModelModuleType ModuleType, const class FName FunctionName, const struct FPalNetArchive& Value);
	void NotifyConcreteModelModule_Multicast_FVector(const struct FGuid& ConcreteModelInstanceId, const EPalMapObjectConcreteModelModuleType ModuleType, const class FName FunctionName, const struct FVector& Value);
	void NotifyConcreteModelModule_Multicast_int32(const struct FGuid& ConcreteModelInstanceId, const EPalMapObjectConcreteModelModuleType ModuleType, const class FName FunctionName, int32 Value);
	void NotifyConcreteModelModule_Multicast_void(const struct FGuid& ConcreteModelInstanceId, const EPalMapObjectConcreteModelModuleType ModuleType, const class FName FunctionName);
	void NotifyConcreteModelModule_RequestClient_bool(const struct FGuid& ConcreteModelInstanceId, const EPalMapObjectConcreteModelModuleType ModuleType, const class FName FunctionName, bool Value);
	void NotifyConcreteModelModule_RequestClient_FPalNetArchive(const struct FGuid& ConcreteModelInstanceId, const EPalMapObjectConcreteModelModuleType ModuleType, const class FName FunctionName, const struct FPalNetArchive& Value);
	void NotifyConcreteModelModule_RequestClient_FVector(const struct FGuid& ConcreteModelInstanceId, const EPalMapObjectConcreteModelModuleType ModuleType, const class FName FunctionName, const struct FVector& Value);
	void NotifyConcreteModelModule_RequestClient_int32(const struct FGuid& ConcreteModelInstanceId, const EPalMapObjectConcreteModelModuleType ModuleType, const class FName FunctionName, int32 Value);
	void NotifyConcreteModelModule_RequestClient_void(const struct FGuid& ConcreteModelInstanceId, const EPalMapObjectConcreteModelModuleType ModuleType, const class FName FunctionName);
	void NotifyReceivePickupResultFailed_ToClient(class UPalMapObjectPickableItemModelBase* Model);
	void NotifyReceivePickupResultSuccess_ToClient(const struct FPalNetArchive& PickupItemArchive, class UPalMapObjectPickableItemModelBase* Model, bool IsAllPickup);
	void ReceiveDismantleObjectResult_ToClient(const EPalMapObjectOperationResult Result, const struct FGuid& InstanceId);
	void ReceiveUpdateHp_ToClient(const struct FGuid& InstanceId, const int32 UpdatedHp);
	void RecieveDamageMapObject_ToClient(const struct FGuid& InstanceId, const struct FPalDamageInfo& Info, const int32 DamagedHp);
	void RecieveDestroyMapObject_Multicast(const struct FGuid& InstanceId);
	void RequestBuildCancel_ToServer(const struct FGuid& InstanceId);
	void RequestConcreteModel_bool(const struct FGuid& ConcreteModelInstanceId, const class FName FunctionName, bool Value);
	void RequestConcreteModel_FPalNetArchive(const struct FGuid& ConcreteModelInstanceId, const class FName FunctionName, const struct FPalNetArchive& Value);
	void RequestConcreteModel_FVector(const struct FGuid& ConcreteModelInstanceId, const class FName FunctionName, const struct FVector& Value);
	void RequestConcreteModel_int32(const struct FGuid& ConcreteModelInstanceId, const class FName FunctionName, int32 Value);
	void RequestConcreteModel_Server_bool(const struct FGuid& ConcreteModelInstanceId, const class FName FunctionName, bool Value);
	void RequestConcreteModel_Server_FPalNetArchive(const struct FGuid& ConcreteModelInstanceId, const class FName FunctionName, const struct FPalNetArchive& Value);
	void RequestConcreteModel_Server_FVector(const struct FGuid& ConcreteModelInstanceId, const class FName FunctionName, const struct FVector& Value);
	void RequestConcreteModel_Server_int32(const struct FGuid& ConcreteModelInstanceId, const class FName FunctionName, int32 Value);
	void RequestConcreteModel_Server_void(const struct FGuid& ConcreteModelInstanceId, const class FName FunctionName);
	void RequestConcreteModel_void(const struct FGuid& ConcreteModelInstanceId, const class FName FunctionName);
	void RequestConcreteModelModule_Server_bool(const struct FGuid& ConcreteModelInstanceId, const EPalMapObjectConcreteModelModuleType ModuleType, const class FName FunctionName, bool Value);
	void RequestConcreteModelModule_Server_FPalNetArchive(const struct FGuid& ConcreteModelInstanceId, const EPalMapObjectConcreteModelModuleType ModuleType, const class FName FunctionName, const struct FPalNetArchive& Value);
	void RequestConcreteModelModule_Server_FVector(const struct FGuid& ConcreteModelInstanceId, const EPalMapObjectConcreteModelModuleType ModuleType, const class FName FunctionName, const struct FVector& Value);
	void RequestConcreteModelModule_Server_int32(const struct FGuid& ConcreteModelInstanceId, const EPalMapObjectConcreteModelModuleType ModuleType, const class FName FunctionName, int32 Value);
	void RequestConcreteModelModule_Server_void(const struct FGuid& ConcreteModelInstanceId, const EPalMapObjectConcreteModelModuleType ModuleType, const class FName FunctionName);
	void RequestDamageFoliage_ToServer(const struct FPalCellCoord& CellCoord, const class FName ModelId, const TArray<struct FPalFoliageInstanceId>& InstanceIds, const struct FPalDamageInfo& DamageInfo);
	void RequestDamageMapObject_ToServer(const struct FGuid& InstanceId, const struct FPalDamageInfo& Info);
	void RequestDamageMapObjectSpawner_ToServer(class APalMapObjectSpawnerBase* TargetSpawnerActor, const struct FPalDamageInfo& DamageInfo);
	void RequestDismantleObject_ToServer(const struct FGuid& InstanceId);
	void RequestRepair_ToServer(const struct FGuid& InstanceId);
	void RequestSpawnMapObject_ToServer(const struct FGuid& RequestID, const class FName MapObjectId, const struct FVector& Location, const struct FQuat& Rotation, const TArray<struct FPalNetArchive>& ExtraParameterArchives);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalNetworkMapObjectComponent">();
	}
	static class UPalNetworkMapObjectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalNetworkMapObjectComponent>();
	}
};
static_assert(alignof(UPalNetworkMapObjectComponent) == 0x000008, "Wrong alignment on UPalNetworkMapObjectComponent");
static_assert(sizeof(UPalNetworkMapObjectComponent) == 0x000140, "Wrong size on UPalNetworkMapObjectComponent");
static_assert(offsetof(UPalNetworkMapObjectComponent, MapObjectSpawnRequestParameterMap) == 0x0000A0, "Member 'UPalNetworkMapObjectComponent::MapObjectSpawnRequestParameterMap' has a wrong offset!");
static_assert(offsetof(UPalNetworkMapObjectComponent, SpawnRequestHandlerMap) == 0x0000F0, "Member 'UPalNetworkMapObjectComponent::SpawnRequestHandlerMap' has a wrong offset!");

// Class Pal.PalNetworkPlayerComponent
// 0x0000 (0x00A0 - 0x00A0)
class UPalNetworkPlayerComponent final : public UActorComponent
{
public:
	void Dev_RequestTeleportToBossTower_ToServer(EPalBossType BossType);
	void Dev_RequestTeleportToCurrentDungeonGoal_ToServer();
	void Dev_RequestTeleportToCurrentDungeonTreasureBox_ToServer();
	void Dev_RequestTeleportToDungeonEntranceByDataLayer_ToServer(const class FName DataLayerName);
	void Dev_RequestTeleportToDungeonEntranceByIndex_ToServer(const int32 Param_Index);
	void LoadoutSelectorEquipItem(class UPalLoadoutSelectorComponent* LoadoutSelector, EPalPlayerInventoryType InventoryType, int32 Param_Index);
	void LoadoutSelectorRemoveEquipItem(class UPalLoadoutSelectorComponent* LoadoutSelector);
	void NotifyEndCrime_ToClient(const struct FGuid& CrimeInstanceId);
	void NotifyQuestCompleted(TSubclassOf<class UPalQuestData> CompletedQuestDataClass);
	void NotifyReleaseWanted_ToClient(class UPalIndividualCharacterHandle* CriminalHandle);
	void NotifyReportCriminal_ToClient(class UPalIndividualCharacterHandle* CriminalHandle, const TArray<class FName>& CrimeIds);
	void NotifyStartCrime_ToClient(const struct FGuid& CrimeInstanceId);
	void NotifyUnlockAchievement_ToClient(const class FString& AchievementId);
	void ReceiveEnterStageRequestResult_ToRequestClient(const struct FPalStageInstanceId& StageInstanceId, const EPalStageRequestResult Result);
	void ReceiveExitStageRequestResult_ToRequestClient(const EPalStageRequestResult Result);
	void RegisterRespawnLocation_ToServer(const struct FGuid& PlayerUId, const struct FVector& Location);
	void RequestAddBossTechnolgyPointByItem_ToServer(const struct FPalItemSlotId& ConsumeItemSlotID);
	void RequestAddItem_ToServer(const class FName StaticItemId, const int32 Count, bool IsAssignPassive);
	void RequestAddTechnolgyPoint_ToServer(const int32 AddPoint);
	void RequestAddTechnolgyPointByItem_ToServer(const struct FPalItemSlotId& ConsumeItemSlotID);
	void RequestChangeVoiceID_ToServer(int32 NewVoiceID);
	void RequestDropItemFromInventoryDropSlot_ToServer();
	void RequestDropOtomoPal_ToServer(const int32 OtomoIndex);
	void RequestEnterStage_ToServer(const struct FPalStageInstanceId& StageInstanceId);
	void RequestExitStage_ToServer();
	void RequestMoveItemToInventoryFromContainer(class UPalItemContainer* FromContainer, bool IsTryEquip);
	void RequestMoveItemToInventoryFromSlot(class UPalItemSlot* FromSlot, bool IsTryEquip);
	void RequestSortInventory_ToServer();
	void RequestTrashItemFromInventoryDropSlot_ToServer();
	void RequestUnlockTechnology_ToServer(const class FName& UnlockTechnologyName);
	void SetCurrentSelectPalSphereIndex_ToServer(int32 NextIndex, class UPalLoadoutSelectorComponent* LoadoutSelector);
	void ShowBossDefeatRewardUI_ToClient(int32 TechPoint, bool AfterTeleport, int32 DelayTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalNetworkPlayerComponent">();
	}
	static class UPalNetworkPlayerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalNetworkPlayerComponent>();
	}
};
static_assert(alignof(UPalNetworkPlayerComponent) == 0x000008, "Wrong alignment on UPalNetworkPlayerComponent");
static_assert(sizeof(UPalNetworkPlayerComponent) == 0x0000A0, "Wrong size on UPalNetworkPlayerComponent");

// Class Pal.PalNetworkPlayerStateComponent
// 0x0050 (0x00F0 - 0x00A0)
class UPalNetworkPlayerStateComponent final : public UActorComponent
{
public:
	TMap<struct FGuid, struct FPalNetworkPlayerObtainClientParameter> ObtainClientParamMap;                              // 0x00A0(0x0050)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalNetworkPlayerStateComponent">();
	}
	static class UPalNetworkPlayerStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalNetworkPlayerStateComponent>();
	}
};
static_assert(alignof(UPalNetworkPlayerStateComponent) == 0x000008, "Wrong alignment on UPalNetworkPlayerStateComponent");
static_assert(sizeof(UPalNetworkPlayerStateComponent) == 0x0000F0, "Wrong size on UPalNetworkPlayerStateComponent");
static_assert(offsetof(UPalNetworkPlayerStateComponent, ObtainClientParamMap) == 0x0000A0, "Member 'UPalNetworkPlayerStateComponent::ObtainClientParamMap' has a wrong offset!");

// Class Pal.PalNetworkShopComponent
// 0x0000 (0x00A0 - 0x00A0)
class UPalNetworkShopComponent final : public UActorComponent
{
public:
	void ReceiveDroppedPalProductData_ToClient(const TArray<struct FPalDroppedPalProductDataForShop>& CollectedData);
	void RecieveBuyResult_ToClient(EPalShopBuyResultType ResultType);
	void RemoveShopData_ToServer(const struct FGuid& RemoveShopID);
	void RequestBuyLostPal_ToServer(const struct FGuid& RequestPlayerUId, const struct FPalCharacterStoredParameterId& StoredParameterId);
	void RequestBuyProduct_ToServer(const struct FPalInstanceID& RequestPlayerInstanceId, const struct FGuid& ShopID, const struct FGuid& ProductId, int32 BuyNum);
	void RequestCollectDroppedPalProductData(const struct FGuid& RequestPlayerUId, const int32 MaxCollectNum);
	void RequestSellItems_ToServer(const struct FGuid& RequestPlayerUId, const struct FGuid& ShopID, const TArray<struct FPalItemSlotIdAndNum>& SellItemSlotIDArray);
	void RequestSellPals_ToServer(const struct FGuid& RequestPlayerUId, const struct FGuid& ShopID, const TArray<struct FPalCharacterSlotId>& SellPalSlotIDArray);
	void SetupShopDataForActor_ToServer(class AActor* VenderActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalNetworkShopComponent">();
	}
	static class UPalNetworkShopComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalNetworkShopComponent>();
	}
};
static_assert(alignof(UPalNetworkShopComponent) == 0x000008, "Wrong alignment on UPalNetworkShopComponent");
static_assert(sizeof(UPalNetworkShopComponent) == 0x0000A0, "Wrong size on UPalNetworkShopComponent");

// Class Pal.PalNetworkTimeComponent
// 0x0000 (0x00A0 - 0x00A0)
class UPalNetworkTimeComponent final : public UActorComponent
{
public:
	void NightSkip_ToClient();
	void PreNightSkip_ToClient();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalNetworkTimeComponent">();
	}
	static class UPalNetworkTimeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalNetworkTimeComponent>();
	}
};
static_assert(alignof(UPalNetworkTimeComponent) == 0x000008, "Wrong alignment on UPalNetworkTimeComponent");
static_assert(sizeof(UPalNetworkTimeComponent) == 0x0000A0, "Wrong size on UPalNetworkTimeComponent");

// Class Pal.PalUIWorldSettingBase
// 0x0148 (0x0578 - 0x0430)
class UPalUIWorldSettingBase : public UPalUserWidgetOverlayUI
{
public:
	struct FPalOptionWorldSettings                OriginalSetting;                                   // 0x0430(0x0138)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FString                                 CachedInputWorldName;                              // 0x0568(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool CompleteSetting(const struct FPalOptionWorldSettings& NewSetting);
	void OnCompletedSaveSetting(bool IsSuccess);
	void OnFilteredWorldName(const class FString& NewWorldName);
	void OnReceivedWordFilteringResult(const class FString& ResponseBody, bool bResponseOK, int32 ResponseCode);
	bool TryRequestWorldNameFilter(const class FString& NewWorldName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIWorldSettingBase">();
	}
	static class UPalUIWorldSettingBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIWorldSettingBase>();
	}
};
static_assert(alignof(UPalUIWorldSettingBase) == 0x000008, "Wrong alignment on UPalUIWorldSettingBase");
static_assert(sizeof(UPalUIWorldSettingBase) == 0x000578, "Wrong size on UPalUIWorldSettingBase");
static_assert(offsetof(UPalUIWorldSettingBase, OriginalSetting) == 0x000430, "Member 'UPalUIWorldSettingBase::OriginalSetting' has a wrong offset!");
static_assert(offsetof(UPalUIWorldSettingBase, CachedInputWorldName) == 0x000568, "Member 'UPalUIWorldSettingBase::CachedInputWorldName' has a wrong offset!");

// Class Pal.PalNetworkTransmitter
// 0x00D8 (0x0368 - 0x0290)
class APalNetworkTransmitter final : public AActor
{
public:
	uint8                                         Pad_2DA0[0x50];                                    // 0x0290(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalNetworkMapObjectComponent*          MapObject;                                         // 0x02E0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalNetworkItemComponent*               Item;                                              // 0x02E8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalNetworkBaseCampComponent*           BaseCamp;                                          // 0x02F0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalNetworkCharacterContainerComponent* CharacterContainer;                                // 0x02F8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalNetworkPlayerComponent*             Player;                                            // 0x0300(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalNetworkCharacterComponent*          Character;                                         // 0x0308(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalNetworkWorkProgressComponent*       WorkProgress;                                      // 0x0310(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalNetworkWorldSecurityComponent*      WorldSecurity;                                     // 0x0318(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalNetworkBossBattleComponent*         BossBattle;                                        // 0x0320(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalNetworkTimeComponent*               Time;                                              // 0x0328(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalNetworkShopComponent*               Shop;                                              // 0x0330(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalNetworkInvaderComponent*            Invader;                                           // 0x0338(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalNetworkCharacterStatusOperationComponent* CharacterStatusOperation;                          // 0x0340(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalNetworkRaidBossComponent*           RaidBoss;                                          // 0x0348(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalNetworkIndividualComponent*         NetworkIndividualComponent;                        // 0x0350(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FPalNetworkTransmitterDelaySpawnInfo> DelayDelegateCallQueue;                            // 0x0358(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void Debug_LogServerThreadNum_ToRequestPlayer(const class FString& Message);
	void Debug_LogServerThreadNum_ToServer();
	void Debug_ReceiveLogTreasureBoxLocalPlayerAround_ToRequestPlayer(const class FString& Message);
	void Debug_RequestLogTreasureBoxLocalPlayerAround_ToServer();
	void DummyReliableFunction();
	void SetupBroadcast_FromServer();
	void SpawnActor_ToServer(class UClass* ActorClass, const struct FNetworkActorSpawnParameters& SpawnParameter, const struct FGuid& Guid);
	struct FGuid SpawnActorBroadcast(class UClass* ActorClass, const struct FNetworkActorSpawnParameters& SpawnParameter, TDelegate<void(const struct FGuid& SpawnGUID, class AActor* SpawnActor)> SpawnDelegate);
	void SpawnedActor_ToALL(class AActor* SpawnedActor, class AActor* SpawnedController, const struct FNetworkActorSpawnParameters& SpawnParameter, const struct FGuid& Guid);
	void SpawnedNonReliableActor_ToALL(class UClass* ActorClass, const struct FNetworkActorSpawnParameters& SpawnParameter, int32 IssuerID);
	void SpawnNonReliableActor_ToServer(class UClass* ActorClass, const struct FNetworkActorSpawnParameters& SpawnParameter, int32 IssuerID);
	struct FGuid SpawnNonReliableActorBroadcast(class UClass* ActorClass, const struct FNetworkActorSpawnParameters& SpawnParameter, TDelegate<void(const struct FGuid& SpawnGUID, class AActor* SpawnActor)> SpawnDelegate);
	struct FGuid SpawnReliableActorBroadcast(class UClass* ActorClass, const struct FNetworkActorSpawnParameters& SpawnParameter, TDelegate<void(const struct FGuid& SpawnGUID, class AActor* SpawnActor)> SpawnDelegate);

	class UPalNetworkBaseCampComponent* GetBaseCamp() const;
	class UPalNetworkBossBattleComponent* GetBossBattle() const;
	class UPalNetworkCharacterComponent* GetCharacter() const;
	class UPalNetworkCharacterContainerComponent* GetCharacterContainer() const;
	class UPalNetworkCharacterStatusOperationComponent* GetCharacterStatusOperation() const;
	class UPalNetworkInvaderComponent* GetInvader() const;
	class UPalNetworkItemComponent* GetItem() const;
	class UPalNetworkMapObjectComponent* GetMapObject() const;
	class UPalNetworkPlayerComponent* GetPlayer() const;
	class UPalNetworkShopComponent* GetShop() const;
	class UPalNetworkTimeComponent* GetTime() const;
	class UPalNetworkWorkProgressComponent* GetWorkProgress() const;
	class UPalNetworkWorldSecurityComponent* GetWorldSecurity() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalNetworkTransmitter">();
	}
	static class APalNetworkTransmitter* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalNetworkTransmitter>();
	}
};
static_assert(alignof(APalNetworkTransmitter) == 0x000008, "Wrong alignment on APalNetworkTransmitter");
static_assert(sizeof(APalNetworkTransmitter) == 0x000368, "Wrong size on APalNetworkTransmitter");
static_assert(offsetof(APalNetworkTransmitter, MapObject) == 0x0002E0, "Member 'APalNetworkTransmitter::MapObject' has a wrong offset!");
static_assert(offsetof(APalNetworkTransmitter, Item) == 0x0002E8, "Member 'APalNetworkTransmitter::Item' has a wrong offset!");
static_assert(offsetof(APalNetworkTransmitter, BaseCamp) == 0x0002F0, "Member 'APalNetworkTransmitter::BaseCamp' has a wrong offset!");
static_assert(offsetof(APalNetworkTransmitter, CharacterContainer) == 0x0002F8, "Member 'APalNetworkTransmitter::CharacterContainer' has a wrong offset!");
static_assert(offsetof(APalNetworkTransmitter, Player) == 0x000300, "Member 'APalNetworkTransmitter::Player' has a wrong offset!");
static_assert(offsetof(APalNetworkTransmitter, Character) == 0x000308, "Member 'APalNetworkTransmitter::Character' has a wrong offset!");
static_assert(offsetof(APalNetworkTransmitter, WorkProgress) == 0x000310, "Member 'APalNetworkTransmitter::WorkProgress' has a wrong offset!");
static_assert(offsetof(APalNetworkTransmitter, WorldSecurity) == 0x000318, "Member 'APalNetworkTransmitter::WorldSecurity' has a wrong offset!");
static_assert(offsetof(APalNetworkTransmitter, BossBattle) == 0x000320, "Member 'APalNetworkTransmitter::BossBattle' has a wrong offset!");
static_assert(offsetof(APalNetworkTransmitter, Time) == 0x000328, "Member 'APalNetworkTransmitter::Time' has a wrong offset!");
static_assert(offsetof(APalNetworkTransmitter, Shop) == 0x000330, "Member 'APalNetworkTransmitter::Shop' has a wrong offset!");
static_assert(offsetof(APalNetworkTransmitter, Invader) == 0x000338, "Member 'APalNetworkTransmitter::Invader' has a wrong offset!");
static_assert(offsetof(APalNetworkTransmitter, CharacterStatusOperation) == 0x000340, "Member 'APalNetworkTransmitter::CharacterStatusOperation' has a wrong offset!");
static_assert(offsetof(APalNetworkTransmitter, RaidBoss) == 0x000348, "Member 'APalNetworkTransmitter::RaidBoss' has a wrong offset!");
static_assert(offsetof(APalNetworkTransmitter, NetworkIndividualComponent) == 0x000350, "Member 'APalNetworkTransmitter::NetworkIndividualComponent' has a wrong offset!");
static_assert(offsetof(APalNetworkTransmitter, DelayDelegateCallQueue) == 0x000358, "Member 'APalNetworkTransmitter::DelayDelegateCallQueue' has a wrong offset!");

// Class Pal.PalNetworkWorldSecurityComponent
// 0x0000 (0x00A0 - 0x00A0)
class UPalNetworkWorldSecurityComponent final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalNetworkWorldSecurityComponent">();
	}
	static class UPalNetworkWorldSecurityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalNetworkWorldSecurityComponent>();
	}
};
static_assert(alignof(UPalNetworkWorldSecurityComponent) == 0x000008, "Wrong alignment on UPalNetworkWorldSecurityComponent");
static_assert(sizeof(UPalNetworkWorldSecurityComponent) == 0x0000A0, "Wrong size on UPalNetworkWorldSecurityComponent");

// Class Pal.PalNiagaraSoundStopInterface
// 0x0000 (0x0028 - 0x0028)
class IPalNiagaraSoundStopInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalNiagaraSoundStopInterface">();
	}
	static class IPalNiagaraSoundStopInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPalNiagaraSoundStopInterface>();
	}
};
static_assert(alignof(IPalNiagaraSoundStopInterface) == 0x000008, "Wrong alignment on IPalNiagaraSoundStopInterface");
static_assert(sizeof(IPalNiagaraSoundStopInterface) == 0x000028, "Wrong size on IPalNiagaraSoundStopInterface");

// Class Pal.PalNoteDataAsset
// 0x0050 (0x0080 - 0x0030)
class UPalNoteDataAsset final : public UDataAsset
{
public:
	TMap<class FName, class UPalNoteData*>        NoteDataMap;                                       // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	const class UPalNoteData* Find(const class FName ID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalNoteDataAsset">();
	}
	static class UPalNoteDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalNoteDataAsset>();
	}
};
static_assert(alignof(UPalNoteDataAsset) == 0x000008, "Wrong alignment on UPalNoteDataAsset");
static_assert(sizeof(UPalNoteDataAsset) == 0x000080, "Wrong size on UPalNoteDataAsset");
static_assert(offsetof(UPalNoteDataAsset, NoteDataMap) == 0x000030, "Member 'UPalNoteDataAsset::NoteDataMap' has a wrong offset!");

// Class Pal.PalNPCAIWeaponHandle
// 0x00B8 (0x00E0 - 0x0028)
class UPalNPCAIWeaponHandle : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnInitializeEnd;                                   // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<EPalWeaponType, struct FPalNPCWeaponCombatInfo> CombatAIParamMap;                                  // 0x0038(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class AActor*                                 ShooterHuman;                                      // 0x0088(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DA3[0x50];                                    // 0x0090(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AimToTarget(class AActor* TargetActor, bool Aim, float DeltaTime);
	void DecreaseBullet();
	void EquipWeapon();
	void FullReload();
	TSubclassOf<class UPalAIActionBase> GetCombatClass();
	TSubclassOf<class UPalStateMachineStateBase> GetFireStateClass();
	bool GetIsMeleeAttackWithGun();
	int32 GetMaxShootCount();
	float GetRandomMoveTimeMin();
	float GetReloadTime();
	int32 GetRemainingBullet();
	float GetShootInterval();
	bool GetUseSideDashMovement();
	void InitializeNPCWeapon(class APalWeaponBase* WeaponActor);
	bool IsEndInitialize();
	bool IsNear_FarRange(class AActor* TargetActor, float FarRangePlusOffset);
	bool IsNear_NearRange(class AActor* TargetActor, float NearRangePlusOffset);
	bool IsTargetInConeShap();
	void OnInitializeEnd__DelegateSignature();
	void ReleaseTrigger();
	void ShootBurstBullet(float PullSecond);
	void ShootOneBullet();
	void TerminateNPCWeapon();
	void UnequipWeapon();

	bool IsMagazineEmpty() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalNPCAIWeaponHandle">();
	}
	static class UPalNPCAIWeaponHandle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalNPCAIWeaponHandle>();
	}
};
static_assert(alignof(UPalNPCAIWeaponHandle) == 0x000008, "Wrong alignment on UPalNPCAIWeaponHandle");
static_assert(sizeof(UPalNPCAIWeaponHandle) == 0x0000E0, "Wrong size on UPalNPCAIWeaponHandle");
static_assert(offsetof(UPalNPCAIWeaponHandle, OnInitializeEnd) == 0x000028, "Member 'UPalNPCAIWeaponHandle::OnInitializeEnd' has a wrong offset!");
static_assert(offsetof(UPalNPCAIWeaponHandle, CombatAIParamMap) == 0x000038, "Member 'UPalNPCAIWeaponHandle::CombatAIParamMap' has a wrong offset!");
static_assert(offsetof(UPalNPCAIWeaponHandle, ShooterHuman) == 0x000088, "Member 'UPalNPCAIWeaponHandle::ShooterHuman' has a wrong offset!");

// Class Pal.PalVisualEffectComponent
// 0x00A0 (0x0140 - 0x00A0)
class UPalVisualEffectComponent final : public UActorComponent
{
public:
	TMap<EPalVisualEffectID, TSoftClassPtr<class UClass>> VisualEffectClass_OverrideMap;                     // 0x00A0(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnAddVisualEffectDelegate;                         // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRemoveVisualEffectDelegate;                      // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCompleteVisualEffectDelegate;                    // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UPalVisualEffectBase*>           ExecutionVisualEffects;                            // 0x0120(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	TArray<class UPalVisualEffectBase*>           TerminatingVisualEffects;                          // 0x0130(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)

public:
	static class UPalVisualEffectBase* AddVisualEffectForActor(class AActor* Actor, EPalVisualEffectID VisualEffectID, const struct FPalVisualEffectDynamicParameter& Parameter);
	static class UPalVisualEffectBase* AddVisualEffectForActor_Local(class AActor* Actor, EPalVisualEffectID VisualEffectID, const struct FPalVisualEffectDynamicParameter& Parameter);
	static void RemoveVisualEffectForActor(class AActor* Actor, EPalVisualEffectID VisualEffectID);
	static void RemoveVisualEffectForActor_Local(class AActor* Actor, EPalVisualEffectID VisualEffectID);

	class UPalVisualEffectBase* AddVisualEffect(EPalVisualEffectID VisualEffectID, const struct FPalVisualEffectDynamicParameter& Parameter);
	class UPalVisualEffectBase* AddVisualEffect_Local(EPalVisualEffectID VisualEffectID, const struct FPalVisualEffectDynamicParameter& Parameter);
	void AddVisualEffect_ToALL(EPalVisualEffectID VisualEffectID, const struct FPalVisualEffectDynamicParameter& Parameter, int32 IssuerID);
	void AddVisualEffect_ToServer(EPalVisualEffectID VisualEffectID, const struct FPalVisualEffectDynamicParameter& Parameter, int32 IssuerID);
	void BeginPlay();
	void EndPlay(const EEndPlayReason EndPlayReason);
	void OnAddVisualEffect__DelegateSignature(const class UPalVisualEffectComponent* VisualEffectComponent, EPalVisualEffectID VisualEffectID, class UPalVisualEffectBase* VisualEffect);
	void OnCompleteVisualEffect__DelegateSignature(const class UPalVisualEffectComponent* VisualEffectComponent, EPalVisualEffectID VisualEffectID, class UPalVisualEffectBase* VisualEffect);
	void OnRemoveVisualEffect__DelegateSignature(const class UPalVisualEffectComponent* VisualEffectComponent, EPalVisualEffectID VisualEffectID);
	void RemoveConflictVisualEffect(EPalVisualEffectID VisualEffectID);
	void RemoveVisualEffect(EPalVisualEffectID VisualEffectID);
	void RemoveVisualEffect_Local(EPalVisualEffectID VisualEffectID);
	void RemoveVisualEffect_ToALL(EPalVisualEffectID VisualEffectID, int32 IssuerID);
	void RemoveVisualEffect_ToServer(EPalVisualEffectID VisualEffectID, int32 IssuerID);
	void RemoveVisualEffectByConflict_ToALL(EPalVisualEffectID VisualEffectID, int32 IssuerID);
	void RemoveVisualEffectByConflict_ToServer(EPalVisualEffectID VisualEffectID, int32 IssuerID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalVisualEffectComponent">();
	}
	static class UPalVisualEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalVisualEffectComponent>();
	}
};
static_assert(alignof(UPalVisualEffectComponent) == 0x000008, "Wrong alignment on UPalVisualEffectComponent");
static_assert(sizeof(UPalVisualEffectComponent) == 0x000140, "Wrong size on UPalVisualEffectComponent");
static_assert(offsetof(UPalVisualEffectComponent, VisualEffectClass_OverrideMap) == 0x0000A0, "Member 'UPalVisualEffectComponent::VisualEffectClass_OverrideMap' has a wrong offset!");
static_assert(offsetof(UPalVisualEffectComponent, OnAddVisualEffectDelegate) == 0x0000F0, "Member 'UPalVisualEffectComponent::OnAddVisualEffectDelegate' has a wrong offset!");
static_assert(offsetof(UPalVisualEffectComponent, OnRemoveVisualEffectDelegate) == 0x000100, "Member 'UPalVisualEffectComponent::OnRemoveVisualEffectDelegate' has a wrong offset!");
static_assert(offsetof(UPalVisualEffectComponent, OnCompleteVisualEffectDelegate) == 0x000110, "Member 'UPalVisualEffectComponent::OnCompleteVisualEffectDelegate' has a wrong offset!");
static_assert(offsetof(UPalVisualEffectComponent, ExecutionVisualEffects) == 0x000120, "Member 'UPalVisualEffectComponent::ExecutionVisualEffects' has a wrong offset!");
static_assert(offsetof(UPalVisualEffectComponent, TerminatingVisualEffects) == 0x000130, "Member 'UPalVisualEffectComponent::TerminatingVisualEffects' has a wrong offset!");

// Class Pal.PalNPCCampSpawnerBase
// 0x0008 (0x0298 - 0x0290)
class APalNPCCampSpawnerBase final : public AActor
{
public:
	class FName                                   CampSpawnerName;                                   // 0x0290(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	float CalcRemainDespawnTime(const struct FPalEnemyCampStatus& CampStatus) const;
	float CalcRemainRespawnTime(const struct FPalEnemyCampStatus& CampStatus) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalNPCCampSpawnerBase">();
	}
	static class APalNPCCampSpawnerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalNPCCampSpawnerBase>();
	}
};
static_assert(alignof(APalNPCCampSpawnerBase) == 0x000008, "Wrong alignment on APalNPCCampSpawnerBase");
static_assert(sizeof(APalNPCCampSpawnerBase) == 0x000298, "Wrong size on APalNPCCampSpawnerBase");
static_assert(offsetof(APalNPCCampSpawnerBase, CampSpawnerName) == 0x000290, "Member 'APalNPCCampSpawnerBase::CampSpawnerName' has a wrong offset!");

// Class Pal.PalNPCInteractConditionFunctions
// 0x0008 (0x0030 - 0x0028)
class UPalNPCInteractConditionFunctions : public UObject
{
public:
	class UObject*                                Owner;                                             // 0x0028(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SetOwner(class UObject* Param_Owner);

	const class UObject* GetOwner() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalNPCInteractConditionFunctions">();
	}
	static class UPalNPCInteractConditionFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalNPCInteractConditionFunctions>();
	}
};
static_assert(alignof(UPalNPCInteractConditionFunctions) == 0x000008, "Wrong alignment on UPalNPCInteractConditionFunctions");
static_assert(sizeof(UPalNPCInteractConditionFunctions) == 0x000030, "Wrong size on UPalNPCInteractConditionFunctions");
static_assert(offsetof(UPalNPCInteractConditionFunctions, Owner) == 0x000028, "Member 'UPalNPCInteractConditionFunctions::Owner' has a wrong offset!");

// Class Pal.PalNPCInteractionComponent
// 0x00D8 (0x0178 - 0x00A0)
class UPalNPCInteractionComponent : public UActorComponent
{
public:
	uint8                                         Pad_2DBA[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             NPCInteractionDataTable;                           // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             NPCInteractConditionConstValDataTable;             // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalNPCInteractConditionFunctions> ConditionFunctionClass;                            // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DBB[0x10];                                    // 0x00C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, EPalIncidentTalkType>       TalkTypeMap;                                       // 0x00D0(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	TMap<class FName, class UPalNPCInteractCondition*> InteractConditions;                                // 0x0120(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	class UPalNPCInteractConditionFunctions*      ConditionFunctions;                                // 0x0170(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void BeginPlay();
	void DebugInteractConditionString(const class FString& TestText);
	void EndTalk(class APalPlayerCharacter* TalkPlayer);
	void Initialize();
	void OnTriggerInteract(class AActor* Other, EPalInteractiveObjectIndicatorType IndicatorType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalNPCInteractionComponent">();
	}
	static class UPalNPCInteractionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalNPCInteractionComponent>();
	}
};
static_assert(alignof(UPalNPCInteractionComponent) == 0x000008, "Wrong alignment on UPalNPCInteractionComponent");
static_assert(sizeof(UPalNPCInteractionComponent) == 0x000178, "Wrong size on UPalNPCInteractionComponent");
static_assert(offsetof(UPalNPCInteractionComponent, NPCInteractionDataTable) == 0x0000A8, "Member 'UPalNPCInteractionComponent::NPCInteractionDataTable' has a wrong offset!");
static_assert(offsetof(UPalNPCInteractionComponent, NPCInteractConditionConstValDataTable) == 0x0000B0, "Member 'UPalNPCInteractionComponent::NPCInteractConditionConstValDataTable' has a wrong offset!");
static_assert(offsetof(UPalNPCInteractionComponent, ConditionFunctionClass) == 0x0000B8, "Member 'UPalNPCInteractionComponent::ConditionFunctionClass' has a wrong offset!");
static_assert(offsetof(UPalNPCInteractionComponent, TalkTypeMap) == 0x0000D0, "Member 'UPalNPCInteractionComponent::TalkTypeMap' has a wrong offset!");
static_assert(offsetof(UPalNPCInteractionComponent, InteractConditions) == 0x000120, "Member 'UPalNPCInteractionComponent::InteractConditions' has a wrong offset!");
static_assert(offsetof(UPalNPCInteractionComponent, ConditionFunctions) == 0x000170, "Member 'UPalNPCInteractionComponent::ConditionFunctions' has a wrong offset!");

// Class Pal.PalNPCInteractionDataTableUtility
// 0x0000 (0x0028 - 0x0028)
class UPalNPCInteractionDataTableUtility final : public UBlueprintFunctionLibrary
{
public:
	static void GetJSONStringByInteractionDataTable(class FString* OutString, const TMap<class FName, struct FPalNPCInteractionDataTableRow>& DataRows);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalNPCInteractionDataTableUtility">();
	}
	static class UPalNPCInteractionDataTableUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalNPCInteractionDataTableUtility>();
	}
};
static_assert(alignof(UPalNPCInteractionDataTableUtility) == 0x000008, "Wrong alignment on UPalNPCInteractionDataTableUtility");
static_assert(sizeof(UPalNPCInteractionDataTableUtility) == 0x000028, "Wrong size on UPalNPCInteractionDataTableUtility");

// Class Pal.PalNPCMultiTalkHandle
// 0x0010 (0x0038 - 0x0028)
class UPalNPCMultiTalkHandle : public UObject
{
public:
	class FName                                   TalkId;                                            // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DBD[0x8];                                     // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UDataTable* GetTalkData(const class FName& InTalkID);
	void IncrementTalkCountRecord();
	void OnFinishOneTalk();
	void SetIsTransientTalkCount(bool IsTransient);

	int32 GetCurrentTalkCount() const;
	class UPalPlayerLocalRecordData* GetLocalRecordData() const;
	class UPalPlayerDataStorage* GetPlayerDataStorage() const;
	class FName GetTalkId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalNPCMultiTalkHandle">();
	}
	static class UPalNPCMultiTalkHandle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalNPCMultiTalkHandle>();
	}
};
static_assert(alignof(UPalNPCMultiTalkHandle) == 0x000008, "Wrong alignment on UPalNPCMultiTalkHandle");
static_assert(sizeof(UPalNPCMultiTalkHandle) == 0x000038, "Wrong size on UPalNPCMultiTalkHandle");
static_assert(offsetof(UPalNPCMultiTalkHandle, TalkId) == 0x000028, "Member 'UPalNPCMultiTalkHandle::TalkId' has a wrong offset!");

// Class Pal.PalNPCTalkComponent
// 0x0028 (0x00C8 - 0x00A0)
class UPalNPCTalkComponent final : public UActorComponent
{
public:
	bool                                          IsTalking;                                         // 0x00A0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2DBE[0x7];                                     // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnTalkStartDelegate;                               // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTalkEndDelegate;                                 // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	bool GetIsTalking();
	void StartTalk(class AActor* Other);
	void TalkEndDelegate__DelegateSignature(class AActor* SelfActor, class AActor* TargetActor);
	void TalkStartDelegate__DelegateSignature(class AActor* SelfActor, class AActor* TargetActor);
	void TriggerEndTalk(class AActor* Other);
	void TriggerStartTalk(class AActor* Other, EPalInteractiveObjectIndicatorType IndicatorType);

	bool HasTalkData(class APalCharacter* TalkCharacter) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalNPCTalkComponent">();
	}
	static class UPalNPCTalkComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalNPCTalkComponent>();
	}
};
static_assert(alignof(UPalNPCTalkComponent) == 0x000008, "Wrong alignment on UPalNPCTalkComponent");
static_assert(sizeof(UPalNPCTalkComponent) == 0x0000C8, "Wrong size on UPalNPCTalkComponent");
static_assert(offsetof(UPalNPCTalkComponent, IsTalking) == 0x0000A0, "Member 'UPalNPCTalkComponent::IsTalking' has a wrong offset!");
static_assert(offsetof(UPalNPCTalkComponent, OnTalkStartDelegate) == 0x0000A8, "Member 'UPalNPCTalkComponent::OnTalkStartDelegate' has a wrong offset!");
static_assert(offsetof(UPalNPCTalkComponent, OnTalkEndDelegate) == 0x0000B8, "Member 'UPalNPCTalkComponent::OnTalkEndDelegate' has a wrong offset!");

// Class Pal.PalNPCTalkSystemCustomFunctionInterface
// 0x0000 (0x0028 - 0x0028)
class IPalNPCTalkSystemCustomFunctionInterface final : public IInterface
{
public:
	void AddArgument(const class FString& Key, const class FText& Text);
	void SetCustomFunctionChoseIndex(int32 Param_Index);
	void SetCustomFunctionResult(EPalNPCTalkCustomFunctionResult CustomFunctionResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalNPCTalkSystemCustomFunctionInterface">();
	}
	static class IPalNPCTalkSystemCustomFunctionInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPalNPCTalkSystemCustomFunctionInterface>();
	}
};
static_assert(alignof(IPalNPCTalkSystemCustomFunctionInterface) == 0x000008, "Wrong alignment on IPalNPCTalkSystemCustomFunctionInterface");
static_assert(sizeof(IPalNPCTalkSystemCustomFunctionInterface) == 0x000028, "Wrong size on IPalNPCTalkSystemCustomFunctionInterface");

// Class Pal.PalNPCWeaponGenerator
// 0x0070 (0x0098 - 0x0028)
class UPalNPCWeaponGenerator : public UObject
{
public:
	TMap<EPalWeaponType, class FName>             WeaponIDMap;                                       // 0x0028(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FPalContainerId                        WeaponContainerId;                                 // 0x0078(0x0010)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APalWeaponBase*                         WeaponActorBP;                                     // 0x0088(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsDefaultEquipWeapon;                              // 0x0090(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DC1[0x7];                                     // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GenerateWeapn(EPalWeaponType WeaponType, bool IsDefaultEquip);
	void OnSpawnEvent(class APalWeaponBase* WeaponActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalNPCWeaponGenerator">();
	}
	static class UPalNPCWeaponGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalNPCWeaponGenerator>();
	}
};
static_assert(alignof(UPalNPCWeaponGenerator) == 0x000008, "Wrong alignment on UPalNPCWeaponGenerator");
static_assert(sizeof(UPalNPCWeaponGenerator) == 0x000098, "Wrong size on UPalNPCWeaponGenerator");
static_assert(offsetof(UPalNPCWeaponGenerator, WeaponIDMap) == 0x000028, "Member 'UPalNPCWeaponGenerator::WeaponIDMap' has a wrong offset!");
static_assert(offsetof(UPalNPCWeaponGenerator, WeaponContainerId) == 0x000078, "Member 'UPalNPCWeaponGenerator::WeaponContainerId' has a wrong offset!");
static_assert(offsetof(UPalNPCWeaponGenerator, WeaponActorBP) == 0x000088, "Member 'UPalNPCWeaponGenerator::WeaponActorBP' has a wrong offset!");
static_assert(offsetof(UPalNPCWeaponGenerator, IsDefaultEquipWeapon) == 0x000090, "Member 'UPalNPCWeaponGenerator::IsDefaultEquipWeapon' has a wrong offset!");

// Class Pal.PalObjectCollector
// 0x0220 (0x0290 - 0x0070)
class UPalObjectCollector final : public UPalWorldSubsystem
{
public:
	uint8                                         Pad_2DC2[0x60];                                    // 0x0070(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APalCharacter*>                  PalCharacter_All;                                  // 0x00D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class APalCharacter*>                  PalCharacter_NPC;                                  // 0x00E0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class APalCharacter*>                  PalCharacter_Player;                               // 0x00F0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class APalMapObjectSpawnerBase*>       MapObject_SpawnerBase;                             // 0x0100(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<class APalCharacter*, struct FPalCharacterList> NearestCharacter_FromPlayer;                       // 0x0110(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TArray<class APalMapObjectSpawnerBase*>       NearestSpawnerBase;                                // 0x0160(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DC3[0x28];                                    // 0x0170(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class APalCharacter*, struct FPalCharacterList> CalculationNearestCharacter_FromPlayer;            // 0x0198(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TArray<class APalMapObjectSpawnerBase*>       CalculationNearSpawnerBase_FromPlayer;             // 0x01E8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FVector>                        BaseCampLocationList;                              // 0x01F8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	bool                                          bIsUpdateBaseCamp;                                 // 0x0208(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DC4[0x7];                                     // 0x0209(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APalMapObjectSpawnerBase*>       CalculationNearSpawnerBase_FromBaseCamp;           // 0x0210(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DC5[0x60];                                    // 0x0220(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NearStartDistanceForSpawnerBase;                   // 0x0280(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         NearEndDistanceForSpawnerBase;                     // 0x0284(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         NearDistanceForSpawnerBaseFromBaseCamp;            // 0x0288(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DC6[0x4];                                     // 0x028C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<struct FPalSpawnerGroupInfo> GetRandomSpawnerGroupInfo(const struct FVector& SpawnerLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalObjectCollector">();
	}
	static class UPalObjectCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalObjectCollector>();
	}
};
static_assert(alignof(UPalObjectCollector) == 0x000008, "Wrong alignment on UPalObjectCollector");
static_assert(sizeof(UPalObjectCollector) == 0x000290, "Wrong size on UPalObjectCollector");
static_assert(offsetof(UPalObjectCollector, PalCharacter_All) == 0x0000D0, "Member 'UPalObjectCollector::PalCharacter_All' has a wrong offset!");
static_assert(offsetof(UPalObjectCollector, PalCharacter_NPC) == 0x0000E0, "Member 'UPalObjectCollector::PalCharacter_NPC' has a wrong offset!");
static_assert(offsetof(UPalObjectCollector, PalCharacter_Player) == 0x0000F0, "Member 'UPalObjectCollector::PalCharacter_Player' has a wrong offset!");
static_assert(offsetof(UPalObjectCollector, MapObject_SpawnerBase) == 0x000100, "Member 'UPalObjectCollector::MapObject_SpawnerBase' has a wrong offset!");
static_assert(offsetof(UPalObjectCollector, NearestCharacter_FromPlayer) == 0x000110, "Member 'UPalObjectCollector::NearestCharacter_FromPlayer' has a wrong offset!");
static_assert(offsetof(UPalObjectCollector, NearestSpawnerBase) == 0x000160, "Member 'UPalObjectCollector::NearestSpawnerBase' has a wrong offset!");
static_assert(offsetof(UPalObjectCollector, CalculationNearestCharacter_FromPlayer) == 0x000198, "Member 'UPalObjectCollector::CalculationNearestCharacter_FromPlayer' has a wrong offset!");
static_assert(offsetof(UPalObjectCollector, CalculationNearSpawnerBase_FromPlayer) == 0x0001E8, "Member 'UPalObjectCollector::CalculationNearSpawnerBase_FromPlayer' has a wrong offset!");
static_assert(offsetof(UPalObjectCollector, BaseCampLocationList) == 0x0001F8, "Member 'UPalObjectCollector::BaseCampLocationList' has a wrong offset!");
static_assert(offsetof(UPalObjectCollector, bIsUpdateBaseCamp) == 0x000208, "Member 'UPalObjectCollector::bIsUpdateBaseCamp' has a wrong offset!");
static_assert(offsetof(UPalObjectCollector, CalculationNearSpawnerBase_FromBaseCamp) == 0x000210, "Member 'UPalObjectCollector::CalculationNearSpawnerBase_FromBaseCamp' has a wrong offset!");
static_assert(offsetof(UPalObjectCollector, NearStartDistanceForSpawnerBase) == 0x000280, "Member 'UPalObjectCollector::NearStartDistanceForSpawnerBase' has a wrong offset!");
static_assert(offsetof(UPalObjectCollector, NearEndDistanceForSpawnerBase) == 0x000284, "Member 'UPalObjectCollector::NearEndDistanceForSpawnerBase' has a wrong offset!");
static_assert(offsetof(UPalObjectCollector, NearDistanceForSpawnerBaseFromBaseCamp) == 0x000288, "Member 'UPalObjectCollector::NearDistanceForSpawnerBaseFromBaseCamp' has a wrong offset!");

// Class Pal.PalObjectReplicatorComponent
// 0x0010 (0x00B0 - 0x00A0)
class UPalObjectReplicatorComponent final : public UActorComponent
{
public:
	TArray<class UObject*>                        ReplicateObject;                                   // 0x00A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalObjectReplicatorComponent">();
	}
	static class UPalObjectReplicatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalObjectReplicatorComponent>();
	}
};
static_assert(alignof(UPalObjectReplicatorComponent) == 0x000008, "Wrong alignment on UPalObjectReplicatorComponent");
static_assert(sizeof(UPalObjectReplicatorComponent) == 0x0000B0, "Wrong size on UPalObjectReplicatorComponent");
static_assert(offsetof(UPalObjectReplicatorComponent, ReplicateObject) == 0x0000A0, "Member 'UPalObjectReplicatorComponent::ReplicateObject' has a wrong offset!");

// Class Pal.PalOilRigCannonBase
// 0x0050 (0x02E0 - 0x0290)
class APalOilRigCannonBase final : public AActor
{
public:
	float                                         RangeMin;                                          // 0x0290(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RangeMax;                                          // 0x0294(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PitchMin;                                          // 0x0298(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PitchMax;                                          // 0x029C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         YawMax;                                            // 0x02A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PitchSpeed;                                        // 0x02A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         YawSpeed;                                          // 0x02A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ChangeTargetInterval;                              // 0x02AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BulletSpeed;                                       // 0x02B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2DC7[0x4];                                     // 0x02B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         TargetActors;                                      // 0x02B8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class AActor*                                 AimTargetActor;                                    // 0x02C8(0x0008)(Net, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ChangeTargetTimer;                                 // 0x02D0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentYaw;                                        // 0x02D4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsShooting;                                        // 0x02D8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsInConeAimTarget;                                 // 0x02D9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DC8[0x6];                                     // 0x02DA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddOverlapCharacter(class AActor* Actor);
	bool CanRayCastToTarget();
	bool IsShootingGun();
	void PullTrigger_BP();
	void PullTrigger_ToAll();
	void ReleaseTrigger_BP();
	void ReleaseTrigger_ToAll();
	void RemoveOverlapCharacter(class AActor* Actor);

	class USceneComponent* GetPitchMesh() const;
	class USceneComponent* GetYawMesh() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalOilRigCannonBase">();
	}
	static class APalOilRigCannonBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalOilRigCannonBase>();
	}
};
static_assert(alignof(APalOilRigCannonBase) == 0x000008, "Wrong alignment on APalOilRigCannonBase");
static_assert(sizeof(APalOilRigCannonBase) == 0x0002E0, "Wrong size on APalOilRigCannonBase");
static_assert(offsetof(APalOilRigCannonBase, RangeMin) == 0x000290, "Member 'APalOilRigCannonBase::RangeMin' has a wrong offset!");
static_assert(offsetof(APalOilRigCannonBase, RangeMax) == 0x000294, "Member 'APalOilRigCannonBase::RangeMax' has a wrong offset!");
static_assert(offsetof(APalOilRigCannonBase, PitchMin) == 0x000298, "Member 'APalOilRigCannonBase::PitchMin' has a wrong offset!");
static_assert(offsetof(APalOilRigCannonBase, PitchMax) == 0x00029C, "Member 'APalOilRigCannonBase::PitchMax' has a wrong offset!");
static_assert(offsetof(APalOilRigCannonBase, YawMax) == 0x0002A0, "Member 'APalOilRigCannonBase::YawMax' has a wrong offset!");
static_assert(offsetof(APalOilRigCannonBase, PitchSpeed) == 0x0002A4, "Member 'APalOilRigCannonBase::PitchSpeed' has a wrong offset!");
static_assert(offsetof(APalOilRigCannonBase, YawSpeed) == 0x0002A8, "Member 'APalOilRigCannonBase::YawSpeed' has a wrong offset!");
static_assert(offsetof(APalOilRigCannonBase, ChangeTargetInterval) == 0x0002AC, "Member 'APalOilRigCannonBase::ChangeTargetInterval' has a wrong offset!");
static_assert(offsetof(APalOilRigCannonBase, BulletSpeed) == 0x0002B0, "Member 'APalOilRigCannonBase::BulletSpeed' has a wrong offset!");
static_assert(offsetof(APalOilRigCannonBase, TargetActors) == 0x0002B8, "Member 'APalOilRigCannonBase::TargetActors' has a wrong offset!");
static_assert(offsetof(APalOilRigCannonBase, AimTargetActor) == 0x0002C8, "Member 'APalOilRigCannonBase::AimTargetActor' has a wrong offset!");
static_assert(offsetof(APalOilRigCannonBase, ChangeTargetTimer) == 0x0002D0, "Member 'APalOilRigCannonBase::ChangeTargetTimer' has a wrong offset!");
static_assert(offsetof(APalOilRigCannonBase, CurrentYaw) == 0x0002D4, "Member 'APalOilRigCannonBase::CurrentYaw' has a wrong offset!");
static_assert(offsetof(APalOilRigCannonBase, IsShooting) == 0x0002D8, "Member 'APalOilRigCannonBase::IsShooting' has a wrong offset!");
static_assert(offsetof(APalOilRigCannonBase, IsInConeAimTarget) == 0x0002D9, "Member 'APalOilRigCannonBase::IsInConeAimTarget' has a wrong offset!");

// Class Pal.PalOilrigManager
// 0x0008 (0x0078 - 0x0070)
class UPalOilrigManager : public UPalWorldSubsystem
{
public:
	class AActor*                                 CurrentShootingTower;                              // 0x0070(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AddShootingTower(class AActor* Tower);
	bool IsShootingAnyTower();
	void RemoveShootingTower(class AActor* Tower);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalOilrigManager">();
	}
	static class UPalOilrigManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalOilrigManager>();
	}
};
static_assert(alignof(UPalOilrigManager) == 0x000008, "Wrong alignment on UPalOilrigManager");
static_assert(sizeof(UPalOilrigManager) == 0x000078, "Wrong size on UPalOilrigManager");
static_assert(offsetof(UPalOilrigManager, CurrentShootingTower) == 0x000070, "Member 'UPalOilrigManager::CurrentShootingTower' has a wrong offset!");

// Class Pal.PalOptionReplicator
// 0x0138 (0x0160 - 0x0028)
class UPalOptionReplicator final : public UPalGameStateReplicatorBase
{
public:
	struct FPalOptionWorldSettings                OptionWorldSettings;                               // 0x0028(0x0138)(Edit, Net, DisableEditOnTemplate, Transient, EditConst, RepNotify, NativeAccessSpecifierPrivate)

public:
	void OnRep_OptionWorldSettings();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalOptionReplicator">();
	}
	static class UPalOptionReplicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalOptionReplicator>();
	}
};
static_assert(alignof(UPalOptionReplicator) == 0x000008, "Wrong alignment on UPalOptionReplicator");
static_assert(sizeof(UPalOptionReplicator) == 0x000160, "Wrong size on UPalOptionReplicator");
static_assert(offsetof(UPalOptionReplicator, OptionWorldSettings) == 0x000028, "Member 'UPalOptionReplicator::OptionWorldSettings' has a wrong offset!");

// Class Pal.PalOptionSubsystem
// 0x06D0 (0x0740 - 0x0070)
class UPalOptionSubsystem : public UPalWorldSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnChangeKeyboardDelegate;                          // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangePadDelegate;                               // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeGraphicsDelegate;                          // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeWorldSettingsDelegate;                     // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeKeyConfigDelegate;                         // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeUISettingDelegate;                         // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeScreenRatioDelegate;                       // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	struct FPalOptionWorldStaticSettings          OptionWorldStaticSettings;                         // 0x00E0(0x00F0)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FPalOptionLocalStaticSettings          OptionLocalStaticSettings;                         // 0x01D0(0x0050)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FPalOptionWorldSettings                OptionWorldSettings;                               // 0x0220(0x0138)(Protected, NativeAccessSpecifierProtected)
	struct FPalOptionWorldSettings                OptionWorldSettingsCache;                          // 0x0358(0x0138)(Protected, NativeAccessSpecifierProtected)
	struct FPalOptionGraphicsSettings             GraphicsSettings;                                  // 0x0490(0x0054)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FPalOptionAudioSettings                AudioSettings;                                     // 0x04E4(0x001C)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FPalOptionCommonSettings               CommonSettings;                                    // 0x0500(0x0028)(Protected, NativeAccessSpecifierProtected)
	struct FPalOptionKeyboardSettings             KeyboardSettings;                                  // 0x0528(0x0014)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FPalOptionPadSettings                  PadSettings;                                       // 0x053C(0x001C)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FPalKeyConfigSettings                  KeyConfigSettings;                                 // 0x0558(0x0160)(Protected, NativeAccessSpecifierProtected)
	struct FPalOptionUISettings                   UISettings;                                        // 0x06B8(0x000C)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2DC9[0x24];                                    // 0x06C4(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BaseFov;                                           // 0x06E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DCA[0x4];                                     // 0x06EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Namespace;                                         // 0x06F0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DCB[0x18];                                    // 0x0700(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             OptionWorldPresetTable;                            // 0x0718(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             OptionWorldModePresetTable;                        // 0x0720(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             OptionGraphicsPresetTable;                         // 0x0728(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class APalPlayerCharacter>        PalPlayerCharacterClass;                           // 0x0730(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DCC[0x8];                                     // 0x0738(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyGraphicsPreset(struct FPalOptionGraphicsSettings& OutSettings, EPalOptionGraphicsLevel GraphicsLevel);
	void ApplyGraphicsPresetByBenchMark(struct FPalOptionGraphicsSettings& OutSettings);
	void ApplyWorldModePreset(struct FPalOptionWorldSettings& OutSettings, bool bIsPvP);
	void ApplyWorldPreset(struct FPalOptionWorldSettings& OutSettings, EPalOptionWorldDifficulty Difficulty);
	void ApplyWorldSettings();
	struct FIntPoint GetGameResolution();
	void GetSupportScreenSizes(TArray<struct FIntPoint>* SupportResolutions, EWindowMode WindowMode);
	void OnChangeGraphicsDelegate__DelegateSignature(const struct FPalOptionGraphicsSettings& PrevSettings, const struct FPalOptionGraphicsSettings& NewSettings);
	void OnChangeKeyboardDelegate__DelegateSignature(const struct FPalOptionKeyboardSettings& PrevSettings, const struct FPalOptionKeyboardSettings& NewSettings);
	void OnChangeKeyConfigDelegate__DelegateSignature(const struct FPalKeyConfigSettings& PrevSettings, const struct FPalKeyConfigSettings& NewSettings);
	void OnChangePadDelegate__DelegateSignature(const struct FPalOptionPadSettings& PrevSettings, const struct FPalOptionPadSettings& NewSettings);
	void OnChangeScreenRatioDelegate__DelegateSignature(float NewRatio);
	void OnChangeUISettingDelegate__DelegateSignature(const struct FPalOptionUISettings& PrevSettings, const struct FPalOptionUISettings& NewSettings);
	void OnChangeWorldSettingsDelegate__DelegateSignature(const struct FPalOptionWorldSettings& PrevSettings, const struct FPalOptionWorldSettings& NewSettings);
	void OnCompletedGetBanlist(const class FString& ResponseBody, bool bResponseOK, int32 ResponseCode);
	void RefreshBanList();
	void SaveLocalSettings();
	void SetAudioSettings(const struct FPalOptionAudioSettings& InAudioSettings);
	void SetCommonSettings(const struct FPalOptionCommonSettings& InCommonSettings);
	void SetGraphicsSettings(const struct FPalOptionGraphicsSettings& InGraphicsSettings);
	void SetKeyboardSettings(const struct FPalOptionKeyboardSettings& InKeyboardSettings);
	void SetKeyConfigSettings(const struct FPalKeyConfigSettings& InKeyConfigSettings);
	void SetOptionWorldSettings(const struct FPalOptionWorldSettings& InOptionWorldSettings);
	void SetPadSettings(const struct FPalOptionPadSettings& InPadSettings);
	void SetUISettings(const struct FPalOptionUISettings& InUISettings);

	const struct FPalOptionAudioSettings GetAudioSettings() const;
	const struct FPalOptionCommonSettings GetCommonSettings() const;
	const struct FPalOptionGraphicsSettings GetGraphicsSettings() const;
	const struct FPalOptionKeyboardSettings GetKeyboardSettings() const;
	const struct FPalKeyConfigSettings GetKeyConfigSettings() const;
	const struct FPalOptionLocalStaticSettings GetOptionLocalStaticSettings() const;
	const struct FPalOptionWorldSettings GetOptionWorldSettings() const;
	const struct FPalOptionWorldStaticSettings GetOptionWorldStaticSettings() const;
	const struct FPalOptionPadSettings GetPadSettings() const;
	const struct FPalOptionUISettings GetUISettings() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalOptionSubsystem">();
	}
	static class UPalOptionSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalOptionSubsystem>();
	}
};
static_assert(alignof(UPalOptionSubsystem) == 0x000008, "Wrong alignment on UPalOptionSubsystem");
static_assert(sizeof(UPalOptionSubsystem) == 0x000740, "Wrong size on UPalOptionSubsystem");
static_assert(offsetof(UPalOptionSubsystem, OnChangeKeyboardDelegate) == 0x000070, "Member 'UPalOptionSubsystem::OnChangeKeyboardDelegate' has a wrong offset!");
static_assert(offsetof(UPalOptionSubsystem, OnChangePadDelegate) == 0x000080, "Member 'UPalOptionSubsystem::OnChangePadDelegate' has a wrong offset!");
static_assert(offsetof(UPalOptionSubsystem, OnChangeGraphicsDelegate) == 0x000090, "Member 'UPalOptionSubsystem::OnChangeGraphicsDelegate' has a wrong offset!");
static_assert(offsetof(UPalOptionSubsystem, OnChangeWorldSettingsDelegate) == 0x0000A0, "Member 'UPalOptionSubsystem::OnChangeWorldSettingsDelegate' has a wrong offset!");
static_assert(offsetof(UPalOptionSubsystem, OnChangeKeyConfigDelegate) == 0x0000B0, "Member 'UPalOptionSubsystem::OnChangeKeyConfigDelegate' has a wrong offset!");
static_assert(offsetof(UPalOptionSubsystem, OnChangeUISettingDelegate) == 0x0000C0, "Member 'UPalOptionSubsystem::OnChangeUISettingDelegate' has a wrong offset!");
static_assert(offsetof(UPalOptionSubsystem, OnChangeScreenRatioDelegate) == 0x0000D0, "Member 'UPalOptionSubsystem::OnChangeScreenRatioDelegate' has a wrong offset!");
static_assert(offsetof(UPalOptionSubsystem, OptionWorldStaticSettings) == 0x0000E0, "Member 'UPalOptionSubsystem::OptionWorldStaticSettings' has a wrong offset!");
static_assert(offsetof(UPalOptionSubsystem, OptionLocalStaticSettings) == 0x0001D0, "Member 'UPalOptionSubsystem::OptionLocalStaticSettings' has a wrong offset!");
static_assert(offsetof(UPalOptionSubsystem, OptionWorldSettings) == 0x000220, "Member 'UPalOptionSubsystem::OptionWorldSettings' has a wrong offset!");
static_assert(offsetof(UPalOptionSubsystem, OptionWorldSettingsCache) == 0x000358, "Member 'UPalOptionSubsystem::OptionWorldSettingsCache' has a wrong offset!");
static_assert(offsetof(UPalOptionSubsystem, GraphicsSettings) == 0x000490, "Member 'UPalOptionSubsystem::GraphicsSettings' has a wrong offset!");
static_assert(offsetof(UPalOptionSubsystem, AudioSettings) == 0x0004E4, "Member 'UPalOptionSubsystem::AudioSettings' has a wrong offset!");
static_assert(offsetof(UPalOptionSubsystem, CommonSettings) == 0x000500, "Member 'UPalOptionSubsystem::CommonSettings' has a wrong offset!");
static_assert(offsetof(UPalOptionSubsystem, KeyboardSettings) == 0x000528, "Member 'UPalOptionSubsystem::KeyboardSettings' has a wrong offset!");
static_assert(offsetof(UPalOptionSubsystem, PadSettings) == 0x00053C, "Member 'UPalOptionSubsystem::PadSettings' has a wrong offset!");
static_assert(offsetof(UPalOptionSubsystem, KeyConfigSettings) == 0x000558, "Member 'UPalOptionSubsystem::KeyConfigSettings' has a wrong offset!");
static_assert(offsetof(UPalOptionSubsystem, UISettings) == 0x0006B8, "Member 'UPalOptionSubsystem::UISettings' has a wrong offset!");
static_assert(offsetof(UPalOptionSubsystem, BaseFov) == 0x0006E8, "Member 'UPalOptionSubsystem::BaseFov' has a wrong offset!");
static_assert(offsetof(UPalOptionSubsystem, Namespace) == 0x0006F0, "Member 'UPalOptionSubsystem::Namespace' has a wrong offset!");
static_assert(offsetof(UPalOptionSubsystem, OptionWorldPresetTable) == 0x000718, "Member 'UPalOptionSubsystem::OptionWorldPresetTable' has a wrong offset!");
static_assert(offsetof(UPalOptionSubsystem, OptionWorldModePresetTable) == 0x000720, "Member 'UPalOptionSubsystem::OptionWorldModePresetTable' has a wrong offset!");
static_assert(offsetof(UPalOptionSubsystem, OptionGraphicsPresetTable) == 0x000728, "Member 'UPalOptionSubsystem::OptionGraphicsPresetTable' has a wrong offset!");
static_assert(offsetof(UPalOptionSubsystem, PalPlayerCharacterClass) == 0x000730, "Member 'UPalOptionSubsystem::PalPlayerCharacterClass' has a wrong offset!");

// Class Pal.PalOptionSaveGame
// 0x0240 (0x0268 - 0x0028)
class UPalOptionSaveGame final : public USaveGame
{
public:
	struct FPalOptionSaveData                     OptionSaveData;                                    // 0x0028(0x0240)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalOptionSaveGame">();
	}
	static class UPalOptionSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalOptionSaveGame>();
	}
};
static_assert(alignof(UPalOptionSaveGame) == 0x000008, "Wrong alignment on UPalOptionSaveGame");
static_assert(sizeof(UPalOptionSaveGame) == 0x000268, "Wrong size on UPalOptionSaveGame");
static_assert(offsetof(UPalOptionSaveGame, OptionSaveData) == 0x000028, "Member 'UPalOptionSaveGame::OptionSaveData' has a wrong offset!");

// Class Pal.PalOtomoAttackStopJudgeByBall
// 0x0008 (0x0030 - 0x0028)
class UPalOtomoAttackStopJudgeByBall final : public UObject
{
public:
	bool                                          IsProhibitAttack;                                  // 0x0028(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DD2[0x7];                                     // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalOtomoAttackStopJudgeByBall">();
	}
	static class UPalOtomoAttackStopJudgeByBall* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalOtomoAttackStopJudgeByBall>();
	}
};
static_assert(alignof(UPalOtomoAttackStopJudgeByBall) == 0x000008, "Wrong alignment on UPalOtomoAttackStopJudgeByBall");
static_assert(sizeof(UPalOtomoAttackStopJudgeByBall) == 0x000030, "Wrong size on UPalOtomoAttackStopJudgeByBall");
static_assert(offsetof(UPalOtomoAttackStopJudgeByBall, IsProhibitAttack) == 0x000028, "Member 'UPalOtomoAttackStopJudgeByBall::IsProhibitAttack' has a wrong offset!");

// Class Pal.PalOtomoAttackStopJudgeByBallList
// 0x0050 (0x0078 - 0x0028)
class UPalOtomoAttackStopJudgeByBallList final : public UObject
{
public:
	TMap<struct FGuid, class UPalOtomoAttackStopJudgeByBall*> JudgeList;                                         // 0x0028(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	void OnHitCaptureBall(class AActor* Attacker);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalOtomoAttackStopJudgeByBallList">();
	}
	static class UPalOtomoAttackStopJudgeByBallList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalOtomoAttackStopJudgeByBallList>();
	}
};
static_assert(alignof(UPalOtomoAttackStopJudgeByBallList) == 0x000008, "Wrong alignment on UPalOtomoAttackStopJudgeByBallList");
static_assert(sizeof(UPalOtomoAttackStopJudgeByBallList) == 0x000078, "Wrong size on UPalOtomoAttackStopJudgeByBallList");
static_assert(offsetof(UPalOtomoAttackStopJudgeByBallList, JudgeList) == 0x000028, "Member 'UPalOtomoAttackStopJudgeByBallList::JudgeList' has a wrong offset!");

// Class Pal.PalOtomoSpawnCollisionChecker
// 0x0008 (0x0030 - 0x0028)
class UPalOtomoSpawnCollisionChecker final : public UObject
{
public:
	uint8                                         Pad_2DD3[0x8];                                     // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector GetLocation_WhenSpawnPalSphgereThrow(const struct FHitResult& Hit, class APawn* CurrentSelectPalActor);
	struct FTransform GetTransform_WhenSpawnPalNearTrainer(class AActor* Trainer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalOtomoSpawnCollisionChecker">();
	}
	static class UPalOtomoSpawnCollisionChecker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalOtomoSpawnCollisionChecker>();
	}
};
static_assert(alignof(UPalOtomoSpawnCollisionChecker) == 0x000008, "Wrong alignment on UPalOtomoSpawnCollisionChecker");
static_assert(sizeof(UPalOtomoSpawnCollisionChecker) == 0x000030, "Wrong size on UPalOtomoSpawnCollisionChecker");

// Class Pal.PalOtomoUiBase
// 0x0000 (0x0408 - 0x0408)
class UPalOtomoUiBase final : public UPalUserWidget
{
public:
	EPalTribeID GetTribeIDFromClass(const TSubclassOf<class AActor>& TargetActorClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalOtomoUiBase">();
	}
	static class UPalOtomoUiBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalOtomoUiBase>();
	}
};
static_assert(alignof(UPalOtomoUiBase) == 0x000008, "Wrong alignment on UPalOtomoUiBase");
static_assert(sizeof(UPalOtomoUiBase) == 0x000408, "Wrong size on UPalOtomoUiBase");

// Class Pal.PalOwnerCharacterAcquirableInterface
// 0x0000 (0x0028 - 0x0028)
class IPalOwnerCharacterAcquirableInterface final : public IInterface
{
public:
	class APalCharacter* GetOwnerCharacter();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalOwnerCharacterAcquirableInterface">();
	}
	static class IPalOwnerCharacterAcquirableInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPalOwnerCharacterAcquirableInterface>();
	}
};
static_assert(alignof(IPalOwnerCharacterAcquirableInterface) == 0x000008, "Wrong alignment on IPalOwnerCharacterAcquirableInterface");
static_assert(sizeof(IPalOwnerCharacterAcquirableInterface) == 0x000028, "Wrong size on IPalOwnerCharacterAcquirableInterface");

// Class Pal.PalPartnerSkillPassiveSkill
// 0x00D0 (0x00F8 - 0x0028)
class UPalPartnerSkillPassiveSkill final : public UObject
{
public:
	TDelegate<void(class AActor* Trainer)>        IsRestrictedDelegate;                              // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsReserving;                                       // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRestricted;                                     // 0x0039(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRequireWorkerWorkingPassiveSkill;                 // 0x003A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsWorking;                                        // 0x003B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DD6[0x4];                                     // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPalPassivePartnerSkillIdAndParameters> PassiveSkills;                                     // 0x0040(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	TMap<struct FPalDataTableRowName_PassiveSkillData, struct FPalPassivePartnerSkillStatus> SkillStatus;                                       // 0x0050(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	int32                                         CurrentRank;                                       // 0x00A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DD7[0x54];                                    // 0x00A4(0x0054)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InactivateWorkingSkill();
	void Initialize(const TArray<struct FPalPassivePartnerSkillIdAndParameters>& _PassiveSkills);
	bool IsRestricted__DelegateSignature(class AActor* Trainer);
	void ObserveWorking();
	void OnActivatedAsOtomo();
	void OnActivatedAsOtomoHolder();
	void OnActivatedAsWorker();
	void OnInactivatedAsOtomo();
	void OnInactivatedAsOtomoHolder();
	void OnInactivatedAsWorker();
	void OnReserveActivated();
	void OnReserveInactivated();
	void OnRideActivated();
	void OnRideInactivated();
	void OnUpdateInventoryContainer();
	void OnUpdateOtomoHolder(class APalCharacter* Character);
	void OnWorkerAssignChanged(class UPalCharacterParameterComponent* Parameter);

	int32 GetOtomoRank() const;
	class APalCharacter* GetOwner() const;
	TArray<class FName> GetPassiveSkillList() const;
	class ACharacter* GetTrainer() const;
	class APalPlayerCharacter* GetTrainerActor() const;
	class APalPlayerController* GetTrainerController() const;
	bool IsRestricted() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalPartnerSkillPassiveSkill">();
	}
	static class UPalPartnerSkillPassiveSkill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalPartnerSkillPassiveSkill>();
	}
};
static_assert(alignof(UPalPartnerSkillPassiveSkill) == 0x000008, "Wrong alignment on UPalPartnerSkillPassiveSkill");
static_assert(sizeof(UPalPartnerSkillPassiveSkill) == 0x0000F8, "Wrong size on UPalPartnerSkillPassiveSkill");
static_assert(offsetof(UPalPartnerSkillPassiveSkill, IsRestrictedDelegate) == 0x000028, "Member 'UPalPartnerSkillPassiveSkill::IsRestrictedDelegate' has a wrong offset!");
static_assert(offsetof(UPalPartnerSkillPassiveSkill, IsReserving) == 0x000038, "Member 'UPalPartnerSkillPassiveSkill::IsReserving' has a wrong offset!");
static_assert(offsetof(UPalPartnerSkillPassiveSkill, bIsRestricted) == 0x000039, "Member 'UPalPartnerSkillPassiveSkill::bIsRestricted' has a wrong offset!");
static_assert(offsetof(UPalPartnerSkillPassiveSkill, bRequireWorkerWorkingPassiveSkill) == 0x00003A, "Member 'UPalPartnerSkillPassiveSkill::bRequireWorkerWorkingPassiveSkill' has a wrong offset!");
static_assert(offsetof(UPalPartnerSkillPassiveSkill, bIsWorking) == 0x00003B, "Member 'UPalPartnerSkillPassiveSkill::bIsWorking' has a wrong offset!");
static_assert(offsetof(UPalPartnerSkillPassiveSkill, PassiveSkills) == 0x000040, "Member 'UPalPartnerSkillPassiveSkill::PassiveSkills' has a wrong offset!");
static_assert(offsetof(UPalPartnerSkillPassiveSkill, SkillStatus) == 0x000050, "Member 'UPalPartnerSkillPassiveSkill::SkillStatus' has a wrong offset!");
static_assert(offsetof(UPalPartnerSkillPassiveSkill, CurrentRank) == 0x0000A0, "Member 'UPalPartnerSkillPassiveSkill::CurrentRank' has a wrong offset!");

// Class Pal.PalPassiveSkillComponent
// 0x0140 (0x01E0 - 0x00A0)
class UPalPassiveSkillComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnStartSkillEffectDelegate;                        // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeSkillEffectValueDelegate;                  // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEndSkillEffectDelegate;                          // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DD9[0x50];                                    // 0x00D0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPalPassiveSkillEffectInfos>    SkillInfos;                                        // 0x0120(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	TArray<struct FPalPassiveSkillEffectInfos>    SkillInfosMirror;                                  // 0x0130(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<EPalPassiveSkillEffectType, EPalStatusID> SkillStatusMap;                                    // 0x0140(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DDA[0x50];                                    // 0x0190(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddSpecialAttackRateInfo(TArray<struct FPalSpecialAttackRateInfo>* SpecialAttackRateInfos);
	float GetParameterWithPassiveSkillEffect(float OriginalValue, EPalPassiveSkillEffectType EffectType);
	void OnChangeSkillEffectValue(EPalPassiveSkillEffectType EffectType, float Value);
	void OnChangeSkillEffectValue__DelegateSignature(EPalPassiveSkillEffectType EffectType, float Value);
	void OnEndSkillEffect(EPalPassiveSkillEffectType EffectType);
	void OnEndSkillEffect__DelegateSignature(EPalPassiveSkillEffectType EffectType);
	void OnRep_SkillInfos();
	void OnStartSkillEffect(EPalPassiveSkillEffectType EffectType, float Value);
	void OnStartSkillEffect__DelegateSignature(EPalPassiveSkillEffectType EffectType, float Value);
	void OverrideDamageInfoBySkill(struct FPalDamageInfo* InoutDamageInfo);
	void SetupSkillFromSelf(class UObject* OwnerObject, const TArray<class FName>& SkillList);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalPassiveSkillComponent">();
	}
	static class UPalPassiveSkillComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalPassiveSkillComponent>();
	}
};
static_assert(alignof(UPalPassiveSkillComponent) == 0x000008, "Wrong alignment on UPalPassiveSkillComponent");
static_assert(sizeof(UPalPassiveSkillComponent) == 0x0001E0, "Wrong size on UPalPassiveSkillComponent");
static_assert(offsetof(UPalPassiveSkillComponent, OnStartSkillEffectDelegate) == 0x0000A0, "Member 'UPalPassiveSkillComponent::OnStartSkillEffectDelegate' has a wrong offset!");
static_assert(offsetof(UPalPassiveSkillComponent, OnChangeSkillEffectValueDelegate) == 0x0000B0, "Member 'UPalPassiveSkillComponent::OnChangeSkillEffectValueDelegate' has a wrong offset!");
static_assert(offsetof(UPalPassiveSkillComponent, OnEndSkillEffectDelegate) == 0x0000C0, "Member 'UPalPassiveSkillComponent::OnEndSkillEffectDelegate' has a wrong offset!");
static_assert(offsetof(UPalPassiveSkillComponent, SkillInfos) == 0x000120, "Member 'UPalPassiveSkillComponent::SkillInfos' has a wrong offset!");
static_assert(offsetof(UPalPassiveSkillComponent, SkillInfosMirror) == 0x000130, "Member 'UPalPassiveSkillComponent::SkillInfosMirror' has a wrong offset!");
static_assert(offsetof(UPalPassiveSkillComponent, SkillStatusMap) == 0x000140, "Member 'UPalPassiveSkillComponent::SkillStatusMap' has a wrong offset!");

// Class Pal.PalPersistentSoundPlayer
// 0x0018 (0x0040 - 0x0028)
class UPalPersistentSoundPlayer : public UObject
{
public:
	class UAkAudioEvent*                          AudioEvent;                                        // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FadeDuration;                                      // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DE0[0x4];                                     // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  PlayActor;                                         // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalPersistentSoundPlayer">();
	}
	static class UPalPersistentSoundPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalPersistentSoundPlayer>();
	}
};
static_assert(alignof(UPalPersistentSoundPlayer) == 0x000008, "Wrong alignment on UPalPersistentSoundPlayer");
static_assert(sizeof(UPalPersistentSoundPlayer) == 0x000040, "Wrong size on UPalPersistentSoundPlayer");
static_assert(offsetof(UPalPersistentSoundPlayer, AudioEvent) == 0x000028, "Member 'UPalPersistentSoundPlayer::AudioEvent' has a wrong offset!");
static_assert(offsetof(UPalPersistentSoundPlayer, FadeDuration) == 0x000030, "Member 'UPalPersistentSoundPlayer::FadeDuration' has a wrong offset!");
static_assert(offsetof(UPalPersistentSoundPlayer, PlayActor) == 0x000038, "Member 'UPalPersistentSoundPlayer::PlayActor' has a wrong offset!");

// Class Pal.PalPhysicsDefine
// 0x0000 (0x0028 - 0x0028)
class UPalPhysicsDefine final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalPhysicsDefine">();
	}
	static class UPalPhysicsDefine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalPhysicsDefine>();
	}
};
static_assert(alignof(UPalPhysicsDefine) == 0x000008, "Wrong alignment on UPalPhysicsDefine");
static_assert(sizeof(UPalPhysicsDefine) == 0x000028, "Wrong size on UPalPhysicsDefine");

// Class Pal.PalPhysicsUtility
// 0x0000 (0x0028 - 0x0028)
class UPalPhysicsUtility final : public UBlueprintFunctionLibrary
{
public:
	static void SetCanEverAffectNavigation(class UActorComponent* Component, bool bAffect);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalPhysicsUtility">();
	}
	static class UPalPhysicsUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalPhysicsUtility>();
	}
};
static_assert(alignof(UPalPhysicsUtility) == 0x000008, "Wrong alignment on UPalPhysicsUtility");
static_assert(sizeof(UPalPhysicsUtility) == 0x000028, "Wrong size on UPalPhysicsUtility");

// Class Pal.PalPlayerAccount
// 0x00F8 (0x0120 - 0x0028)
class UPalPlayerAccount final : public UObject
{
public:
	struct FGuid                                  PlayerUId;                                         // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPalInstanceID                         InstanceId;                                        // 0x0038(0x0030)(Edit, DisableEditOnTemplate, Transient, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPalPlayerAccountState                        State;                                             // 0x0068(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DE2[0x7];                                     // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalIndividualCharacterHandle*          IndividualHandle;                                  // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DE3[0x8];                                     // 0x0078(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LastSavedTransform;                                // 0x0080(0x0060)(Edit, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalPlayerOtomoData*                    OtomoData;                                         // 0x00E0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalPlayerDataCharacterMake*            CharacterMakeData;                                 // 0x00E8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalPlayerInventoryData*                InventoryData;                                     // 0x00F0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalPlayerDataPalStorage*               PalStorage;                                        // 0x00F8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalTechnologyData*                     TechnologyData;                                    // 0x0100(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalPlayerRecordData*                   RecordData;                                        // 0x0108(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsSelectedInitMapPoint;                           // 0x0110(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShouldSaveOnNextTime;                             // 0x0111(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DE4[0xE];                                     // 0x0112(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalPlayerAccount">();
	}
	static class UPalPlayerAccount* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalPlayerAccount>();
	}
};
static_assert(alignof(UPalPlayerAccount) == 0x000010, "Wrong alignment on UPalPlayerAccount");
static_assert(sizeof(UPalPlayerAccount) == 0x000120, "Wrong size on UPalPlayerAccount");
static_assert(offsetof(UPalPlayerAccount, PlayerUId) == 0x000028, "Member 'UPalPlayerAccount::PlayerUId' has a wrong offset!");
static_assert(offsetof(UPalPlayerAccount, InstanceId) == 0x000038, "Member 'UPalPlayerAccount::InstanceId' has a wrong offset!");
static_assert(offsetof(UPalPlayerAccount, State) == 0x000068, "Member 'UPalPlayerAccount::State' has a wrong offset!");
static_assert(offsetof(UPalPlayerAccount, IndividualHandle) == 0x000070, "Member 'UPalPlayerAccount::IndividualHandle' has a wrong offset!");
static_assert(offsetof(UPalPlayerAccount, LastSavedTransform) == 0x000080, "Member 'UPalPlayerAccount::LastSavedTransform' has a wrong offset!");
static_assert(offsetof(UPalPlayerAccount, OtomoData) == 0x0000E0, "Member 'UPalPlayerAccount::OtomoData' has a wrong offset!");
static_assert(offsetof(UPalPlayerAccount, CharacterMakeData) == 0x0000E8, "Member 'UPalPlayerAccount::CharacterMakeData' has a wrong offset!");
static_assert(offsetof(UPalPlayerAccount, InventoryData) == 0x0000F0, "Member 'UPalPlayerAccount::InventoryData' has a wrong offset!");
static_assert(offsetof(UPalPlayerAccount, PalStorage) == 0x0000F8, "Member 'UPalPlayerAccount::PalStorage' has a wrong offset!");
static_assert(offsetof(UPalPlayerAccount, TechnologyData) == 0x000100, "Member 'UPalPlayerAccount::TechnologyData' has a wrong offset!");
static_assert(offsetof(UPalPlayerAccount, RecordData) == 0x000108, "Member 'UPalPlayerAccount::RecordData' has a wrong offset!");
static_assert(offsetof(UPalPlayerAccount, bIsSelectedInitMapPoint) == 0x000110, "Member 'UPalPlayerAccount::bIsSelectedInitMapPoint' has a wrong offset!");
static_assert(offsetof(UPalPlayerAccount, bShouldSaveOnNextTime) == 0x000111, "Member 'UPalPlayerAccount::bShouldSaveOnNextTime' has a wrong offset!");

// Class Pal.PalPlayerCharacter
// 0x0210 (0x0B20 - 0x0910)
class APalPlayerCharacter : public APalCharacter
{
public:
	uint8                                         Pad_2DE5[0x8];                                     // 0x0908(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalShooterComponent*                   ShooterComponent;                                  // 0x0910(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalInteractComponent*                  InteractComponent;                                 // 0x0918(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalBuilderComponent*                   BuilderComponent;                                  // 0x0920(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalLoadoutSelectorComponent*           LoadoutSelectorComponent;                          // 0x0928(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalInsideBaseCampCheckComponent*       InsideBaseCampCheckComponent;                      // 0x0930(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalObjectReplicatorComponent*          HighPriorityObjectReplicatorComponent;             // 0x0938(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerReviveDelegate;                            // 0x0940(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerRespawnDelegate;                           // 0x0950(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerMoveToRespawnLocationDelegate;             // 0x0960(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCombatRankDownDelegate;                          // 0x0970(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAddRemoveEnemyDelegate;                          // 0x0980(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeBattleModeDelegate_ForPlayer;              // 0x0990(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerDeathAction;                               // 0x09A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeBossTowerEntrancePlayer;                   // 0x09B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeBossEntrancePlayer;                        // 0x09C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCombatStartUIAction;                             // 0x09D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeRegionArea;                                // 0x09E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLiftupCampPal;                                   // 0x09F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEndLiftCampPal;                                  // 0x0A00(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnToggleSleepPlayerBed;                            // 0x0A10(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGrapplingCancelPlayerBed;                        // 0x0A20(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInsufficientPalStamina;                          // 0x0A30(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	class FName                                   LastInsideRegionNameID;                            // 0x0A40(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerCameraYaw;                                   // 0x0A48(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PlayerCameraPitch;                                 // 0x0A4C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsAdjustedLocationByLoad;                          // 0x0A50(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DE6[0x7];                                     // 0x0A51(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           IdleAnimMontage;                                   // 0x0A58(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalPlayerBattleSituation*              PlayerBattleSituation;                             // 0x0A60(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsNearCommonEnemyFlag;                             // 0x0A68(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsSetRespawnTelemetry;                            // 0x0A69(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DE7[0xE];                                     // 0x0A6A(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UPalPlayerGenderChanger>    GenderChangerClass;                                // 0x0A78(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalPlayerGenderChanger*                GenderChanger;                                     // 0x0A80(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSpectatorMode;                                    // 0x0A88(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DE8[0x3];                                     // 0x0A89(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPalPlayerDataCharacterMakeInfo        CharacterMakeInfo;                                 // 0x0A8C(0x0094)(Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)

public:
	void AdjustLocationByLoad(class APalCharacter* InCharacter);
	void CallMoveToRespawnLocationDelegate(const struct FVector& Location);
	void CallRespawnDelegate();
	void CallReviveDelegate();
	void ChangeToFemale();
	void ChangeToMale();
	void CreateLantern();
	class USkeletalMeshComponent* GetHeadMesh();
	void OnAddRemoveEnemyDelegate__DelegateSignature(EPalBattleBGMType Rank, bool IsAdd);
	void OnBeginAction(const class UPalActionBase* Action);
	void OnChangeBattleEnemyRank(EPalBattleBGMType Rank, bool IsAdd);
	void OnChangeBossTowerEntrancePlayer__DelegateSignature(class FName BossType, const TArray<class APalPlayerCharacter*>& PlayerList);
	void OnChangeMovementMode(class UPalCharacterMovementComponent* Component, EMovementMode PrevMode, EMovementMode NewMode, EPalCharacterMovementCustomMode PrevCustomMode, EPalCharacterMovementCustomMode NewCustomMode);
	void OnChangeNearEnemy_ToAll(bool IsExist);
	void OnChangeNextWeapon();
	void OnChangePlayerBattleMode__DelegateSignature(bool IsBattle);
	void OnChangePrevWeapon();
	void OnChangeRegionAreaDelegate__DelegateSignature(const class FName& RegionNameID);
	void OnChangeShooterState(bool IsAim, bool IsShoot);
	void OnCombatRankDownDelegate__DelegateSignature(EPalPlayerBattleFinishType FinishType);
	void OnCombatStartUIActionDelegate__DelegateSignature();
	void OnCompleteInitializeParameter(class APalCharacter* InCharacter);
	void OnDamagePlayer_Server(const struct FPalDamageResult& DamageResult);
	void OnDownBattleEnemyRank(EPalPlayerBattleFinishType FinishType);
	void OnEndGliding();
	void OnEndIdle();
	void OnEndLiftCampPalDelegate__DelegateSignature();
	void OnEnterBaseCamp_StartBaseCampCombat(class UPalBaseCampModel* CampModel);
	void OnInsufficientPalStaminaDelegate__DelegateSignature();
	void OnJumpDisable();
	void OnLiftupCampPalDelegate__DelegateSignature(class APalCharacter* LiftingPal);
	void OnMontageEnded(class UAnimMontage* Montage, bool bInterrupted);
	void OnPlayerDeathAction__DelegateSignature();
	void OnPlayerMoveToRespawnLocationDelegate__DelegateSignature(class APalPlayerCharacter* Player, const struct FVector& Location);
	void OnPlayerRespawnDelegate__DelegateSignature(class APalPlayerCharacter* Player);
	void OnPlayerReviveDelegate__DelegateSignature(class APalPlayerCharacter* Player);
	void OnReloadStart();
	void OnRep_CharacterMakeInfo();
	void OnRep_SpectatorMode(bool before);
	void OnSPOverhead();
	void OnStartGliding();
	void OnToggleGrapplingCancelDelegate__DelegateSignature(bool CancelEnable);
	void OnToggleSleepPlayerBedDelegate__DelegateSignature(bool IsSleep);
	void OnTriggerInteract(class AActor* OtherActor, EPalInteractiveObjectIndicatorType IndicatorType);
	void OnUpdateEssentialItemContainer(class UPalItemContainer* Container);
	void PlayEatAnimation();
	void PlayIdleAnimation(class UAnimMontage* Montage);
	void SetNearCommonEnemy(bool IsExistNearEnemy);
	void SetSpectatorMode(bool bSpectator);
	void StopIdleAnimation();

	struct FRotator GetCameraRotator() const;
	const struct FPalPlayerDataCharacterMakeInfo GetCharacterMakeInfo() const;
	void GetLastInsideRegionNameID(class FName* OutNameID) const;
	class APalPlayerController* GetPalPlayerController() const;
	bool IsAdjustedLocation() const;
	bool IsGliding() const;
	bool IsGuildMaster() const;
	bool IsIdle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalPlayerCharacter">();
	}
	static class APalPlayerCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalPlayerCharacter>();
	}
};
static_assert(alignof(APalPlayerCharacter) == 0x000010, "Wrong alignment on APalPlayerCharacter");
static_assert(sizeof(APalPlayerCharacter) == 0x000B20, "Wrong size on APalPlayerCharacter");
static_assert(offsetof(APalPlayerCharacter, ShooterComponent) == 0x000910, "Member 'APalPlayerCharacter::ShooterComponent' has a wrong offset!");
static_assert(offsetof(APalPlayerCharacter, InteractComponent) == 0x000918, "Member 'APalPlayerCharacter::InteractComponent' has a wrong offset!");
static_assert(offsetof(APalPlayerCharacter, BuilderComponent) == 0x000920, "Member 'APalPlayerCharacter::BuilderComponent' has a wrong offset!");
static_assert(offsetof(APalPlayerCharacter, LoadoutSelectorComponent) == 0x000928, "Member 'APalPlayerCharacter::LoadoutSelectorComponent' has a wrong offset!");
static_assert(offsetof(APalPlayerCharacter, InsideBaseCampCheckComponent) == 0x000930, "Member 'APalPlayerCharacter::InsideBaseCampCheckComponent' has a wrong offset!");
static_assert(offsetof(APalPlayerCharacter, HighPriorityObjectReplicatorComponent) == 0x000938, "Member 'APalPlayerCharacter::HighPriorityObjectReplicatorComponent' has a wrong offset!");
static_assert(offsetof(APalPlayerCharacter, OnPlayerReviveDelegate) == 0x000940, "Member 'APalPlayerCharacter::OnPlayerReviveDelegate' has a wrong offset!");
static_assert(offsetof(APalPlayerCharacter, OnPlayerRespawnDelegate) == 0x000950, "Member 'APalPlayerCharacter::OnPlayerRespawnDelegate' has a wrong offset!");
static_assert(offsetof(APalPlayerCharacter, OnPlayerMoveToRespawnLocationDelegate) == 0x000960, "Member 'APalPlayerCharacter::OnPlayerMoveToRespawnLocationDelegate' has a wrong offset!");
static_assert(offsetof(APalPlayerCharacter, OnCombatRankDownDelegate) == 0x000970, "Member 'APalPlayerCharacter::OnCombatRankDownDelegate' has a wrong offset!");
static_assert(offsetof(APalPlayerCharacter, OnAddRemoveEnemyDelegate) == 0x000980, "Member 'APalPlayerCharacter::OnAddRemoveEnemyDelegate' has a wrong offset!");
static_assert(offsetof(APalPlayerCharacter, OnChangeBattleModeDelegate_ForPlayer) == 0x000990, "Member 'APalPlayerCharacter::OnChangeBattleModeDelegate_ForPlayer' has a wrong offset!");
static_assert(offsetof(APalPlayerCharacter, OnPlayerDeathAction) == 0x0009A0, "Member 'APalPlayerCharacter::OnPlayerDeathAction' has a wrong offset!");
static_assert(offsetof(APalPlayerCharacter, OnChangeBossTowerEntrancePlayer) == 0x0009B0, "Member 'APalPlayerCharacter::OnChangeBossTowerEntrancePlayer' has a wrong offset!");
static_assert(offsetof(APalPlayerCharacter, OnChangeBossEntrancePlayer) == 0x0009C0, "Member 'APalPlayerCharacter::OnChangeBossEntrancePlayer' has a wrong offset!");
static_assert(offsetof(APalPlayerCharacter, OnCombatStartUIAction) == 0x0009D0, "Member 'APalPlayerCharacter::OnCombatStartUIAction' has a wrong offset!");
static_assert(offsetof(APalPlayerCharacter, OnChangeRegionArea) == 0x0009E0, "Member 'APalPlayerCharacter::OnChangeRegionArea' has a wrong offset!");
static_assert(offsetof(APalPlayerCharacter, OnLiftupCampPal) == 0x0009F0, "Member 'APalPlayerCharacter::OnLiftupCampPal' has a wrong offset!");
static_assert(offsetof(APalPlayerCharacter, OnEndLiftCampPal) == 0x000A00, "Member 'APalPlayerCharacter::OnEndLiftCampPal' has a wrong offset!");
static_assert(offsetof(APalPlayerCharacter, OnToggleSleepPlayerBed) == 0x000A10, "Member 'APalPlayerCharacter::OnToggleSleepPlayerBed' has a wrong offset!");
static_assert(offsetof(APalPlayerCharacter, OnGrapplingCancelPlayerBed) == 0x000A20, "Member 'APalPlayerCharacter::OnGrapplingCancelPlayerBed' has a wrong offset!");
static_assert(offsetof(APalPlayerCharacter, OnInsufficientPalStamina) == 0x000A30, "Member 'APalPlayerCharacter::OnInsufficientPalStamina' has a wrong offset!");
static_assert(offsetof(APalPlayerCharacter, LastInsideRegionNameID) == 0x000A40, "Member 'APalPlayerCharacter::LastInsideRegionNameID' has a wrong offset!");
static_assert(offsetof(APalPlayerCharacter, PlayerCameraYaw) == 0x000A48, "Member 'APalPlayerCharacter::PlayerCameraYaw' has a wrong offset!");
static_assert(offsetof(APalPlayerCharacter, PlayerCameraPitch) == 0x000A4C, "Member 'APalPlayerCharacter::PlayerCameraPitch' has a wrong offset!");
static_assert(offsetof(APalPlayerCharacter, IsAdjustedLocationByLoad) == 0x000A50, "Member 'APalPlayerCharacter::IsAdjustedLocationByLoad' has a wrong offset!");
static_assert(offsetof(APalPlayerCharacter, IdleAnimMontage) == 0x000A58, "Member 'APalPlayerCharacter::IdleAnimMontage' has a wrong offset!");
static_assert(offsetof(APalPlayerCharacter, PlayerBattleSituation) == 0x000A60, "Member 'APalPlayerCharacter::PlayerBattleSituation' has a wrong offset!");
static_assert(offsetof(APalPlayerCharacter, IsNearCommonEnemyFlag) == 0x000A68, "Member 'APalPlayerCharacter::IsNearCommonEnemyFlag' has a wrong offset!");
static_assert(offsetof(APalPlayerCharacter, bIsSetRespawnTelemetry) == 0x000A69, "Member 'APalPlayerCharacter::bIsSetRespawnTelemetry' has a wrong offset!");
static_assert(offsetof(APalPlayerCharacter, GenderChangerClass) == 0x000A78, "Member 'APalPlayerCharacter::GenderChangerClass' has a wrong offset!");
static_assert(offsetof(APalPlayerCharacter, GenderChanger) == 0x000A80, "Member 'APalPlayerCharacter::GenderChanger' has a wrong offset!");
static_assert(offsetof(APalPlayerCharacter, bSpectatorMode) == 0x000A88, "Member 'APalPlayerCharacter::bSpectatorMode' has a wrong offset!");
static_assert(offsetof(APalPlayerCharacter, CharacterMakeInfo) == 0x000A8C, "Member 'APalPlayerCharacter::CharacterMakeInfo' has a wrong offset!");

// Class Pal.PalPlayerController
// 0x04C8 (0x0D18 - 0x0850)
class APalPlayerController : public ACommonPlayerController
{
public:
	bool                                          bAdmin;                                            // 0x0850(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DEC[0x7];                                     // 0x0851(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalAIActionComponent*                  AIActionComponent;                                 // 0x0858(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalCutsceneComponent*                  CutsceneComponent;                                 // 0x0860(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APalNetworkTransmitter*                 Transmitter;                                       // 0x0868(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WeaponPaletteLongPressTime;                        // 0x0870(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PawnChangeCameraInterpChangeTime;                  // 0x0874(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOpenConstructionMenu;                            // 0x0878(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DED[0x7];                                     // 0x0879(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnCoopRequestDelegate;                             // 0x0880(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCoopReleaseDelegate;                             // 0x0890(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInteractDelegate;                                // 0x08A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInteract2Delegate;                               // 0x08B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressedJumpDelegate;                             // 0x08C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInputMoveForwardDelegate;                        // 0x08D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMoveInputDelegate;                               // 0x08E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DEE[0x10];                                    // 0x08F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnPressedThrowPalButtonDelegate;                   // 0x0900(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnReleasedThrowPalButtonDelegate;                  // 0x0910(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnPressedSpawnPalButtonDelegate;                   // 0x0920(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnLongPressedSpawnPalButtonDelegate;               // 0x0930(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnReleasedSpawnPalButtonDelegate;                  // 0x0940(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnLongReleasedSpawnPalButtonDelegate;              // 0x0950(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnPressedPartnerInstructionsButtonDelegate;        // 0x0960(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnPressConstructionMenuButtonDelegate;             // 0x0970(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DEF[0xC8];                                    // 0x0980(0x00C8)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            RecoilCurve;                                       // 0x0A48(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DF0[0x70];                                    // 0x0A50(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TimerGaugeDisplayOffset;                           // 0x0AC0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UCameraShakeBase>           DamageCameraShake;                                 // 0x0AD8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UPalPlayerDamageCamShakeRegulator> DamageCamShakeRegulatorClass;                      // 0x0AE0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalPlayerDamageCamShakeRegulator*      DamageCamShakeRegulator;                           // 0x0AE8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UPalLongPressObject*>            LongPressObjects;                                  // 0x0AF0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<class FName, float>                      CameraRotateModifierMap;                           // 0x0B00(0x0050)(NativeAccessSpecifierPrivate)
	TArray<struct FRotator>                       AutoAimRotatorList;                                // 0x0B50(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DF1[0x100];                                   // 0x0B60(0x0100)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDelegateTickFunction                  PawnAfterTickFunction;                             // 0x0C60(0x0038)(NativeAccessSpecifierPrivate)
	class AActor*                                 AutoAimTarget;                                     // 0x0C98(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                ReticleTargetOffset;                               // 0x0CA0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              GamePadNativeAxis;                                 // 0x0CB8(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              MouseNativeAxis;                                   // 0x0CC8(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                               CacheActorRotator;                                 // 0x0CD8(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DF2[0x10];                                    // 0x0CF0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalPlayerInputOneFlameCommandList*     PlayerInputOneFlameCommandList;                    // 0x0D00(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  GuildFlowUniqueIdClientCache;                      // 0x0D08(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ActivateCurrentOtomoNearThePlayer();
	void AddCameraRotateSpeedModifierRate(const class FName& ModifierName, float Rate);
	void CallOnCoopReleaseDelegate_ToServer();
	void ConfirmRequestGuild_ToClient(const struct FGuid& FlowUniqueId, const EPalGuildJoinRequestConfirm ConfirmType);
	void Debug_AddExpForALLPlayer_ToServer(int32 AddExp);
	void Debug_AddMoney_ToServer(int64 AddValue);
	void Debug_AddPartyExp_ToServer(int32 AddExp);
	void Debug_AddPlayerExp_ToServer(int32 AddExp);
	void Debug_CheatCommand_ToServer(const class FString& Command);
	void Debug_EnableCollectPalCount();
	void Debug_ForceSpawnRarePal_ToServer();
	void Debug_IgnoreRestrictedByItemsForPartnerSkill();
	void Debug_InsightsTraceStart_ToServer();
	void Debug_InsightsTraceStop_ToServer();
	void Debug_InvaderMarch();
	void Debug_InvaderMarchRandom();
	void Debug_Muteki_ToServer();
	void Debug_NotConsumeMaterialsInBuild();
	void Debug_NotConsumeMaterialsInCraft();
	void Debug_ParallelForUpdateActiveTiles();
	void Debug_ReceiveCheatCommand_ToClient(const class FString& Message);
	void Debug_RerollCharacterMake();
	void Debug_SetFPSForServer(float Fps);
	void Debug_SetPalWorldTime(int32 Hour);
	void Debug_SetPalWorldTimeScale(float Rate);
	void Debug_ShowInvaderDebugLog();
	void Debug_Teleport2D(const struct FVector& Location);
	void Debug_TeleportToBotCamp(int32 botIndex);
	void Debug_TeleportToBotLocation(int32 botIndex);
	void Debug_TeleportToNearestCamp();
	void Debug_TeleportToNearestPlayer();
	void Debug_TogglePartnerSkillNoDecrease();
	void DoStep(EPalStepAxisType Axis, const struct FVector2D& StepDirection);
	void EnableShootingByAction(const class UPalActionComponent* Component);
	void EndFlyToServer();
	void GetOffToServer();
	TSubclassOf<class UPalUserWidgetTimerGaugeBase> GetTimerGaugeWidgetClass();
	void InactiveOtomo();
	void JumpCancelPalThrow(class UPalCharacterMovementComponent* MovementComponent);
	void NotifyConfirmRequestGuild_ToServer(const struct FGuid& FlowUniqueId, const bool bResponse);
	void NotifyLiftupCampPal_ToClient(class APalCharacter* TargetCharacter);
	void OnActionBegin(const class UPalActionBase* ActionBase);
	void OnChangeInstructions();
	void OnChangeKeyboardOption(const struct FPalOptionKeyboardSettings& PrevSettings, const struct FPalOptionKeyboardSettings& NewSettings);
	void OnChangeOtomoSlot();
	void OnChangePadOption(const struct FPalOptionPadSettings& PrevSettings, const struct FPalOptionPadSettings& NewSettings);
	void OnChangeSwimming(bool IsInSwimming);
	void OnCoopReleaseDelegate__DelegateSignature();
	void OnCoopRequestDelegate__DelegateSignature();
	void OnDamage(const struct FPalDamageResult& DamageResult);
	void OnDestroyPawn(class AActor* DestroyedActor);
	void OnEndAim();
	void OnEndCoopRequest();
	void OnEndRolling();
	void OnFixedWeightInventory(float Weight);
	void OnFlyRideTakeOff();
	void OnGetOffAndDespawnSupportPal();
	void OnInitializeLocalPlayer_BP();
	void OnInteractDelegate__DelegateSignature();
	void OnJump(class UPalCharacterMovementComponent* MovementComponent);
	void OnLanded(class UPalCharacterMovementComponent* MovementComponent, const struct FHitResult& Hit);
	void OnLongPressedCoopButton();
	void OnLongPressedSpawnPalButtonDelegate__DelegateSignature();
	void OnLongReleasedSpawnPalButton();
	void OnLongReleasedSpawnPalButtonDelegate__DelegateSignature();
	void OnMoveInputDelegate__DelegateSignature();
	void OnOtomo_LongPressed();
	void OnOtomo_LongReleased();
	void OnOtomo_Pressed();
	void OnOtomo_ShortReleased();
	void OnOtomoChangeDecrement();
	void OnOtomoChangeIncrement();
	void OnOverWeightInventory(float Weight);
	void OnPressConstructionMenuButtonDelegate__DelegateSignature();
	void OnPressedJumpDelegate__DelegateSignature();
	void OnPressedMoveForwardDelegate__DelegateSignature(float InputValue, bool IsController);
	void OnPressedPartnerInstructionsButtonDelegate__DelegateSignature();
	void OnPressedSpawnPalButtonDelegate__DelegateSignature();
	void OnPressedThrowPalButtonDelegate__DelegateSignature();
	void OnPressedUseRecoveryItemButton();
	void OnReceiveConfirmResultRequestGuild_ClientInternal(const bool bResponse);
	void OnReleasedSpawnPalButton();
	void OnReleasedSpawnPalButtonDelegate__DelegateSignature();
	void OnReleasedThrowPalButtonDelegate__DelegateSignature();
	void OnSpawnAndRideSupportPal();
	void OnStartAim();
	void OnStartCoopRequest();
	void OnStartGliding();
	void OnSwitchOtomoSpawn();
	void OnUpdateWeightInventory(float Weight);
	void OnWeaponNotify(EWeaponNotifyType Type);
	void PalDeprojectScreenPositionToWorld(struct FVector* StartLocation, struct FVector* RayDirection);
	void PlaySkill(int32 SlotID);
	void ReceiveFailedRequestGuildWithAlert_ToClient(const EPalGuildJoinRequestResult Result);
	void ReceiveFailedRequestGuildWithLog_ToClient(const EPalGuildJoinRequestResult Result);
	void ReceiveLiftupRequestResult_ToClient(EPalLiftupRequestResult Result);
	void ReceiveOfferJoinGuildPlayer_ToClient(const struct FGuid& FlowUniqueId, const struct FPalInstanceID& RequestPlayerInstanceId);
	void ReceiveSuccessRequestEnterGuild_ToClient(const EPalGuildJoinRequestResult Result, const struct FPalInstanceID& EnterPlayerInstanceId);
	void RemoveCameraRotateSpeedModifierRate(const class FName& ModifierName);
	void RequestBanPlayerFromGuild_ToServer(const struct FGuid& TargetPlayerUId);
	void RequestChangeAdminGuild_ToServer(const struct FGuid& NextAdminPlayerUId);
	void RequestChangeCharacterMakeInfo_ToServer(const struct FPalPlayerDataCharacterMakeInfo& NewMakeInfo);
	void RequestChangeGuildName_ToServer(const class FString& NewGuildName);
	void RequestEnterToPlayerGuild_ToServer(class APalPlayerCharacter* RespondentPlayerCharacter);
	void RequestExitGuild_ToServer();
	void RequestFastTravel_ToServer(const struct FGuid& LocationId);
	void RequestLiftup_ToServer(class APalCharacter* TargetCharacter);
	void RequestLiftupThrow_ToServer(class AActor* Target);
	void RequestUseReturnToBaseCampItem(const struct FPalItemSlotId& ItemData);
	void RequestUseReturnToBaseCampItem_ToServer(const struct FPalItemSlotId& ItemData);
	void RPCDummy();
	void SelfKillPlayer();
	void SendLog_ToClient(const EPalLogPriority Priority, const class FText& Text, const struct FPalLogAdditionalData& AdditionalData);
	void SendScreenLogToClient(const class FString& Message, const struct FLinearColor& Color, float Duration, const class FName& Key);
	void SetCameraRotatorToPlayerCharacter_ToServer(const struct FRotator& CameraRotator);
	void SetCaptureLevelForSphere(class APalSphereBodyBase* Target, int32 Level);
	void SetCaptureLevelForSphere_ToALL(int32 ID, class APalSphereBodyBase* Target, int32 Level);
	void SetCaptureLevelForSphere_ToServer(int32 ID, class APalSphereBodyBase* Target, int32 Level);
	void SetDisableInputFlag(class FName FlagName, bool IsDisable);
	void SetDisableSwitchPalFlag(class FName FlagName, bool IsDisable);
	void SetDisableThrowPalFlag(class FName FlagName, bool IsDisable);
	void SetHoldOtomo(int32 HoldID, class UPalIndividualCharacterHandle* OtomoHandle);
	void SetOtomoSlot(int32 SlotID);
	void SetRiderRelativeRotation_ToServer(const struct FRotator& Rotator);
	void SetSneakBonusFlagForSphere(class APalSphereBodyBase* Target, bool IsSneak);
	void SetSneakBonusFlagForSphere_ToALL(int32 ID, class APalSphereBodyBase* Target, bool IsSneak);
	void SetSneakBonusFlagForSphere_ToServer(int32 ID, class APalSphereBodyBase* Target, bool IsSneak);
	void SetupInternalForSphere(class APalSphereBodyBase* Target, class APalCharacter* TargetCharacter);
	void SetupInternalForSphere_ToALL(int32 ID, class APalSphereBodyBase* Target, class APalCharacter* TargetCharacter);
	void SetupInternalForSphere_ToServer(int32 ID, class APalSphereBodyBase* Target, class APalCharacter* TargetCharacter);
	void ShooterComponent_ChangeIsAiming_ToServer(class UPalShooterComponent* Shooter, int32 ID, bool IsAiming);
	void ShooterComponent_ChangeIsShooting_ToServer(class UPalShooterComponent* Shooter, int32 ID, bool IsShooting);
	void ShooterComponent_ReloadWeapon_ToServer(class UPalShooterComponent* Shooter, int32 ID);
	void ShooterComponent_SetTargetDirection_ToServer(class UPalShooterComponent* Shooter, const struct FVector& TargetDirection);
	void ShooterComponent_StopReload_ToServer(class UPalShooterComponent* Shooter, int32 ID);
	void StartFlyToServer();
	void StartStepCoolDownCoolTimer();
	void TeleportToSafePoint_ToServer();
	void ThrowPalByOutSide(class AActor* PreOtomoPal);
	bool TrySwitchOtomo();
	void UpdateCharacterNickName_ToServer(const struct FPalInstanceID& InstanceId, const class FString& NewNickName);

	bool CanCooping() const;
	struct FVector2D GetControllerLeftStickValue() const;
	struct FVector2D GetControllerRightStickValue() const;
	class APalCharacter* GetControlPalCharacter() const;
	class APalCharacter* GetDefaultPlayerCharacter() const;
	struct FVector2D GetKeyboardMoveValue() const;
	class UPalLoadoutSelectorComponent* GetLoadoutSelectorComponent() const;
	class APalCharacter* GetLowBodyPalCharacter() const;
	class APawn* GetLowBodyPawn() const;
	class APalPlayerState* GetPalPlayerState() const;
	const struct FGuid GetPlayerUId() const;
	class AActor* GetRidingCharacter() const;
	bool IsCooping() const;
	bool IsRiding() const;
	bool IsRidingFlyPal() const;
	bool IsSwimming() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalPlayerController">();
	}
	static class APalPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalPlayerController>();
	}
};
static_assert(alignof(APalPlayerController) == 0x000008, "Wrong alignment on APalPlayerController");
static_assert(sizeof(APalPlayerController) == 0x000D18, "Wrong size on APalPlayerController");
static_assert(offsetof(APalPlayerController, bAdmin) == 0x000850, "Member 'APalPlayerController::bAdmin' has a wrong offset!");
static_assert(offsetof(APalPlayerController, AIActionComponent) == 0x000858, "Member 'APalPlayerController::AIActionComponent' has a wrong offset!");
static_assert(offsetof(APalPlayerController, CutsceneComponent) == 0x000860, "Member 'APalPlayerController::CutsceneComponent' has a wrong offset!");
static_assert(offsetof(APalPlayerController, Transmitter) == 0x000868, "Member 'APalPlayerController::Transmitter' has a wrong offset!");
static_assert(offsetof(APalPlayerController, WeaponPaletteLongPressTime) == 0x000870, "Member 'APalPlayerController::WeaponPaletteLongPressTime' has a wrong offset!");
static_assert(offsetof(APalPlayerController, PawnChangeCameraInterpChangeTime) == 0x000874, "Member 'APalPlayerController::PawnChangeCameraInterpChangeTime' has a wrong offset!");
static_assert(offsetof(APalPlayerController, IsOpenConstructionMenu) == 0x000878, "Member 'APalPlayerController::IsOpenConstructionMenu' has a wrong offset!");
static_assert(offsetof(APalPlayerController, OnCoopRequestDelegate) == 0x000880, "Member 'APalPlayerController::OnCoopRequestDelegate' has a wrong offset!");
static_assert(offsetof(APalPlayerController, OnCoopReleaseDelegate) == 0x000890, "Member 'APalPlayerController::OnCoopReleaseDelegate' has a wrong offset!");
static_assert(offsetof(APalPlayerController, OnInteractDelegate) == 0x0008A0, "Member 'APalPlayerController::OnInteractDelegate' has a wrong offset!");
static_assert(offsetof(APalPlayerController, OnInteract2Delegate) == 0x0008B0, "Member 'APalPlayerController::OnInteract2Delegate' has a wrong offset!");
static_assert(offsetof(APalPlayerController, OnPressedJumpDelegate) == 0x0008C0, "Member 'APalPlayerController::OnPressedJumpDelegate' has a wrong offset!");
static_assert(offsetof(APalPlayerController, OnInputMoveForwardDelegate) == 0x0008D0, "Member 'APalPlayerController::OnInputMoveForwardDelegate' has a wrong offset!");
static_assert(offsetof(APalPlayerController, OnMoveInputDelegate) == 0x0008E0, "Member 'APalPlayerController::OnMoveInputDelegate' has a wrong offset!");
static_assert(offsetof(APalPlayerController, OnPressedThrowPalButtonDelegate) == 0x000900, "Member 'APalPlayerController::OnPressedThrowPalButtonDelegate' has a wrong offset!");
static_assert(offsetof(APalPlayerController, OnReleasedThrowPalButtonDelegate) == 0x000910, "Member 'APalPlayerController::OnReleasedThrowPalButtonDelegate' has a wrong offset!");
static_assert(offsetof(APalPlayerController, OnPressedSpawnPalButtonDelegate) == 0x000920, "Member 'APalPlayerController::OnPressedSpawnPalButtonDelegate' has a wrong offset!");
static_assert(offsetof(APalPlayerController, OnLongPressedSpawnPalButtonDelegate) == 0x000930, "Member 'APalPlayerController::OnLongPressedSpawnPalButtonDelegate' has a wrong offset!");
static_assert(offsetof(APalPlayerController, OnReleasedSpawnPalButtonDelegate) == 0x000940, "Member 'APalPlayerController::OnReleasedSpawnPalButtonDelegate' has a wrong offset!");
static_assert(offsetof(APalPlayerController, OnLongReleasedSpawnPalButtonDelegate) == 0x000950, "Member 'APalPlayerController::OnLongReleasedSpawnPalButtonDelegate' has a wrong offset!");
static_assert(offsetof(APalPlayerController, OnPressedPartnerInstructionsButtonDelegate) == 0x000960, "Member 'APalPlayerController::OnPressedPartnerInstructionsButtonDelegate' has a wrong offset!");
static_assert(offsetof(APalPlayerController, OnPressConstructionMenuButtonDelegate) == 0x000970, "Member 'APalPlayerController::OnPressConstructionMenuButtonDelegate' has a wrong offset!");
static_assert(offsetof(APalPlayerController, RecoilCurve) == 0x000A48, "Member 'APalPlayerController::RecoilCurve' has a wrong offset!");
static_assert(offsetof(APalPlayerController, TimerGaugeDisplayOffset) == 0x000AC0, "Member 'APalPlayerController::TimerGaugeDisplayOffset' has a wrong offset!");
static_assert(offsetof(APalPlayerController, DamageCameraShake) == 0x000AD8, "Member 'APalPlayerController::DamageCameraShake' has a wrong offset!");
static_assert(offsetof(APalPlayerController, DamageCamShakeRegulatorClass) == 0x000AE0, "Member 'APalPlayerController::DamageCamShakeRegulatorClass' has a wrong offset!");
static_assert(offsetof(APalPlayerController, DamageCamShakeRegulator) == 0x000AE8, "Member 'APalPlayerController::DamageCamShakeRegulator' has a wrong offset!");
static_assert(offsetof(APalPlayerController, LongPressObjects) == 0x000AF0, "Member 'APalPlayerController::LongPressObjects' has a wrong offset!");
static_assert(offsetof(APalPlayerController, CameraRotateModifierMap) == 0x000B00, "Member 'APalPlayerController::CameraRotateModifierMap' has a wrong offset!");
static_assert(offsetof(APalPlayerController, AutoAimRotatorList) == 0x000B50, "Member 'APalPlayerController::AutoAimRotatorList' has a wrong offset!");
static_assert(offsetof(APalPlayerController, PawnAfterTickFunction) == 0x000C60, "Member 'APalPlayerController::PawnAfterTickFunction' has a wrong offset!");
static_assert(offsetof(APalPlayerController, AutoAimTarget) == 0x000C98, "Member 'APalPlayerController::AutoAimTarget' has a wrong offset!");
static_assert(offsetof(APalPlayerController, ReticleTargetOffset) == 0x000CA0, "Member 'APalPlayerController::ReticleTargetOffset' has a wrong offset!");
static_assert(offsetof(APalPlayerController, GamePadNativeAxis) == 0x000CB8, "Member 'APalPlayerController::GamePadNativeAxis' has a wrong offset!");
static_assert(offsetof(APalPlayerController, MouseNativeAxis) == 0x000CC8, "Member 'APalPlayerController::MouseNativeAxis' has a wrong offset!");
static_assert(offsetof(APalPlayerController, CacheActorRotator) == 0x000CD8, "Member 'APalPlayerController::CacheActorRotator' has a wrong offset!");
static_assert(offsetof(APalPlayerController, PlayerInputOneFlameCommandList) == 0x000D00, "Member 'APalPlayerController::PlayerInputOneFlameCommandList' has a wrong offset!");
static_assert(offsetof(APalPlayerController, GuildFlowUniqueIdClientCache) == 0x000D08, "Member 'APalPlayerController::GuildFlowUniqueIdClientCache' has a wrong offset!");

// Class Pal.PalPlayerDamageCamShakeRegulator
// 0x0008 (0x0030 - 0x0028)
class UPalPlayerDamageCamShakeRegulator final : public UObject
{
public:
	class UDataTable*                             DamageCameraShakeTable;                            // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalPlayerDamageCamShakeRegulator">();
	}
	static class UPalPlayerDamageCamShakeRegulator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalPlayerDamageCamShakeRegulator>();
	}
};
static_assert(alignof(UPalPlayerDamageCamShakeRegulator) == 0x000008, "Wrong alignment on UPalPlayerDamageCamShakeRegulator");
static_assert(sizeof(UPalPlayerDamageCamShakeRegulator) == 0x000030, "Wrong size on UPalPlayerDamageCamShakeRegulator");
static_assert(offsetof(UPalPlayerDamageCamShakeRegulator, DamageCameraShakeTable) == 0x000028, "Member 'UPalPlayerDamageCamShakeRegulator::DamageCameraShakeTable' has a wrong offset!");

// Class Pal.PalPlayerDataPalStorage
// 0x0038 (0x0060 - 0x0028)
class UPalPlayerDataPalStorage final : public UObject
{
public:
	int32                                         PageNum;                                           // 0x0028(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SlotNumInPage;                                     // 0x002C(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalIndividualCharacterContainer*       TargetContainer;                                   // 0x0030(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalIndividualCharacterSlotsObserver*   SlotObserver;                                      // 0x0038(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  OwnerPlayerUId;                                    // 0x0040(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsOpen;                                            // 0x0050(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E0E[0xF];                                     // 0x0051(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_TargetContainer();
	void OnUpdateCharacterContainer_InServer();

	class UPalIndividualCharacterSlot* GetSlot(const int32 PageIndex, const int32 SlotIndex) const;
	void GetSlotsInPage(const int32 PageIndex, TArray<class UPalIndividualCharacterSlot*>* Slots) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalPlayerDataPalStorage">();
	}
	static class UPalPlayerDataPalStorage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalPlayerDataPalStorage>();
	}
};
static_assert(alignof(UPalPlayerDataPalStorage) == 0x000008, "Wrong alignment on UPalPlayerDataPalStorage");
static_assert(sizeof(UPalPlayerDataPalStorage) == 0x000060, "Wrong size on UPalPlayerDataPalStorage");
static_assert(offsetof(UPalPlayerDataPalStorage, PageNum) == 0x000028, "Member 'UPalPlayerDataPalStorage::PageNum' has a wrong offset!");
static_assert(offsetof(UPalPlayerDataPalStorage, SlotNumInPage) == 0x00002C, "Member 'UPalPlayerDataPalStorage::SlotNumInPage' has a wrong offset!");
static_assert(offsetof(UPalPlayerDataPalStorage, TargetContainer) == 0x000030, "Member 'UPalPlayerDataPalStorage::TargetContainer' has a wrong offset!");
static_assert(offsetof(UPalPlayerDataPalStorage, SlotObserver) == 0x000038, "Member 'UPalPlayerDataPalStorage::SlotObserver' has a wrong offset!");
static_assert(offsetof(UPalPlayerDataPalStorage, OwnerPlayerUId) == 0x000040, "Member 'UPalPlayerDataPalStorage::OwnerPlayerUId' has a wrong offset!");
static_assert(offsetof(UPalPlayerDataPalStorage, IsOpen) == 0x000050, "Member 'UPalPlayerDataPalStorage::IsOpen' has a wrong offset!");

// Class Pal.PalPlayerDataStorage
// 0x0000 (0x0028 - 0x0028)
class UPalPlayerDataStorage : public UObject
{
public:
	class UPalItemContainerMultiHelper* GetInventoryContainers();

	void GetInventoryInfo(struct FPalPlayerDataInventoryInfo* OutInventoryInfo) const;
	class UPalPlayerDataPalStorage* GetPalStorage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalPlayerDataStorage">();
	}
	static class UPalPlayerDataStorage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalPlayerDataStorage>();
	}
};
static_assert(alignof(UPalPlayerDataStorage) == 0x000008, "Wrong alignment on UPalPlayerDataStorage");
static_assert(sizeof(UPalPlayerDataStorage) == 0x000028, "Wrong size on UPalPlayerDataStorage");

// Class Pal.PalPlayerGenderChanger
// 0x0158 (0x0180 - 0x0028)
class UPalPlayerGenderChanger : public UObject
{
public:
	struct FPlayerGenderParams                    MaleCharacterParams;                               // 0x0028(0x00A8)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FPlayerGenderParams                    FemaleCharacterParams;                             // 0x00D0(0x00A8)(Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsEpmtyFamaleParams;                              // 0x0178(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFamale;                                         // 0x0179(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E10[0x6];                                     // 0x017A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalPlayerGenderChanger">();
	}
	static class UPalPlayerGenderChanger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalPlayerGenderChanger>();
	}
};
static_assert(alignof(UPalPlayerGenderChanger) == 0x000008, "Wrong alignment on UPalPlayerGenderChanger");
static_assert(sizeof(UPalPlayerGenderChanger) == 0x000180, "Wrong size on UPalPlayerGenderChanger");
static_assert(offsetof(UPalPlayerGenderChanger, MaleCharacterParams) == 0x000028, "Member 'UPalPlayerGenderChanger::MaleCharacterParams' has a wrong offset!");
static_assert(offsetof(UPalPlayerGenderChanger, FemaleCharacterParams) == 0x0000D0, "Member 'UPalPlayerGenderChanger::FemaleCharacterParams' has a wrong offset!");
static_assert(offsetof(UPalPlayerGenderChanger, bIsEpmtyFamaleParams) == 0x000178, "Member 'UPalPlayerGenderChanger::bIsEpmtyFamaleParams' has a wrong offset!");
static_assert(offsetof(UPalPlayerGenderChanger, bIsFamale) == 0x000179, "Member 'UPalPlayerGenderChanger::bIsFamale' has a wrong offset!");

// Class Pal.PalPlayerInput
// 0x00B0 (0x0548 - 0x0498)
class UPalPlayerInput : public UPlayerInput
{
public:
	FMulticastInlineDelegateProperty_             OnKeyConfigChanged;                                // 0x0498(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TSet<struct FKey>                             EnableKeys;                                        // 0x04A8(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSet<struct FKey>                             DisableKeys;                                       // 0x04F8(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	struct FPalKeyConfigKeys GetActionConfigKeys(const class FName InActionName, EPalKeyConfigCategory Category);
	struct FPalKeyConfigKeys GetAxisConfigKeys(const class FName InAxisName, EPalKeyConfigCategory Category, EPalKeyConfigAxisFilterType FilterType);
	void OnChangeKeyConfig(const struct FPalKeyConfigSettings& PrevSettings, const struct FPalKeyConfigSettings& NewSettings);
	void OnKeyConfigChangedDelegate__DelegateSignature();
	void ResetActionKey(const class FName InActionName, EPalKeyConfigCategory Category);
	void ResetAxisKey(const class FName InAxisName, EPalKeyConfigCategory Category, EPalKeyConfigAxisFilterType FilterType);
	bool UpdateActionMapping(const class FName InActionName, const struct FPalKeyConfigKeys& NewKey, EPalKeyConfigCategory Category);

	void FiltterCategoryActionMappings(EPalKeyConfigCategory Category, TArray<struct FInputActionKeyMapping>* Mappings) const;
	void FiltterCategoryAxisMappings(EPalKeyConfigCategory Category, EPalKeyConfigAxisFilterType FilterType, TArray<struct FInputAxisKeyMapping>* Mappings) const;
	void GetActionMappingByName(const class FName InActionName, TArray<struct FInputActionKeyMapping>* OutMappings) const;
	void GetAxisMappingByName(const class FName InAxisName, TArray<struct FInputAxisKeyMapping>* OutMappings) const;
	bool IsEnableKey(const struct FKey& Key, EPalKeyConfigCategory InputType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalPlayerInput">();
	}
	static class UPalPlayerInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalPlayerInput>();
	}
};
static_assert(alignof(UPalPlayerInput) == 0x000008, "Wrong alignment on UPalPlayerInput");
static_assert(sizeof(UPalPlayerInput) == 0x000548, "Wrong size on UPalPlayerInput");
static_assert(offsetof(UPalPlayerInput, OnKeyConfigChanged) == 0x000498, "Member 'UPalPlayerInput::OnKeyConfigChanged' has a wrong offset!");
static_assert(offsetof(UPalPlayerInput, EnableKeys) == 0x0004A8, "Member 'UPalPlayerInput::EnableKeys' has a wrong offset!");
static_assert(offsetof(UPalPlayerInput, DisableKeys) == 0x0004F8, "Member 'UPalPlayerInput::DisableKeys' has a wrong offset!");

// Class Pal.PalPlayerInputOneFlameCommand
// 0x0078 (0x00A0 - 0x0028)
class UPalPlayerInputOneFlameCommand final : public UObject
{
public:
	uint8                                         Pad_2E19[0x70];                                    // 0x0028(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	EPalPlayerInputButtonType                     CurrentState;                                      // 0x0098(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E1A[0x7];                                     // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPress();
	void OnRelease();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalPlayerInputOneFlameCommand">();
	}
	static class UPalPlayerInputOneFlameCommand* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalPlayerInputOneFlameCommand>();
	}
};
static_assert(alignof(UPalPlayerInputOneFlameCommand) == 0x000008, "Wrong alignment on UPalPlayerInputOneFlameCommand");
static_assert(sizeof(UPalPlayerInputOneFlameCommand) == 0x0000A0, "Wrong size on UPalPlayerInputOneFlameCommand");
static_assert(offsetof(UPalPlayerInputOneFlameCommand, CurrentState) == 0x000098, "Member 'UPalPlayerInputOneFlameCommand::CurrentState' has a wrong offset!");

// Class Pal.PalPlayerInputOneFlameCommandList
// 0x0018 (0x0040 - 0x0028)
class UPalPlayerInputOneFlameCommandList final : public UObject
{
public:
	TArray<class UPalPlayerInputOneFlameCommand*> List;                                              // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class FName                                   DebugName;                                         // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalPlayerInputOneFlameCommandList">();
	}
	static class UPalPlayerInputOneFlameCommandList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalPlayerInputOneFlameCommandList>();
	}
};
static_assert(alignof(UPalPlayerInputOneFlameCommandList) == 0x000008, "Wrong alignment on UPalPlayerInputOneFlameCommandList");
static_assert(sizeof(UPalPlayerInputOneFlameCommandList) == 0x000040, "Wrong size on UPalPlayerInputOneFlameCommandList");
static_assert(offsetof(UPalPlayerInputOneFlameCommandList, List) == 0x000028, "Member 'UPalPlayerInputOneFlameCommandList::List' has a wrong offset!");
static_assert(offsetof(UPalPlayerInputOneFlameCommandList, DebugName) == 0x000038, "Member 'UPalPlayerInputOneFlameCommandList::DebugName' has a wrong offset!");

// Class Pal.PalPlayerInventoryData
// 0x0178 (0x01A0 - 0x0028)
class UPalPlayerInventoryData : public UObject
{
public:
	uint8                                         Pad_2E1B[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnUpdateInventoryContainerDelegate;                // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateEssentialContainerDelegate;                // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateLoadoutSlotDelegate;                       // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateEquipmentSlotDelegate;                     // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateWeightInventoryDelegate;                   // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateMaxWeightInventoryDelegate;                // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnOverWeightInventoryDelegate;                     // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFixedInventoryWeightDelegate;                    // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMaxWeightBuffedDelegate;                         // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCurrentWeightBuffedDelegate;                     // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPickupItemDelegate;                              // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGetItemFromConvertItemMapObject;                 // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FPalPlayerDataInventoryInfo            InventoryInfo;                                     // 0x00F0(0x0060)(Edit, Net, DisableEditOnTemplate, EditConst, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E1C[0x8];                                     // 0x0150(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           FullInventoryLogGuardTimerHandle;                  // 0x0158(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         NowItemWeight;                                     // 0x0160(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxInventoryWeight;                                // 0x0164(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxInventoryWeight_Cached;                         // 0x0168(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E1D[0x4];                                     // 0x016C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalItemContainerMultiHelper*           InventoryMultiHelper;                              // 0x0170(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PassiveBuffedMaxWeight;                            // 0x0178(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PassiveBuffedCurrentWeight;                        // 0x017C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  OwnerPlayerUId;                                    // 0x0180(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalMoneyData*                          MoneyData;                                         // 0x0190(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          EquipmentBreakAudioEvent;                          // 0x0198(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddFullInventoryLog_Client();
	EPalItemOperationResult AddItem_ServerInternal(const class FName StaticItemId, const int32 Count, bool IsAssignPassive);
	bool CanCheckPalTalentsByInventoryItem();
	void CurrentWeightBuffedDelegate__DelegateSignature(float ChangedWeight);
	void FixedWeightInventoryDelegate__DelegateSignature(float NowWeight);
	void GetItemInfoByItemTypeA(const TArray<EPalItemTypeA>& ItemTypeA, TArray<struct FPalItemAndNum>* OutItemInfos);
	float GetPassiveBuffedItemWeight(const class UPalStaticItemDataBase* Item);
	bool IsEquipSlot(class UPalItemSlot* CheckSlot);
	void MaxWeightBuffedDelegate__DelegateSignature();
	void OnEndPassiveSkill(EPalPassiveSkillEffectType EffectType);
	void OnOnUpdateStatusPoint(class FName StatusName, int32 PrevPoint, int32 NewPoint);
	void OnRep_BuffCurrentWeight();
	void OnRep_BuffMaxWeight();
	void OnRep_InventoryInfo();
	void OnRep_maxInventoryWeight();
	void OnUpdateAnyEquipmentDurability(float OldDurability, float NewDurability);
	void OnUpdateEquipmentSlot(class UPalItemSlot* Slot);
	void OnUpdateEquipmentSlot_ForServer(class UPalItemSlot* Slot);
	void OnUpdateEssentialContainer(class UPalItemContainer* Container);
	void OnUpdateInventoryContainer(class UPalItemContainer* Container);
	void OnUpdateLoadoutSlot(class UPalItemSlot* Slot);
	void OnUpdatePassiveSkill(EPalPassiveSkillEffectType EffectType, float Value);
	void OverWeightInventoryDelegate__DelegateSignature(float NowWeight);
	void PickupItemDelegate__DelegateSignature(TArray<struct FPalItemAndNum>* ItemInfos);
	void RequestAddItem(const class FName StaticItemId, const int32 Count, bool IsAssignPassive);
	void RequestDropItemFromDropSlot();
	void RequestDropItemFromDropSlot_ServerInternal();
	void RequestFillSlotToInventoryFromTargetContainer_ToServer(const struct FPalContainerId& FromContainerId);
	void RequestFillSlotToTargetContainerFromInventory_ToServer(const struct FPalContainerId& ToContainerId);
	void RequestSortInventory();
	void RequestSortInventory_ServerInternal();
	void RequestTrashItemFromDropSlot();
	void RequestTrashItemFromDropSlot_ServerInternal();
	bool TryEquipSlot(class UPalItemSlot* Slot);
	bool TryGetEmptySlot(EPalPlayerInventoryType InventoryType, class UPalItemSlot** EmptySlot);
	bool TryGetItemIdBySlot(EPalPlayerEquipItemSlotType EquipmentSlotType, struct FPalItemId* OutItemId);
	bool TryRemoveEquipment(class UPalItemSlot* EquipSlot);
	void UpdateEquipmentSlotDelegate__DelegateSignature(class UPalItemSlot* ItemSlot, EPalPlayerEquipItemSlotType SlotType);
	void UpdateEssentialContainerDelegate__DelegateSignature(class UPalItemContainer* Container);
	void UpdateInventoryContainerDelegate__DelegateSignature(class UPalItemContainer* Container);
	void UpdateLoadoutSlotDelegate__DelegateSignature(class UPalItemSlot* ItemSlot, EPalPlayerInventoryType UpdatedLoadoutType);
	void UpdateMaxWeightInventoryDelegate__DelegateSignature(float MaxWeight);
	void UpdateWeightInventoryDelegate__DelegateSignature(float NowWeight);

	bool CanEquip(EPalPlayerEquipItemSlotType EquipmentSlotType, const class FName& StaticItemId) const;
	int32 CountItemNum(const class FName& StaticItemId) const;
	EPalPlayerInventoryType GetInventoryTypeFromItemTypeA(const EPalItemTypeA ItemTypeA) const;
	EPalPlayerInventoryType GetInventoryTypeFromStaticItemID(const class FName& StaticItemId) const;
	float GetNowItemWeight() const;
	int32 GetUnlockedFoodEquipSlotNum() const;
	bool IsEquip(EPalPlayerEquipItemSlotType EquipmentSlotType, const class FName& StaticItemId) const;
	bool IsExistItem(const class FName& StaticItemId) const;
	bool TryGetContainerFromInventoryType(const EPalPlayerInventoryType InventoryType, class UPalItemContainer** OutContainer) const;
	bool TryGetContainerFromStaticItemID(const class FName& StaticItemId, class UPalItemContainer** OutContainer) const;
	bool TryGetContainerIDFromInventoryType(const EPalPlayerInventoryType InventoryType, struct FPalContainerId* OutContainerId) const;
	bool TryGetContainerIdFromItemType(EPalItemTypeA ItemTypeA, struct FPalContainerId* OutContainerId) const;
	bool TryGetEquipmentContainerIDFromStaticItemID(const class FName& StaticItemId, struct FPalContainerId* OutContainerId) const;
	EPalPlayerEquipItemSlotType TryGetEquipmentTypeFromStaticItemID(const class FName& StaticItemId) const;
	bool TryGetItemSlotFromEquipmentType(EPalPlayerEquipItemSlotType EquipmentSlotType, class UPalItemSlot** OutSlot) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalPlayerInventoryData">();
	}
	static class UPalPlayerInventoryData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalPlayerInventoryData>();
	}
};
static_assert(alignof(UPalPlayerInventoryData) == 0x000008, "Wrong alignment on UPalPlayerInventoryData");
static_assert(sizeof(UPalPlayerInventoryData) == 0x0001A0, "Wrong size on UPalPlayerInventoryData");
static_assert(offsetof(UPalPlayerInventoryData, OnUpdateInventoryContainerDelegate) == 0x000030, "Member 'UPalPlayerInventoryData::OnUpdateInventoryContainerDelegate' has a wrong offset!");
static_assert(offsetof(UPalPlayerInventoryData, OnUpdateEssentialContainerDelegate) == 0x000040, "Member 'UPalPlayerInventoryData::OnUpdateEssentialContainerDelegate' has a wrong offset!");
static_assert(offsetof(UPalPlayerInventoryData, OnUpdateLoadoutSlotDelegate) == 0x000050, "Member 'UPalPlayerInventoryData::OnUpdateLoadoutSlotDelegate' has a wrong offset!");
static_assert(offsetof(UPalPlayerInventoryData, OnUpdateEquipmentSlotDelegate) == 0x000060, "Member 'UPalPlayerInventoryData::OnUpdateEquipmentSlotDelegate' has a wrong offset!");
static_assert(offsetof(UPalPlayerInventoryData, OnUpdateWeightInventoryDelegate) == 0x000070, "Member 'UPalPlayerInventoryData::OnUpdateWeightInventoryDelegate' has a wrong offset!");
static_assert(offsetof(UPalPlayerInventoryData, OnUpdateMaxWeightInventoryDelegate) == 0x000080, "Member 'UPalPlayerInventoryData::OnUpdateMaxWeightInventoryDelegate' has a wrong offset!");
static_assert(offsetof(UPalPlayerInventoryData, OnOverWeightInventoryDelegate) == 0x000090, "Member 'UPalPlayerInventoryData::OnOverWeightInventoryDelegate' has a wrong offset!");
static_assert(offsetof(UPalPlayerInventoryData, OnFixedInventoryWeightDelegate) == 0x0000A0, "Member 'UPalPlayerInventoryData::OnFixedInventoryWeightDelegate' has a wrong offset!");
static_assert(offsetof(UPalPlayerInventoryData, OnMaxWeightBuffedDelegate) == 0x0000B0, "Member 'UPalPlayerInventoryData::OnMaxWeightBuffedDelegate' has a wrong offset!");
static_assert(offsetof(UPalPlayerInventoryData, OnCurrentWeightBuffedDelegate) == 0x0000C0, "Member 'UPalPlayerInventoryData::OnCurrentWeightBuffedDelegate' has a wrong offset!");
static_assert(offsetof(UPalPlayerInventoryData, OnPickupItemDelegate) == 0x0000D0, "Member 'UPalPlayerInventoryData::OnPickupItemDelegate' has a wrong offset!");
static_assert(offsetof(UPalPlayerInventoryData, OnGetItemFromConvertItemMapObject) == 0x0000E0, "Member 'UPalPlayerInventoryData::OnGetItemFromConvertItemMapObject' has a wrong offset!");
static_assert(offsetof(UPalPlayerInventoryData, InventoryInfo) == 0x0000F0, "Member 'UPalPlayerInventoryData::InventoryInfo' has a wrong offset!");
static_assert(offsetof(UPalPlayerInventoryData, FullInventoryLogGuardTimerHandle) == 0x000158, "Member 'UPalPlayerInventoryData::FullInventoryLogGuardTimerHandle' has a wrong offset!");
static_assert(offsetof(UPalPlayerInventoryData, NowItemWeight) == 0x000160, "Member 'UPalPlayerInventoryData::NowItemWeight' has a wrong offset!");
static_assert(offsetof(UPalPlayerInventoryData, MaxInventoryWeight) == 0x000164, "Member 'UPalPlayerInventoryData::MaxInventoryWeight' has a wrong offset!");
static_assert(offsetof(UPalPlayerInventoryData, MaxInventoryWeight_Cached) == 0x000168, "Member 'UPalPlayerInventoryData::MaxInventoryWeight_Cached' has a wrong offset!");
static_assert(offsetof(UPalPlayerInventoryData, InventoryMultiHelper) == 0x000170, "Member 'UPalPlayerInventoryData::InventoryMultiHelper' has a wrong offset!");
static_assert(offsetof(UPalPlayerInventoryData, PassiveBuffedMaxWeight) == 0x000178, "Member 'UPalPlayerInventoryData::PassiveBuffedMaxWeight' has a wrong offset!");
static_assert(offsetof(UPalPlayerInventoryData, PassiveBuffedCurrentWeight) == 0x00017C, "Member 'UPalPlayerInventoryData::PassiveBuffedCurrentWeight' has a wrong offset!");
static_assert(offsetof(UPalPlayerInventoryData, OwnerPlayerUId) == 0x000180, "Member 'UPalPlayerInventoryData::OwnerPlayerUId' has a wrong offset!");
static_assert(offsetof(UPalPlayerInventoryData, MoneyData) == 0x000190, "Member 'UPalPlayerInventoryData::MoneyData' has a wrong offset!");
static_assert(offsetof(UPalPlayerInventoryData, EquipmentBreakAudioEvent) == 0x000198, "Member 'UPalPlayerInventoryData::EquipmentBreakAudioEvent' has a wrong offset!");

// Class Pal.PalPlayerManager
// 0x0130 (0x01A0 - 0x0070)
class UPalPlayerManager : public UPalWorldSubsystem
{
public:
	uint8                                         Pad_2E3C[0x18];                                    // 0x0070(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPalPlayerClassStructSet               PlayerClassStructSet;                              // 0x0088(0x0028)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGuid, class UPalPlayerAccount*>  PlayerAccountMap;                                  // 0x00B0(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGuid, class UPalLoginPlayer*>    LoginPlayerMap;                                    // 0x0100(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TMap<struct FPalInstanceID, class UPalIndividualCharacterHandle*> HoldingNotYetLoginPlayerHandleMap;                 // 0x0150(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	void OnCreatedIndividualHandleByAppliedSaveData_ServerInternal(const struct FPalInstanceID& IndividualId);
	void PlayerAccountDelegate__DelegateSignature(class UPalPlayerAccount* PlayerAccount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalPlayerManager">();
	}
	static class UPalPlayerManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalPlayerManager>();
	}
};
static_assert(alignof(UPalPlayerManager) == 0x000008, "Wrong alignment on UPalPlayerManager");
static_assert(sizeof(UPalPlayerManager) == 0x0001A0, "Wrong size on UPalPlayerManager");
static_assert(offsetof(UPalPlayerManager, PlayerClassStructSet) == 0x000088, "Member 'UPalPlayerManager::PlayerClassStructSet' has a wrong offset!");
static_assert(offsetof(UPalPlayerManager, PlayerAccountMap) == 0x0000B0, "Member 'UPalPlayerManager::PlayerAccountMap' has a wrong offset!");
static_assert(offsetof(UPalPlayerManager, LoginPlayerMap) == 0x000100, "Member 'UPalPlayerManager::LoginPlayerMap' has a wrong offset!");
static_assert(offsetof(UPalPlayerManager, HoldingNotYetLoginPlayerHandleMap) == 0x000150, "Member 'UPalPlayerManager::HoldingNotYetLoginPlayerHandleMap' has a wrong offset!");

// Class Pal.PalPlayerMenuUI
// 0x0018 (0x0290 - 0x0278)
class UPalPlayerMenuUI final : public UUserWidget
{
public:
	struct FPalItemSlotId                         SelectItemSlot;                                    // 0x0278(0x0014)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsDraging;                                         // 0x028C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E3D[0x3];                                     // 0x028D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddMousePitchInput(float Val);
	void AddMouseYawInput(float Val);
	void BackOneWidget();
	void CloseChestMenu(class UPalItemContainer* ChestContainer);
	void CloseInventoryMenu();
	void CreateDragWidget(const struct FPalItemSlotId& SlotID);
	bool GetIsDragingt();
	struct FPalItemSlotId GetSelectedItemSlot();
	void InitBindAxis();
	void OpenChestMenu(class UPalItemContainer* ChestContainer);
	void OpenInventoryMenu();
	void OpenWidget(TSubclassOf<class UUserWidget> WidgetClass, class UUserWidget** OutWidget, int32* ZOrder);
	void SetIsDraging(bool Draging);
	void SetSelectedItemSlot(const struct FPalItemSlotId& SelectSlot);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalPlayerMenuUI">();
	}
	static class UPalPlayerMenuUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalPlayerMenuUI>();
	}
};
static_assert(alignof(UPalPlayerMenuUI) == 0x000008, "Wrong alignment on UPalPlayerMenuUI");
static_assert(sizeof(UPalPlayerMenuUI) == 0x000290, "Wrong size on UPalPlayerMenuUI");
static_assert(offsetof(UPalPlayerMenuUI, SelectItemSlot) == 0x000278, "Member 'UPalPlayerMenuUI::SelectItemSlot' has a wrong offset!");
static_assert(offsetof(UPalPlayerMenuUI, IsDraging) == 0x00028C, "Member 'UPalPlayerMenuUI::IsDraging' has a wrong offset!");

// Class Pal.PalPlayerOtomoData
// 0x0018 (0x0040 - 0x0028)
class UPalPlayerOtomoData final : public UObject
{
public:
	struct FPalContainerId                        OtomoCharacterContainerId;                         // 0x0028(0x0010)(Edit, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPalOtomoPalOrderType                         OtomoOrder;                                        // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E3F[0x7];                                     // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalPlayerOtomoData">();
	}
	static class UPalPlayerOtomoData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalPlayerOtomoData>();
	}
};
static_assert(alignof(UPalPlayerOtomoData) == 0x000008, "Wrong alignment on UPalPlayerOtomoData");
static_assert(sizeof(UPalPlayerOtomoData) == 0x000040, "Wrong size on UPalPlayerOtomoData");
static_assert(offsetof(UPalPlayerOtomoData, OtomoCharacterContainerId) == 0x000028, "Member 'UPalPlayerOtomoData::OtomoCharacterContainerId' has a wrong offset!");
static_assert(offsetof(UPalPlayerOtomoData, OtomoOrder) == 0x000038, "Member 'UPalPlayerOtomoData::OtomoOrder' has a wrong offset!");

// Class Pal.PalPlayerPartyPalHolder
// 0x0030 (0x0058 - 0x0028)
class UPalPlayerPartyPalHolder final : public UObject
{
public:
	class UPalIndividualCharacterHandle*          FirstOtomoPal;                                     // 0x0028(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalIndividualCharacterHandle*          SecondOtomoPal;                                    // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UPalIndividualCharacterHandle*>  BenchMember;                                       // 0x0038(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	float                                         FirstCoolTimer;                                    // 0x0048(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SecondCoolTimer;                                   // 0x004C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CoolDownTime;                                      // 0x0050(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E40[0x4];                                     // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangePalSlot(bool SecondPal);
	float GetCoolTimeRate(bool SecondPal);
	class UPalIndividualCharacterHandle* GetOtomoPal(bool SecondPal);
	void GetPartyMember(TArray<class UPalIndividualCharacterHandle*>* OutPartyMember);
	bool IsUsableCommandSkill(bool SecondPal);
	bool PawnOtmoIsPartyOtomo(bool SecondPal, class UPalIndividualCharacterHandle* IDHandle);
	void RestartCoolTime(bool SecondPal);
	void SetUpPartyHolder(float CoolDownTime_Second);
	void Test_SetClassArray(const TArray<TSubclassOf<class APalCharacter>>& MonsterClassArray);
	void UpdateCoolTimer(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalPlayerPartyPalHolder">();
	}
	static class UPalPlayerPartyPalHolder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalPlayerPartyPalHolder>();
	}
};
static_assert(alignof(UPalPlayerPartyPalHolder) == 0x000008, "Wrong alignment on UPalPlayerPartyPalHolder");
static_assert(sizeof(UPalPlayerPartyPalHolder) == 0x000058, "Wrong size on UPalPlayerPartyPalHolder");
static_assert(offsetof(UPalPlayerPartyPalHolder, FirstOtomoPal) == 0x000028, "Member 'UPalPlayerPartyPalHolder::FirstOtomoPal' has a wrong offset!");
static_assert(offsetof(UPalPlayerPartyPalHolder, SecondOtomoPal) == 0x000030, "Member 'UPalPlayerPartyPalHolder::SecondOtomoPal' has a wrong offset!");
static_assert(offsetof(UPalPlayerPartyPalHolder, BenchMember) == 0x000038, "Member 'UPalPlayerPartyPalHolder::BenchMember' has a wrong offset!");
static_assert(offsetof(UPalPlayerPartyPalHolder, FirstCoolTimer) == 0x000048, "Member 'UPalPlayerPartyPalHolder::FirstCoolTimer' has a wrong offset!");
static_assert(offsetof(UPalPlayerPartyPalHolder, SecondCoolTimer) == 0x00004C, "Member 'UPalPlayerPartyPalHolder::SecondCoolTimer' has a wrong offset!");
static_assert(offsetof(UPalPlayerPartyPalHolder, CoolDownTime) == 0x000050, "Member 'UPalPlayerPartyPalHolder::CoolDownTime' has a wrong offset!");

// Class Pal.PalPlayerRecordData
// 0x0B00 (0x0B28 - 0x0028)
class UPalPlayerRecordData : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnRelicNumUpdate;                                  // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRelicNumAdd;                                     // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           RecordDataTriggerClassArray;                       // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class UPalPlayerRecordDataTrigger*>    RecordDataTriggerArray;                            // 0x0058(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FGuid                                  OwnerPlayerUId;                                    // 0x0068(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPalPlayerRecordDataRepInfoArray_BoolVal TowerBossDefeatFlag;                               // 0x0078(0x0178)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPublic)
	struct FPalPlayerRecordDataRepInfoArray_BoolVal NormalBossDefeatFlag;                              // 0x01F0(0x0178)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPublic)
	int32                                         BossDefeatCount;                                   // 0x0368(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TribeCaptureCount;                                 // 0x036C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPalPlayerRecordDataRepInfoArray_IntVal PalCaptureCount;                                   // 0x0370(0x0178)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPublic)
	struct FPalPlayerRecordDataRepInfoArray_BoolVal PaldeckUnlockFlag;                                 // 0x04E8(0x0178)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPublic)
	int32                                         PalCaptureCountBonusCount_Tier1;                   // 0x0660(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PalCaptureCountBonusCount_Tier2;                   // 0x0664(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PalCaptureCountBonusCount_Tier3;                   // 0x0668(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E45[0x4];                                     // 0x066C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPalPlayerRecordDataRepInfoArray_BoolVal RelicObtainForInstanceFlag;                        // 0x0670(0x0178)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPublic)
	int32                                         RelicPossessNum;                                   // 0x07E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RelicPossessNumMirror;                             // 0x07EC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPalPlayerRecordDataRepInfoArray_BoolVal NoteObtainForInstanceFlag;                         // 0x07F0(0x0178)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPublic)
	struct FPalPlayerRecordDataRepInfoArray_BoolVal FastTravelPointUnlockFlag;                         // 0x0968(0x0178)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPublic)
	struct FPalStageInstanceId                    EnteringStageInstanceId;                           // 0x0AE0(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E46[0x4];                                     // 0x0AF4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGuid>                          BuildingObjectMapObjectInstanceIds;                // 0x0AF8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPublic)
	class FString                                 Debug_EnteringStageDataLayerName;                  // 0x0B08(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Debug_LastEnteredStageDataLayerName;               // 0x0B18(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnCompleteBuild_ServerInternal(class UPalMapObjectModel* MapObjectModel);
	void OnRelicNumAddedDelegate__DelegateSignature(int32 AddNum);
	void OnRelicNumUpdateDelegate__DelegateSignature();
	void OnRep_RelicNum();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalPlayerRecordData">();
	}
	static class UPalPlayerRecordData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalPlayerRecordData>();
	}
};
static_assert(alignof(UPalPlayerRecordData) == 0x000008, "Wrong alignment on UPalPlayerRecordData");
static_assert(sizeof(UPalPlayerRecordData) == 0x000B28, "Wrong size on UPalPlayerRecordData");
static_assert(offsetof(UPalPlayerRecordData, OnRelicNumUpdate) == 0x000028, "Member 'UPalPlayerRecordData::OnRelicNumUpdate' has a wrong offset!");
static_assert(offsetof(UPalPlayerRecordData, OnRelicNumAdd) == 0x000038, "Member 'UPalPlayerRecordData::OnRelicNumAdd' has a wrong offset!");
static_assert(offsetof(UPalPlayerRecordData, RecordDataTriggerClassArray) == 0x000048, "Member 'UPalPlayerRecordData::RecordDataTriggerClassArray' has a wrong offset!");
static_assert(offsetof(UPalPlayerRecordData, RecordDataTriggerArray) == 0x000058, "Member 'UPalPlayerRecordData::RecordDataTriggerArray' has a wrong offset!");
static_assert(offsetof(UPalPlayerRecordData, OwnerPlayerUId) == 0x000068, "Member 'UPalPlayerRecordData::OwnerPlayerUId' has a wrong offset!");
static_assert(offsetof(UPalPlayerRecordData, TowerBossDefeatFlag) == 0x000078, "Member 'UPalPlayerRecordData::TowerBossDefeatFlag' has a wrong offset!");
static_assert(offsetof(UPalPlayerRecordData, NormalBossDefeatFlag) == 0x0001F0, "Member 'UPalPlayerRecordData::NormalBossDefeatFlag' has a wrong offset!");
static_assert(offsetof(UPalPlayerRecordData, BossDefeatCount) == 0x000368, "Member 'UPalPlayerRecordData::BossDefeatCount' has a wrong offset!");
static_assert(offsetof(UPalPlayerRecordData, TribeCaptureCount) == 0x00036C, "Member 'UPalPlayerRecordData::TribeCaptureCount' has a wrong offset!");
static_assert(offsetof(UPalPlayerRecordData, PalCaptureCount) == 0x000370, "Member 'UPalPlayerRecordData::PalCaptureCount' has a wrong offset!");
static_assert(offsetof(UPalPlayerRecordData, PaldeckUnlockFlag) == 0x0004E8, "Member 'UPalPlayerRecordData::PaldeckUnlockFlag' has a wrong offset!");
static_assert(offsetof(UPalPlayerRecordData, PalCaptureCountBonusCount_Tier1) == 0x000660, "Member 'UPalPlayerRecordData::PalCaptureCountBonusCount_Tier1' has a wrong offset!");
static_assert(offsetof(UPalPlayerRecordData, PalCaptureCountBonusCount_Tier2) == 0x000664, "Member 'UPalPlayerRecordData::PalCaptureCountBonusCount_Tier2' has a wrong offset!");
static_assert(offsetof(UPalPlayerRecordData, PalCaptureCountBonusCount_Tier3) == 0x000668, "Member 'UPalPlayerRecordData::PalCaptureCountBonusCount_Tier3' has a wrong offset!");
static_assert(offsetof(UPalPlayerRecordData, RelicObtainForInstanceFlag) == 0x000670, "Member 'UPalPlayerRecordData::RelicObtainForInstanceFlag' has a wrong offset!");
static_assert(offsetof(UPalPlayerRecordData, RelicPossessNum) == 0x0007E8, "Member 'UPalPlayerRecordData::RelicPossessNum' has a wrong offset!");
static_assert(offsetof(UPalPlayerRecordData, RelicPossessNumMirror) == 0x0007EC, "Member 'UPalPlayerRecordData::RelicPossessNumMirror' has a wrong offset!");
static_assert(offsetof(UPalPlayerRecordData, NoteObtainForInstanceFlag) == 0x0007F0, "Member 'UPalPlayerRecordData::NoteObtainForInstanceFlag' has a wrong offset!");
static_assert(offsetof(UPalPlayerRecordData, FastTravelPointUnlockFlag) == 0x000968, "Member 'UPalPlayerRecordData::FastTravelPointUnlockFlag' has a wrong offset!");
static_assert(offsetof(UPalPlayerRecordData, EnteringStageInstanceId) == 0x000AE0, "Member 'UPalPlayerRecordData::EnteringStageInstanceId' has a wrong offset!");
static_assert(offsetof(UPalPlayerRecordData, BuildingObjectMapObjectInstanceIds) == 0x000AF8, "Member 'UPalPlayerRecordData::BuildingObjectMapObjectInstanceIds' has a wrong offset!");
static_assert(offsetof(UPalPlayerRecordData, Debug_EnteringStageDataLayerName) == 0x000B08, "Member 'UPalPlayerRecordData::Debug_EnteringStageDataLayerName' has a wrong offset!");
static_assert(offsetof(UPalPlayerRecordData, Debug_LastEnteredStageDataLayerName) == 0x000B18, "Member 'UPalPlayerRecordData::Debug_LastEnteredStageDataLayerName' has a wrong offset!");

// Class Pal.PalPlayerLocalRecordData
// 0x02E0 (0x0308 - 0x0028)
class UPalPlayerLocalRecordData final : public UObject
{
public:
	TMap<EPalTribeID, int32>                      Local_ActivateOtomoCount;                          // 0x0028(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPublic)
	TMap<EPalTribeID, bool>                       Local_PalEncountFlag;                              // 0x0078(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPublic)
	TMap<EPalTribeID, bool>                       Local_PalDexNewFlag;                               // 0x00C8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPublic)
	TMap<class FName, bool>                       Local_NoteCheckedFlag;                             // 0x0118(0x0050)(Edit, BlueprintVisible, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPublic)
	TMap<EPalPlayerInventoryType, int32>          Local_LoadoutSelectedIndexMap;                     // 0x0168(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPublic)
	TMap<class FName, int32>                      Local_NewUnlockedBuilds;                           // 0x01B8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPublic)
	bool                                          Local_IsBuildMenuChecked;                          // 0x0208(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E47[0x7];                                     // 0x0209(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, int32>                      Local_NPCTalkCountMap;                             // 0x0210(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPublic)
	TMap<class FName, bool>                       Local_NewUnlockedTechs;                            // 0x0260(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPublic)
	TMap<class FName, bool>                       Local_ShowedCutsceneFlag;                          // 0x02B0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPublic)
	int32                                         Local_PlayTime;                                    // 0x0300(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E48[0x4];                                     // 0x0304(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalPlayerLocalRecordData">();
	}
	static class UPalPlayerLocalRecordData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalPlayerLocalRecordData>();
	}
};
static_assert(alignof(UPalPlayerLocalRecordData) == 0x000008, "Wrong alignment on UPalPlayerLocalRecordData");
static_assert(sizeof(UPalPlayerLocalRecordData) == 0x000308, "Wrong size on UPalPlayerLocalRecordData");
static_assert(offsetof(UPalPlayerLocalRecordData, Local_ActivateOtomoCount) == 0x000028, "Member 'UPalPlayerLocalRecordData::Local_ActivateOtomoCount' has a wrong offset!");
static_assert(offsetof(UPalPlayerLocalRecordData, Local_PalEncountFlag) == 0x000078, "Member 'UPalPlayerLocalRecordData::Local_PalEncountFlag' has a wrong offset!");
static_assert(offsetof(UPalPlayerLocalRecordData, Local_PalDexNewFlag) == 0x0000C8, "Member 'UPalPlayerLocalRecordData::Local_PalDexNewFlag' has a wrong offset!");
static_assert(offsetof(UPalPlayerLocalRecordData, Local_NoteCheckedFlag) == 0x000118, "Member 'UPalPlayerLocalRecordData::Local_NoteCheckedFlag' has a wrong offset!");
static_assert(offsetof(UPalPlayerLocalRecordData, Local_LoadoutSelectedIndexMap) == 0x000168, "Member 'UPalPlayerLocalRecordData::Local_LoadoutSelectedIndexMap' has a wrong offset!");
static_assert(offsetof(UPalPlayerLocalRecordData, Local_NewUnlockedBuilds) == 0x0001B8, "Member 'UPalPlayerLocalRecordData::Local_NewUnlockedBuilds' has a wrong offset!");
static_assert(offsetof(UPalPlayerLocalRecordData, Local_IsBuildMenuChecked) == 0x000208, "Member 'UPalPlayerLocalRecordData::Local_IsBuildMenuChecked' has a wrong offset!");
static_assert(offsetof(UPalPlayerLocalRecordData, Local_NPCTalkCountMap) == 0x000210, "Member 'UPalPlayerLocalRecordData::Local_NPCTalkCountMap' has a wrong offset!");
static_assert(offsetof(UPalPlayerLocalRecordData, Local_NewUnlockedTechs) == 0x000260, "Member 'UPalPlayerLocalRecordData::Local_NewUnlockedTechs' has a wrong offset!");
static_assert(offsetof(UPalPlayerLocalRecordData, Local_ShowedCutsceneFlag) == 0x0002B0, "Member 'UPalPlayerLocalRecordData::Local_ShowedCutsceneFlag' has a wrong offset!");
static_assert(offsetof(UPalPlayerLocalRecordData, Local_PlayTime) == 0x000300, "Member 'UPalPlayerLocalRecordData::Local_PlayTime' has a wrong offset!");

// Class Pal.PalPlayerRecordDataInternals
// 0x0000 (0x0028 - 0x0028)
class UPalPlayerRecordDataInternals final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalPlayerRecordDataInternals">();
	}
	static class UPalPlayerRecordDataInternals* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalPlayerRecordDataInternals>();
	}
};
static_assert(alignof(UPalPlayerRecordDataInternals) == 0x000008, "Wrong alignment on UPalPlayerRecordDataInternals");
static_assert(sizeof(UPalPlayerRecordDataInternals) == 0x000028, "Wrong size on UPalPlayerRecordDataInternals");

// Class Pal.PalPlayerRecordDataTrigger
// 0x0000 (0x0028 - 0x0028)
class UPalPlayerRecordDataTrigger : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalPlayerRecordDataTrigger">();
	}
	static class UPalPlayerRecordDataTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalPlayerRecordDataTrigger>();
	}
};
static_assert(alignof(UPalPlayerRecordDataTrigger) == 0x000008, "Wrong alignment on UPalPlayerRecordDataTrigger");
static_assert(sizeof(UPalPlayerRecordDataTrigger) == 0x000028, "Wrong size on UPalPlayerRecordDataTrigger");

// Class Pal.PalPlayerUIDCommandlet
// 0x0000 (0x0080 - 0x0080)
class UPalPlayerUIDCommandlet final : public UCommandlet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalPlayerUIDCommandlet">();
	}
	static class UPalPlayerUIDCommandlet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalPlayerUIDCommandlet>();
	}
};
static_assert(alignof(UPalPlayerUIDCommandlet) == 0x000008, "Wrong alignment on UPalPlayerUIDCommandlet");
static_assert(sizeof(UPalPlayerUIDCommandlet) == 0x000080, "Wrong size on UPalPlayerUIDCommandlet");

// Class Pal.PalPlayerUtility
// 0x0000 (0x0028 - 0x0028)
class UPalPlayerUtility final : public UBlueprintFunctionLibrary
{
public:
	static void ReadPlayerFeedItemTo(const struct FPalNetArchive& Blackboard, struct FPalItemSlotId* ItemSlotId, int32* ItemNum);
	static void ReadPlayerGrappling(const struct FPalNetArchive& Blackboard, struct FVector* HitLocatoin, struct FVector* MoveEndLocation, float* Speed);
	static void WritePlayerFeedItemTo(struct FPalNetArchive& Blackboard, const struct FPalItemSlotId& ItemSlotId, const int32& ItemNum);
	static void WritePlayerGrappling(struct FPalNetArchive& Blackboard, const struct FVector& HitLocatoin, const struct FVector& MoveEndLocation, const float& Speed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalPlayerUtility">();
	}
	static class UPalPlayerUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalPlayerUtility>();
	}
};
static_assert(alignof(UPalPlayerUtility) == 0x000008, "Wrong alignment on UPalPlayerUtility");
static_assert(sizeof(UPalPlayerUtility) == 0x000028, "Wrong size on UPalPlayerUtility");

// Class Pal.PalPoseableMeshComponent
// 0x01B0 (0x1130 - 0x0F80)
class UPalPoseableMeshComponent final : public USkeletalMeshComponent
{
public:
	uint8                                         Pad_2E4B[0x1B0];                                   // 0x0F80(0x01B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CopyPoseFromSkeletalComponent(class USkeletalMeshComponent* InComponentToCopy);
	struct FVector GetBoneLocationByName(class FName BoneName, EBoneSpaces BoneSpace);
	struct FRotator GetBoneRotationByName(class FName BoneName, EBoneSpaces BoneSpace);
	struct FVector GetBoneScaleByName(class FName BoneName, EBoneSpaces BoneSpace);
	struct FTransform GetBoneTransformByName(class FName BoneName, EBoneSpaces BoneSpace);
	void ResetBoneTransformByName(class FName BoneName);
	void SetBoneLocationByName(class FName BoneName, const struct FVector& InLocation, EBoneSpaces BoneSpace);
	void SetBoneRotationByName(class FName BoneName, const struct FRotator& InRotation, EBoneSpaces BoneSpace);
	void SetBoneScaleByName(class FName BoneName, const struct FVector& InScale3D, EBoneSpaces BoneSpace);
	void SetBoneTransformByName(class FName BoneName, const struct FTransform& InTransform, EBoneSpaces BoneSpace);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalPoseableMeshComponent">();
	}
	static class UPalPoseableMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalPoseableMeshComponent>();
	}
};
static_assert(alignof(UPalPoseableMeshComponent) == 0x000010, "Wrong alignment on UPalPoseableMeshComponent");
static_assert(sizeof(UPalPoseableMeshComponent) == 0x001130, "Wrong size on UPalPoseableMeshComponent");

// Class Pal.PalWorkForLevelObject
// 0x0000 (0x0320 - 0x0320)
class UPalWorkForLevelObject final : public UPalWorkBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorkForLevelObject">();
	}
	static class UPalWorkForLevelObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWorkForLevelObject>();
	}
};
static_assert(alignof(UPalWorkForLevelObject) == 0x000010, "Wrong alignment on UPalWorkForLevelObject");
static_assert(sizeof(UPalWorkForLevelObject) == 0x000320, "Wrong size on UPalWorkForLevelObject");

// Class Pal.PalProceduralFoliageComponent
// 0x0008 (0x00D0 - 0x00C8)
class UPalProceduralFoliageComponent final : public UProceduralFoliageComponent
{
public:
	class UShapeComponent*                        SpawningShape;                                     // 0x00C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalProceduralFoliageComponent">();
	}
	static class UPalProceduralFoliageComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalProceduralFoliageComponent>();
	}
};
static_assert(alignof(UPalProceduralFoliageComponent) == 0x000008, "Wrong alignment on UPalProceduralFoliageComponent");
static_assert(sizeof(UPalProceduralFoliageComponent) == 0x0000D0, "Wrong size on UPalProceduralFoliageComponent");
static_assert(offsetof(UPalProceduralFoliageComponent, SpawningShape) == 0x0000C8, "Member 'UPalProceduralFoliageComponent::SpawningShape' has a wrong offset!");

// Class Pal.PalProjectileMovementComponent
// 0x0000 (0x0240 - 0x0240)
class UPalProjectileMovementComponent final : public UProjectileMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalProjectileMovementComponent">();
	}
	static class UPalProjectileMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalProjectileMovementComponent>();
	}
};
static_assert(alignof(UPalProjectileMovementComponent) == 0x000010, "Wrong alignment on UPalProjectileMovementComponent");
static_assert(sizeof(UPalProjectileMovementComponent) == 0x000240, "Wrong size on UPalProjectileMovementComponent");

// Class Pal.PalQuestBlock_CheckBossDefeat
// 0x0020 (0x0070 - 0x0050)
class UPalQuestBlock_CheckBossDefeat final : public UPalQuestBlock
{
public:
	EPalBossType                                  CheckBossType;                                     // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E55[0x7];                                     // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           CheckTimerHandle;                                  // 0x0058(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E56[0x10];                                    // 0x0060(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckFlag();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalQuestBlock_CheckBossDefeat">();
	}
	static class UPalQuestBlock_CheckBossDefeat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalQuestBlock_CheckBossDefeat>();
	}
};
static_assert(alignof(UPalQuestBlock_CheckBossDefeat) == 0x000008, "Wrong alignment on UPalQuestBlock_CheckBossDefeat");
static_assert(sizeof(UPalQuestBlock_CheckBossDefeat) == 0x000070, "Wrong size on UPalQuestBlock_CheckBossDefeat");
static_assert(offsetof(UPalQuestBlock_CheckBossDefeat, CheckBossType) == 0x000050, "Member 'UPalQuestBlock_CheckBossDefeat::CheckBossType' has a wrong offset!");
static_assert(offsetof(UPalQuestBlock_CheckBossDefeat, CheckTimerHandle) == 0x000058, "Member 'UPalQuestBlock_CheckBossDefeat::CheckTimerHandle' has a wrong offset!");

// Class Pal.PalWorkProgressManager
// 0x0318 (0x0388 - 0x0070)
class UPalWorkProgressManager : public UPalWorldSubsystem
{
public:
	uint8                                         Pad_2E57[0x40];                                    // 0x0070(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGuid, class UPalWorkBase*>       WorkMap_InServer;                                  // 0x00B0(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E58[0x60];                                    // 0x0100(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FPalWorkAssignDefineData> WorkAssignDefineMap;                               // 0x0160(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	struct FPalWorkAssignDefineData               NotWorkableAssignDefine;                           // 0x01B0(0x0038)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FPalWorkAssignDefineData               BuildAssignDefine;                                 // 0x01E8(0x0038)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<EObjectTypeQuery>                      SearchWorkObjectObjectTypes;                       // 0x0220(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<EPalWorkType, EPalActionType>            WorkCompleteActionMap;                             // 0x0230(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FGuid>               LevelObjectWorkIdMap;                              // 0x0280(0x0050)(Edit, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class UPalWorkBase*>                   MoveCheckWorkList_InServer_Async;                  // 0x02D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UPalWorkBase*>                   MovedWorkList_InServer_Async;                      // 0x02E0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	int32                                         MoveCheckProcessIndex;                             // 0x02F0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MoveCheckMaxNumPerFrame;                           // 0x02F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         WorkTickInvokeMaxNumInOneTick;                     // 0x02F8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E59[0x4];                                     // 0x02FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EPalWorkType, int32>                     WorkTypeAssignPriorityMap;                         // 0x0300(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E5A[0x38];                                    // 0x0350(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void WorkDelegate__DelegateSignature(class UPalWorkBase* Work);

	class UPalWorkBase* GetWork(const struct FGuid& WorkId) const;
	class UPalWorkAssign* GetWorkAssign(const struct FPalWorkAssignHandleId& WorkAssignId) const;
	class UPalWorkBase* GetWorkByAssignId(const struct FPalWorkAssignHandleId& WorkAssignId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorkProgressManager">();
	}
	static class UPalWorkProgressManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWorkProgressManager>();
	}
};
static_assert(alignof(UPalWorkProgressManager) == 0x000008, "Wrong alignment on UPalWorkProgressManager");
static_assert(sizeof(UPalWorkProgressManager) == 0x000388, "Wrong size on UPalWorkProgressManager");
static_assert(offsetof(UPalWorkProgressManager, WorkMap_InServer) == 0x0000B0, "Member 'UPalWorkProgressManager::WorkMap_InServer' has a wrong offset!");
static_assert(offsetof(UPalWorkProgressManager, WorkAssignDefineMap) == 0x000160, "Member 'UPalWorkProgressManager::WorkAssignDefineMap' has a wrong offset!");
static_assert(offsetof(UPalWorkProgressManager, NotWorkableAssignDefine) == 0x0001B0, "Member 'UPalWorkProgressManager::NotWorkableAssignDefine' has a wrong offset!");
static_assert(offsetof(UPalWorkProgressManager, BuildAssignDefine) == 0x0001E8, "Member 'UPalWorkProgressManager::BuildAssignDefine' has a wrong offset!");
static_assert(offsetof(UPalWorkProgressManager, SearchWorkObjectObjectTypes) == 0x000220, "Member 'UPalWorkProgressManager::SearchWorkObjectObjectTypes' has a wrong offset!");
static_assert(offsetof(UPalWorkProgressManager, WorkCompleteActionMap) == 0x000230, "Member 'UPalWorkProgressManager::WorkCompleteActionMap' has a wrong offset!");
static_assert(offsetof(UPalWorkProgressManager, LevelObjectWorkIdMap) == 0x000280, "Member 'UPalWorkProgressManager::LevelObjectWorkIdMap' has a wrong offset!");
static_assert(offsetof(UPalWorkProgressManager, MoveCheckWorkList_InServer_Async) == 0x0002D0, "Member 'UPalWorkProgressManager::MoveCheckWorkList_InServer_Async' has a wrong offset!");
static_assert(offsetof(UPalWorkProgressManager, MovedWorkList_InServer_Async) == 0x0002E0, "Member 'UPalWorkProgressManager::MovedWorkList_InServer_Async' has a wrong offset!");
static_assert(offsetof(UPalWorkProgressManager, MoveCheckProcessIndex) == 0x0002F0, "Member 'UPalWorkProgressManager::MoveCheckProcessIndex' has a wrong offset!");
static_assert(offsetof(UPalWorkProgressManager, MoveCheckMaxNumPerFrame) == 0x0002F4, "Member 'UPalWorkProgressManager::MoveCheckMaxNumPerFrame' has a wrong offset!");
static_assert(offsetof(UPalWorkProgressManager, WorkTickInvokeMaxNumInOneTick) == 0x0002F8, "Member 'UPalWorkProgressManager::WorkTickInvokeMaxNumInOneTick' has a wrong offset!");
static_assert(offsetof(UPalWorkProgressManager, WorkTypeAssignPriorityMap) == 0x000300, "Member 'UPalWorkProgressManager::WorkTypeAssignPriorityMap' has a wrong offset!");

// Class Pal.PalQuestBlock_CheckPalCaptureNum
// 0x0018 (0x0068 - 0x0050)
class UPalQuestBlock_CheckPalCaptureNum final : public UPalQuestBlock
{
public:
	int32                                         RequireCount;                                      // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPalDataTableRowName_PalMonsterData    CountPalName;                                      // 0x0054(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NowCaptureCount;                                   // 0x005C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           CheckTimerHandle;                                  // 0x0060(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void CheckCount();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalQuestBlock_CheckPalCaptureNum">();
	}
	static class UPalQuestBlock_CheckPalCaptureNum* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalQuestBlock_CheckPalCaptureNum>();
	}
};
static_assert(alignof(UPalQuestBlock_CheckPalCaptureNum) == 0x000008, "Wrong alignment on UPalQuestBlock_CheckPalCaptureNum");
static_assert(sizeof(UPalQuestBlock_CheckPalCaptureNum) == 0x000068, "Wrong size on UPalQuestBlock_CheckPalCaptureNum");
static_assert(offsetof(UPalQuestBlock_CheckPalCaptureNum, RequireCount) == 0x000050, "Member 'UPalQuestBlock_CheckPalCaptureNum::RequireCount' has a wrong offset!");
static_assert(offsetof(UPalQuestBlock_CheckPalCaptureNum, CountPalName) == 0x000054, "Member 'UPalQuestBlock_CheckPalCaptureNum::CountPalName' has a wrong offset!");
static_assert(offsetof(UPalQuestBlock_CheckPalCaptureNum, NowCaptureCount) == 0x00005C, "Member 'UPalQuestBlock_CheckPalCaptureNum::NowCaptureCount' has a wrong offset!");
static_assert(offsetof(UPalQuestBlock_CheckPalCaptureNum, CheckTimerHandle) == 0x000060, "Member 'UPalQuestBlock_CheckPalCaptureNum::CheckTimerHandle' has a wrong offset!");

// Class Pal.PalQuestBlock_CheckTechnology
// 0x0008 (0x0058 - 0x0050)
class UPalQuestBlock_CheckTechnology final : public UPalQuestBlock
{
public:
	struct FPalDataTableRowName_RecipeTechnologyData RequireTechnologyName;                             // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnUnlockedAnyTechnology();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalQuestBlock_CheckTechnology">();
	}
	static class UPalQuestBlock_CheckTechnology* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalQuestBlock_CheckTechnology>();
	}
};
static_assert(alignof(UPalQuestBlock_CheckTechnology) == 0x000008, "Wrong alignment on UPalQuestBlock_CheckTechnology");
static_assert(sizeof(UPalQuestBlock_CheckTechnology) == 0x000058, "Wrong size on UPalQuestBlock_CheckTechnology");
static_assert(offsetof(UPalQuestBlock_CheckTechnology, RequireTechnologyName) == 0x000050, "Member 'UPalQuestBlock_CheckTechnology::RequireTechnologyName' has a wrong offset!");

// Class Pal.PalQuestBlock_CountBaseCamp
// 0x0010 (0x0060 - 0x0050)
class UPalQuestBlock_CountBaseCamp final : public UPalQuestBlock
{
public:
	int32                                         RequireCampCount;                                  // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NowBaseCampCount;                                  // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           CheckTimerHandle;                                  // 0x0058(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnTimer_CheckBaseCamp();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalQuestBlock_CountBaseCamp">();
	}
	static class UPalQuestBlock_CountBaseCamp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalQuestBlock_CountBaseCamp>();
	}
};
static_assert(alignof(UPalQuestBlock_CountBaseCamp) == 0x000008, "Wrong alignment on UPalQuestBlock_CountBaseCamp");
static_assert(sizeof(UPalQuestBlock_CountBaseCamp) == 0x000060, "Wrong size on UPalQuestBlock_CountBaseCamp");
static_assert(offsetof(UPalQuestBlock_CountBaseCamp, RequireCampCount) == 0x000050, "Member 'UPalQuestBlock_CountBaseCamp::RequireCampCount' has a wrong offset!");
static_assert(offsetof(UPalQuestBlock_CountBaseCamp, NowBaseCampCount) == 0x000054, "Member 'UPalQuestBlock_CountBaseCamp::NowBaseCampCount' has a wrong offset!");
static_assert(offsetof(UPalQuestBlock_CountBaseCamp, CheckTimerHandle) == 0x000058, "Member 'UPalQuestBlock_CountBaseCamp::CheckTimerHandle' has a wrong offset!");

// Class Pal.PalQuestBlock_CountBuild
// 0x0030 (0x0080 - 0x0050)
class UPalQuestBlock_CountBuild final : public UPalQuestBlock
{
public:
	struct FPalDataTableRowName_MapObjectData     RequireBuildObjectName;                            // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RequireBuildCount;                                 // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NowBuildCount;                                     // 0x005C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NowBlueprintCount;                                 // 0x0060(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E5B[0x4];                                     // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class UPalMapObjectModel>> CheckMapObjectModels;                              // 0x0068(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           CheckTimerHandle;                                  // 0x0078(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnAddedMapObjectModel_Server(class UPalMapObjectModel* MapObjectModel, const struct FVector& Vector);
	void OnRepMapObjectModel_Client(class UPalMapObjectModel* MapObjectModel);
	void OnTimer_CheckMapObject();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalQuestBlock_CountBuild">();
	}
	static class UPalQuestBlock_CountBuild* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalQuestBlock_CountBuild>();
	}
};
static_assert(alignof(UPalQuestBlock_CountBuild) == 0x000008, "Wrong alignment on UPalQuestBlock_CountBuild");
static_assert(sizeof(UPalQuestBlock_CountBuild) == 0x000080, "Wrong size on UPalQuestBlock_CountBuild");
static_assert(offsetof(UPalQuestBlock_CountBuild, RequireBuildObjectName) == 0x000050, "Member 'UPalQuestBlock_CountBuild::RequireBuildObjectName' has a wrong offset!");
static_assert(offsetof(UPalQuestBlock_CountBuild, RequireBuildCount) == 0x000058, "Member 'UPalQuestBlock_CountBuild::RequireBuildCount' has a wrong offset!");
static_assert(offsetof(UPalQuestBlock_CountBuild, NowBuildCount) == 0x00005C, "Member 'UPalQuestBlock_CountBuild::NowBuildCount' has a wrong offset!");
static_assert(offsetof(UPalQuestBlock_CountBuild, NowBlueprintCount) == 0x000060, "Member 'UPalQuestBlock_CountBuild::NowBlueprintCount' has a wrong offset!");
static_assert(offsetof(UPalQuestBlock_CountBuild, CheckMapObjectModels) == 0x000068, "Member 'UPalQuestBlock_CountBuild::CheckMapObjectModels' has a wrong offset!");
static_assert(offsetof(UPalQuestBlock_CountBuild, CheckTimerHandle) == 0x000078, "Member 'UPalQuestBlock_CountBuild::CheckTimerHandle' has a wrong offset!");

// Class Pal.PalQuestBlock_CountPickupItem
// 0x0010 (0x0060 - 0x0050)
class UPalQuestBlock_CountPickupItem final : public UPalQuestBlock
{
public:
	int32                                         RequireCount;                                      // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPalDataTableRowName_ItemData          DetectItemName;                                    // 0x0054(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NowPickupCount;                                    // 0x005C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnPickupItem(TArray<struct FPalItemAndNum>* ItemInfos);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalQuestBlock_CountPickupItem">();
	}
	static class UPalQuestBlock_CountPickupItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalQuestBlock_CountPickupItem>();
	}
};
static_assert(alignof(UPalQuestBlock_CountPickupItem) == 0x000008, "Wrong alignment on UPalQuestBlock_CountPickupItem");
static_assert(sizeof(UPalQuestBlock_CountPickupItem) == 0x000060, "Wrong size on UPalQuestBlock_CountPickupItem");
static_assert(offsetof(UPalQuestBlock_CountPickupItem, RequireCount) == 0x000050, "Member 'UPalQuestBlock_CountPickupItem::RequireCount' has a wrong offset!");
static_assert(offsetof(UPalQuestBlock_CountPickupItem, DetectItemName) == 0x000054, "Member 'UPalQuestBlock_CountPickupItem::DetectItemName' has a wrong offset!");
static_assert(offsetof(UPalQuestBlock_CountPickupItem, NowPickupCount) == 0x00005C, "Member 'UPalQuestBlock_CountPickupItem::NowPickupCount' has a wrong offset!");

// Class Pal.PalQuestBlock_DefeatWildBoss
// 0x0010 (0x0060 - 0x0050)
class UPalQuestBlock_DefeatWildBoss final : public UPalQuestBlock
{
public:
	class FName                                   BossSpawnerName;                                   // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           CheckTimerHandle;                                  // 0x0058(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void CheckFlag();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalQuestBlock_DefeatWildBoss">();
	}
	static class UPalQuestBlock_DefeatWildBoss* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalQuestBlock_DefeatWildBoss>();
	}
};
static_assert(alignof(UPalQuestBlock_DefeatWildBoss) == 0x000008, "Wrong alignment on UPalQuestBlock_DefeatWildBoss");
static_assert(sizeof(UPalQuestBlock_DefeatWildBoss) == 0x000060, "Wrong size on UPalQuestBlock_DefeatWildBoss");
static_assert(offsetof(UPalQuestBlock_DefeatWildBoss, BossSpawnerName) == 0x000050, "Member 'UPalQuestBlock_DefeatWildBoss::BossSpawnerName' has a wrong offset!");
static_assert(offsetof(UPalQuestBlock_DefeatWildBoss, CheckTimerHandle) == 0x000058, "Member 'UPalQuestBlock_DefeatWildBoss::CheckTimerHandle' has a wrong offset!");

// Class Pal.PalQuestBlock_DetectCapturePal
// 0x0010 (0x0060 - 0x0050)
class UPalQuestBlock_DetectCapturePal final : public UPalQuestBlock
{
public:
	int32                                         RequireCount;                                      // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPalDataTableRowName_PalMonsterData    DetectPalName;                                     // 0x0054(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NowCaptureCount;                                   // 0x005C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnCapturedPal(const struct FPalUIPalCaptureInfo& CaptureInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalQuestBlock_DetectCapturePal">();
	}
	static class UPalQuestBlock_DetectCapturePal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalQuestBlock_DetectCapturePal>();
	}
};
static_assert(alignof(UPalQuestBlock_DetectCapturePal) == 0x000008, "Wrong alignment on UPalQuestBlock_DetectCapturePal");
static_assert(sizeof(UPalQuestBlock_DetectCapturePal) == 0x000060, "Wrong size on UPalQuestBlock_DetectCapturePal");
static_assert(offsetof(UPalQuestBlock_DetectCapturePal, RequireCount) == 0x000050, "Member 'UPalQuestBlock_DetectCapturePal::RequireCount' has a wrong offset!");
static_assert(offsetof(UPalQuestBlock_DetectCapturePal, DetectPalName) == 0x000054, "Member 'UPalQuestBlock_DetectCapturePal::DetectPalName' has a wrong offset!");
static_assert(offsetof(UPalQuestBlock_DetectCapturePal, NowCaptureCount) == 0x00005C, "Member 'UPalQuestBlock_DetectCapturePal::NowCaptureCount' has a wrong offset!");

// Class Pal.PalQuestBlock_DetectCraft
// 0x0010 (0x0060 - 0x0050)
class UPalQuestBlock_DetectCraft final : public UPalQuestBlock
{
public:
	int32                                         RequireCount;                                      // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPalDataTableRowName_ItemData          DetectItemName;                                    // 0x0054(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NowCraftNumCount;                                  // 0x005C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnCraftItem(TArray<struct FPalItemAndNum>* ItemInfos);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalQuestBlock_DetectCraft">();
	}
	static class UPalQuestBlock_DetectCraft* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalQuestBlock_DetectCraft>();
	}
};
static_assert(alignof(UPalQuestBlock_DetectCraft) == 0x000008, "Wrong alignment on UPalQuestBlock_DetectCraft");
static_assert(sizeof(UPalQuestBlock_DetectCraft) == 0x000060, "Wrong size on UPalQuestBlock_DetectCraft");
static_assert(offsetof(UPalQuestBlock_DetectCraft, RequireCount) == 0x000050, "Member 'UPalQuestBlock_DetectCraft::RequireCount' has a wrong offset!");
static_assert(offsetof(UPalQuestBlock_DetectCraft, DetectItemName) == 0x000054, "Member 'UPalQuestBlock_DetectCraft::DetectItemName' has a wrong offset!");
static_assert(offsetof(UPalQuestBlock_DetectCraft, NowCraftNumCount) == 0x00005C, "Member 'UPalQuestBlock_DetectCraft::NowCraftNumCount' has a wrong offset!");

// Class Pal.PalQuestBlock_FastTravelCount
// 0x0010 (0x0060 - 0x0050)
class UPalQuestBlock_FastTravelCount final : public UPalQuestBlock
{
public:
	int32                                         RequireUnlockCount;                                // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E5C[0x4];                                     // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           CheckTimerHandle;                                  // 0x0058(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void CheckFlag();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalQuestBlock_FastTravelCount">();
	}
	static class UPalQuestBlock_FastTravelCount* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalQuestBlock_FastTravelCount>();
	}
};
static_assert(alignof(UPalQuestBlock_FastTravelCount) == 0x000008, "Wrong alignment on UPalQuestBlock_FastTravelCount");
static_assert(sizeof(UPalQuestBlock_FastTravelCount) == 0x000060, "Wrong size on UPalQuestBlock_FastTravelCount");
static_assert(offsetof(UPalQuestBlock_FastTravelCount, RequireUnlockCount) == 0x000050, "Member 'UPalQuestBlock_FastTravelCount::RequireUnlockCount' has a wrong offset!");
static_assert(offsetof(UPalQuestBlock_FastTravelCount, CheckTimerHandle) == 0x000058, "Member 'UPalQuestBlock_FastTravelCount::CheckTimerHandle' has a wrong offset!");

// Class Pal.PalQuestBlock_HasItem
// 0x0058 (0x00A8 - 0x0050)
class UPalQuestBlock_HasItem final : public UPalQuestBlock
{
public:
	TMap<struct FPalDataTableRowName_ItemData, int32> RequireItemMap;                                    // 0x0050(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTimerHandle                           CheckTimerHandle;                                  // 0x00A0(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void CheckItem();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalQuestBlock_HasItem">();
	}
	static class UPalQuestBlock_HasItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalQuestBlock_HasItem>();
	}
};
static_assert(alignof(UPalQuestBlock_HasItem) == 0x000008, "Wrong alignment on UPalQuestBlock_HasItem");
static_assert(sizeof(UPalQuestBlock_HasItem) == 0x0000A8, "Wrong size on UPalQuestBlock_HasItem");
static_assert(offsetof(UPalQuestBlock_HasItem, RequireItemMap) == 0x000050, "Member 'UPalQuestBlock_HasItem::RequireItemMap' has a wrong offset!");
static_assert(offsetof(UPalQuestBlock_HasItem, CheckTimerHandle) == 0x0000A0, "Member 'UPalQuestBlock_HasItem::CheckTimerHandle' has a wrong offset!");

// Class Pal.PalQuestBlock_OpenSurvivalGuide
// 0x0008 (0x0058 - 0x0050)
class UPalQuestBlock_OpenSurvivalGuide final : public UPalQuestBlock
{
public:
	struct FTimerHandle                           CheckTimerHandle;                                  // 0x0050(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnTimer_CheckOpen();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalQuestBlock_OpenSurvivalGuide">();
	}
	static class UPalQuestBlock_OpenSurvivalGuide* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalQuestBlock_OpenSurvivalGuide>();
	}
};
static_assert(alignof(UPalQuestBlock_OpenSurvivalGuide) == 0x000008, "Wrong alignment on UPalQuestBlock_OpenSurvivalGuide");
static_assert(sizeof(UPalQuestBlock_OpenSurvivalGuide) == 0x000058, "Wrong size on UPalQuestBlock_OpenSurvivalGuide");
static_assert(offsetof(UPalQuestBlock_OpenSurvivalGuide, CheckTimerHandle) == 0x000050, "Member 'UPalQuestBlock_OpenSurvivalGuide::CheckTimerHandle' has a wrong offset!");

// Class Pal.PalQuestData
// 0x00D0 (0x00F8 - 0x0028)
class UPalQuestData final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnUpdatedQuestDelegate;                            // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCompletedQuestDelegate;                          // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UPalQuestBlock*                         NowQuestBlock;                                     // 0x0048(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E5D[0x10];                                    // 0x0050(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           QuestBlockList;                                    // 0x0060(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	struct FPalCommonQuestRewardData              CommonRewardData;                                  // 0x0070(0x0058)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   CustomQuestRewardGiverClass;                       // 0x00C8(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool CompleteNowBlock();
	void CompleteQuestDelegate__DelegateSignature(class UPalQuestData* CompletedQuest);
	void GetCommonRewardData(struct FPalCommonQuestRewardData* OutData);
	void GetCustomRewardGiverClass(TSoftClassPtr<class UClass>* OutClass);
	void GetQuestBlock(class UPalQuestBlock** OutBlock);
	void GetQuestDataName(class FName* OutName);
	void Initialize(int32 BlockIndex, const class FName& InQuestName);
	void InitializeWithoutLoadQuestBlock(int32 BlockIndex, const class FName& InQuestName);
	void OnCompletedQuestBlock(class UPalQuestBlock* CompletedBlock);
	void OnUpdatedQuestBlock(class UPalQuestBlock* UpdatedBlock);
	void ProgressInternal();
	void UpdatedQuestDelegate__DelegateSignature(class UPalQuestData* UpdatedQuest);

	int32 GetNowQuestBlockIndex() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalQuestData">();
	}
	static class UPalQuestData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalQuestData>();
	}
};
static_assert(alignof(UPalQuestData) == 0x000008, "Wrong alignment on UPalQuestData");
static_assert(sizeof(UPalQuestData) == 0x0000F8, "Wrong size on UPalQuestData");
static_assert(offsetof(UPalQuestData, OnUpdatedQuestDelegate) == 0x000028, "Member 'UPalQuestData::OnUpdatedQuestDelegate' has a wrong offset!");
static_assert(offsetof(UPalQuestData, OnCompletedQuestDelegate) == 0x000038, "Member 'UPalQuestData::OnCompletedQuestDelegate' has a wrong offset!");
static_assert(offsetof(UPalQuestData, NowQuestBlock) == 0x000048, "Member 'UPalQuestData::NowQuestBlock' has a wrong offset!");
static_assert(offsetof(UPalQuestData, QuestBlockList) == 0x000060, "Member 'UPalQuestData::QuestBlockList' has a wrong offset!");
static_assert(offsetof(UPalQuestData, CommonRewardData) == 0x000070, "Member 'UPalQuestData::CommonRewardData' has a wrong offset!");
static_assert(offsetof(UPalQuestData, CustomQuestRewardGiverClass) == 0x0000C8, "Member 'UPalQuestData::CustomQuestRewardGiverClass' has a wrong offset!");

// Class Pal.PalQuestManager
// 0x0090 (0x00B8 - 0x0028)
class UPalQuestManager : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnUpdatedQuestDelegate;                            // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCompletedQuestDelegate;                          // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<class FName, class UPalQuestData*>       OrderedQuestMap;                                   // 0x0048(0x0050)(Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           CompletedQuestNames;                               // 0x0098(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UDataTable*                             QuestDataSet;                                      // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalCommonQuestRewardGiver*             CommonRewardGiver;                                 // 0x00B0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void CompletedAnyQuestDelegate__DelegateSignature(class UPalQuestData* CompletedQuest);
	bool IsAllQuestComplete();
	void OnCompletedQuest(class UPalQuestData* CompletedQuest);
	void OnUpdatedQuest(class UPalQuestData* UpdatedQuest);
	void UpdatedAnyQuestDelegate__DelegateSignature(class UPalQuestData* UpdatedQuest);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalQuestManager">();
	}
	static class UPalQuestManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalQuestManager>();
	}
};
static_assert(alignof(UPalQuestManager) == 0x000008, "Wrong alignment on UPalQuestManager");
static_assert(sizeof(UPalQuestManager) == 0x0000B8, "Wrong size on UPalQuestManager");
static_assert(offsetof(UPalQuestManager, OnUpdatedQuestDelegate) == 0x000028, "Member 'UPalQuestManager::OnUpdatedQuestDelegate' has a wrong offset!");
static_assert(offsetof(UPalQuestManager, OnCompletedQuestDelegate) == 0x000038, "Member 'UPalQuestManager::OnCompletedQuestDelegate' has a wrong offset!");
static_assert(offsetof(UPalQuestManager, OrderedQuestMap) == 0x000048, "Member 'UPalQuestManager::OrderedQuestMap' has a wrong offset!");
static_assert(offsetof(UPalQuestManager, CompletedQuestNames) == 0x000098, "Member 'UPalQuestManager::CompletedQuestNames' has a wrong offset!");
static_assert(offsetof(UPalQuestManager, QuestDataSet) == 0x0000A8, "Member 'UPalQuestManager::QuestDataSet' has a wrong offset!");
static_assert(offsetof(UPalQuestManager, CommonRewardGiver) == 0x0000B0, "Member 'UPalQuestManager::CommonRewardGiver' has a wrong offset!");

// Class Pal.PalRadarChartWidgetBase
// 0x0048 (0x0478 - 0x0430)
class UPalRadarChartWidgetBase final : public UPalCustomPrimitiveWidget
{
public:
	EPalRadarChartDrawType                        DrawType;                                          // 0x0430(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E5E[0x3];                                     // 0x0431(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ParameterNum;                                      // 0x0434(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsMinMaxValuePerParam;                             // 0x0438(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E5F[0x7];                                     // 0x0439(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 ParameterValueMin;                                 // 0x0440(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 ParameterValueMax;                                 // 0x0450(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FColor                                 FillColor;                                         // 0x0460(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 MaxValuefillColor;                                 // 0x0464(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 BorderColor;                                       // 0x0468(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         borderSize;                                        // 0x046C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsCheckParameterMaxValue;                          // 0x0470(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E60[0x7];                                     // 0x0471(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BuildVertexData();
	int32 GetMaxValue(int32 Param_Index);
	int32 GetMinValue(int32 Param_Index);
	void SetParameterValue(int32 Param_Index, int32 Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalRadarChartWidgetBase">();
	}
	static class UPalRadarChartWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalRadarChartWidgetBase>();
	}
};
static_assert(alignof(UPalRadarChartWidgetBase) == 0x000008, "Wrong alignment on UPalRadarChartWidgetBase");
static_assert(sizeof(UPalRadarChartWidgetBase) == 0x000478, "Wrong size on UPalRadarChartWidgetBase");
static_assert(offsetof(UPalRadarChartWidgetBase, DrawType) == 0x000430, "Member 'UPalRadarChartWidgetBase::DrawType' has a wrong offset!");
static_assert(offsetof(UPalRadarChartWidgetBase, ParameterNum) == 0x000434, "Member 'UPalRadarChartWidgetBase::ParameterNum' has a wrong offset!");
static_assert(offsetof(UPalRadarChartWidgetBase, IsMinMaxValuePerParam) == 0x000438, "Member 'UPalRadarChartWidgetBase::IsMinMaxValuePerParam' has a wrong offset!");
static_assert(offsetof(UPalRadarChartWidgetBase, ParameterValueMin) == 0x000440, "Member 'UPalRadarChartWidgetBase::ParameterValueMin' has a wrong offset!");
static_assert(offsetof(UPalRadarChartWidgetBase, ParameterValueMax) == 0x000450, "Member 'UPalRadarChartWidgetBase::ParameterValueMax' has a wrong offset!");
static_assert(offsetof(UPalRadarChartWidgetBase, FillColor) == 0x000460, "Member 'UPalRadarChartWidgetBase::FillColor' has a wrong offset!");
static_assert(offsetof(UPalRadarChartWidgetBase, MaxValuefillColor) == 0x000464, "Member 'UPalRadarChartWidgetBase::MaxValuefillColor' has a wrong offset!");
static_assert(offsetof(UPalRadarChartWidgetBase, BorderColor) == 0x000468, "Member 'UPalRadarChartWidgetBase::BorderColor' has a wrong offset!");
static_assert(offsetof(UPalRadarChartWidgetBase, borderSize) == 0x00046C, "Member 'UPalRadarChartWidgetBase::borderSize' has a wrong offset!");
static_assert(offsetof(UPalRadarChartWidgetBase, IsCheckParameterMaxValue) == 0x000470, "Member 'UPalRadarChartWidgetBase::IsCheckParameterMaxValue' has a wrong offset!");

// Class Pal.PalRagdollPreset
// 0x0018 (0x0040 - 0x0028)
class UPalRagdollPreset : public UObject
{
public:
	TArray<class FName>                           LockBoneNames;                                     // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         LinearDamping;                                     // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngularDamping;                                    // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalRagdollPreset">();
	}
	static class UPalRagdollPreset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalRagdollPreset>();
	}
};
static_assert(alignof(UPalRagdollPreset) == 0x000008, "Wrong alignment on UPalRagdollPreset");
static_assert(sizeof(UPalRagdollPreset) == 0x000040, "Wrong size on UPalRagdollPreset");
static_assert(offsetof(UPalRagdollPreset, LockBoneNames) == 0x000028, "Member 'UPalRagdollPreset::LockBoneNames' has a wrong offset!");
static_assert(offsetof(UPalRagdollPreset, LinearDamping) == 0x000038, "Member 'UPalRagdollPreset::LinearDamping' has a wrong offset!");
static_assert(offsetof(UPalRagdollPreset, AngularDamping) == 0x00003C, "Member 'UPalRagdollPreset::AngularDamping' has a wrong offset!");

// Class Pal.PalRaidBossComponent
// 0x00D0 (0x0170 - 0x00A0)
class UPalRaidBossComponent : public UActorComponent
{
public:
	TArray<class UPalIndividualCharacterHandle*>  RaidBossPalList;                                   // 0x00A0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UPalIndividualCharacterHandle*>  DeadRaidBossPalList;                               // 0x00B0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FGuid                                  BaseCanpID;                                        // 0x00C0(0x0010)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                BaseCampLocation;                                  // 0x00D0(0x0018)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RemainBattleTimer;                                 // 0x00E8(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPalRaidBossBattleStateType                   CurrentState;                                      // 0x00EC(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E61[0x3];                                     // 0x00ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPalRaidBossSpawnerInfo                SpawnerInfo;                                       // 0x00F0(0x0060)(Edit, DisableEditOnTemplate, Transient, EditConst, NoDestructor, NativeAccessSpecifierPrivate)
	class FName                                   StartItemName;                                     // 0x0150(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  StartRequestPlayerUID;                             // 0x0158(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E62[0x8];                                     // 0x0168(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddGroupCharacter(class UPalIndividualCharacterHandle* PalHandle);
	void CallOnEnd_ToAll(EPalRaidBossBattleFinishType FinishType);
	class APalPlayerCharacter* FindInRangePlayers(TArray<class APalPlayerCharacter*>* Players, bool OnlyAlive);
	struct FGuid GetCampID();
	float GetRemainTimer();
	class FName GetStartItemName();
	bool IsValidPlayerInCamp(class APalPlayerCharacter* Player);
	void OnCapturePal(class APalCharacter* SelfCharacter, class APalCharacter* Attacker);
	void OnDeadPal(const struct FPalDeadInfo& DeadInfo);
	void OnDisposeBaseCamp(class UPalBaseCampModel* Model);
	void OnSpawnBossPal(class AActor* Pal);
	void SpawnRaidBoss_BP(const struct FPalRaidBossSpawnInfoList& SpawnInfo, const struct FTransform& SpawnTransform, TArray<class UPalIndividualCharacterHandle*>* OutIndividualHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalRaidBossComponent">();
	}
	static class UPalRaidBossComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalRaidBossComponent>();
	}
};
static_assert(alignof(UPalRaidBossComponent) == 0x000010, "Wrong alignment on UPalRaidBossComponent");
static_assert(sizeof(UPalRaidBossComponent) == 0x000170, "Wrong size on UPalRaidBossComponent");
static_assert(offsetof(UPalRaidBossComponent, RaidBossPalList) == 0x0000A0, "Member 'UPalRaidBossComponent::RaidBossPalList' has a wrong offset!");
static_assert(offsetof(UPalRaidBossComponent, DeadRaidBossPalList) == 0x0000B0, "Member 'UPalRaidBossComponent::DeadRaidBossPalList' has a wrong offset!");
static_assert(offsetof(UPalRaidBossComponent, BaseCanpID) == 0x0000C0, "Member 'UPalRaidBossComponent::BaseCanpID' has a wrong offset!");
static_assert(offsetof(UPalRaidBossComponent, BaseCampLocation) == 0x0000D0, "Member 'UPalRaidBossComponent::BaseCampLocation' has a wrong offset!");
static_assert(offsetof(UPalRaidBossComponent, RemainBattleTimer) == 0x0000E8, "Member 'UPalRaidBossComponent::RemainBattleTimer' has a wrong offset!");
static_assert(offsetof(UPalRaidBossComponent, CurrentState) == 0x0000EC, "Member 'UPalRaidBossComponent::CurrentState' has a wrong offset!");
static_assert(offsetof(UPalRaidBossComponent, SpawnerInfo) == 0x0000F0, "Member 'UPalRaidBossComponent::SpawnerInfo' has a wrong offset!");
static_assert(offsetof(UPalRaidBossComponent, StartItemName) == 0x000150, "Member 'UPalRaidBossComponent::StartItemName' has a wrong offset!");
static_assert(offsetof(UPalRaidBossComponent, StartRequestPlayerUID) == 0x000158, "Member 'UPalRaidBossComponent::StartRequestPlayerUID' has a wrong offset!");

// Class Pal.PalRandomIncidentActionBase
// 0x0020 (0x0048 - 0x0028)
class UPalRandomIncidentActionBase : public UObject
{
public:
	uint8                                         Pad_2E65[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnRandomIncidentActionNotify;                      // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsTickable;                                       // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E66[0x7];                                     // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Initialize();
	void OnAllNpcSpawned();
	void OnInitialized();
	void OnRandomIncidentActionNotify__DelegateSignature(EPalRandomIncidentActionNotifyType NotifyType);
	void OnStart();
	void OnTerminate();
	void OnTick(float DeltaTime);
	void SendNotify(EPalRandomIncidentActionNotifyType NotifyType);
	void SetTickable(bool IsTickable);
	void Start();
	void Terminate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalRandomIncidentActionBase">();
	}
	static class UPalRandomIncidentActionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalRandomIncidentActionBase>();
	}
};
static_assert(alignof(UPalRandomIncidentActionBase) == 0x000008, "Wrong alignment on UPalRandomIncidentActionBase");
static_assert(sizeof(UPalRandomIncidentActionBase) == 0x000048, "Wrong size on UPalRandomIncidentActionBase");
static_assert(offsetof(UPalRandomIncidentActionBase, OnRandomIncidentActionNotify) == 0x000030, "Member 'UPalRandomIncidentActionBase::OnRandomIncidentActionNotify' has a wrong offset!");
static_assert(offsetof(UPalRandomIncidentActionBase, bIsTickable) == 0x000040, "Member 'UPalRandomIncidentActionBase::bIsTickable' has a wrong offset!");

// Class Pal.PalRandomIncidentBase
// 0x0030 (0x0190 - 0x0160)
class UPalRandomIncidentBase : public UPalIncidentBase
{
public:
	FMulticastInlineDelegateProperty_             OnEnterAnyArea;                                    // 0x0160(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnExitAnyArea;                                     // 0x0170(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsFinishWithIncidentSpawner;                      // 0x0180(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPalRandomIncidentSpawnerAreaType             PrevEnterArea;                                     // 0x0181(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E67[0xE];                                     // 0x0182(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastOnEnterAreaAndOnExitArea(int32 PlayerId);
	void CreateSpawnMonsterDataListFromOutbreakRow(const class UDataTable* Table, TArray<struct FPalRandomIncidentSpawnMonsterData>& OutMonsterList, TArray<class FName>& Names);
	class APalRandomIncidentNPCSpawner* GetNPCSpawner();
	bool IsOutbreakTable(const class UDataTable* Table);
	void OnEnterAnyArea__DelegateSignature(EPalRandomIncidentSpawnerAreaType AreaType, int32 PlayerId);
	void OnExitAnyArea__DelegateSignature(EPalRandomIncidentSpawnerAreaType AreaType, int32 PlayerId);
	void SetDisableFlagForNPCSpawner(const struct FVector& Center, float Radius, const class FName& Param_Name, bool IsDisable);

	int32 GetPlayerId() const;
	bool IsFinishWithIncidentSpawner() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalRandomIncidentBase">();
	}
	static class UPalRandomIncidentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalRandomIncidentBase>();
	}
};
static_assert(alignof(UPalRandomIncidentBase) == 0x000010, "Wrong alignment on UPalRandomIncidentBase");
static_assert(sizeof(UPalRandomIncidentBase) == 0x000190, "Wrong size on UPalRandomIncidentBase");
static_assert(offsetof(UPalRandomIncidentBase, OnEnterAnyArea) == 0x000160, "Member 'UPalRandomIncidentBase::OnEnterAnyArea' has a wrong offset!");
static_assert(offsetof(UPalRandomIncidentBase, OnExitAnyArea) == 0x000170, "Member 'UPalRandomIncidentBase::OnExitAnyArea' has a wrong offset!");
static_assert(offsetof(UPalRandomIncidentBase, bIsFinishWithIncidentSpawner) == 0x000180, "Member 'UPalRandomIncidentBase::bIsFinishWithIncidentSpawner' has a wrong offset!");
static_assert(offsetof(UPalRandomIncidentBase, PrevEnterArea) == 0x000181, "Member 'UPalRandomIncidentBase::PrevEnterArea' has a wrong offset!");

// Class Pal.PalRandomIncidentLotteryBase
// 0x0018 (0x0040 - 0x0028)
class UPalRandomIncidentLotteryBase : public UObject
{
public:
	float                                         LotteryRate;                                       // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E6C[0x4];                                     // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPalRandomIncidentSpawnIncidentParameter> LotteryParameters;                                 // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	bool LotteryIncident(struct FPalRandomIncidentSpawnIncidentParameter* OutResult);

	int32 GetLotteryParameters(TArray<struct FPalRandomIncidentSpawnIncidentParameter>* OutParam) const;
	float GetLotteryRate() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalRandomIncidentLotteryBase">();
	}
	static class UPalRandomIncidentLotteryBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalRandomIncidentLotteryBase>();
	}
};
static_assert(alignof(UPalRandomIncidentLotteryBase) == 0x000008, "Wrong alignment on UPalRandomIncidentLotteryBase");
static_assert(sizeof(UPalRandomIncidentLotteryBase) == 0x000040, "Wrong size on UPalRandomIncidentLotteryBase");
static_assert(offsetof(UPalRandomIncidentLotteryBase, LotteryRate) == 0x000028, "Member 'UPalRandomIncidentLotteryBase::LotteryRate' has a wrong offset!");
static_assert(offsetof(UPalRandomIncidentLotteryBase, LotteryParameters) == 0x000030, "Member 'UPalRandomIncidentLotteryBase::LotteryParameters' has a wrong offset!");

// Class Pal.PalRandomIncidentSpawnerBase
// 0x0130 (0x03C0 - 0x0290)
class APalRandomIncidentSpawnerBase : public AActor
{
public:
	TMap<class FName, struct FPalRandomIncidentWalkPathReferenceData> WalkPointRefarences;                               // 0x0290(0x0050)(Edit, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UPalRandomIncidentLotteryBase> LotteryClass;                                      // 0x02E0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CoolDownTimeMinute;                                // 0x02E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E6F[0x4];                                     // 0x02EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        CoolDownTimeSecRemain;                             // 0x02F0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<EPalRandomIncidentSpawnerAreaType, float> AreaRadius;                                        // 0x02F8(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	int32                                         PlayerId;                                          // 0x0348(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E70[0x4];                                     // 0x034C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalIncidentBase*                       ExecIncident;                                      // 0x0350(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPalRandomIncidentSpawnerStatus               Status;                                            // 0x0358(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E71[0x7];                                     // 0x0359(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalIncidentDynamicParameterRandom*     Parameter;                                         // 0x0360(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalRandomIncidentLotteryBase*          Lottery;                                           // 0x0368(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E72[0x50];                                    // 0x0370(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddWalkPath(const class FName& PathName, const TArray<class AActor*>& PointList);
	void CollectChildActors(TArray<class AActor*>* OutList);
	void CollectWalkPoints(const TArray<class AActor*>& WalkPoints);
	void CreateWalkPathList();
	void DestroyUnuseActors(TArray<class AActor*>* OutList);
	void EndIncident();
	class APalCharacter* FindPlayerInsideArea(EPalRandomIncidentSpawnerAreaType AreaType);
	void OnIncidentSpawned(class UPalIncidentBase* Incident, class UPalIncidentDynamicParameterRandom* DynamicParameter);
	void SetAreaRadius(EPalRandomIncidentSpawnerAreaType AreaType, float Radius);
	void SetStatus(EPalRandomIncidentSpawnerStatus NewStatus);
	void StartCoolDown();
	void UpdateStatusCoolDown(float DeltaTime);
	void UpdateStatusExecuting(float DeltaTime);
	void UpdateStatusIdle(float DeltaTime);
	void UpdateStatusWaitPlayerOutside(float DeltaTime);

	float GetAreaRadius(EPalRandomIncidentSpawnerAreaType AreaType) const;
	const TMap<EPalRandomIncidentSpawnerAreaType, float> GetAreaRadiusAll() const;
	bool IsInsideArea(EPalRandomIncidentSpawnerAreaType Area, const class ACharacter* PPlayer) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalRandomIncidentSpawnerBase">();
	}
	static class APalRandomIncidentSpawnerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalRandomIncidentSpawnerBase>();
	}
};
static_assert(alignof(APalRandomIncidentSpawnerBase) == 0x000008, "Wrong alignment on APalRandomIncidentSpawnerBase");
static_assert(sizeof(APalRandomIncidentSpawnerBase) == 0x0003C0, "Wrong size on APalRandomIncidentSpawnerBase");
static_assert(offsetof(APalRandomIncidentSpawnerBase, WalkPointRefarences) == 0x000290, "Member 'APalRandomIncidentSpawnerBase::WalkPointRefarences' has a wrong offset!");
static_assert(offsetof(APalRandomIncidentSpawnerBase, LotteryClass) == 0x0002E0, "Member 'APalRandomIncidentSpawnerBase::LotteryClass' has a wrong offset!");
static_assert(offsetof(APalRandomIncidentSpawnerBase, CoolDownTimeMinute) == 0x0002E8, "Member 'APalRandomIncidentSpawnerBase::CoolDownTimeMinute' has a wrong offset!");
static_assert(offsetof(APalRandomIncidentSpawnerBase, CoolDownTimeSecRemain) == 0x0002F0, "Member 'APalRandomIncidentSpawnerBase::CoolDownTimeSecRemain' has a wrong offset!");
static_assert(offsetof(APalRandomIncidentSpawnerBase, AreaRadius) == 0x0002F8, "Member 'APalRandomIncidentSpawnerBase::AreaRadius' has a wrong offset!");
static_assert(offsetof(APalRandomIncidentSpawnerBase, PlayerId) == 0x000348, "Member 'APalRandomIncidentSpawnerBase::PlayerId' has a wrong offset!");
static_assert(offsetof(APalRandomIncidentSpawnerBase, ExecIncident) == 0x000350, "Member 'APalRandomIncidentSpawnerBase::ExecIncident' has a wrong offset!");
static_assert(offsetof(APalRandomIncidentSpawnerBase, Status) == 0x000358, "Member 'APalRandomIncidentSpawnerBase::Status' has a wrong offset!");
static_assert(offsetof(APalRandomIncidentSpawnerBase, Parameter) == 0x000360, "Member 'APalRandomIncidentSpawnerBase::Parameter' has a wrong offset!");
static_assert(offsetof(APalRandomIncidentSpawnerBase, Lottery) == 0x000368, "Member 'APalRandomIncidentSpawnerBase::Lottery' has a wrong offset!");

// Class Pal.PalRCONSubsystem
// 0x0190 (0x01C0 - 0x0030)
class UPalRCONSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_2E78[0x190];                                   // 0x0030(0x0190)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalRCONSubsystem">();
	}
	static class UPalRCONSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalRCONSubsystem>();
	}
};
static_assert(alignof(UPalRCONSubsystem) == 0x000008, "Wrong alignment on UPalRCONSubsystem");
static_assert(sizeof(UPalRCONSubsystem) == 0x0001C0, "Wrong size on UPalRCONSubsystem");

// Class Pal.PalRecastNavMesh
// 0x00A0 (0x0638 - 0x0598)
class APalRecastNavMesh final : public ARecastNavMesh
{
public:
	uint8                                         Pad_2E79[0xA0];                                    // 0x0598(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalRecastNavMesh">();
	}
	static class APalRecastNavMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalRecastNavMesh>();
	}
};
static_assert(alignof(APalRecastNavMesh) == 0x000008, "Wrong alignment on APalRecastNavMesh");
static_assert(sizeof(APalRecastNavMesh) == 0x000638, "Wrong size on APalRecastNavMesh");

// Class Pal.PalRecordTrigger_BossBattle
// 0x0000 (0x0028 - 0x0028)
class UPalRecordTrigger_BossBattle final : public UPalPlayerRecordDataTrigger
{
public:
	void OnLocalPlayerBossBattleSuccessed(class APalPlayerCharacter* LocalPlayer, EPalBossType BossType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalRecordTrigger_BossBattle">();
	}
	static class UPalRecordTrigger_BossBattle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalRecordTrigger_BossBattle>();
	}
};
static_assert(alignof(UPalRecordTrigger_BossBattle) == 0x000008, "Wrong alignment on UPalRecordTrigger_BossBattle");
static_assert(sizeof(UPalRecordTrigger_BossBattle) == 0x000028, "Wrong size on UPalRecordTrigger_BossBattle");

// Class Pal.PalRegionAreaTriggerBase
// 0x0008 (0x0298 - 0x0290)
class APalRegionAreaTriggerBase final : public AActor
{
public:
	class FName                                   BindRegionNameMsgID;                               // 0x0290(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnEndOverlap(class AActor* OtherActor);
	void OnOverlap(class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalRegionAreaTriggerBase">();
	}
	static class APalRegionAreaTriggerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalRegionAreaTriggerBase>();
	}
};
static_assert(alignof(APalRegionAreaTriggerBase) == 0x000008, "Wrong alignment on APalRegionAreaTriggerBase");
static_assert(sizeof(APalRegionAreaTriggerBase) == 0x000298, "Wrong size on APalRegionAreaTriggerBase");
static_assert(offsetof(APalRegionAreaTriggerBase, BindRegionNameMsgID) == 0x000290, "Member 'APalRegionAreaTriggerBase::BindRegionNameMsgID' has a wrong offset!");

// Class Pal.PalReplicationGraph
// 0x0120 (0x0690 - 0x0570)
class UPalReplicationGraph final : public UReplicationGraph
{
public:
	TArray<class UClass*>                         SpatializedClasses;                                // 0x0570(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UClass*>                         NonSpatializedChildClasses;                        // 0x0580(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UClass*>                         AlwaysRelevantClasses;                             // 0x0590(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UReplicationGraphNode_GridSpatialization2D* GridNode;                                          // 0x05A0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReplicationGraphNode_ActorList*        AlwaysRelevantNode;                                // 0x05A8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E7B[0xE0];                                    // 0x05B0(0x00E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalReplicationGraph">();
	}
	static class UPalReplicationGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalReplicationGraph>();
	}
};
static_assert(alignof(UPalReplicationGraph) == 0x000010, "Wrong alignment on UPalReplicationGraph");
static_assert(sizeof(UPalReplicationGraph) == 0x000690, "Wrong size on UPalReplicationGraph");
static_assert(offsetof(UPalReplicationGraph, SpatializedClasses) == 0x000570, "Member 'UPalReplicationGraph::SpatializedClasses' has a wrong offset!");
static_assert(offsetof(UPalReplicationGraph, NonSpatializedChildClasses) == 0x000580, "Member 'UPalReplicationGraph::NonSpatializedChildClasses' has a wrong offset!");
static_assert(offsetof(UPalReplicationGraph, AlwaysRelevantClasses) == 0x000590, "Member 'UPalReplicationGraph::AlwaysRelevantClasses' has a wrong offset!");
static_assert(offsetof(UPalReplicationGraph, GridNode) == 0x0005A0, "Member 'UPalReplicationGraph::GridNode' has a wrong offset!");
static_assert(offsetof(UPalReplicationGraph, AlwaysRelevantNode) == 0x0005A8, "Member 'UPalReplicationGraph::AlwaysRelevantNode' has a wrong offset!");

// Class Pal.PalReplicationGraphNode_AlwaysRelevant_ForConnection
// 0x0240 (0x0290 - 0x0050)
class UPalReplicationGraphNode_AlwaysRelevant_ForConnection final : public UReplicationGraphNode
{
public:
	uint8                                         Pad_2E7C[0x220];                                   // 0x0050(0x0220)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 LastPawn;                                          // 0x0270(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FAlwaysRelevantActorInfo>       PastRelevantActors;                                // 0x0278(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E7D[0x8];                                     // 0x0288(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalReplicationGraphNode_AlwaysRelevant_ForConnection">();
	}
	static class UPalReplicationGraphNode_AlwaysRelevant_ForConnection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalReplicationGraphNode_AlwaysRelevant_ForConnection>();
	}
};
static_assert(alignof(UPalReplicationGraphNode_AlwaysRelevant_ForConnection) == 0x000008, "Wrong alignment on UPalReplicationGraphNode_AlwaysRelevant_ForConnection");
static_assert(sizeof(UPalReplicationGraphNode_AlwaysRelevant_ForConnection) == 0x000290, "Wrong size on UPalReplicationGraphNode_AlwaysRelevant_ForConnection");
static_assert(offsetof(UPalReplicationGraphNode_AlwaysRelevant_ForConnection, LastPawn) == 0x000270, "Member 'UPalReplicationGraphNode_AlwaysRelevant_ForConnection::LastPawn' has a wrong offset!");
static_assert(offsetof(UPalReplicationGraphNode_AlwaysRelevant_ForConnection, PastRelevantActors) == 0x000278, "Member 'UPalReplicationGraphNode_AlwaysRelevant_ForConnection::PastRelevantActors' has a wrong offset!");

// Class Pal.PalUISelectNumParameter
// 0x0040 (0x0078 - 0x0038)
class UPalUISelectNumParameter final : public UPalHUDDispatchParameterBase
{
public:
	TDelegate<void(EPalUISelectNumResult ResultType, int32 SelectedNum)> ComplateCallBack;                                  // 0x0038(0x0010)(BlueprintVisible, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(int32 NowSelectedNum)>         ChangedNumCallBacl;                                // 0x0048(0x0010)(BlueprintVisible, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinNum;                                            // 0x0058(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxNum;                                            // 0x005C(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultNum;                                        // 0x0060(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E7E[0x4];                                     // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              Position;                                          // 0x0068(0x0010)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void InvokeChangedNumCallback(int32 SelectedNum);
	void InvokeComplateCallback(EPalUISelectNumResult Result, int32 SelectedNum);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUISelectNumParameter">();
	}
	static class UPalUISelectNumParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUISelectNumParameter>();
	}
};
static_assert(alignof(UPalUISelectNumParameter) == 0x000008, "Wrong alignment on UPalUISelectNumParameter");
static_assert(sizeof(UPalUISelectNumParameter) == 0x000078, "Wrong size on UPalUISelectNumParameter");
static_assert(offsetof(UPalUISelectNumParameter, ComplateCallBack) == 0x000038, "Member 'UPalUISelectNumParameter::ComplateCallBack' has a wrong offset!");
static_assert(offsetof(UPalUISelectNumParameter, ChangedNumCallBacl) == 0x000048, "Member 'UPalUISelectNumParameter::ChangedNumCallBacl' has a wrong offset!");
static_assert(offsetof(UPalUISelectNumParameter, MinNum) == 0x000058, "Member 'UPalUISelectNumParameter::MinNum' has a wrong offset!");
static_assert(offsetof(UPalUISelectNumParameter, MaxNum) == 0x00005C, "Member 'UPalUISelectNumParameter::MaxNum' has a wrong offset!");
static_assert(offsetof(UPalUISelectNumParameter, DefaultNum) == 0x000060, "Member 'UPalUISelectNumParameter::DefaultNum' has a wrong offset!");
static_assert(offsetof(UPalUISelectNumParameter, Position) == 0x000068, "Member 'UPalUISelectNumParameter::Position' has a wrong offset!");

// Class Pal.PalRESTAPISubsystem
// 0x0010 (0x0040 - 0x0030)
class UPalRESTAPISubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_2E80[0x10];                                    // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalRESTAPISubsystem">();
	}
	static class UPalRESTAPISubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalRESTAPISubsystem>();
	}
};
static_assert(alignof(UPalRESTAPISubsystem) == 0x000008, "Wrong alignment on UPalRESTAPISubsystem");
static_assert(sizeof(UPalRESTAPISubsystem) == 0x000040, "Wrong size on UPalRESTAPISubsystem");

// Class Pal.PalReticleTargetUtility
// 0x0000 (0x0028 - 0x0028)
class UPalReticleTargetUtility final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalReticleTargetUtility">();
	}
	static class UPalReticleTargetUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalReticleTargetUtility>();
	}
};
static_assert(alignof(UPalReticleTargetUtility) == 0x000008, "Wrong alignment on UPalReticleTargetUtility");
static_assert(sizeof(UPalReticleTargetUtility) == 0x000028, "Wrong size on UPalReticleTargetUtility");

// Class Pal.PalRichTextBlockBase
// 0x0020 (0x08F0 - 0x08D0)
class UPalRichTextBlockBase : public UCommonRichTextBlock
{
public:
	struct FDataTableRowHandle                    BindTextDatatableHandle;                           // 0x08C8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          IsAutoTextSetWhenWidgetRebuilt;                    // 0x08D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E81[0x3];                                     // 0x08D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DefaultStyleName;                                  // 0x08DC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAutoAdjustScale;                                 // 0x08E4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E82[0x3];                                     // 0x08E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxWidth;                                          // 0x08E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E83[0x4];                                     // 0x08EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Left(const int32 Count, class FText* OutText);
	void SetText_GDKInternal(bool IsSuccess, const class FString& OutString);

	class FText GetBindedOriginalText() const;
	int32 GetTextLengthWithoutTag() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalRichTextBlockBase">();
	}
	static class UPalRichTextBlockBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalRichTextBlockBase>();
	}
};
static_assert(alignof(UPalRichTextBlockBase) == 0x000010, "Wrong alignment on UPalRichTextBlockBase");
static_assert(sizeof(UPalRichTextBlockBase) == 0x0008F0, "Wrong size on UPalRichTextBlockBase");
static_assert(offsetof(UPalRichTextBlockBase, BindTextDatatableHandle) == 0x0008C8, "Member 'UPalRichTextBlockBase::BindTextDatatableHandle' has a wrong offset!");
static_assert(offsetof(UPalRichTextBlockBase, IsAutoTextSetWhenWidgetRebuilt) == 0x0008D8, "Member 'UPalRichTextBlockBase::IsAutoTextSetWhenWidgetRebuilt' has a wrong offset!");
static_assert(offsetof(UPalRichTextBlockBase, DefaultStyleName) == 0x0008DC, "Member 'UPalRichTextBlockBase::DefaultStyleName' has a wrong offset!");
static_assert(offsetof(UPalRichTextBlockBase, IsAutoAdjustScale) == 0x0008E4, "Member 'UPalRichTextBlockBase::IsAutoAdjustScale' has a wrong offset!");
static_assert(offsetof(UPalRichTextBlockBase, MaxWidth) == 0x0008E8, "Member 'UPalRichTextBlockBase::MaxWidth' has a wrong offset!");

// Class Pal.PalRichTextIconDecorator
// 0x0008 (0x0038 - 0x0030)
class UPalRichTextIconDecorator : public URichTextBlockImageDecorator
{
public:
	class UDataTable*                             ControlKeyIconData;                                // 0x0030(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalRichTextIconDecorator">();
	}
	static class UPalRichTextIconDecorator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalRichTextIconDecorator>();
	}
};
static_assert(alignof(UPalRichTextIconDecorator) == 0x000008, "Wrong alignment on UPalRichTextIconDecorator");
static_assert(sizeof(UPalRichTextIconDecorator) == 0x000038, "Wrong size on UPalRichTextIconDecorator");
static_assert(offsetof(UPalRichTextIconDecorator, ControlKeyIconData) == 0x000030, "Member 'UPalRichTextIconDecorator::ControlKeyIconData' has a wrong offset!");

// Class Pal.PalWorldBaseInfoSaveDataUtility
// 0x0000 (0x0028 - 0x0028)
class UPalWorldBaseInfoSaveDataUtility final : public UBlueprintFunctionLibrary
{
public:
	static class FString GetWorldName(const struct FPalWorldBaseInfoSaveData& SaveData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorldBaseInfoSaveDataUtility">();
	}
	static class UPalWorldBaseInfoSaveDataUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWorldBaseInfoSaveDataUtility>();
	}
};
static_assert(alignof(UPalWorldBaseInfoSaveDataUtility) == 0x000008, "Wrong alignment on UPalWorldBaseInfoSaveDataUtility");
static_assert(sizeof(UPalWorldBaseInfoSaveDataUtility) == 0x000028, "Wrong size on UPalWorldBaseInfoSaveDataUtility");

// Class Pal.PalLocalWorldSaveGame
// 0x02E8 (0x0310 - 0x0028)
class UPalLocalWorldSaveGame final : public USaveGame
{
public:
	int32                                         Version;                                           // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E86[0x4];                                     // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPalLocalSaveData                      SaveData;                                          // 0x0030(0x02E0)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLocalWorldSaveGame">();
	}
	static class UPalLocalWorldSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalLocalWorldSaveGame>();
	}
};
static_assert(alignof(UPalLocalWorldSaveGame) == 0x000008, "Wrong alignment on UPalLocalWorldSaveGame");
static_assert(sizeof(UPalLocalWorldSaveGame) == 0x000310, "Wrong size on UPalLocalWorldSaveGame");
static_assert(offsetof(UPalLocalWorldSaveGame, Version) == 0x000028, "Member 'UPalLocalWorldSaveGame::Version' has a wrong offset!");
static_assert(offsetof(UPalLocalWorldSaveGame, SaveData) == 0x000030, "Member 'UPalLocalWorldSaveGame::SaveData' has a wrong offset!");

// Class Pal.PalWorldBaseInfoSaveGame
// 0x0038 (0x0060 - 0x0028)
class UPalWorldBaseInfoSaveGame final : public USaveGame
{
public:
	int32                                         Version;                                           // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E87[0x4];                                     // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              Timestamp;                                         // 0x0030(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPalWorldBaseInfoSaveData              SaveData;                                          // 0x0038(0x0028)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorldBaseInfoSaveGame">();
	}
	static class UPalWorldBaseInfoSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWorldBaseInfoSaveGame>();
	}
};
static_assert(alignof(UPalWorldBaseInfoSaveGame) == 0x000008, "Wrong alignment on UPalWorldBaseInfoSaveGame");
static_assert(sizeof(UPalWorldBaseInfoSaveGame) == 0x000060, "Wrong size on UPalWorldBaseInfoSaveGame");
static_assert(offsetof(UPalWorldBaseInfoSaveGame, Version) == 0x000028, "Member 'UPalWorldBaseInfoSaveGame::Version' has a wrong offset!");
static_assert(offsetof(UPalWorldBaseInfoSaveGame, Timestamp) == 0x000030, "Member 'UPalWorldBaseInfoSaveGame::Timestamp' has a wrong offset!");
static_assert(offsetof(UPalWorldBaseInfoSaveGame, SaveData) == 0x000038, "Member 'UPalWorldBaseInfoSaveGame::SaveData' has a wrong offset!");

// Class Pal.PalWorldPlayerSaveGame
// 0x04C8 (0x04F0 - 0x0028)
class UPalWorldPlayerSaveGame final : public USaveGame
{
public:
	int32                                         Version;                                           // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E88[0x4];                                     // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              Timestamp;                                         // 0x0030(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E89[0x8];                                     // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPalWorldPlayerSaveData                SaveData;                                          // 0x0040(0x04B0)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorldPlayerSaveGame">();
	}
	static class UPalWorldPlayerSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWorldPlayerSaveGame>();
	}
};
static_assert(alignof(UPalWorldPlayerSaveGame) == 0x000010, "Wrong alignment on UPalWorldPlayerSaveGame");
static_assert(sizeof(UPalWorldPlayerSaveGame) == 0x0004F0, "Wrong size on UPalWorldPlayerSaveGame");
static_assert(offsetof(UPalWorldPlayerSaveGame, Version) == 0x000028, "Member 'UPalWorldPlayerSaveGame::Version' has a wrong offset!");
static_assert(offsetof(UPalWorldPlayerSaveGame, Timestamp) == 0x000030, "Member 'UPalWorldPlayerSaveGame::Timestamp' has a wrong offset!");
static_assert(offsetof(UPalWorldPlayerSaveGame, SaveData) == 0x000040, "Member 'UPalWorldPlayerSaveGame::SaveData' has a wrong offset!");

// Class Pal.PalWorldOptionSaveGame
// 0x0148 (0x0170 - 0x0028)
class UPalWorldOptionSaveGame final : public USaveGame
{
public:
	int32                                         Version;                                           // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E8A[0x4];                                     // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              Timestamp;                                         // 0x0030(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPalOptionWorldSaveData                OptionWorldData;                                   // 0x0038(0x0138)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorldOptionSaveGame">();
	}
	static class UPalWorldOptionSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWorldOptionSaveGame>();
	}
};
static_assert(alignof(UPalWorldOptionSaveGame) == 0x000008, "Wrong alignment on UPalWorldOptionSaveGame");
static_assert(sizeof(UPalWorldOptionSaveGame) == 0x000170, "Wrong size on UPalWorldOptionSaveGame");
static_assert(offsetof(UPalWorldOptionSaveGame, Version) == 0x000028, "Member 'UPalWorldOptionSaveGame::Version' has a wrong offset!");
static_assert(offsetof(UPalWorldOptionSaveGame, Timestamp) == 0x000030, "Member 'UPalWorldOptionSaveGame::Timestamp' has a wrong offset!");
static_assert(offsetof(UPalWorldOptionSaveGame, OptionWorldData) == 0x000038, "Member 'UPalWorldOptionSaveGame::OptionWorldData' has a wrong offset!");

// Class Pal.PalGameWorldDataSaveInterface
// 0x0000 (0x0028 - 0x0028)
class IPalGameWorldDataSaveInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGameWorldDataSaveInterface">();
	}
	static class IPalGameWorldDataSaveInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPalGameWorldDataSaveInterface>();
	}
};
static_assert(alignof(IPalGameWorldDataSaveInterface) == 0x000008, "Wrong alignment on IPalGameWorldDataSaveInterface");
static_assert(sizeof(IPalGameWorldDataSaveInterface) == 0x000028, "Wrong size on IPalGameWorldDataSaveInterface");

// Class Pal.PalSaveGameManager
// 0x0288 (0x02B0 - 0x0028)
class UPalSaveGameManager : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnStartedWorldAutoSave;                            // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEndedWorldAutoSave;                              // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStartedLocalWorldAutoSave;                       // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEndedLocalWorldAutoSave;                         // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStartedPlayerAutoSave;                           // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEndedPlayerAutoSave;                             // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	class UPalWorldSaveGame*                      LoadedWorldSaveData;                               // 0x0088(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalLocalWorldSaveGame*                 LoadedLocalWorldSaveData;                          // 0x0090(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalWorldOptionSaveGame*                LoadedWorldOptionSaveData;                         // 0x0098(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           AutoSaveWorldDataTimerHandle;                      // 0x00A0(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           AutoSaveLocalWorldDataTimerHandle;                 // 0x00A8(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 AutoSaveWorldDefaultName;                          // 0x00B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TScriptInterface<class IPalGameWorldDataSaveInterface>> GameSavers;                                        // 0x00C0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TScriptInterface<class IPalGamePlayerDataSaveInterface> PlayerDataSaver;                                   // 0x00D0(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsAppliedPlayerSaveData;                           // 0x00E0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E8B[0x7];                                     // 0x00E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPalAsyncSaveProcessParallel           WorldSaveProcess;                                  // 0x00E8(0x0060)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E8C[0x10];                                    // 0x0148(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsForceDisableAutoSave;                           // 0x0158(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsUseBackupSaveData;                              // 0x0159(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E8D[0x2];                                     // 0x015A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NearSaveBackupNum;                                 // 0x015C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MinutesSaveBackupNum;                              // 0x0160(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         HourSaveBackupNum;                                 // 0x0164(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         DaySaveBackupNum;                                  // 0x0168(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E8E[0x4];                                     // 0x016C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EPalInLoadCollectionType, struct FFlagContainer> bIsCollectIDInLoad;                                // 0x0170(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TSet<struct FPalInstanceID>                   UsedInstanceIDSetInLoad;                           // 0x01C0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TSet<struct FPalContainerId>                  UsedContainerIDSetInLoad;                          // 0x0210(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TSet<struct FPalDynamicItemId>                UsedDynamicItemIDSetInLoad;                        // 0x0260(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	bool IsAppliedPlayerData();
	bool IsExistSocialId(const struct FSocialId& ID);
	void OnEndedLocalWorldAutoSave__DelegateSignature(bool IsSuccess);
	void OnEndedPlayerAutoSave__DelegateSignature(bool IsSuccess);
	void OnEndedWorldAutoSave__DelegateSignature(bool IsSuccess);
	void OnFinishedWorldAsyncSaveGameInternal(const class FString& SlotName, const int32 UserIndex, bool bSuccess, const class FString& WorldName, const class FString& Timestamp);
	void OnStartedLocalWorldAutoSave__DelegateSignature();
	void OnStartedPlayerAutoSave__DelegateSignature();
	void OnStartedWorldAutoSave__DelegateSignature();
	void StartLocalWorldDataAutoSave();
	void StartWorldDataAutoSave();

	class UPalLocalWorldSaveGame* GetLoadedLocalWorldSaveData() const;
	class UPalWorldOptionSaveGame* GetLoadedWorldOptionSaveData() const;
	class UPalWorldSaveGame* GetLoadedWorldSaveData() const;
	int32 GetMaxWorldSaveDataNum() const;
	TMap<class FString, struct FPalWorldBaseInfoData> GetWorldBaseInfoMap() const;
	TArray<class FString> GetWorldNames() const;
	bool IsLoadedLocalWorldData() const;
	bool IsLoadedWorldData() const;
	bool IsLoadedWorldOptionData() const;
	bool IsValidLocalWorldData(const class FString& WorldName) const;
	bool IsValidWorldData(const class FString& WorldName) const;
	bool IsValidWorldSaveDirectoryName(const class FString& WorldSaveDirectoryName) const;
	bool IsValidWorldSaveDirectoryName_LocalData(const class FString& WorldSaveDirectoryName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalSaveGameManager">();
	}
	static class UPalSaveGameManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalSaveGameManager>();
	}
};
static_assert(alignof(UPalSaveGameManager) == 0x000008, "Wrong alignment on UPalSaveGameManager");
static_assert(sizeof(UPalSaveGameManager) == 0x0002B0, "Wrong size on UPalSaveGameManager");
static_assert(offsetof(UPalSaveGameManager, OnStartedWorldAutoSave) == 0x000028, "Member 'UPalSaveGameManager::OnStartedWorldAutoSave' has a wrong offset!");
static_assert(offsetof(UPalSaveGameManager, OnEndedWorldAutoSave) == 0x000038, "Member 'UPalSaveGameManager::OnEndedWorldAutoSave' has a wrong offset!");
static_assert(offsetof(UPalSaveGameManager, OnStartedLocalWorldAutoSave) == 0x000048, "Member 'UPalSaveGameManager::OnStartedLocalWorldAutoSave' has a wrong offset!");
static_assert(offsetof(UPalSaveGameManager, OnEndedLocalWorldAutoSave) == 0x000058, "Member 'UPalSaveGameManager::OnEndedLocalWorldAutoSave' has a wrong offset!");
static_assert(offsetof(UPalSaveGameManager, OnStartedPlayerAutoSave) == 0x000068, "Member 'UPalSaveGameManager::OnStartedPlayerAutoSave' has a wrong offset!");
static_assert(offsetof(UPalSaveGameManager, OnEndedPlayerAutoSave) == 0x000078, "Member 'UPalSaveGameManager::OnEndedPlayerAutoSave' has a wrong offset!");
static_assert(offsetof(UPalSaveGameManager, LoadedWorldSaveData) == 0x000088, "Member 'UPalSaveGameManager::LoadedWorldSaveData' has a wrong offset!");
static_assert(offsetof(UPalSaveGameManager, LoadedLocalWorldSaveData) == 0x000090, "Member 'UPalSaveGameManager::LoadedLocalWorldSaveData' has a wrong offset!");
static_assert(offsetof(UPalSaveGameManager, LoadedWorldOptionSaveData) == 0x000098, "Member 'UPalSaveGameManager::LoadedWorldOptionSaveData' has a wrong offset!");
static_assert(offsetof(UPalSaveGameManager, AutoSaveWorldDataTimerHandle) == 0x0000A0, "Member 'UPalSaveGameManager::AutoSaveWorldDataTimerHandle' has a wrong offset!");
static_assert(offsetof(UPalSaveGameManager, AutoSaveLocalWorldDataTimerHandle) == 0x0000A8, "Member 'UPalSaveGameManager::AutoSaveLocalWorldDataTimerHandle' has a wrong offset!");
static_assert(offsetof(UPalSaveGameManager, AutoSaveWorldDefaultName) == 0x0000B0, "Member 'UPalSaveGameManager::AutoSaveWorldDefaultName' has a wrong offset!");
static_assert(offsetof(UPalSaveGameManager, GameSavers) == 0x0000C0, "Member 'UPalSaveGameManager::GameSavers' has a wrong offset!");
static_assert(offsetof(UPalSaveGameManager, PlayerDataSaver) == 0x0000D0, "Member 'UPalSaveGameManager::PlayerDataSaver' has a wrong offset!");
static_assert(offsetof(UPalSaveGameManager, IsAppliedPlayerSaveData) == 0x0000E0, "Member 'UPalSaveGameManager::IsAppliedPlayerSaveData' has a wrong offset!");
static_assert(offsetof(UPalSaveGameManager, WorldSaveProcess) == 0x0000E8, "Member 'UPalSaveGameManager::WorldSaveProcess' has a wrong offset!");
static_assert(offsetof(UPalSaveGameManager, bIsForceDisableAutoSave) == 0x000158, "Member 'UPalSaveGameManager::bIsForceDisableAutoSave' has a wrong offset!");
static_assert(offsetof(UPalSaveGameManager, bIsUseBackupSaveData) == 0x000159, "Member 'UPalSaveGameManager::bIsUseBackupSaveData' has a wrong offset!");
static_assert(offsetof(UPalSaveGameManager, NearSaveBackupNum) == 0x00015C, "Member 'UPalSaveGameManager::NearSaveBackupNum' has a wrong offset!");
static_assert(offsetof(UPalSaveGameManager, MinutesSaveBackupNum) == 0x000160, "Member 'UPalSaveGameManager::MinutesSaveBackupNum' has a wrong offset!");
static_assert(offsetof(UPalSaveGameManager, HourSaveBackupNum) == 0x000164, "Member 'UPalSaveGameManager::HourSaveBackupNum' has a wrong offset!");
static_assert(offsetof(UPalSaveGameManager, DaySaveBackupNum) == 0x000168, "Member 'UPalSaveGameManager::DaySaveBackupNum' has a wrong offset!");
static_assert(offsetof(UPalSaveGameManager, bIsCollectIDInLoad) == 0x000170, "Member 'UPalSaveGameManager::bIsCollectIDInLoad' has a wrong offset!");
static_assert(offsetof(UPalSaveGameManager, UsedInstanceIDSetInLoad) == 0x0001C0, "Member 'UPalSaveGameManager::UsedInstanceIDSetInLoad' has a wrong offset!");
static_assert(offsetof(UPalSaveGameManager, UsedContainerIDSetInLoad) == 0x000210, "Member 'UPalSaveGameManager::UsedContainerIDSetInLoad' has a wrong offset!");
static_assert(offsetof(UPalSaveGameManager, UsedDynamicItemIDSetInLoad) == 0x000260, "Member 'UPalSaveGameManager::UsedDynamicItemIDSetInLoad' has a wrong offset!");

// Class Pal.PalScrollBox
// 0x0B48 (0x0CB0 - 0x0168)
class UPalScrollBox final : public UPanelWidget
{
public:
	uint8                                         Pad_2E95[0x8];                                     // 0x0168(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScrollBoxStyle                        WidgetStyle;                                       // 0x0170(0x0350)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FScrollBarStyle                        WidgetBarStyle;                                    // 0x04C0(0x0770)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class USlateWidgetStyleAsset*                 Style;                                             // 0x0C30(0x0008)(ZeroConstructor, Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USlateWidgetStyleAsset*                 BarStyle;                                          // 0x0C38(0x0008)(ZeroConstructor, Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrientation                                  Orientation;                                       // 0x0C40(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESlateVisibility                              ScrollBarVisibility;                               // 0x0C41(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EConsumeMouseWheel                            ConsumeMouseWheel;                                 // 0x0C42(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E96[0x5];                                     // 0x0C43(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ScrollbarThickness;                                // 0x0C48(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMargin                                ScrollbarPadding;                                  // 0x0C58(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          AlwaysShowScrollbar;                               // 0x0C68(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AlwaysShowScrollbarTrack;                          // 0x0C69(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowOverscroll;                                   // 0x0C6A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimateWheelScrolling;                            // 0x0C6B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPalDescendantScrollDestination               NavigationDestination;                             // 0x0C6C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E97[0x3];                                     // 0x0C6D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NavigationScrollPadding;                           // 0x0C70(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPalScrollWhenFocusChanges                    ScrollWhenFocusChanges;                            // 0x0C74(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowRightClickDragScrolling;                     // 0x0C75(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E98[0x2];                                     // 0x0C76(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WheelScrollMultiplier;                             // 0x0C78(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E99[0x4];                                     // 0x0C7C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnUserScrolled;                                    // 0x0C80(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E9A[0x20];                                    // 0x0C90(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndInertialScrolling();
	void ScrollToEnd();
	void ScrollToStart();
	void ScrollWidgetIntoView(class UWidget* WidgetToFind, bool AnimateScroll, EPalDescendantScrollDestination ScrollDestination, float Padding);
	void SetAllowOverscroll(bool NewAllowOverscroll);
	void SetAlwaysShowScrollbar(bool NewAlwaysShowScrollbar);
	void SetAnimateWheelScrolling(bool bShouldAnimateWheelScrolling);
	void SetConsumeMouseWheel(EConsumeMouseWheel NewConsumeMouseWheel);
	void SetOrientation(EOrientation NewOrientation);
	void SetScrollbarPadding(const struct FMargin& NewScrollbarPadding);
	void SetScrollbarThickness(const struct FVector2D& NewScrollbarThickness);
	void SetScrollBarVisibility(ESlateVisibility NewScrollBarVisibility);
	void SetScrollOffset(float NewScrollOffset);
	void SetScrollWhenFocusChanges(EPalScrollWhenFocusChanges NewScrollWhenFocusChanges);
	void SetWheelScrollMultiplier(float NewWheelScrollMultiplier);

	float GetScrollOffset() const;
	float GetScrollOffsetOfEnd() const;
	float GetViewOffsetFraction() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalScrollBox">();
	}
	static class UPalScrollBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalScrollBox>();
	}
};
static_assert(alignof(UPalScrollBox) == 0x000010, "Wrong alignment on UPalScrollBox");
static_assert(sizeof(UPalScrollBox) == 0x000CB0, "Wrong size on UPalScrollBox");
static_assert(offsetof(UPalScrollBox, WidgetStyle) == 0x000170, "Member 'UPalScrollBox::WidgetStyle' has a wrong offset!");
static_assert(offsetof(UPalScrollBox, WidgetBarStyle) == 0x0004C0, "Member 'UPalScrollBox::WidgetBarStyle' has a wrong offset!");
static_assert(offsetof(UPalScrollBox, Style) == 0x000C30, "Member 'UPalScrollBox::Style' has a wrong offset!");
static_assert(offsetof(UPalScrollBox, BarStyle) == 0x000C38, "Member 'UPalScrollBox::BarStyle' has a wrong offset!");
static_assert(offsetof(UPalScrollBox, Orientation) == 0x000C40, "Member 'UPalScrollBox::Orientation' has a wrong offset!");
static_assert(offsetof(UPalScrollBox, ScrollBarVisibility) == 0x000C41, "Member 'UPalScrollBox::ScrollBarVisibility' has a wrong offset!");
static_assert(offsetof(UPalScrollBox, ConsumeMouseWheel) == 0x000C42, "Member 'UPalScrollBox::ConsumeMouseWheel' has a wrong offset!");
static_assert(offsetof(UPalScrollBox, ScrollbarThickness) == 0x000C48, "Member 'UPalScrollBox::ScrollbarThickness' has a wrong offset!");
static_assert(offsetof(UPalScrollBox, ScrollbarPadding) == 0x000C58, "Member 'UPalScrollBox::ScrollbarPadding' has a wrong offset!");
static_assert(offsetof(UPalScrollBox, AlwaysShowScrollbar) == 0x000C68, "Member 'UPalScrollBox::AlwaysShowScrollbar' has a wrong offset!");
static_assert(offsetof(UPalScrollBox, AlwaysShowScrollbarTrack) == 0x000C69, "Member 'UPalScrollBox::AlwaysShowScrollbarTrack' has a wrong offset!");
static_assert(offsetof(UPalScrollBox, AllowOverscroll) == 0x000C6A, "Member 'UPalScrollBox::AllowOverscroll' has a wrong offset!");
static_assert(offsetof(UPalScrollBox, bAnimateWheelScrolling) == 0x000C6B, "Member 'UPalScrollBox::bAnimateWheelScrolling' has a wrong offset!");
static_assert(offsetof(UPalScrollBox, NavigationDestination) == 0x000C6C, "Member 'UPalScrollBox::NavigationDestination' has a wrong offset!");
static_assert(offsetof(UPalScrollBox, NavigationScrollPadding) == 0x000C70, "Member 'UPalScrollBox::NavigationScrollPadding' has a wrong offset!");
static_assert(offsetof(UPalScrollBox, ScrollWhenFocusChanges) == 0x000C74, "Member 'UPalScrollBox::ScrollWhenFocusChanges' has a wrong offset!");
static_assert(offsetof(UPalScrollBox, bAllowRightClickDragScrolling) == 0x000C75, "Member 'UPalScrollBox::bAllowRightClickDragScrolling' has a wrong offset!");
static_assert(offsetof(UPalScrollBox, WheelScrollMultiplier) == 0x000C78, "Member 'UPalScrollBox::WheelScrollMultiplier' has a wrong offset!");
static_assert(offsetof(UPalScrollBox, OnUserScrolled) == 0x000C80, "Member 'UPalScrollBox::OnUserScrolled' has a wrong offset!");

// Class Pal.PalScrollBoxSlot
// 0x0020 (0x0058 - 0x0038)
class UPalScrollBoxSlot final : public UPanelSlot
{
public:
	struct FMargin                                Padding;                                           // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVerticalAlignment                            VerticalAlignment;                                 // 0x0049(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E9C[0xE];                                     // 0x004A(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment);
	void SetPadding(const struct FMargin& InPadding);
	void SetVerticalAlignment(EVerticalAlignment InVerticalAlignment);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalScrollBoxSlot">();
	}
	static class UPalScrollBoxSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalScrollBoxSlot>();
	}
};
static_assert(alignof(UPalScrollBoxSlot) == 0x000008, "Wrong alignment on UPalScrollBoxSlot");
static_assert(sizeof(UPalScrollBoxSlot) == 0x000058, "Wrong size on UPalScrollBoxSlot");
static_assert(offsetof(UPalScrollBoxSlot, Padding) == 0x000038, "Member 'UPalScrollBoxSlot::Padding' has a wrong offset!");
static_assert(offsetof(UPalScrollBoxSlot, HorizontalAlignment) == 0x000048, "Member 'UPalScrollBoxSlot::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UPalScrollBoxSlot, VerticalAlignment) == 0x000049, "Member 'UPalScrollBoxSlot::VerticalAlignment' has a wrong offset!");

// Class Pal.PalShooterAnimeAssetBase
// 0x0258 (0x0280 - 0x0028)
class UPalShooterAnimeAssetBase : public UObject
{
public:
	struct FWeaponAnimationInfo                   AnimeInfo;                                         // 0x0028(0x0258)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void ChangeRideMontage(class UAnimMontage* NextAnim, EWeaponAnimationType AnimType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalShooterAnimeAssetBase">();
	}
	static class UPalShooterAnimeAssetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalShooterAnimeAssetBase>();
	}
};
static_assert(alignof(UPalShooterAnimeAssetBase) == 0x000008, "Wrong alignment on UPalShooterAnimeAssetBase");
static_assert(sizeof(UPalShooterAnimeAssetBase) == 0x000280, "Wrong size on UPalShooterAnimeAssetBase");
static_assert(offsetof(UPalShooterAnimeAssetBase, AnimeInfo) == 0x000028, "Member 'UPalShooterAnimeAssetBase::AnimeInfo' has a wrong offset!");

// Class Pal.PalUniqueRideAnimeAssetBase
// 0x0138 (0x0160 - 0x0028)
class UPalUniqueRideAnimeAssetBase : public UObject
{
public:
	struct FVector                                IKPoleLocation_Hand_R;                             // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                IKPoleLocation_Hand_L;                             // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                IKPoleLocation_Foot_R;                             // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                IKPoleLocation_Foot_L;                             // 0x0070(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableLeftHandIK_BallMotion;                      // 0x0088(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E9E[0x7];                                     // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          RidingAnimation;                                   // 0x0090(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           RidingAnimation_Ball_Aim;                          // 0x0098(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           RidingAnimation_Ball_Fire;                         // 0x00A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E9F[0x8];                                     // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWeaponNotifyAnimationInfo             WeaponNotifyAnimInfo_Ball_Aim;                     // 0x00B0(0x0058)(Transient, NativeAccessSpecifierPrivate)
	struct FWeaponNotifyAnimationInfo             WeaponNotifyAnimInfo_Ball_Fire;                    // 0x0108(0x0058)(Transient, NativeAccessSpecifierPrivate)

public:
	class UAnimSequence* GetRideAnimSequence();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUniqueRideAnimeAssetBase">();
	}
	static class UPalUniqueRideAnimeAssetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUniqueRideAnimeAssetBase>();
	}
};
static_assert(alignof(UPalUniqueRideAnimeAssetBase) == 0x000008, "Wrong alignment on UPalUniqueRideAnimeAssetBase");
static_assert(sizeof(UPalUniqueRideAnimeAssetBase) == 0x000160, "Wrong size on UPalUniqueRideAnimeAssetBase");
static_assert(offsetof(UPalUniqueRideAnimeAssetBase, IKPoleLocation_Hand_R) == 0x000028, "Member 'UPalUniqueRideAnimeAssetBase::IKPoleLocation_Hand_R' has a wrong offset!");
static_assert(offsetof(UPalUniqueRideAnimeAssetBase, IKPoleLocation_Hand_L) == 0x000040, "Member 'UPalUniqueRideAnimeAssetBase::IKPoleLocation_Hand_L' has a wrong offset!");
static_assert(offsetof(UPalUniqueRideAnimeAssetBase, IKPoleLocation_Foot_R) == 0x000058, "Member 'UPalUniqueRideAnimeAssetBase::IKPoleLocation_Foot_R' has a wrong offset!");
static_assert(offsetof(UPalUniqueRideAnimeAssetBase, IKPoleLocation_Foot_L) == 0x000070, "Member 'UPalUniqueRideAnimeAssetBase::IKPoleLocation_Foot_L' has a wrong offset!");
static_assert(offsetof(UPalUniqueRideAnimeAssetBase, DisableLeftHandIK_BallMotion) == 0x000088, "Member 'UPalUniqueRideAnimeAssetBase::DisableLeftHandIK_BallMotion' has a wrong offset!");
static_assert(offsetof(UPalUniqueRideAnimeAssetBase, RidingAnimation) == 0x000090, "Member 'UPalUniqueRideAnimeAssetBase::RidingAnimation' has a wrong offset!");
static_assert(offsetof(UPalUniqueRideAnimeAssetBase, RidingAnimation_Ball_Aim) == 0x000098, "Member 'UPalUniqueRideAnimeAssetBase::RidingAnimation_Ball_Aim' has a wrong offset!");
static_assert(offsetof(UPalUniqueRideAnimeAssetBase, RidingAnimation_Ball_Fire) == 0x0000A0, "Member 'UPalUniqueRideAnimeAssetBase::RidingAnimation_Ball_Fire' has a wrong offset!");
static_assert(offsetof(UPalUniqueRideAnimeAssetBase, WeaponNotifyAnimInfo_Ball_Aim) == 0x0000B0, "Member 'UPalUniqueRideAnimeAssetBase::WeaponNotifyAnimInfo_Ball_Aim' has a wrong offset!");
static_assert(offsetof(UPalUniqueRideAnimeAssetBase, WeaponNotifyAnimInfo_Ball_Fire) == 0x000108, "Member 'UPalUniqueRideAnimeAssetBase::WeaponNotifyAnimInfo_Ball_Fire' has a wrong offset!");

// Class Pal.PalShooterComponent
// 0x0900 (0x09A0 - 0x00A0)
class UPalShooterComponent final : public UActorComponent
{
public:
	uint8                                         Pad_2EA0[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnChangeTargetDirectionDelegate;                   // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStartAim;                                        // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEndAim;                                          // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPullTrigger;                                     // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnReleaseTrigger;                                  // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeState;                                     // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnWeaponNotifyDelegate;                            // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEndShootingAnimationDelegate;                    // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeWeaponDelegate;                            // 0x0128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnReloadStartDelegate;                             // 0x0138(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnReloadBulletDelegate;                            // 0x0148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdatedUsableHandFlagDelegate;                   // 0x0158(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         WalkSpeedMultiplierInAim;                          // 0x0168(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkSpeedMultiplierInHipShoot;                     // 0x016C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChangeWeaponInterpTime;                            // 0x0170(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EA1[0x4];                                     // 0x0174(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EPalWeaponType, TSoftClassPtr<class UClass>> DefaultWeaponAnimeAssetBPSoftClassMap;             // 0x0178(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<TSoftClassPtr<class UClass>, TSoftClassPtr<class UClass>> OtherWeaponAnimeAssetBPSoftClassMap;               // 0x01C8(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<TSoftClassPtr<class UClass>, EPalWeaponType> WeaponCategoryForPreLoad;                          // 0x0218(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          IsUseBlurUpdate;                                   // 0x0268(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EA2[0x7];                                     // 0x0269(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EPalWeaponType, class UPalShooterAnimeAssetBase*> DefaultWeaponAnimeAssetMap;                        // 0x0270(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<TSoftClassPtr<class UClass>, class UPalShooterAnimeAssetBase*> OtherWeaponAnimeAssetMap;                          // 0x02C0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TSet<EPalWeaponType>                          LoadedDefaultWeaponSet;                            // 0x0310(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TSet<TSoftClassPtr<class UClass>>             LoadedOtherWeaponSet;                              // 0x0360(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<EWeaponAnimationType, struct FWeaponNotifyAnimationInfo> OverrideWeaponNotifyAnimationMap;                  // 0x03B0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	struct FVector                                TargetDirection;                                   // 0x0400(0x0018)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsAiming;                                         // 0x0418(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsShooting;                                       // 0x0419(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsRequestAim;                                     // 0x041A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsRequestPullTrigger;                             // 0x041B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsReloading;                                      // 0x041C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2EA3[0x3];                                     // 0x041D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFlagContainer                         UseControllerRotationYawFlags;                     // 0x0420(0x0050)(NativeAccessSpecifierPrivate)
	class APalWeaponBase*                         HasWeapon;                                         // 0x0470(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APalWeaponBase*                         CacheNextWeapon;                                   // 0x0478(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FWeaponAnimationInfo                   PrevWeaponAnimationInfo;                           // 0x0480(0x0258)(Transient, NativeAccessSpecifierPrivate)
	bool                                          bIsDisableShootingTemporarily;                     // 0x06D8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2EA4[0x17];                                    // 0x06D9(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLayeredFlagContainer                  DisableAimFlag;                                    // 0x06F0(0x0010)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	struct FLayeredFlagContainer                  DisableShootFlag;                                  // 0x0700(0x0010)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2EA5[0xA0];                                    // 0x0710(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLayeredFlagContainer                  DisableWeaponChange;                               // 0x07B0(0x0010)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	struct FFlagContainer                         HiddenWeapon;                                      // 0x07C0(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2EA6[0x150];                                   // 0x0810(0x0150)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PullTriggerCountDown;                              // 0x0960(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         PullTriggerCountDownCount;                         // 0x0964(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ElapsedTimeSinceWeaponChange;                      // 0x0968(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPalWeaponType                                OverrideWeaponType;                                // 0x096C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUnstoppable;                                      // 0x096D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsHoldTrigger;                                    // 0x096E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bBufferedInput;                                    // 0x096F(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsShootingHold;                                   // 0x0970(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsAttachRequest;                                  // 0x0971(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2EA7[0x16];                                    // 0x0972(0x0016)(Fixing Size After Last Property [ Dumper-7 ])
	class APalWeaponBase*                         NPCWeapon;                                         // 0x0988(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentBulletBlurRate;                             // 0x0990(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RapidFireBlur;                                     // 0x0994(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRandomStream                          RandomStream;                                      // 0x0998(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, NativeAccessSpecifierPrivate)

public:
	void AddRapidFireBlur();
	void AttachWeapon(class APalWeaponBase* Weapon);
	void AttachWeapon_ForNPC_ToAll(bool IsNotNull);
	void AttachWeapon_ForPartnerSkillPalWeapon_ToAll(class APalWeaponBase* Weapon);
	void BowPullAnimeEnd();
	bool CanWeaponChangeAnime();
	void ChangeIsAiming(bool Param_IsAiming);
	void ChangeIsAiming_ToALL(int32 ID, bool Param_IsAiming);
	void ChangeIsAiming_ToServer(int32 ID, bool Param_IsAiming);
	void ChangeIsShooting(bool Param_IsShooting);
	void ChangeIsShooting_ToALL(int32 ID, bool Param_IsShooting);
	void ChangeIsShooting_ToServer(int32 ID, bool Param_IsShooting);
	void ChangeStateDelegate__DelegateSignature(bool IsAim, bool IsShoot);
	void ChangeTargetDirectionDelegate__DelegateSignature(const struct FVector& Direction);
	void ChangeWeapon(class APalWeaponBase* Weapon);
	void EndAim();
	void EndAimDelegate__DelegateSignature();
	class UPalShooterAnimeAssetBase* GetBowAnimAsset();
	float GetCurrentBulletBlurRate();
	class UPalShooterAnimeAssetBase* GetThrowAnimAsset();
	bool IsHiddenAttachWeapon();
	void OnChangeChangeImportance(EPalCharacterImportanceType Next);
	void OnChangeTargetDirection();
	void OnChangeWeapon__DelegateSignature(class APalWeaponBase* Weapon);
	void OnCrouch(class UPalCharacterMovementComponent* Component, bool bIsCrouch);
	void OnDead(const struct FPalDeadInfo& DeadInfo);
	void OnEndReloadAnimation(class UAnimMontage* Montage, bool bInterrupted);
	void OnEndShootingAnimation__DelegateSignature(class UAnimMontage* Montage);
	void OnJump(class UPalCharacterMovementComponent* Component);
	void OnLanded(class UPalCharacterMovementComponent* Component, const struct FHitResult& Hit);
	void OnOwnerAnimInitialized();
	void OnReloadBullet__DelegateSignature();
	void OnReloadStart__DelegateSignature();
	void OnStartOwnerAction(const class UPalActionBase* Action);
	void OnUpdatedUsableHandFlag__DelegateSignature(bool CanUseLeftHandFlag, bool CanUseRightHandFlag);
	void OnWeaponAnimationNotifyBegin(class FName NotifyName, const struct FBranchingPointNotifyPayload& BranchingPointNotifyPayload);
	void OnWeaponAnimationNotifyEnd(class FName NotifyName, const struct FBranchingPointNotifyPayload& BranchingPointNotifyPayload);
	void OnWeaponNotify(EWeaponNotifyType Type);
	void OnWeaponNotifyDelegate__DelegateSignature(EWeaponNotifyType Type);
	void PullTrigger();
	void PullTriggerDelegate__DelegateSignature();
	void ReleaseTrigger();
	void ReloadWeapon();
	void ReloadWeapon_ToALL(int32 ID);
	void ReloadWeapon_ToServer(int32 ID);
	void ReloadWeaponInternal();
	void ResetOverrideWeaponType();
	void ReturnTriggerDelegate__DelegateSignature();
	void SetDisableAimFlag(class FName FlagName, bool IsDisable);
	void SetDisableAimFlag_Layered(EPalShooterFlagContainerPriority Priority, class FName FlagName, bool IsDisable);
	void SetDisableChangeWeaponFlag(class FName FlagName, bool IsDisable);
	void SetDisableChangeWeaponFlag_Layered(EPalShooterFlagContainerPriority Priority, class FName FlagName, bool IsDisable);
	void SetDisableEndAim(class FName FlagName, bool IsDisable);
	void SetDisableLeftHandAttachFlag(class FName FlagName, bool IsDisable);
	void SetDisableReloadFlag(class FName FlagName, bool IsDisable);
	void SetDisableShootFlag(class FName FlagName, bool IsDisable);
	void SetDisableShootFlag_Layered(EPalShooterFlagContainerPriority Priority, class FName FlagName, bool IsDisable);
	void SetDisableWeaponChangeAnime(class FName FlagName, bool bIsUsed);
	void SetDisableWeaponForUI(bool Disable);
	void SetHiddenAttachWeapon(class FName FlagName, bool IsHidden);
	void SetOverrideWeaponType(EPalWeaponType Type);
	void SetShootingHold(bool IsHold);
	void SetTargetDirection(const struct FVector& Direction);
	void SetTargetDirection_ByServer(const struct FVector& Param_TargetDirection);
	void SetTargetDirection_ToServer(const struct FVector& Param_TargetDirection);
	void SetupInputComponent(class UInputComponent* InputComponent);
	void SetUsedLeftHand(class FName FlagName, bool bIsUsed);
	void SetUsedRightHand(class FName FlagName, bool bIsUsed);
	void StartAim();
	void StartAimDelegate__DelegateSignature();
	void StopPullTriggerAnime_forBP();
	void StopReload();
	void StopReload_ToALL(int32 ID);
	void StopReload_ToServer(int32 ID);
	void StopReloadInternal();
	void StopWeaponChangeAnimation();

	bool CanAim() const;
	bool CanAutoAim() const;
	bool CanChangeNextWeapon() const;
	bool CanChangeNextWeapon_Layered(EPalShooterFlagContainerPriority Priority) const;
	bool CanLeftHandAttach() const;
	bool CanReload() const;
	bool CanShoot() const;
	bool CanUseLeftHand() const;
	bool CanUseRightHand() const;
	bool CanUseWeapon(class APalWeaponBase* Weapon) const;
	float GetChangeWeaponAnimationWeight() const;
	const struct FRidingAnimationInfo GetCurrentRidingAnimationInfo() const;
	const struct FWeaponAnimationInfo GetCurrentWeaponAnimationInfo() const;
	class APalWeaponBase* GetHasWeapon() const;
	const struct FWeaponAnimationInfo GetPrevWeaponAnimationInfo() const;
	struct FVector GetTargetDirection() const;
	bool IsAiming() const;
	bool IsPlayShootingAnimation() const;
	bool IsReloading() const;
	bool IsShooting() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalShooterComponent">();
	}
	static class UPalShooterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalShooterComponent>();
	}
};
static_assert(alignof(UPalShooterComponent) == 0x000008, "Wrong alignment on UPalShooterComponent");
static_assert(sizeof(UPalShooterComponent) == 0x0009A0, "Wrong size on UPalShooterComponent");
static_assert(offsetof(UPalShooterComponent, OnChangeTargetDirectionDelegate) == 0x0000A8, "Member 'UPalShooterComponent::OnChangeTargetDirectionDelegate' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, OnStartAim) == 0x0000B8, "Member 'UPalShooterComponent::OnStartAim' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, OnEndAim) == 0x0000C8, "Member 'UPalShooterComponent::OnEndAim' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, OnPullTrigger) == 0x0000D8, "Member 'UPalShooterComponent::OnPullTrigger' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, OnReleaseTrigger) == 0x0000E8, "Member 'UPalShooterComponent::OnReleaseTrigger' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, OnChangeState) == 0x0000F8, "Member 'UPalShooterComponent::OnChangeState' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, OnWeaponNotifyDelegate) == 0x000108, "Member 'UPalShooterComponent::OnWeaponNotifyDelegate' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, OnEndShootingAnimationDelegate) == 0x000118, "Member 'UPalShooterComponent::OnEndShootingAnimationDelegate' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, OnChangeWeaponDelegate) == 0x000128, "Member 'UPalShooterComponent::OnChangeWeaponDelegate' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, OnReloadStartDelegate) == 0x000138, "Member 'UPalShooterComponent::OnReloadStartDelegate' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, OnReloadBulletDelegate) == 0x000148, "Member 'UPalShooterComponent::OnReloadBulletDelegate' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, OnUpdatedUsableHandFlagDelegate) == 0x000158, "Member 'UPalShooterComponent::OnUpdatedUsableHandFlagDelegate' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, WalkSpeedMultiplierInAim) == 0x000168, "Member 'UPalShooterComponent::WalkSpeedMultiplierInAim' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, WalkSpeedMultiplierInHipShoot) == 0x00016C, "Member 'UPalShooterComponent::WalkSpeedMultiplierInHipShoot' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, ChangeWeaponInterpTime) == 0x000170, "Member 'UPalShooterComponent::ChangeWeaponInterpTime' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, DefaultWeaponAnimeAssetBPSoftClassMap) == 0x000178, "Member 'UPalShooterComponent::DefaultWeaponAnimeAssetBPSoftClassMap' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, OtherWeaponAnimeAssetBPSoftClassMap) == 0x0001C8, "Member 'UPalShooterComponent::OtherWeaponAnimeAssetBPSoftClassMap' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, WeaponCategoryForPreLoad) == 0x000218, "Member 'UPalShooterComponent::WeaponCategoryForPreLoad' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, IsUseBlurUpdate) == 0x000268, "Member 'UPalShooterComponent::IsUseBlurUpdate' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, DefaultWeaponAnimeAssetMap) == 0x000270, "Member 'UPalShooterComponent::DefaultWeaponAnimeAssetMap' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, OtherWeaponAnimeAssetMap) == 0x0002C0, "Member 'UPalShooterComponent::OtherWeaponAnimeAssetMap' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, LoadedDefaultWeaponSet) == 0x000310, "Member 'UPalShooterComponent::LoadedDefaultWeaponSet' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, LoadedOtherWeaponSet) == 0x000360, "Member 'UPalShooterComponent::LoadedOtherWeaponSet' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, OverrideWeaponNotifyAnimationMap) == 0x0003B0, "Member 'UPalShooterComponent::OverrideWeaponNotifyAnimationMap' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, TargetDirection) == 0x000400, "Member 'UPalShooterComponent::TargetDirection' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, bIsAiming) == 0x000418, "Member 'UPalShooterComponent::bIsAiming' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, bIsShooting) == 0x000419, "Member 'UPalShooterComponent::bIsShooting' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, bIsRequestAim) == 0x00041A, "Member 'UPalShooterComponent::bIsRequestAim' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, bIsRequestPullTrigger) == 0x00041B, "Member 'UPalShooterComponent::bIsRequestPullTrigger' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, bIsReloading) == 0x00041C, "Member 'UPalShooterComponent::bIsReloading' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, UseControllerRotationYawFlags) == 0x000420, "Member 'UPalShooterComponent::UseControllerRotationYawFlags' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, HasWeapon) == 0x000470, "Member 'UPalShooterComponent::HasWeapon' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, CacheNextWeapon) == 0x000478, "Member 'UPalShooterComponent::CacheNextWeapon' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, PrevWeaponAnimationInfo) == 0x000480, "Member 'UPalShooterComponent::PrevWeaponAnimationInfo' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, bIsDisableShootingTemporarily) == 0x0006D8, "Member 'UPalShooterComponent::bIsDisableShootingTemporarily' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, DisableAimFlag) == 0x0006F0, "Member 'UPalShooterComponent::DisableAimFlag' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, DisableShootFlag) == 0x000700, "Member 'UPalShooterComponent::DisableShootFlag' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, DisableWeaponChange) == 0x0007B0, "Member 'UPalShooterComponent::DisableWeaponChange' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, HiddenWeapon) == 0x0007C0, "Member 'UPalShooterComponent::HiddenWeapon' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, PullTriggerCountDown) == 0x000960, "Member 'UPalShooterComponent::PullTriggerCountDown' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, PullTriggerCountDownCount) == 0x000964, "Member 'UPalShooterComponent::PullTriggerCountDownCount' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, ElapsedTimeSinceWeaponChange) == 0x000968, "Member 'UPalShooterComponent::ElapsedTimeSinceWeaponChange' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, OverrideWeaponType) == 0x00096C, "Member 'UPalShooterComponent::OverrideWeaponType' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, bUnstoppable) == 0x00096D, "Member 'UPalShooterComponent::bUnstoppable' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, bIsHoldTrigger) == 0x00096E, "Member 'UPalShooterComponent::bIsHoldTrigger' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, bBufferedInput) == 0x00096F, "Member 'UPalShooterComponent::bBufferedInput' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, bIsShootingHold) == 0x000970, "Member 'UPalShooterComponent::bIsShootingHold' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, bIsAttachRequest) == 0x000971, "Member 'UPalShooterComponent::bIsAttachRequest' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, NPCWeapon) == 0x000988, "Member 'UPalShooterComponent::NPCWeapon' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, CurrentBulletBlurRate) == 0x000990, "Member 'UPalShooterComponent::CurrentBulletBlurRate' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, RapidFireBlur) == 0x000994, "Member 'UPalShooterComponent::RapidFireBlur' has a wrong offset!");
static_assert(offsetof(UPalShooterComponent, RandomStream) == 0x000998, "Member 'UPalShooterComponent::RandomStream' has a wrong offset!");

// Class Pal.PalSpringArmComponent
// 0x0010 (0x03B0 - 0x03A0)
#pragma pack(push, 0x1)
class alignas(0x10) UPalSpringArmComponent : public USpringArmComponent
{
public:
	ECollisionChannel                             WaterProbeChannel;                                 // 0x03A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EBF[0x7];                                     // 0x03A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalSpringArmComponent">();
	}
	static class UPalSpringArmComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalSpringArmComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UPalSpringArmComponent) == 0x000010, "Wrong alignment on UPalSpringArmComponent");
static_assert(sizeof(UPalSpringArmComponent) == 0x0003B0, "Wrong size on UPalSpringArmComponent");
static_assert(offsetof(UPalSpringArmComponent, WaterProbeChannel) == 0x0003A0, "Member 'UPalSpringArmComponent::WaterProbeChannel' has a wrong offset!");

// Class Pal.PalShooterSpringArmComponent
// 0x0350 (0x0700 - 0x03B0)
class UPalShooterSpringArmComponent final : public UPalSpringArmComponent
{
public:
	float                                         CameraInterpTime;                                  // 0x03A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimingCameraLagSpeed;                              // 0x03AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            LengthInterpCurve;                                 // 0x03B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            OffsetInterpCurve;                                 // 0x03B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkCameraArmLength;                               // 0x03C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EC0[0x4];                                     // 0x03C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                WalkCameraOffset;                                  // 0x03C8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HipShootCameraArmLength;                           // 0x03E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EC1[0x4];                                     // 0x03E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HipShootCameraOffset;                              // 0x03E8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimCameraArmLength;                                // 0x0400(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EC2[0x4];                                     // 0x0404(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AimCameraOffset;                                   // 0x0408(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EPalWeaponType, struct FShooterSpringCameraParameter> DefaultWeaponStandCameraParameterMap;              // 0x0420(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<TSoftClassPtr<class UClass>, struct FShooterSpringCameraParameter> UniqueWeaponStandCameraParameterMap;               // 0x0470(0x0050)(Edit, NativeAccessSpecifierPublic)
	float                                         AirCameraArmLength;                                // 0x04C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EC3[0x4];                                     // 0x04C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AirCameraOffset;                                   // 0x04C8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirHipShootCameraArmLength;                        // 0x04E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EC4[0x4];                                     // 0x04E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AirHipShootCameraOffset;                           // 0x04E8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirAimCameraArmLength;                             // 0x0500(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EC5[0x4];                                     // 0x0504(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AirAimCameraOffset;                                // 0x0508(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlyCameraArmLength;                                // 0x0520(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EC6[0x4];                                     // 0x0524(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                FlyCameraOffset;                                   // 0x0528(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlyHipShootCameraArmLength;                        // 0x0540(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EC7[0x4];                                     // 0x0544(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                FlyHipShootCameraOffset;                           // 0x0548(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlyAimCameraArmLength;                             // 0x0560(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EC8[0x4];                                     // 0x0564(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                FlyAimCameraOffset;                                // 0x0568(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchCameraArmLength;                             // 0x0580(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EC9[0x4];                                     // 0x0584(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CrouchCameraOffset;                                // 0x0588(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchHipShootCameraArmLength;                     // 0x05A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2ECA[0x4];                                     // 0x05A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CrouchHipShootCameraOffset;                        // 0x05A8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchAimCameraArmLength;                          // 0x05C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2ECB[0x4];                                     // 0x05C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CrouchAimCameraOffset;                             // 0x05C8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlidingCameraArmLength;                            // 0x05E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2ECC[0x4];                                     // 0x05E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SlidingCameraOffset;                               // 0x05E8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlidingHipShootCameraArmLength;                    // 0x0600(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2ECD[0x4];                                     // 0x0604(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SlidingHipShootCameraOffset;                       // 0x0608(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlidingAimCameraArmLength;                         // 0x0620(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2ECE[0x4];                                     // 0x0624(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SlidingAimCameraOffset;                            // 0x0628(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeadCameraArmLength;                               // 0x0640(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2ECF[0x4];                                     // 0x0644(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DeadCameraOffset;                                  // 0x0648(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2ED0[0x48];                                    // 0x0660(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFixedPoint64                          PrevPlayerHp;                                      // 0x06A8(0x0008)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         DefaultCameraLagSpeed;                             // 0x06B0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2ED1[0x4];                                     // 0x06B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalShooterComponent*                   ShooterComponent;                                  // 0x06B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalCharacterMovementComponent*         MoveComponent;                                     // 0x06C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalCharacterParameterComponent*        ParameterComponent;                                // 0x06C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalDamageReactionComponent*            DamageReactionComponent;                           // 0x06D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFloatContainer                        ArmLengthScaleContainer;                           // 0x06D8(0x0010)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_2ED2[0x18];                                    // 0x06E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeArmParameter_forBP();
	void OnChangeCrouch(class UPalCharacterMovementComponent* Component, bool IsCrouch);
	void OnChangeGraphicsDelegate(const struct FPalOptionGraphicsSettings& PrevSettings, const struct FPalOptionGraphicsSettings& NewSettings);
	void OnChangeShootState(bool IsAim, bool IsShooting);
	void OnChangeSliding(class UPalCharacterMovementComponent* Component, bool IsSliding);
	void OnCompleteInitializeParameter(class APalCharacter* InCharacter);
	void OnDead(const struct FPalDeadInfo& DeadInfo);
	void OnDyingDeadEnd(class APalPlayerCharacter* PlayerCharacter);
	void OnEndAim();
	void OnFly(class UPalCharacterMovementComponent* Component);
	void OnJump(class UPalCharacterMovementComponent* Component);
	void OnLanded(class UPalCharacterMovementComponent* Component, const struct FHitResult& Hit);
	void OnPullTrigger();
	void OnReleaseTrigger();
	void OnStartAim();
	void OnUpdatePlayerHp(const struct FFixedPoint64& NowHP, const struct FFixedPoint64& NowMaxHP);
	void RegisterAdditionalOffset(const struct FShooterSpringCameraAdditionalOffset& Offset);
	void ResetCameraDirection();
	void ResetCameraInterp();
	void SetCameraLengthScale(class FName FlagName, float Scale);
	void UnregisterAdditionalOffset(const class FName& FlgName);
	void UnregisterAdditionalOffsets();
	void UpdateCameraInterp(float DeltaTime);

	float GetCurrentCameraArmLength() const;
	struct FVector GetCurrentCameraOffset() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalShooterSpringArmComponent">();
	}
	static class UPalShooterSpringArmComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalShooterSpringArmComponent>();
	}
};
static_assert(alignof(UPalShooterSpringArmComponent) == 0x000010, "Wrong alignment on UPalShooterSpringArmComponent");
static_assert(sizeof(UPalShooterSpringArmComponent) == 0x000700, "Wrong size on UPalShooterSpringArmComponent");
static_assert(offsetof(UPalShooterSpringArmComponent, CameraInterpTime) == 0x0003A8, "Member 'UPalShooterSpringArmComponent::CameraInterpTime' has a wrong offset!");
static_assert(offsetof(UPalShooterSpringArmComponent, AimingCameraLagSpeed) == 0x0003AC, "Member 'UPalShooterSpringArmComponent::AimingCameraLagSpeed' has a wrong offset!");
static_assert(offsetof(UPalShooterSpringArmComponent, LengthInterpCurve) == 0x0003B0, "Member 'UPalShooterSpringArmComponent::LengthInterpCurve' has a wrong offset!");
static_assert(offsetof(UPalShooterSpringArmComponent, OffsetInterpCurve) == 0x0003B8, "Member 'UPalShooterSpringArmComponent::OffsetInterpCurve' has a wrong offset!");
static_assert(offsetof(UPalShooterSpringArmComponent, WalkCameraArmLength) == 0x0003C0, "Member 'UPalShooterSpringArmComponent::WalkCameraArmLength' has a wrong offset!");
static_assert(offsetof(UPalShooterSpringArmComponent, WalkCameraOffset) == 0x0003C8, "Member 'UPalShooterSpringArmComponent::WalkCameraOffset' has a wrong offset!");
static_assert(offsetof(UPalShooterSpringArmComponent, HipShootCameraArmLength) == 0x0003E0, "Member 'UPalShooterSpringArmComponent::HipShootCameraArmLength' has a wrong offset!");
static_assert(offsetof(UPalShooterSpringArmComponent, HipShootCameraOffset) == 0x0003E8, "Member 'UPalShooterSpringArmComponent::HipShootCameraOffset' has a wrong offset!");
static_assert(offsetof(UPalShooterSpringArmComponent, AimCameraArmLength) == 0x000400, "Member 'UPalShooterSpringArmComponent::AimCameraArmLength' has a wrong offset!");
static_assert(offsetof(UPalShooterSpringArmComponent, AimCameraOffset) == 0x000408, "Member 'UPalShooterSpringArmComponent::AimCameraOffset' has a wrong offset!");
static_assert(offsetof(UPalShooterSpringArmComponent, DefaultWeaponStandCameraParameterMap) == 0x000420, "Member 'UPalShooterSpringArmComponent::DefaultWeaponStandCameraParameterMap' has a wrong offset!");
static_assert(offsetof(UPalShooterSpringArmComponent, UniqueWeaponStandCameraParameterMap) == 0x000470, "Member 'UPalShooterSpringArmComponent::UniqueWeaponStandCameraParameterMap' has a wrong offset!");
static_assert(offsetof(UPalShooterSpringArmComponent, AirCameraArmLength) == 0x0004C0, "Member 'UPalShooterSpringArmComponent::AirCameraArmLength' has a wrong offset!");
static_assert(offsetof(UPalShooterSpringArmComponent, AirCameraOffset) == 0x0004C8, "Member 'UPalShooterSpringArmComponent::AirCameraOffset' has a wrong offset!");
static_assert(offsetof(UPalShooterSpringArmComponent, AirHipShootCameraArmLength) == 0x0004E0, "Member 'UPalShooterSpringArmComponent::AirHipShootCameraArmLength' has a wrong offset!");
static_assert(offsetof(UPalShooterSpringArmComponent, AirHipShootCameraOffset) == 0x0004E8, "Member 'UPalShooterSpringArmComponent::AirHipShootCameraOffset' has a wrong offset!");
static_assert(offsetof(UPalShooterSpringArmComponent, AirAimCameraArmLength) == 0x000500, "Member 'UPalShooterSpringArmComponent::AirAimCameraArmLength' has a wrong offset!");
static_assert(offsetof(UPalShooterSpringArmComponent, AirAimCameraOffset) == 0x000508, "Member 'UPalShooterSpringArmComponent::AirAimCameraOffset' has a wrong offset!");
static_assert(offsetof(UPalShooterSpringArmComponent, FlyCameraArmLength) == 0x000520, "Member 'UPalShooterSpringArmComponent::FlyCameraArmLength' has a wrong offset!");
static_assert(offsetof(UPalShooterSpringArmComponent, FlyCameraOffset) == 0x000528, "Member 'UPalShooterSpringArmComponent::FlyCameraOffset' has a wrong offset!");
static_assert(offsetof(UPalShooterSpringArmComponent, FlyHipShootCameraArmLength) == 0x000540, "Member 'UPalShooterSpringArmComponent::FlyHipShootCameraArmLength' has a wrong offset!");
static_assert(offsetof(UPalShooterSpringArmComponent, FlyHipShootCameraOffset) == 0x000548, "Member 'UPalShooterSpringArmComponent::FlyHipShootCameraOffset' has a wrong offset!");
static_assert(offsetof(UPalShooterSpringArmComponent, FlyAimCameraArmLength) == 0x000560, "Member 'UPalShooterSpringArmComponent::FlyAimCameraArmLength' has a wrong offset!");
static_assert(offsetof(UPalShooterSpringArmComponent, FlyAimCameraOffset) == 0x000568, "Member 'UPalShooterSpringArmComponent::FlyAimCameraOffset' has a wrong offset!");
static_assert(offsetof(UPalShooterSpringArmComponent, CrouchCameraArmLength) == 0x000580, "Member 'UPalShooterSpringArmComponent::CrouchCameraArmLength' has a wrong offset!");
static_assert(offsetof(UPalShooterSpringArmComponent, CrouchCameraOffset) == 0x000588, "Member 'UPalShooterSpringArmComponent::CrouchCameraOffset' has a wrong offset!");
static_assert(offsetof(UPalShooterSpringArmComponent, CrouchHipShootCameraArmLength) == 0x0005A0, "Member 'UPalShooterSpringArmComponent::CrouchHipShootCameraArmLength' has a wrong offset!");
static_assert(offsetof(UPalShooterSpringArmComponent, CrouchHipShootCameraOffset) == 0x0005A8, "Member 'UPalShooterSpringArmComponent::CrouchHipShootCameraOffset' has a wrong offset!");
static_assert(offsetof(UPalShooterSpringArmComponent, CrouchAimCameraArmLength) == 0x0005C0, "Member 'UPalShooterSpringArmComponent::CrouchAimCameraArmLength' has a wrong offset!");
static_assert(offsetof(UPalShooterSpringArmComponent, CrouchAimCameraOffset) == 0x0005C8, "Member 'UPalShooterSpringArmComponent::CrouchAimCameraOffset' has a wrong offset!");
static_assert(offsetof(UPalShooterSpringArmComponent, SlidingCameraArmLength) == 0x0005E0, "Member 'UPalShooterSpringArmComponent::SlidingCameraArmLength' has a wrong offset!");
static_assert(offsetof(UPalShooterSpringArmComponent, SlidingCameraOffset) == 0x0005E8, "Member 'UPalShooterSpringArmComponent::SlidingCameraOffset' has a wrong offset!");
static_assert(offsetof(UPalShooterSpringArmComponent, SlidingHipShootCameraArmLength) == 0x000600, "Member 'UPalShooterSpringArmComponent::SlidingHipShootCameraArmLength' has a wrong offset!");
static_assert(offsetof(UPalShooterSpringArmComponent, SlidingHipShootCameraOffset) == 0x000608, "Member 'UPalShooterSpringArmComponent::SlidingHipShootCameraOffset' has a wrong offset!");
static_assert(offsetof(UPalShooterSpringArmComponent, SlidingAimCameraArmLength) == 0x000620, "Member 'UPalShooterSpringArmComponent::SlidingAimCameraArmLength' has a wrong offset!");
static_assert(offsetof(UPalShooterSpringArmComponent, SlidingAimCameraOffset) == 0x000628, "Member 'UPalShooterSpringArmComponent::SlidingAimCameraOffset' has a wrong offset!");
static_assert(offsetof(UPalShooterSpringArmComponent, DeadCameraArmLength) == 0x000640, "Member 'UPalShooterSpringArmComponent::DeadCameraArmLength' has a wrong offset!");
static_assert(offsetof(UPalShooterSpringArmComponent, DeadCameraOffset) == 0x000648, "Member 'UPalShooterSpringArmComponent::DeadCameraOffset' has a wrong offset!");
static_assert(offsetof(UPalShooterSpringArmComponent, PrevPlayerHp) == 0x0006A8, "Member 'UPalShooterSpringArmComponent::PrevPlayerHp' has a wrong offset!");
static_assert(offsetof(UPalShooterSpringArmComponent, DefaultCameraLagSpeed) == 0x0006B0, "Member 'UPalShooterSpringArmComponent::DefaultCameraLagSpeed' has a wrong offset!");
static_assert(offsetof(UPalShooterSpringArmComponent, ShooterComponent) == 0x0006B8, "Member 'UPalShooterSpringArmComponent::ShooterComponent' has a wrong offset!");
static_assert(offsetof(UPalShooterSpringArmComponent, MoveComponent) == 0x0006C0, "Member 'UPalShooterSpringArmComponent::MoveComponent' has a wrong offset!");
static_assert(offsetof(UPalShooterSpringArmComponent, ParameterComponent) == 0x0006C8, "Member 'UPalShooterSpringArmComponent::ParameterComponent' has a wrong offset!");
static_assert(offsetof(UPalShooterSpringArmComponent, DamageReactionComponent) == 0x0006D0, "Member 'UPalShooterSpringArmComponent::DamageReactionComponent' has a wrong offset!");
static_assert(offsetof(UPalShooterSpringArmComponent, ArmLengthScaleContainer) == 0x0006D8, "Member 'UPalShooterSpringArmComponent::ArmLengthScaleContainer' has a wrong offset!");

// Class Pal.PalShopManager
// 0x00E0 (0x0150 - 0x0070)
class UPalShopManager final : public UPalWorldSubsystem
{
public:
	uint8                                         Pad_2ED5[0x8];                                     // 0x0070(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnRecievedBuyResultDelegate;                       // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnReceivedDroppedPalDataDelegate;                  // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<struct FGuid, class UPalShopBase*>       CreatedItemShopMap_ForServer;                      // 0x0098(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<struct FGuid, class UPalShopBase*>       CreatedPalShopMap_ForServer;                       // 0x00E8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TArray<struct FPalDroppedPalProductDataForShop> LocalDroppedPalData;                               // 0x0138(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UPalShopProduct_LostPal*                LostPalProduct_Tmp;                                // 0x0148(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalShopManager">();
	}
	static class UPalShopManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalShopManager>();
	}
};
static_assert(alignof(UPalShopManager) == 0x000008, "Wrong alignment on UPalShopManager");
static_assert(sizeof(UPalShopManager) == 0x000150, "Wrong size on UPalShopManager");
static_assert(offsetof(UPalShopManager, OnRecievedBuyResultDelegate) == 0x000078, "Member 'UPalShopManager::OnRecievedBuyResultDelegate' has a wrong offset!");
static_assert(offsetof(UPalShopManager, OnReceivedDroppedPalDataDelegate) == 0x000088, "Member 'UPalShopManager::OnReceivedDroppedPalDataDelegate' has a wrong offset!");
static_assert(offsetof(UPalShopManager, CreatedItemShopMap_ForServer) == 0x000098, "Member 'UPalShopManager::CreatedItemShopMap_ForServer' has a wrong offset!");
static_assert(offsetof(UPalShopManager, CreatedPalShopMap_ForServer) == 0x0000E8, "Member 'UPalShopManager::CreatedPalShopMap_ForServer' has a wrong offset!");
static_assert(offsetof(UPalShopManager, LocalDroppedPalData) == 0x000138, "Member 'UPalShopManager::LocalDroppedPalData' has a wrong offset!");
static_assert(offsetof(UPalShopManager, LostPalProduct_Tmp) == 0x000148, "Member 'UPalShopManager::LostPalProduct_Tmp' has a wrong offset!");

// Class Pal.PalShopProductBase
// 0x0040 (0x0068 - 0x0028)
class UPalShopProductBase : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnUpdateNowStockNumDelegate;                       // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateMaxStockNumDelegate;                       // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGuid                                  MyProductID;                                       // 0x0048(0x0010)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsInfinityStockFlag;                               // 0x0058(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2ED6[0x3];                                     // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StockNum;                                          // 0x005C(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MaxStockNum;                                       // 0x0060(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsValidProductFlag;                                // 0x0064(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2ED7[0x3];                                     // 0x0065(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetId(struct FGuid* OutID);
	bool IsValidProduct();
	void OnRep_MaxStockNum();
	void OnRep_StockNum();
	void UpdateMaxStockNumDelegate__DelegateSignature(int32 Param_MaxStockNum);
	void UpdateNowStockNumDelegate__DelegateSignature(int32 NowStock);

	bool CanBuy_LocalPlayer() const;
	int32 GetMaxBuyNum_LocalPlayer() const;
	int32 GetMaxStockNum() const;
	void GetProductNameText(class FText* OutText) const;
	int32 GetRemainStockNum() const;
	bool IsInfinityStock() const;
	bool IsSoldout() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalShopProductBase">();
	}
	static class UPalShopProductBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalShopProductBase>();
	}
};
static_assert(alignof(UPalShopProductBase) == 0x000008, "Wrong alignment on UPalShopProductBase");
static_assert(sizeof(UPalShopProductBase) == 0x000068, "Wrong size on UPalShopProductBase");
static_assert(offsetof(UPalShopProductBase, OnUpdateNowStockNumDelegate) == 0x000028, "Member 'UPalShopProductBase::OnUpdateNowStockNumDelegate' has a wrong offset!");
static_assert(offsetof(UPalShopProductBase, OnUpdateMaxStockNumDelegate) == 0x000038, "Member 'UPalShopProductBase::OnUpdateMaxStockNumDelegate' has a wrong offset!");
static_assert(offsetof(UPalShopProductBase, MyProductID) == 0x000048, "Member 'UPalShopProductBase::MyProductID' has a wrong offset!");
static_assert(offsetof(UPalShopProductBase, IsInfinityStockFlag) == 0x000058, "Member 'UPalShopProductBase::IsInfinityStockFlag' has a wrong offset!");
static_assert(offsetof(UPalShopProductBase, StockNum) == 0x00005C, "Member 'UPalShopProductBase::StockNum' has a wrong offset!");
static_assert(offsetof(UPalShopProductBase, MaxStockNum) == 0x000060, "Member 'UPalShopProductBase::MaxStockNum' has a wrong offset!");
static_assert(offsetof(UPalShopProductBase, IsValidProductFlag) == 0x000064, "Member 'UPalShopProductBase::IsValidProductFlag' has a wrong offset!");

// Class Pal.PalShopProduct_PalSaveParameter
// 0x0290 (0x02F8 - 0x0068)
class UPalShopProduct_PalSaveParameter : public UPalShopProductBase
{
public:
	struct FPalIndividualCharacterSaveParameter   ProductPalSaveParameter;                           // 0x0068(0x0280)(Net, NativeAccessSpecifierPrivate)
	struct FGuid                                  ReservedPlayerUID;                                 // 0x02E8(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnCreatedBuyPal(const struct FPalInstanceID& CreatedPalInstanceID);

	int32 GetPrice() const;
	void GetProductPalParameter(struct FPalIndividualCharacterSaveParameter* OutParameter) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalShopProduct_PalSaveParameter">();
	}
	static class UPalShopProduct_PalSaveParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalShopProduct_PalSaveParameter>();
	}
};
static_assert(alignof(UPalShopProduct_PalSaveParameter) == 0x000008, "Wrong alignment on UPalShopProduct_PalSaveParameter");
static_assert(sizeof(UPalShopProduct_PalSaveParameter) == 0x0002F8, "Wrong size on UPalShopProduct_PalSaveParameter");
static_assert(offsetof(UPalShopProduct_PalSaveParameter, ProductPalSaveParameter) == 0x000068, "Member 'UPalShopProduct_PalSaveParameter::ProductPalSaveParameter' has a wrong offset!");
static_assert(offsetof(UPalShopProduct_PalSaveParameter, ReservedPlayerUID) == 0x0002E8, "Member 'UPalShopProduct_PalSaveParameter::ReservedPlayerUID' has a wrong offset!");

// Class Pal.PalShopProduct_LostPal
// 0x0010 (0x0308 - 0x02F8)
class UPalShopProduct_LostPal final : public UPalShopProduct_PalSaveParameter
{
public:
	uint8                                         Pad_2ED8[0x10];                                    // 0x02F8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalShopProduct_LostPal">();
	}
	static class UPalShopProduct_LostPal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalShopProduct_LostPal>();
	}
};
static_assert(alignof(UPalShopProduct_LostPal) == 0x000008, "Wrong alignment on UPalShopProduct_LostPal");
static_assert(sizeof(UPalShopProduct_LostPal) == 0x000308, "Wrong size on UPalShopProduct_LostPal");

// Class Pal.PalShopProduct_TradeItem
// 0x0010 (0x0078 - 0x0068)
class UPalShopProduct_TradeItem final : public UPalShopProductBase
{
public:
	class FName                                   ProductStaticItemID;                               // 0x0068(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BuyRate;                                           // 0x0070(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2ED9[0x4];                                     // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetProductStaticItemID(class FName* OutStaticID) const;
	int32 GetRequireMoney() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalShopProduct_TradeItem">();
	}
	static class UPalShopProduct_TradeItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalShopProduct_TradeItem>();
	}
};
static_assert(alignof(UPalShopProduct_TradeItem) == 0x000008, "Wrong alignment on UPalShopProduct_TradeItem");
static_assert(sizeof(UPalShopProduct_TradeItem) == 0x000078, "Wrong size on UPalShopProduct_TradeItem");
static_assert(offsetof(UPalShopProduct_TradeItem, ProductStaticItemID) == 0x000068, "Member 'UPalShopProduct_TradeItem::ProductStaticItemID' has a wrong offset!");
static_assert(offsetof(UPalShopProduct_TradeItem, BuyRate) == 0x000070, "Member 'UPalShopProduct_TradeItem::BuyRate' has a wrong offset!");

// Class Pal.PalSimpleInteractableObject
// 0x0008 (0x0298 - 0x0290)
class APalSimpleInteractableObject final : public AActor
{
public:
	uint8                                         Pad_2EDA[0x8];                                     // 0x0290(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	EPalInteractiveObjectIndicatorType GetIndicatorType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalSimpleInteractableObject">();
	}
	static class APalSimpleInteractableObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalSimpleInteractableObject>();
	}
};
static_assert(alignof(APalSimpleInteractableObject) == 0x000008, "Wrong alignment on APalSimpleInteractableObject");
static_assert(sizeof(APalSimpleInteractableObject) == 0x000298, "Wrong size on APalSimpleInteractableObject");

// Class Pal.PalSkeletalMeshComponent
// 0x0230 (0x11B0 - 0x0F80)
class UPalSkeletalMeshComponent final : public USkeletalMeshComponent
{
public:
	bool                                          bCanRagdoll;                                       // 0x0F80(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EDB[0x3];                                     // 0x0F81(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClavicleAdjustDegree;                              // 0x0F84(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEnableGroundTilt;                               // 0x0F88(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EDC[0x3];                                     // 0x0F89(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PitchAngle;                                        // 0x0F8C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RollAngle;                                         // 0x0F90(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TiltingInterpTime;                                 // 0x0F94(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DefaultLocation;                                   // 0x0F98(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               DefaultRotator;                                    // 0x0FB0(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                BeginTiltVector;                                   // 0x0FC8(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndTiltVector;                                     // 0x0FE0(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TiltTimer;                                         // 0x0FF8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EDD[0x4];                                     // 0x0FFC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnAppliedMakeInfo;                                 // 0x1000(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FFlagContainer                         DisableTilt;                                       // 0x1010(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	struct FFloatContainer                        ScaleFloatContainer;                               // 0x1060(0x0010)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	struct FFloatContainer                        PitchFloatContainer;                               // 0x1070(0x0010)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	struct FFloatContainer                        AnimRateScaleFloatContainer;                       // 0x1080(0x0010)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	float                                         DefaultAnimRateScale;                              // 0x1090(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2EDE[0x4];                                     // 0x1094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DefaultScale3D;                                    // 0x1098(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPalSkeletalMeshType                          PalSkeletalMeshType;                               // 0x10B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2EDF[0x3];                                     // 0x10B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CharcterMakeMorphMax;                              // 0x10B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2EE0[0x30];                                    // 0x10B8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ItemName;                                          // 0x10E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   BodyTypeName;                                      // 0x10F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          DisableChangeMesh_ByPlayerDead;                    // 0x10F8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2EE1[0x17];                                    // 0x10F9(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	EVisibilityBasedAnimTickOption                DefaultTickOption;                                 // 0x1110(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2EE2[0x3];                                     // 0x1111(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPalPlayerDataCharacterMakeInfo        CharacterMakeInfo;                                 // 0x1114(0x0094)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2EE3[0x8];                                     // 0x11A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AppliedMakeInfoDelegate__DelegateSignature(const class UPalSkeletalMeshComponent* SkeletalMeshComponent);
	void ChangeVisibilityAnimTick(EPalSkeletalTickLayer SkeletalTickLayer);
	float GetAnimRateScale();
	void ResetTransformToDefault();
	void SetCharacterMakeInfo(const struct FPalPlayerDataCharacterMakeInfo& Info);
	void SetDisableChangeMesh(bool Disable);
	void SetEnableRagdollCCD(bool Param_IsActive);
	void SetRuntimeAnimRateScale(class FName FlagName, float RateScale);
	void SetRuntimePitch(class FName FlagName, float Pitch);
	void SetRuntimeScale(class FName FlagName, float Scale);
	void SetTiltDisable(class FName FlagName, bool bIsDisable);

	EPalSkeletalMeshType GetPalSkeletalMeshType() const;
	bool IsDisableTilt() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalSkeletalMeshComponent">();
	}
	static class UPalSkeletalMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalSkeletalMeshComponent>();
	}
};
static_assert(alignof(UPalSkeletalMeshComponent) == 0x000010, "Wrong alignment on UPalSkeletalMeshComponent");
static_assert(sizeof(UPalSkeletalMeshComponent) == 0x0011B0, "Wrong size on UPalSkeletalMeshComponent");
static_assert(offsetof(UPalSkeletalMeshComponent, bCanRagdoll) == 0x000F80, "Member 'UPalSkeletalMeshComponent::bCanRagdoll' has a wrong offset!");
static_assert(offsetof(UPalSkeletalMeshComponent, ClavicleAdjustDegree) == 0x000F84, "Member 'UPalSkeletalMeshComponent::ClavicleAdjustDegree' has a wrong offset!");
static_assert(offsetof(UPalSkeletalMeshComponent, bIsEnableGroundTilt) == 0x000F88, "Member 'UPalSkeletalMeshComponent::bIsEnableGroundTilt' has a wrong offset!");
static_assert(offsetof(UPalSkeletalMeshComponent, PitchAngle) == 0x000F8C, "Member 'UPalSkeletalMeshComponent::PitchAngle' has a wrong offset!");
static_assert(offsetof(UPalSkeletalMeshComponent, RollAngle) == 0x000F90, "Member 'UPalSkeletalMeshComponent::RollAngle' has a wrong offset!");
static_assert(offsetof(UPalSkeletalMeshComponent, TiltingInterpTime) == 0x000F94, "Member 'UPalSkeletalMeshComponent::TiltingInterpTime' has a wrong offset!");
static_assert(offsetof(UPalSkeletalMeshComponent, DefaultLocation) == 0x000F98, "Member 'UPalSkeletalMeshComponent::DefaultLocation' has a wrong offset!");
static_assert(offsetof(UPalSkeletalMeshComponent, DefaultRotator) == 0x000FB0, "Member 'UPalSkeletalMeshComponent::DefaultRotator' has a wrong offset!");
static_assert(offsetof(UPalSkeletalMeshComponent, BeginTiltVector) == 0x000FC8, "Member 'UPalSkeletalMeshComponent::BeginTiltVector' has a wrong offset!");
static_assert(offsetof(UPalSkeletalMeshComponent, EndTiltVector) == 0x000FE0, "Member 'UPalSkeletalMeshComponent::EndTiltVector' has a wrong offset!");
static_assert(offsetof(UPalSkeletalMeshComponent, TiltTimer) == 0x000FF8, "Member 'UPalSkeletalMeshComponent::TiltTimer' has a wrong offset!");
static_assert(offsetof(UPalSkeletalMeshComponent, OnAppliedMakeInfo) == 0x001000, "Member 'UPalSkeletalMeshComponent::OnAppliedMakeInfo' has a wrong offset!");
static_assert(offsetof(UPalSkeletalMeshComponent, DisableTilt) == 0x001010, "Member 'UPalSkeletalMeshComponent::DisableTilt' has a wrong offset!");
static_assert(offsetof(UPalSkeletalMeshComponent, ScaleFloatContainer) == 0x001060, "Member 'UPalSkeletalMeshComponent::ScaleFloatContainer' has a wrong offset!");
static_assert(offsetof(UPalSkeletalMeshComponent, PitchFloatContainer) == 0x001070, "Member 'UPalSkeletalMeshComponent::PitchFloatContainer' has a wrong offset!");
static_assert(offsetof(UPalSkeletalMeshComponent, AnimRateScaleFloatContainer) == 0x001080, "Member 'UPalSkeletalMeshComponent::AnimRateScaleFloatContainer' has a wrong offset!");
static_assert(offsetof(UPalSkeletalMeshComponent, DefaultAnimRateScale) == 0x001090, "Member 'UPalSkeletalMeshComponent::DefaultAnimRateScale' has a wrong offset!");
static_assert(offsetof(UPalSkeletalMeshComponent, DefaultScale3D) == 0x001098, "Member 'UPalSkeletalMeshComponent::DefaultScale3D' has a wrong offset!");
static_assert(offsetof(UPalSkeletalMeshComponent, PalSkeletalMeshType) == 0x0010B0, "Member 'UPalSkeletalMeshComponent::PalSkeletalMeshType' has a wrong offset!");
static_assert(offsetof(UPalSkeletalMeshComponent, CharcterMakeMorphMax) == 0x0010B4, "Member 'UPalSkeletalMeshComponent::CharcterMakeMorphMax' has a wrong offset!");
static_assert(offsetof(UPalSkeletalMeshComponent, ItemName) == 0x0010E8, "Member 'UPalSkeletalMeshComponent::ItemName' has a wrong offset!");
static_assert(offsetof(UPalSkeletalMeshComponent, BodyTypeName) == 0x0010F0, "Member 'UPalSkeletalMeshComponent::BodyTypeName' has a wrong offset!");
static_assert(offsetof(UPalSkeletalMeshComponent, DisableChangeMesh_ByPlayerDead) == 0x0010F8, "Member 'UPalSkeletalMeshComponent::DisableChangeMesh_ByPlayerDead' has a wrong offset!");
static_assert(offsetof(UPalSkeletalMeshComponent, DefaultTickOption) == 0x001110, "Member 'UPalSkeletalMeshComponent::DefaultTickOption' has a wrong offset!");
static_assert(offsetof(UPalSkeletalMeshComponent, CharacterMakeInfo) == 0x001114, "Member 'UPalSkeletalMeshComponent::CharacterMakeInfo' has a wrong offset!");

// Class Pal.PalSkillDamageReactionComponent
// 0x0020 (0x00C0 - 0x00A0)
class UPalSkillDamageReactionComponent final : public UActorComponent
{
public:
	uint8                                         Pad_2EE5[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnDamageDelegate;                                  // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UPalHitEffectSlot*                      EffectSlot;                                        // 0x00B8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalSkillDamageReactionComponent">();
	}
	static class UPalSkillDamageReactionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalSkillDamageReactionComponent>();
	}
};
static_assert(alignof(UPalSkillDamageReactionComponent) == 0x000008, "Wrong alignment on UPalSkillDamageReactionComponent");
static_assert(sizeof(UPalSkillDamageReactionComponent) == 0x0000C0, "Wrong size on UPalSkillDamageReactionComponent");
static_assert(offsetof(UPalSkillDamageReactionComponent, OnDamageDelegate) == 0x0000A8, "Member 'UPalSkillDamageReactionComponent::OnDamageDelegate' has a wrong offset!");
static_assert(offsetof(UPalSkillDamageReactionComponent, EffectSlot) == 0x0000B8, "Member 'UPalSkillDamageReactionComponent::EffectSlot' has a wrong offset!");

// Class Pal.PalSkyCreatorLightingVolume
// 0x0050 (0x02E0 - 0x0290)
class APalSkyCreatorLightingVolume : public AActor
{
public:
	int32                                         Priority;                                          // 0x0290(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransitionSpeed;                                   // 0x0294(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           RayleighScattering;                                // 0x0298(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RayleighExponentialDistribution;                   // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LightAlbedo;                                       // 0x02AC(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LightColor;                                        // 0x02BC(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkyLightIntensity;                                 // 0x02CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOverrideSkyLightIntensity;                       // 0x02D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EE6[0x7];                                     // 0x02D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class APalLightingVolumeController*           VolumeController;                                  // 0x02D8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnEndOverlap(class AActor* OtherActor);
	void OnOverlap(class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalSkyCreatorLightingVolume">();
	}
	static class APalSkyCreatorLightingVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalSkyCreatorLightingVolume>();
	}
};
static_assert(alignof(APalSkyCreatorLightingVolume) == 0x000008, "Wrong alignment on APalSkyCreatorLightingVolume");
static_assert(sizeof(APalSkyCreatorLightingVolume) == 0x0002E0, "Wrong size on APalSkyCreatorLightingVolume");
static_assert(offsetof(APalSkyCreatorLightingVolume, Priority) == 0x000290, "Member 'APalSkyCreatorLightingVolume::Priority' has a wrong offset!");
static_assert(offsetof(APalSkyCreatorLightingVolume, TransitionSpeed) == 0x000294, "Member 'APalSkyCreatorLightingVolume::TransitionSpeed' has a wrong offset!");
static_assert(offsetof(APalSkyCreatorLightingVolume, RayleighScattering) == 0x000298, "Member 'APalSkyCreatorLightingVolume::RayleighScattering' has a wrong offset!");
static_assert(offsetof(APalSkyCreatorLightingVolume, RayleighExponentialDistribution) == 0x0002A8, "Member 'APalSkyCreatorLightingVolume::RayleighExponentialDistribution' has a wrong offset!");
static_assert(offsetof(APalSkyCreatorLightingVolume, LightAlbedo) == 0x0002AC, "Member 'APalSkyCreatorLightingVolume::LightAlbedo' has a wrong offset!");
static_assert(offsetof(APalSkyCreatorLightingVolume, LightColor) == 0x0002BC, "Member 'APalSkyCreatorLightingVolume::LightColor' has a wrong offset!");
static_assert(offsetof(APalSkyCreatorLightingVolume, SkyLightIntensity) == 0x0002CC, "Member 'APalSkyCreatorLightingVolume::SkyLightIntensity' has a wrong offset!");
static_assert(offsetof(APalSkyCreatorLightingVolume, IsOverrideSkyLightIntensity) == 0x0002D0, "Member 'APalSkyCreatorLightingVolume::IsOverrideSkyLightIntensity' has a wrong offset!");
static_assert(offsetof(APalSkyCreatorLightingVolume, VolumeController) == 0x0002D8, "Member 'APalSkyCreatorLightingVolume::VolumeController' has a wrong offset!");

// Class Pal.PalSkyLightVolume
// 0x0010 (0x02A0 - 0x0290)
class APalSkyLightVolume final : public AActor
{
public:
	class USkyLightComponent*                     Component;                                         // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bEnabled : 1;                                      // 0x0298(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2EE7[0x3];                                     // 0x0299(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDisableEnabledFlag;                               // 0x029C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2EE8[0x3];                                     // 0x029D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_bEnabled();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalSkyLightVolume">();
	}
	static class APalSkyLightVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalSkyLightVolume>();
	}
};
static_assert(alignof(APalSkyLightVolume) == 0x000008, "Wrong alignment on APalSkyLightVolume");
static_assert(sizeof(APalSkyLightVolume) == 0x0002A0, "Wrong size on APalSkyLightVolume");
static_assert(offsetof(APalSkyLightVolume, Component) == 0x000290, "Member 'APalSkyLightVolume::Component' has a wrong offset!");
static_assert(offsetof(APalSkyLightVolume, bDisableEnabledFlag) == 0x00029C, "Member 'APalSkyLightVolume::bDisableEnabledFlag' has a wrong offset!");

// Class Pal.PalSoundDebugModel
// 0x0000 (0x0290 - 0x0290)
class APalSoundDebugModel final : public AActor
{
public:
	void Initialize(class UAkAudioEvent* AudioEvent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalSoundDebugModel">();
	}
	static class APalSoundDebugModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalSoundDebugModel>();
	}
};
static_assert(alignof(APalSoundDebugModel) == 0x000008, "Wrong alignment on APalSoundDebugModel");
static_assert(sizeof(APalSoundDebugModel) == 0x000290, "Wrong size on APalSoundDebugModel");

// Class Pal.PalSoundPlayer
// 0x00E0 (0x0108 - 0x0028)
class UPalSoundPlayer final : public UObject
{
public:
	TDelegate<void(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)> AkCallbackOuter;                                   // 0x0028(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StopWhenOwnerDestroyed;                            // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EE9[0x7];                                     // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        OwnerComponent;                                    // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkComponent*                           AkComponent;                                       // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   OwnerAttachPointName;                              // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TDelegate<void(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)> AkCallback;                                        // 0x0058(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<int32, struct FPalSoundPlayingParameter> PlaySoundParameters;                               // 0x0068(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class FName, float>                      OutputBusVolumes;                                  // 0x00B8(0x0050)(NativeAccessSpecifierPrivate)

public:
	void ClearOutputBusVolume(class FName Param_Name);
	void FadeOutByPlayingId(int32 PlayingID, int32 FadeOutDuration);
	bool GetOutputBusVolume(class FName Param_Name, float* Volume);
	struct FVector GetOwnerLocation();
	struct FRotator GetOwnerRotation();
	struct FVector GetWorldLocation();
	void Initialize();
	void OnAkPostEventCallback(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo);
	int32 PlaySound(class UAkAudioEvent* AudioEvent, const struct FPalSoundOptions& Options);
	void PostTrigger(const class FString& Trigger);
	void SetOcclusionRefreshInterval(float Interval);
	void SetOutputBusVolume(class FName Param_Name, float Volume);
	void SetPhysicalMaterial(EPhysicalSurface PhysicalSurface);
	void SetRTPCValue(const class FName& Param_Name, float Value, float InterpolSec);
	void SetSwitch(const class FString& SwitchGroup, const class FString& SwitchState);
	void SetWorldLocation(const struct FVector& Location);
	void StopByPlayingId(int32 PlayingID);
	void StopSound();
	void Terminate();
	void UpdateOutputBusBolume();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalSoundPlayer">();
	}
	static class UPalSoundPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalSoundPlayer>();
	}
};
static_assert(alignof(UPalSoundPlayer) == 0x000008, "Wrong alignment on UPalSoundPlayer");
static_assert(sizeof(UPalSoundPlayer) == 0x000108, "Wrong size on UPalSoundPlayer");
static_assert(offsetof(UPalSoundPlayer, AkCallbackOuter) == 0x000028, "Member 'UPalSoundPlayer::AkCallbackOuter' has a wrong offset!");
static_assert(offsetof(UPalSoundPlayer, StopWhenOwnerDestroyed) == 0x000038, "Member 'UPalSoundPlayer::StopWhenOwnerDestroyed' has a wrong offset!");
static_assert(offsetof(UPalSoundPlayer, OwnerComponent) == 0x000040, "Member 'UPalSoundPlayer::OwnerComponent' has a wrong offset!");
static_assert(offsetof(UPalSoundPlayer, AkComponent) == 0x000048, "Member 'UPalSoundPlayer::AkComponent' has a wrong offset!");
static_assert(offsetof(UPalSoundPlayer, OwnerAttachPointName) == 0x000050, "Member 'UPalSoundPlayer::OwnerAttachPointName' has a wrong offset!");
static_assert(offsetof(UPalSoundPlayer, AkCallback) == 0x000058, "Member 'UPalSoundPlayer::AkCallback' has a wrong offset!");
static_assert(offsetof(UPalSoundPlayer, PlaySoundParameters) == 0x000068, "Member 'UPalSoundPlayer::PlaySoundParameters' has a wrong offset!");
static_assert(offsetof(UPalSoundPlayer, OutputBusVolumes) == 0x0000B8, "Member 'UPalSoundPlayer::OutputBusVolumes' has a wrong offset!");

// Class Pal.PalSoundPlayerComponent
// 0x0048 (0x00E8 - 0x00A0)
class UPalSoundPlayerComponent : public UActorComponent
{
public:
	TSoftClassPtr<class UClass>                   PalSoundSlotClass;                                 // 0x00A0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnGetAkOwnerComponent;                             // 0x00D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalSoundSlot*                          PalSoundSlotCache;                                 // 0x00E0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void BeginPlay();
	class USceneComponent* OnGetAkOwnerComponent__DelegateSignature();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalSoundPlayerComponent">();
	}
	static class UPalSoundPlayerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalSoundPlayerComponent>();
	}
};
static_assert(alignof(UPalSoundPlayerComponent) == 0x000008, "Wrong alignment on UPalSoundPlayerComponent");
static_assert(sizeof(UPalSoundPlayerComponent) == 0x0000E8, "Wrong size on UPalSoundPlayerComponent");
static_assert(offsetof(UPalSoundPlayerComponent, PalSoundSlotClass) == 0x0000A0, "Member 'UPalSoundPlayerComponent::PalSoundSlotClass' has a wrong offset!");
static_assert(offsetof(UPalSoundPlayerComponent, OnGetAkOwnerComponent) == 0x0000D0, "Member 'UPalSoundPlayerComponent::OnGetAkOwnerComponent' has a wrong offset!");
static_assert(offsetof(UPalSoundPlayerComponent, PalSoundSlotCache) == 0x0000E0, "Member 'UPalSoundPlayerComponent::PalSoundSlotCache' has a wrong offset!");

// Class Pal.PalSoundSlot
// 0x00A8 (0x00D0 - 0x0028)
class UPalSoundSlot final : public UObject
{
public:
	TMap<struct FPalDataTableRowName_SoundID, class UAkAudioEvent*> SoundMap;                                          // 0x0028(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<int32, struct FPalDataTableRowName_SoundID> PlaySoundParameters;                               // 0x0078(0x0050)(NativeAccessSpecifierPrivate)
	class UPalSoundPlayer*                        SoundPlayer;                                       // 0x00C8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UAkAudioEvent* GetAkEvent(const struct FPalDataTableRowName_SoundID& ID);
	void Initialize();
	void OnAkPostEventCallback(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo);
	int32 PlaySound(const struct FPalDataTableRowName_SoundID& ID, const struct FPalSoundOptions& Options);
	int32 PlaySoundByAkEvent(class UAkAudioEvent* AkEvent, const struct FPalSoundOptions& Options);
	void SetPhysicalMaterial(EPhysicalSurface PhysicalSurface);
	void SetRTPCValue(const class FName& Param_Name, float Value, float InterpolSec);
	void SetSwitch(const class FString& SwitchGroup, const class FString& SwitchState);
	void StopByPlayingId(int32 PlayingID);
	void StopSound();
	void StopSoundBySoundId(const struct FPalDataTableRowName_SoundID& SoundId);
	void Terminate();

	class UPalSoundPlayer* GetSoundPlayer() const;
	bool IsPlayingBySoundId(const struct FPalDataTableRowName_SoundID& SoundId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalSoundSlot">();
	}
	static class UPalSoundSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalSoundSlot>();
	}
};
static_assert(alignof(UPalSoundSlot) == 0x000008, "Wrong alignment on UPalSoundSlot");
static_assert(sizeof(UPalSoundSlot) == 0x0000D0, "Wrong size on UPalSoundSlot");
static_assert(offsetof(UPalSoundSlot, SoundMap) == 0x000028, "Member 'UPalSoundSlot::SoundMap' has a wrong offset!");
static_assert(offsetof(UPalSoundSlot, PlaySoundParameters) == 0x000078, "Member 'UPalSoundSlot::PlaySoundParameters' has a wrong offset!");
static_assert(offsetof(UPalSoundSlot, SoundPlayer) == 0x0000C8, "Member 'UPalSoundSlot::SoundPlayer' has a wrong offset!");

// Class Pal.PalHUDDispatchParameter_PalShop
// 0x0008 (0x0040 - 0x0038)
class UPalHUDDispatchParameter_PalShop : public UPalHUDDispatchParameterBase
{
public:
	class UPalShopBase*                           Shop;                                              // 0x0038(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalHUDDispatchParameter_PalShop">();
	}
	static class UPalHUDDispatchParameter_PalShop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalHUDDispatchParameter_PalShop>();
	}
};
static_assert(alignof(UPalHUDDispatchParameter_PalShop) == 0x000008, "Wrong alignment on UPalHUDDispatchParameter_PalShop");
static_assert(sizeof(UPalHUDDispatchParameter_PalShop) == 0x000040, "Wrong size on UPalHUDDispatchParameter_PalShop");
static_assert(offsetof(UPalHUDDispatchParameter_PalShop, Shop) == 0x000038, "Member 'UPalHUDDispatchParameter_PalShop::Shop' has a wrong offset!");

// Class Pal.PalSoundUtility
// 0x0000 (0x0028 - 0x0028)
class UPalSoundUtility final : public UBlueprintFunctionLibrary
{
public:
	static void IsSoundPlayingByActor(class AActor* Actor, const struct FPalDataTableRowName_SoundID& ID, TDelegate<void(bool IsPlaying)> Cb);
	static bool PlayAkEventSoundByActor(class AActor* Actor, class UAkAudioEvent* AkEvent);
	static void PlaySoundByActor(class AActor* Actor, const struct FPalDataTableRowName_SoundID& ID, const struct FPalSoundOptions& Option);
	static void PlaySoundByActor_Editor(class AActor* Actor, const struct FPalDataTableRowName_SoundID& ID, const struct FPalSoundOptions& Option, TSoftClassPtr<class UClass> SoundSlotClass, EPhysicalSurface PhysicalSurface);
	static void SetPhysicalMaterial(class AActor* Actor, EPhysicalSurface PhysicalSurface);
	static void SetRTPCValueByActor(class AActor* Actor, const class FName Param_Name, float Value, float InterpolSec);
	static void SetSwitchByActor(class AActor* Actor, const class FString& SwitchGroup, const class FString& SwitchState);
	static class APalSoundDebugModel* SpawnSoundDebugModel(class UAkAudioEvent* AudioEvent, const struct FVector& Location, const struct FRotator& Rotation, class UObject* WorldObject);
	static void StopSoundByActor(class AActor* Actor);
	static void StopSoundByActor_Editor(class AActor* Actor);
	static void StopSoundByActorWithSoundId(class AActor* Actor, const struct FPalDataTableRowName_SoundID& ID);

	void PalSoundUtilityBoolCallbackFunction__DelegateSignature(bool IsPlaying);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalSoundUtility">();
	}
	static class UPalSoundUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalSoundUtility>();
	}
};
static_assert(alignof(UPalSoundUtility) == 0x000008, "Wrong alignment on UPalSoundUtility");
static_assert(sizeof(UPalSoundUtility) == 0x000028, "Wrong size on UPalSoundUtility");

// Class Pal.PalSpectator
// 0x0000 (0x0910 - 0x0910)
class APalSpectator : public APalCharacter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalSpectator">();
	}
	static class APalSpectator* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalSpectator>();
	}
};
static_assert(alignof(APalSpectator) == 0x000010, "Wrong alignment on APalSpectator");
static_assert(sizeof(APalSpectator) == 0x000910, "Wrong size on APalSpectator");

// Class Pal.PalSphereBodyBase
// 0x0000 (0x0290 - 0x0290)
class APalSphereBodyBase : public AActor
{
public:
	void RPCDummy();
	void SetCaptureLevelInternal(int32 Level);
	void SetSneakBonusFlagInternal(bool IsSneak);
	void SetupInternal(class APalCharacter* TargetCharacter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalSphereBodyBase">();
	}
	static class APalSphereBodyBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalSphereBodyBase>();
	}
};
static_assert(alignof(APalSphereBodyBase) == 0x000008, "Wrong alignment on APalSphereBodyBase");
static_assert(sizeof(APalSphereBodyBase) == 0x000290, "Wrong size on APalSphereBodyBase");

// Class Pal.PalSpotAreaBase
// 0x0008 (0x0298 - 0x0290)
class APalSpotAreaBase final : public AActor
{
public:
	EPalAudioState                                AudioState;                                        // 0x0290(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsOverlappedLocalPlayer;                          // 0x0291(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2EF3[0x6];                                     // 0x0292(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class APalPlayerCharacter* PlayerCharacter);
	void OnEndOverlap(class UPrimitiveComponent* OverlappedComponent, class APalPlayerCharacter* PlayerCharacter);

	class UPrimitiveComponent* GetAreaCollision() const;
	EPalAudioState GetAudioState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalSpotAreaBase">();
	}
	static class APalSpotAreaBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalSpotAreaBase>();
	}
};
static_assert(alignof(APalSpotAreaBase) == 0x000008, "Wrong alignment on APalSpotAreaBase");
static_assert(sizeof(APalSpotAreaBase) == 0x000298, "Wrong size on APalSpotAreaBase");
static_assert(offsetof(APalSpotAreaBase, AudioState) == 0x000290, "Member 'APalSpotAreaBase::AudioState' has a wrong offset!");
static_assert(offsetof(APalSpotAreaBase, bIsOverlappedLocalPlayer) == 0x000291, "Member 'APalSpotAreaBase::bIsOverlappedLocalPlayer' has a wrong offset!");

// Class Pal.PalSquad
// 0x0080 (0x00A8 - 0x0028)
class UPalSquad final : public UObject
{
public:
	uint8                                         Pad_2EF4[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnSomeOneDeadDelegate;                             // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCombatPropagationDelegate;                       // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEscapePropagationDelegate;                       // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FPalInstanceID                         LeaderId;                                          // 0x0060(0x0030)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FPalInstanceID>                 MemberIDList;                                      // 0x0090(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UPalAIBlackboardBase*                   LeaderBB;                                          // 0x00A0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AddCharacter(const struct FPalInstanceID& PalInstanceID);
	void CombatStart(class AActor* StartActor);
	void DeadAndUpdateLeader(const struct FPalDeadInfo& DeadInfo);
	void EscapePropagationDelegate__DelegateSignature(class AActor* StartActor, class AActor* TargetActor);
	void EscapeStart(class AActor* StartActor, class AActor* Target);
	void GetMemberID(TArray<struct FPalInstanceID>* OutList);
	void OnCombatPropagationDelegate__DelegateSignature(class AActor* StartActor);
	void OnSomeOneDeadDelegate__DelegateSignature(const struct FPalDeadInfo& DeadInfo);
	void RemoveWhenDestoryActor(class AActor* DestoryActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalSquad">();
	}
	static class UPalSquad* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalSquad>();
	}
};
static_assert(alignof(UPalSquad) == 0x000008, "Wrong alignment on UPalSquad");
static_assert(sizeof(UPalSquad) == 0x0000A8, "Wrong size on UPalSquad");
static_assert(offsetof(UPalSquad, OnSomeOneDeadDelegate) == 0x000030, "Member 'UPalSquad::OnSomeOneDeadDelegate' has a wrong offset!");
static_assert(offsetof(UPalSquad, OnCombatPropagationDelegate) == 0x000040, "Member 'UPalSquad::OnCombatPropagationDelegate' has a wrong offset!");
static_assert(offsetof(UPalSquad, OnEscapePropagationDelegate) == 0x000050, "Member 'UPalSquad::OnEscapePropagationDelegate' has a wrong offset!");
static_assert(offsetof(UPalSquad, LeaderId) == 0x000060, "Member 'UPalSquad::LeaderId' has a wrong offset!");
static_assert(offsetof(UPalSquad, MemberIDList) == 0x000090, "Member 'UPalSquad::MemberIDList' has a wrong offset!");
static_assert(offsetof(UPalSquad, LeaderBB) == 0x0000A0, "Member 'UPalSquad::LeaderBB' has a wrong offset!");

// Class Pal.PalStageRegistrationParameterBase
// 0x0018 (0x0040 - 0x0028)
class UPalStageRegistrationParameterBase : public UObject
{
public:
	uint8                                         Pad_2EF5[0x18];                                    // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalStageRegistrationParameterBase">();
	}
	static class UPalStageRegistrationParameterBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalStageRegistrationParameterBase>();
	}
};
static_assert(alignof(UPalStageRegistrationParameterBase) == 0x000008, "Wrong alignment on UPalStageRegistrationParameterBase");
static_assert(sizeof(UPalStageRegistrationParameterBase) == 0x000040, "Wrong size on UPalStageRegistrationParameterBase");

// Class Pal.PalUIRadialMenuWidgetBase
// 0x0048 (0x0450 - 0x0408)
class UPalUIRadialMenuWidgetBase final : public UPalUserWidget
{
public:
	FMulticastInlineDelegateProperty_             OnChangeSelectedIndex;                             // 0x0408(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         IgnoreMouseLength;                                 // 0x0418(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MenuNum;                                           // 0x041C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ShiftDegree;                                       // 0x0420(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DetectPadAxisBorder;                               // 0x0424(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NowArrowRadian;                                    // 0x0428(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NowSelectedIndex;                                  // 0x042C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<float>                                 MenuAreaStartRadian;                               // 0x0430(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 MenuAreaEndRadian;                                 // 0x0440(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void BuildRadialMenuWidget();
	void CalculateRadialMenuArea(float ParentDegreeAngle);
	void ChangeSelectedIndexDelegate__DelegateSignature(int32 NewIndex, int32 PrevIndex);
	void ClearSelectedIndex();
	float RecalculateRadian(float InRadian);
	void SetSelectedIndexForce(int32 Param_Index);
	void UpdateSelectedIndex_ForceAxis(const struct FVector2D& Axis);
	void UpdateSelectedIndex_ForMouse(const struct FVector2D& MousePosition, const struct FVector2D& CenterPosition);
	void UpdateSelectedIndex_ForPad();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIRadialMenuWidgetBase">();
	}
	static class UPalUIRadialMenuWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIRadialMenuWidgetBase>();
	}
};
static_assert(alignof(UPalUIRadialMenuWidgetBase) == 0x000008, "Wrong alignment on UPalUIRadialMenuWidgetBase");
static_assert(sizeof(UPalUIRadialMenuWidgetBase) == 0x000450, "Wrong size on UPalUIRadialMenuWidgetBase");
static_assert(offsetof(UPalUIRadialMenuWidgetBase, OnChangeSelectedIndex) == 0x000408, "Member 'UPalUIRadialMenuWidgetBase::OnChangeSelectedIndex' has a wrong offset!");
static_assert(offsetof(UPalUIRadialMenuWidgetBase, IgnoreMouseLength) == 0x000418, "Member 'UPalUIRadialMenuWidgetBase::IgnoreMouseLength' has a wrong offset!");
static_assert(offsetof(UPalUIRadialMenuWidgetBase, MenuNum) == 0x00041C, "Member 'UPalUIRadialMenuWidgetBase::MenuNum' has a wrong offset!");
static_assert(offsetof(UPalUIRadialMenuWidgetBase, ShiftDegree) == 0x000420, "Member 'UPalUIRadialMenuWidgetBase::ShiftDegree' has a wrong offset!");
static_assert(offsetof(UPalUIRadialMenuWidgetBase, DetectPadAxisBorder) == 0x000424, "Member 'UPalUIRadialMenuWidgetBase::DetectPadAxisBorder' has a wrong offset!");
static_assert(offsetof(UPalUIRadialMenuWidgetBase, NowArrowRadian) == 0x000428, "Member 'UPalUIRadialMenuWidgetBase::NowArrowRadian' has a wrong offset!");
static_assert(offsetof(UPalUIRadialMenuWidgetBase, NowSelectedIndex) == 0x00042C, "Member 'UPalUIRadialMenuWidgetBase::NowSelectedIndex' has a wrong offset!");
static_assert(offsetof(UPalUIRadialMenuWidgetBase, MenuAreaStartRadian) == 0x000430, "Member 'UPalUIRadialMenuWidgetBase::MenuAreaStartRadian' has a wrong offset!");
static_assert(offsetof(UPalUIRadialMenuWidgetBase, MenuAreaEndRadian) == 0x000440, "Member 'UPalUIRadialMenuWidgetBase::MenuAreaEndRadian' has a wrong offset!");

// Class Pal.PalStageDefines
// 0x0000 (0x0028 - 0x0028)
class UPalStageDefines final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalStageDefines">();
	}
	static class UPalStageDefines* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalStageDefines>();
	}
};
static_assert(alignof(UPalStageDefines) == 0x000008, "Wrong alignment on UPalStageDefines");
static_assert(sizeof(UPalStageDefines) == 0x000028, "Wrong size on UPalStageDefines");

// Class Pal.PalStageUtility
// 0x0000 (0x0028 - 0x0028)
class UPalStageUtility final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalStageUtility">();
	}
	static class UPalStageUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalStageUtility>();
	}
};
static_assert(alignof(UPalStageUtility) == 0x000008, "Wrong alignment on UPalStageUtility");
static_assert(sizeof(UPalStageUtility) == 0x000028, "Wrong size on UPalStageUtility");

// Class Pal.PalStageRegistrationParameterBossBattle
// 0x0008 (0x0048 - 0x0040)
class UPalStageRegistrationParameterBossBattle final : public UPalStageRegistrationParameterBase
{
public:
	uint8                                         Pad_2EF6[0x8];                                     // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalStageRegistrationParameterBossBattle">();
	}
	static class UPalStageRegistrationParameterBossBattle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalStageRegistrationParameterBossBattle>();
	}
};
static_assert(alignof(UPalStageRegistrationParameterBossBattle) == 0x000008, "Wrong alignment on UPalStageRegistrationParameterBossBattle");
static_assert(sizeof(UPalStageRegistrationParameterBossBattle) == 0x000048, "Wrong size on UPalStageRegistrationParameterBossBattle");

// Class Pal.PalStageModelBossBattle
// 0x0008 (0x0070 - 0x0068)
class UPalStageModelBossBattle final : public UPalStageModelBase
{
public:
	class UPalBossBattleInstanceModel*            InstanceModel;                                     // 0x0068(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnRep_InstanceModel();

	class UPalBossBattleInstanceModel* GetInstanceModel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalStageModelBossBattle">();
	}
	static class UPalStageModelBossBattle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalStageModelBossBattle>();
	}
};
static_assert(alignof(UPalStageModelBossBattle) == 0x000008, "Wrong alignment on UPalStageModelBossBattle");
static_assert(sizeof(UPalStageModelBossBattle) == 0x000070, "Wrong size on UPalStageModelBossBattle");
static_assert(offsetof(UPalStageModelBossBattle, InstanceModel) == 0x000068, "Member 'UPalStageModelBossBattle::InstanceModel' has a wrong offset!");

// Class Pal.PalStageRegistrationParameterDungeon
// 0x0010 (0x0050 - 0x0040)
class UPalStageRegistrationParameterDungeon final : public UPalStageRegistrationParameterBase
{
public:
	uint8                                         Pad_2EF7[0x10];                                    // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalStageRegistrationParameterDungeon">();
	}
	static class UPalStageRegistrationParameterDungeon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalStageRegistrationParameterDungeon>();
	}
};
static_assert(alignof(UPalStageRegistrationParameterDungeon) == 0x000008, "Wrong alignment on UPalStageRegistrationParameterDungeon");
static_assert(sizeof(UPalStageRegistrationParameterDungeon) == 0x000050, "Wrong size on UPalStageRegistrationParameterDungeon");

// Class Pal.PalStageReplicator
// 0x0198 (0x01C0 - 0x0028)
class UPalStageReplicator final : public UPalGameStateReplicatorBase
{
public:
	struct FPalFastStageModelRepInfoArray         RepInfoArray;                                      // 0x0028(0x0148)(Edit, Net, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2EF8[0x50];                                    // 0x0170(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalStageReplicator">();
	}
	static class UPalStageReplicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalStageReplicator>();
	}
};
static_assert(alignof(UPalStageReplicator) == 0x000008, "Wrong alignment on UPalStageReplicator");
static_assert(sizeof(UPalStageReplicator) == 0x0001C0, "Wrong size on UPalStageReplicator");
static_assert(offsetof(UPalStageReplicator, RepInfoArray) == 0x000028, "Member 'UPalStageReplicator::RepInfoArray' has a wrong offset!");

// Class Pal.PalWorkReviveCharacter
// 0x0030 (0x0350 - 0x0320)
class UPalWorkReviveCharacter final : public UPalWorkBase
{
public:
	struct FPalInstanceID                         TargetIndividualId;                                // 0x0318(0x0030)(Edit, DisableEditOnTemplate, Transient, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2EF9[0x8];                                     // 0x0348(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorkReviveCharacter">();
	}
	static class UPalWorkReviveCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWorkReviveCharacter>();
	}
};
static_assert(alignof(UPalWorkReviveCharacter) == 0x000010, "Wrong alignment on UPalWorkReviveCharacter");
static_assert(sizeof(UPalWorkReviveCharacter) == 0x000350, "Wrong size on UPalWorkReviveCharacter");
static_assert(offsetof(UPalWorkReviveCharacter, TargetIndividualId) == 0x000318, "Member 'UPalWorkReviveCharacter::TargetIndividualId' has a wrong offset!");

// Class Pal.PalStageWorldSubsystem
// 0x00A0 (0x0110 - 0x0070)
class UPalStageWorldSubsystem final : public UPalWorldSubsystem
{
public:
	TMap<struct FPalStageInstanceId, class UPalStageModelBase*> StageModelMap;                                     // 0x0070(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	TMap<class UDataLayerAsset*, struct FPalStageAreaInfo> StageAreaInfoMap;                                  // 0x00C0(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalStageWorldSubsystem">();
	}
	static class UPalStageWorldSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalStageWorldSubsystem>();
	}
};
static_assert(alignof(UPalStageWorldSubsystem) == 0x000008, "Wrong alignment on UPalStageWorldSubsystem");
static_assert(sizeof(UPalStageWorldSubsystem) == 0x000110, "Wrong size on UPalStageWorldSubsystem");
static_assert(offsetof(UPalStageWorldSubsystem, StageModelMap) == 0x000070, "Member 'UPalStageWorldSubsystem::StageModelMap' has a wrong offset!");
static_assert(offsetof(UPalStageWorldSubsystem, StageAreaInfoMap) == 0x0000C0, "Member 'UPalStageWorldSubsystem::StageAreaInfoMap' has a wrong offset!");

// Class Pal.PalStateMachineStateBase_BlueprintBase
// 0x0000 (0x0030 - 0x0030)
class UPalStateMachineStateBase_BlueprintBase : public UPalStateMachineStateBase
{
public:
	void StateEnter();
	void StateExit();
	void StateTick(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalStateMachineStateBase_BlueprintBase">();
	}
	static class UPalStateMachineStateBase_BlueprintBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalStateMachineStateBase_BlueprintBase>();
	}
};
static_assert(alignof(UPalStateMachineStateBase_BlueprintBase) == 0x000008, "Wrong alignment on UPalStateMachineStateBase_BlueprintBase");
static_assert(sizeof(UPalStateMachineStateBase_BlueprintBase) == 0x000030, "Wrong size on UPalStateMachineStateBase_BlueprintBase");

// Class Pal.PalStaticArmorItemData
// 0x0010 (0x0180 - 0x0170)
class UPalStaticArmorItemData final : public UPalStaticItemDataBase
{
public:
	int32                                         AttackValue;                                       // 0x0170(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DefenseValue;                                      // 0x0174(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         HPValue;                                           // 0x0178(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ShieldValue;                                       // 0x017C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	const int32 GetAttackValue() const;
	const int32 GetDefenseValue() const;
	const int32 GetHPValue() const;
	const int32 GetShieldValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalStaticArmorItemData">();
	}
	static class UPalStaticArmorItemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalStaticArmorItemData>();
	}
};
static_assert(alignof(UPalStaticArmorItemData) == 0x000008, "Wrong alignment on UPalStaticArmorItemData");
static_assert(sizeof(UPalStaticArmorItemData) == 0x000180, "Wrong size on UPalStaticArmorItemData");
static_assert(offsetof(UPalStaticArmorItemData, AttackValue) == 0x000170, "Member 'UPalStaticArmorItemData::AttackValue' has a wrong offset!");
static_assert(offsetof(UPalStaticArmorItemData, DefenseValue) == 0x000174, "Member 'UPalStaticArmorItemData::DefenseValue' has a wrong offset!");
static_assert(offsetof(UPalStaticArmorItemData, HPValue) == 0x000178, "Member 'UPalStaticArmorItemData::HPValue' has a wrong offset!");
static_assert(offsetof(UPalStaticArmorItemData, ShieldValue) == 0x00017C, "Member 'UPalStaticArmorItemData::ShieldValue' has a wrong offset!");

// Class Pal.PalStaticCharacterParameterComponent
// 0x0538 (0x05D8 - 0x00A0)
class UPalStaticCharacterParameterComponent final : public UActorComponent
{
public:
	TMap<EPalAIActionType, TSubclassOf<class UPalAIActionBase>> AIActionMap;                                       // 0x00A0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         CallApproachWalkSpeedMultiplier;                   // 0x00F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EFA[0x4];                                     // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPalRandomRestInfo>             RandomRestMontageInfos;                            // 0x00F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EPalGeneralAnimSequenceType, class UAnimSequence*> GeneralAnimSequenceMap;                            // 0x0108(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<EPalGeneralMontageType, class UAnimMontage*> GeneralMontageMap;                                 // 0x0158(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<EPalGeneralBlendSpaceType, class UBlendSpace*> GeneralBlendSpaceMap;                              // 0x01A8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<EPalRagdollPresetType, TSubclassOf<class UPalRagdollPreset>> RagdollPresetMap;                                  // 0x01F8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<EPalActionType, class UAnimMontage*>     ActionMontageMap;                                  // 0x0248(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   EmoteList;                                         // 0x0298(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<EPalWazaID, TSoftClassPtr<class UClass>> WazaActionDeclarationMap;                          // 0x02A8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<EPalWazaID, TSubclassOf<class UPalActionBase>> WazaActionInstancedMap;                            // 0x02F8(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         CaptureSuccessRate;                                // 0x0348(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPal;                                             // 0x034C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EFB[0x3];                                     // 0x034D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SkillEffectScale;                                  // 0x0350(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EFC[0x4];                                     // 0x0354(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SkillEffectOffsetScale;                            // 0x0358(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FollowSideDistanceRate;                            // 0x0370(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EFD[0x4];                                     // 0x0374(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EPhysicalSurface, struct FFootStampInfo> FootStampMap;                                      // 0x0378(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         StepVelocityXY;                                    // 0x03C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StepVelocityZ;                                     // 0x03CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HeadBoneName;                                      // 0x03D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PhysicsBodyRootName;                               // 0x03D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ToolAttachBoneName;                                // 0x03E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              HPGaugeUIOffset;                                   // 0x03E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExclamationMarkOffsetZ;                            // 0x03F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPalMonsterMovementType                       MovementType;                                      // 0x03FC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EFE[0x3];                                     // 0x03FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Weight_KG;                                         // 0x0400(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Mass_Scale;                                        // 0x0404(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IsGroundCrossRange;                                // 0x0408(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EFF[0x4];                                     // 0x040C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EPalPhysicsBoneType, class FName>        PhysicsBoneNameMap;                                // 0x0410(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          IsUncapturable;                                    // 0x0460(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBackWalkForwardAnime;                            // 0x0461(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRightLeft_WakeupFromRagdoll;                     // 0x0462(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F00[0x5];                                     // 0x0463(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                GetupMotion_UtubuseOrRight_0FramePelvisLocation;   // 0x0468(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                GetupMotion_AomukeOrLeft_0FramePelvisLocation;     // 0x0480(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Ragdoll_RightLeftGetup_ForwardTailName;            // 0x0498(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Ragdoll_RightLeftGetup_RightLegName;               // 0x04A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPalPettingSizeType                           PettingSize;                                       // 0x04A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F01[0x3];                                     // 0x04A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PettingDistance;                                   // 0x04AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PettingStartAddDistance;                           // 0x04B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PettingEndLeaveDistance;                           // 0x04B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PettingCameraCenterDistance_Override;              // 0x04B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PettingCameraHeight_Override;                      // 0x04BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PettingCameraArmLength_Override;                   // 0x04C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPalSizeType                                  Size;                                              // 0x04C4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F02[0x3];                                     // 0x04C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Ragdoll_GravityRate;                               // 0x04C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLookatIKAble;                                    // 0x04CC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F03[0x3];                                     // 0x04CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SmallDamageAnimationApplyRate;                     // 0x04D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmallDamageAnimationPlayRate;                      // 0x04D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FShooterSpringCameraParameter          CameraOffsetInLiftup;                              // 0x04D8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          IsForcedTurnWhenDamageReaction;                    // 0x04F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableNPCDamageRolling;                           // 0x04F9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F04[0x6];                                     // 0x04FA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   PalSoundSlotClass;                                 // 0x0500(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AkAttachPointName;                                 // 0x0530(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PalFootStepEffectAssetClass;                       // 0x0538(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPalStaticCharacterInfo_SpawnItem      SpawnItem;                                         // 0x0568(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UPalSoundSlot*                          PalSoundSlotCache;                                 // 0x05B8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalFootStepEffectAssetBase*            PalFootStepEffectAssetCache;                       // 0x05C0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UPalActionBase>             MissWazaAction;                                    // 0x05C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsBoss_Database;                                   // 0x05D0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsTowerBoss_Database;                              // 0x05D1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsRaidBoss_Database;                               // 0x05D2(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPalSpawnedCharacterType                      SpawnedCharacterType;                              // 0x05D3(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F05[0x4];                                     // 0x05D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetCaptureRate_ByCharacterID();
	EPalSpawnedCharacterType GetSpawnedCharacterType();
	bool IgnoreBlowAway();
	bool IgnoreLeanBack();
	bool IsBossPal_Database();
	bool IsBossPal_Database_ExceptRare();
	bool IsFlyPal();
	bool IsRaidBossPal();
	bool IsRarePal();
	bool IsSwimPal();
	bool IsTowerBossPal();
	void LoadWazaActionClass(EPalWazaID WazaID);
	void SetSpawnedCharacterType(EPalSpawnedCharacterType SpawnedType);

	class UAnimMontage* FindMontange(const EPalActionType ActionType, bool* bExist) const;
	struct FPalRandomRestInfo GetRandomRestInfo() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalStaticCharacterParameterComponent">();
	}
	static class UPalStaticCharacterParameterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalStaticCharacterParameterComponent>();
	}
};
static_assert(alignof(UPalStaticCharacterParameterComponent) == 0x000008, "Wrong alignment on UPalStaticCharacterParameterComponent");
static_assert(sizeof(UPalStaticCharacterParameterComponent) == 0x0005D8, "Wrong size on UPalStaticCharacterParameterComponent");
static_assert(offsetof(UPalStaticCharacterParameterComponent, AIActionMap) == 0x0000A0, "Member 'UPalStaticCharacterParameterComponent::AIActionMap' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, CallApproachWalkSpeedMultiplier) == 0x0000F0, "Member 'UPalStaticCharacterParameterComponent::CallApproachWalkSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, RandomRestMontageInfos) == 0x0000F8, "Member 'UPalStaticCharacterParameterComponent::RandomRestMontageInfos' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, GeneralAnimSequenceMap) == 0x000108, "Member 'UPalStaticCharacterParameterComponent::GeneralAnimSequenceMap' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, GeneralMontageMap) == 0x000158, "Member 'UPalStaticCharacterParameterComponent::GeneralMontageMap' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, GeneralBlendSpaceMap) == 0x0001A8, "Member 'UPalStaticCharacterParameterComponent::GeneralBlendSpaceMap' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, RagdollPresetMap) == 0x0001F8, "Member 'UPalStaticCharacterParameterComponent::RagdollPresetMap' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, ActionMontageMap) == 0x000248, "Member 'UPalStaticCharacterParameterComponent::ActionMontageMap' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, EmoteList) == 0x000298, "Member 'UPalStaticCharacterParameterComponent::EmoteList' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, WazaActionDeclarationMap) == 0x0002A8, "Member 'UPalStaticCharacterParameterComponent::WazaActionDeclarationMap' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, WazaActionInstancedMap) == 0x0002F8, "Member 'UPalStaticCharacterParameterComponent::WazaActionInstancedMap' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, CaptureSuccessRate) == 0x000348, "Member 'UPalStaticCharacterParameterComponent::CaptureSuccessRate' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, IsPal) == 0x00034C, "Member 'UPalStaticCharacterParameterComponent::IsPal' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, SkillEffectScale) == 0x000350, "Member 'UPalStaticCharacterParameterComponent::SkillEffectScale' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, SkillEffectOffsetScale) == 0x000358, "Member 'UPalStaticCharacterParameterComponent::SkillEffectOffsetScale' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, FollowSideDistanceRate) == 0x000370, "Member 'UPalStaticCharacterParameterComponent::FollowSideDistanceRate' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, FootStampMap) == 0x000378, "Member 'UPalStaticCharacterParameterComponent::FootStampMap' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, StepVelocityXY) == 0x0003C8, "Member 'UPalStaticCharacterParameterComponent::StepVelocityXY' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, StepVelocityZ) == 0x0003CC, "Member 'UPalStaticCharacterParameterComponent::StepVelocityZ' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, HeadBoneName) == 0x0003D0, "Member 'UPalStaticCharacterParameterComponent::HeadBoneName' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, PhysicsBodyRootName) == 0x0003D8, "Member 'UPalStaticCharacterParameterComponent::PhysicsBodyRootName' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, ToolAttachBoneName) == 0x0003E0, "Member 'UPalStaticCharacterParameterComponent::ToolAttachBoneName' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, HPGaugeUIOffset) == 0x0003E8, "Member 'UPalStaticCharacterParameterComponent::HPGaugeUIOffset' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, ExclamationMarkOffsetZ) == 0x0003F8, "Member 'UPalStaticCharacterParameterComponent::ExclamationMarkOffsetZ' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, MovementType) == 0x0003FC, "Member 'UPalStaticCharacterParameterComponent::MovementType' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, Weight_KG) == 0x000400, "Member 'UPalStaticCharacterParameterComponent::Weight_KG' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, Mass_Scale) == 0x000404, "Member 'UPalStaticCharacterParameterComponent::Mass_Scale' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, IsGroundCrossRange) == 0x000408, "Member 'UPalStaticCharacterParameterComponent::IsGroundCrossRange' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, PhysicsBoneNameMap) == 0x000410, "Member 'UPalStaticCharacterParameterComponent::PhysicsBoneNameMap' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, IsUncapturable) == 0x000460, "Member 'UPalStaticCharacterParameterComponent::IsUncapturable' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, IsBackWalkForwardAnime) == 0x000461, "Member 'UPalStaticCharacterParameterComponent::IsBackWalkForwardAnime' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, IsRightLeft_WakeupFromRagdoll) == 0x000462, "Member 'UPalStaticCharacterParameterComponent::IsRightLeft_WakeupFromRagdoll' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, GetupMotion_UtubuseOrRight_0FramePelvisLocation) == 0x000468, "Member 'UPalStaticCharacterParameterComponent::GetupMotion_UtubuseOrRight_0FramePelvisLocation' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, GetupMotion_AomukeOrLeft_0FramePelvisLocation) == 0x000480, "Member 'UPalStaticCharacterParameterComponent::GetupMotion_AomukeOrLeft_0FramePelvisLocation' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, Ragdoll_RightLeftGetup_ForwardTailName) == 0x000498, "Member 'UPalStaticCharacterParameterComponent::Ragdoll_RightLeftGetup_ForwardTailName' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, Ragdoll_RightLeftGetup_RightLegName) == 0x0004A0, "Member 'UPalStaticCharacterParameterComponent::Ragdoll_RightLeftGetup_RightLegName' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, PettingSize) == 0x0004A8, "Member 'UPalStaticCharacterParameterComponent::PettingSize' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, PettingDistance) == 0x0004AC, "Member 'UPalStaticCharacterParameterComponent::PettingDistance' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, PettingStartAddDistance) == 0x0004B0, "Member 'UPalStaticCharacterParameterComponent::PettingStartAddDistance' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, PettingEndLeaveDistance) == 0x0004B4, "Member 'UPalStaticCharacterParameterComponent::PettingEndLeaveDistance' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, PettingCameraCenterDistance_Override) == 0x0004B8, "Member 'UPalStaticCharacterParameterComponent::PettingCameraCenterDistance_Override' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, PettingCameraHeight_Override) == 0x0004BC, "Member 'UPalStaticCharacterParameterComponent::PettingCameraHeight_Override' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, PettingCameraArmLength_Override) == 0x0004C0, "Member 'UPalStaticCharacterParameterComponent::PettingCameraArmLength_Override' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, Size) == 0x0004C4, "Member 'UPalStaticCharacterParameterComponent::Size' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, Ragdoll_GravityRate) == 0x0004C8, "Member 'UPalStaticCharacterParameterComponent::Ragdoll_GravityRate' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, IsLookatIKAble) == 0x0004CC, "Member 'UPalStaticCharacterParameterComponent::IsLookatIKAble' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, SmallDamageAnimationApplyRate) == 0x0004D0, "Member 'UPalStaticCharacterParameterComponent::SmallDamageAnimationApplyRate' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, SmallDamageAnimationPlayRate) == 0x0004D4, "Member 'UPalStaticCharacterParameterComponent::SmallDamageAnimationPlayRate' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, CameraOffsetInLiftup) == 0x0004D8, "Member 'UPalStaticCharacterParameterComponent::CameraOffsetInLiftup' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, IsForcedTurnWhenDamageReaction) == 0x0004F8, "Member 'UPalStaticCharacterParameterComponent::IsForcedTurnWhenDamageReaction' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, DisableNPCDamageRolling) == 0x0004F9, "Member 'UPalStaticCharacterParameterComponent::DisableNPCDamageRolling' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, PalSoundSlotClass) == 0x000500, "Member 'UPalStaticCharacterParameterComponent::PalSoundSlotClass' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, AkAttachPointName) == 0x000530, "Member 'UPalStaticCharacterParameterComponent::AkAttachPointName' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, PalFootStepEffectAssetClass) == 0x000538, "Member 'UPalStaticCharacterParameterComponent::PalFootStepEffectAssetClass' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, SpawnItem) == 0x000568, "Member 'UPalStaticCharacterParameterComponent::SpawnItem' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, PalSoundSlotCache) == 0x0005B8, "Member 'UPalStaticCharacterParameterComponent::PalSoundSlotCache' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, PalFootStepEffectAssetCache) == 0x0005C0, "Member 'UPalStaticCharacterParameterComponent::PalFootStepEffectAssetCache' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, MissWazaAction) == 0x0005C8, "Member 'UPalStaticCharacterParameterComponent::MissWazaAction' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, IsBoss_Database) == 0x0005D0, "Member 'UPalStaticCharacterParameterComponent::IsBoss_Database' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, IsTowerBoss_Database) == 0x0005D1, "Member 'UPalStaticCharacterParameterComponent::IsTowerBoss_Database' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, IsRaidBoss_Database) == 0x0005D2, "Member 'UPalStaticCharacterParameterComponent::IsRaidBoss_Database' has a wrong offset!");
static_assert(offsetof(UPalStaticCharacterParameterComponent, SpawnedCharacterType) == 0x0005D3, "Member 'UPalStaticCharacterParameterComponent::SpawnedCharacterType' has a wrong offset!");

// Class Pal.PalStaticConsumeItemData
// 0x0018 (0x0188 - 0x0170)
class UPalStaticConsumeItemData final : public UPalStaticItemDataBase
{
public:
	int32                                         RestoreHP;                                         // 0x0170(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RestoreSP;                                         // 0x0174(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RestoreSatiety;                                    // 0x0178(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RestoreSanity;                                     // 0x017C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPalWazaID                                    WazaID;                                            // 0x0180(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F07[0x7];                                     // 0x0181(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetRestoreHP() const;
	int32 GetRestoreSanity() const;
	int32 GetRestoreSatiety() const;
	int32 GetRestoreSP() const;
	EPalWazaID GetWazaID() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalStaticConsumeItemData">();
	}
	static class UPalStaticConsumeItemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalStaticConsumeItemData>();
	}
};
static_assert(alignof(UPalStaticConsumeItemData) == 0x000008, "Wrong alignment on UPalStaticConsumeItemData");
static_assert(sizeof(UPalStaticConsumeItemData) == 0x000188, "Wrong size on UPalStaticConsumeItemData");
static_assert(offsetof(UPalStaticConsumeItemData, RestoreHP) == 0x000170, "Member 'UPalStaticConsumeItemData::RestoreHP' has a wrong offset!");
static_assert(offsetof(UPalStaticConsumeItemData, RestoreSP) == 0x000174, "Member 'UPalStaticConsumeItemData::RestoreSP' has a wrong offset!");
static_assert(offsetof(UPalStaticConsumeItemData, RestoreSatiety) == 0x000178, "Member 'UPalStaticConsumeItemData::RestoreSatiety' has a wrong offset!");
static_assert(offsetof(UPalStaticConsumeItemData, RestoreSanity) == 0x00017C, "Member 'UPalStaticConsumeItemData::RestoreSanity' has a wrong offset!");
static_assert(offsetof(UPalStaticConsumeItemData, WazaID) == 0x000180, "Member 'UPalStaticConsumeItemData::WazaID' has a wrong offset!");

// Class Pal.PalStaticItemDataManager
// 0x0008 (0x0030 - 0x0028)
class UPalStaticItemDataManager final : public UObject
{
public:
	class UPalStaticItemDataAsset*                StaticItemDataAsset;                               // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalStaticItemDataManager">();
	}
	static class UPalStaticItemDataManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalStaticItemDataManager>();
	}
};
static_assert(alignof(UPalStaticItemDataManager) == 0x000008, "Wrong alignment on UPalStaticItemDataManager");
static_assert(sizeof(UPalStaticItemDataManager) == 0x000030, "Wrong size on UPalStaticItemDataManager");
static_assert(offsetof(UPalStaticItemDataManager, StaticItemDataAsset) == 0x000028, "Member 'UPalStaticItemDataManager::StaticItemDataAsset' has a wrong offset!");

// Class Pal.PalWorldObjectRecorderBase
// 0x0000 (0x0028 - 0x0028)
class UPalWorldObjectRecorderBase : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorldObjectRecorderBase">();
	}
	static class UPalWorldObjectRecorderBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWorldObjectRecorderBase>();
	}
};
static_assert(alignof(UPalWorldObjectRecorderBase) == 0x000008, "Wrong alignment on UPalWorldObjectRecorderBase");
static_assert(sizeof(UPalWorldObjectRecorderBase) == 0x000028, "Wrong size on UPalWorldObjectRecorderBase");

// Class Pal.PalWorldObjectRecord_MapObjectSpawnerInStage
// 0x0050 (0x0078 - 0x0028)
class UPalWorldObjectRecord_MapObjectSpawnerInStage final : public UPalWorldObjectRecorderBase
{
public:
	TMap<struct FPalStageInstanceId, struct FPalWorldObjectRecordData_MapObjectSpawnerInStage> RecordDataMapByStageInstanceId;                    // 0x0028(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorldObjectRecord_MapObjectSpawnerInStage">();
	}
	static class UPalWorldObjectRecord_MapObjectSpawnerInStage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWorldObjectRecord_MapObjectSpawnerInStage>();
	}
};
static_assert(alignof(UPalWorldObjectRecord_MapObjectSpawnerInStage) == 0x000008, "Wrong alignment on UPalWorldObjectRecord_MapObjectSpawnerInStage");
static_assert(sizeof(UPalWorldObjectRecord_MapObjectSpawnerInStage) == 0x000078, "Wrong size on UPalWorldObjectRecord_MapObjectSpawnerInStage");
static_assert(offsetof(UPalWorldObjectRecord_MapObjectSpawnerInStage, RecordDataMapByStageInstanceId) == 0x000028, "Member 'UPalWorldObjectRecord_MapObjectSpawnerInStage::RecordDataMapByStageInstanceId' has a wrong offset!");

// Class Pal.PalStaticItemDataTable
// 0x0008 (0x0030 - 0x0028)
class UPalStaticItemDataTable final : public UObject
{
public:
	class UPalStaticItemDataAsset*                DataAsset;                                         // 0x0028(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalStaticItemDataTable">();
	}
	static class UPalStaticItemDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalStaticItemDataTable>();
	}
};
static_assert(alignof(UPalStaticItemDataTable) == 0x000008, "Wrong alignment on UPalStaticItemDataTable");
static_assert(sizeof(UPalStaticItemDataTable) == 0x000030, "Wrong size on UPalStaticItemDataTable");
static_assert(offsetof(UPalStaticItemDataTable, DataAsset) == 0x000028, "Member 'UPalStaticItemDataTable::DataAsset' has a wrong offset!");

// Class Pal.PalStaticLogCollector
// 0x0018 (0x0040 - 0x0028)
class UPalStaticLogCollector final : public UObject
{
public:
	struct FGuid                                  OverInventoryWeightId;                             // 0x0028(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalLogManager*                         TargetLogManager;                                  // 0x0038(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnEndedWorldAutoSave(bool IsSuccess);
	void OnFixedWeightInventory(float NowWeight);
	void OnOverWeightInventory(float NowWeight);
	void OnReadyPlayerInventoryData(class UPalPlayerDataStorage* PlayerDataStorage);
	void RegisterLogCollectEvent_BP();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalStaticLogCollector">();
	}
	static class UPalStaticLogCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalStaticLogCollector>();
	}
};
static_assert(alignof(UPalStaticLogCollector) == 0x000008, "Wrong alignment on UPalStaticLogCollector");
static_assert(sizeof(UPalStaticLogCollector) == 0x000040, "Wrong size on UPalStaticLogCollector");
static_assert(offsetof(UPalStaticLogCollector, OverInventoryWeightId) == 0x000028, "Member 'UPalStaticLogCollector::OverInventoryWeightId' has a wrong offset!");
static_assert(offsetof(UPalStaticLogCollector, TargetLogManager) == 0x000038, "Member 'UPalStaticLogCollector::TargetLogManager' has a wrong offset!");

// Class Pal.PalStationaryWeaponBase
// 0x0000 (0x0538 - 0x0538)
class APalStationaryWeaponBase : public APalWeaponBase
{
public:
	float GetAttackableAngle();
	float GetAttackableDistance();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalStationaryWeaponBase">();
	}
	static class APalStationaryWeaponBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalStationaryWeaponBase>();
	}
};
static_assert(alignof(APalStationaryWeaponBase) == 0x000008, "Wrong alignment on APalStationaryWeaponBase");
static_assert(sizeof(APalStationaryWeaponBase) == 0x000538, "Wrong size on APalStationaryWeaponBase");

// Class Pal.PalStatModelPerformance
// 0x0018 (0x0040 - 0x0028)
class UPalStatModelPerformance final : public UObject
{
public:
	uint8                                         Pad_2F08[0x18];                                    // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Deinitialize();
	void Initialize();
	void SetupInitializeStat(float FrameTime, float GameThreadTime, float RenderThreadTime, float GPUTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalStatModelPerformance">();
	}
	static class UPalStatModelPerformance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalStatModelPerformance>();
	}
};
static_assert(alignof(UPalStatModelPerformance) == 0x000008, "Wrong alignment on UPalStatModelPerformance");
static_assert(sizeof(UPalStatModelPerformance) == 0x000040, "Wrong size on UPalStatModelPerformance");

// Class Pal.PalStatPalCount
// 0x0010 (0x0038 - 0x0028)
class UPalStatPalCount final : public UObject
{
public:
	uint8                                         Pad_2F09[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UFont*                                  FontObject;                                        // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalStatPalCount">();
	}
	static class UPalStatPalCount* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalStatPalCount>();
	}
};
static_assert(alignof(UPalStatPalCount) == 0x000008, "Wrong alignment on UPalStatPalCount");
static_assert(sizeof(UPalStatPalCount) == 0x000038, "Wrong size on UPalStatPalCount");
static_assert(offsetof(UPalStatPalCount, FontObject) == 0x000030, "Member 'UPalStatPalCount::FontObject' has a wrong offset!");

// Class Pal.PalUIWorldMap
// 0x0000 (0x0430 - 0x0430)
class UPalUIWorldMap final : public UPalUserWidgetOverlayUI
{
public:
	void CreateWorldMapData(EPalWorldMapType WorldMapType);
	void Debug_SetLocation(const struct FVector& Location);
	void RegisterRespawnLocation(const struct FVector& RespawnLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIWorldMap">();
	}
	static class UPalUIWorldMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIWorldMap>();
	}
};
static_assert(alignof(UPalUIWorldMap) == 0x000008, "Wrong alignment on UPalUIWorldMap");
static_assert(sizeof(UPalUIWorldMap) == 0x000430, "Wrong size on UPalUIWorldMap");

// Class Pal.PalStatusLifeSteal
// 0x0000 (0x0048 - 0x0048)
class UPalStatusLifeSteal : public UPalStatusBase
{
public:
	int32 CalucRecoverPoint(int32 Damage);
	void OnLifeSteal(int32 Damage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalStatusLifeSteal">();
	}
	static class UPalStatusLifeSteal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalStatusLifeSteal>();
	}
};
static_assert(alignof(UPalStatusLifeSteal) == 0x000008, "Wrong alignment on UPalStatusLifeSteal");
static_assert(sizeof(UPalStatusLifeSteal) == 0x000048, "Wrong size on UPalStatusLifeSteal");

// Class Pal.PalStatus_StaminaControl
// 0x0008 (0x0050 - 0x0048)
class UPalStatus_StaminaControl final : public UPalStatusBase
{
public:
	bool                                          IsLocalPlayerOrPal;                                // 0x0048(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsPreCliming;                                      // 0x0049(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F0A[0x6];                                     // 0x004A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DecreaseJumpStamina(class UPalCharacterMovementComponent* Movement);
	void DecreaseStepStamina();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalStatus_StaminaControl">();
	}
	static class UPalStatus_StaminaControl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalStatus_StaminaControl>();
	}
};
static_assert(alignof(UPalStatus_StaminaControl) == 0x000008, "Wrong alignment on UPalStatus_StaminaControl");
static_assert(sizeof(UPalStatus_StaminaControl) == 0x000050, "Wrong size on UPalStatus_StaminaControl");
static_assert(offsetof(UPalStatus_StaminaControl, IsLocalPlayerOrPal) == 0x000048, "Member 'UPalStatus_StaminaControl::IsLocalPlayerOrPal' has a wrong offset!");
static_assert(offsetof(UPalStatus_StaminaControl, IsPreCliming) == 0x000049, "Member 'UPalStatus_StaminaControl::IsPreCliming' has a wrong offset!");

// Class Pal.PalSystemInitializeInterface
// 0x0000 (0x0028 - 0x0028)
class IPalSystemInitializeInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalSystemInitializeInterface">();
	}
	static class IPalSystemInitializeInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPalSystemInitializeInterface>();
	}
};
static_assert(alignof(IPalSystemInitializeInterface) == 0x000008, "Wrong alignment on IPalSystemInitializeInterface");
static_assert(sizeof(IPalSystemInitializeInterface) == 0x000028, "Wrong size on IPalSystemInitializeInterface");

// Class Pal.PalEditorTalkTreeDataTable
// 0x0000 (0x0028 - 0x0028)
class UPalEditorTalkTreeDataTable final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalEditorTalkTreeDataTable">();
	}
	static class UPalEditorTalkTreeDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalEditorTalkTreeDataTable>();
	}
};
static_assert(alignof(UPalEditorTalkTreeDataTable) == 0x000008, "Wrong alignment on UPalEditorTalkTreeDataTable");
static_assert(sizeof(UPalEditorTalkTreeDataTable) == 0x000028, "Wrong size on UPalEditorTalkTreeDataTable");

// Class Pal.PalVenderDataComponent
// 0x0100 (0x01A0 - 0x00A0)
class UPalVenderDataComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnRegisteredItemShopDelegate;                      // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRegisteredPalShopDelegate;                       // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGuid                                  MyShopID;                                          // 0x00C0(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ItemShopRestockMinute;                             // 0x00D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPalShopLotteryType                           ItemShopLotteryType;                               // 0x00D4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F0B[0x3];                                     // 0x00D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPalDataTableRowName_ItemShopLotteryData ItemShopSimpleLotteryTableName;                    // 0x00D8(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<EPalShopLotteryBiomeType, struct FPalDataTableRowName_ItemShopLotteryData> ItemShopBiomeLotteryTableMap;                      // 0x00E0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	int32                                         PalShopRestockMinute;                              // 0x0130(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPalShopLotteryType                           PalShopLotteryType;                                // 0x0134(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F0C[0x3];                                     // 0x0135(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPalDataTableRowName_PalShopCreateData PalShopSimpleLotteryTableName;                     // 0x0138(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<EPalShopLotteryBiomeType, struct FPalDataTableRowName_PalShopCreateData> PalShopBiomeLotteryTableMap;                       // 0x0140(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UPalShopBase*                           MyItemShop;                                        // 0x0190(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalShopBase*                           MyPalShop;                                         // 0x0198(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_MyItemShop();
	void OnRep_MyPalShop();
	void RegisteredItemShopDelegate__DelegateSignature();
	void RegisteredPalShopDelegate__DelegateSignature();
	void SetupShopData();

	bool IsValidItemShop() const;
	bool IsValidPalShop() const;
	bool TryGetItemShop(class UPalShopBase** OutShop) const;
	bool TryGetPalShop(class UPalShopBase** OutShop) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalVenderDataComponent">();
	}
	static class UPalVenderDataComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalVenderDataComponent>();
	}
};
static_assert(alignof(UPalVenderDataComponent) == 0x000008, "Wrong alignment on UPalVenderDataComponent");
static_assert(sizeof(UPalVenderDataComponent) == 0x0001A0, "Wrong size on UPalVenderDataComponent");
static_assert(offsetof(UPalVenderDataComponent, OnRegisteredItemShopDelegate) == 0x0000A0, "Member 'UPalVenderDataComponent::OnRegisteredItemShopDelegate' has a wrong offset!");
static_assert(offsetof(UPalVenderDataComponent, OnRegisteredPalShopDelegate) == 0x0000B0, "Member 'UPalVenderDataComponent::OnRegisteredPalShopDelegate' has a wrong offset!");
static_assert(offsetof(UPalVenderDataComponent, MyShopID) == 0x0000C0, "Member 'UPalVenderDataComponent::MyShopID' has a wrong offset!");
static_assert(offsetof(UPalVenderDataComponent, ItemShopRestockMinute) == 0x0000D0, "Member 'UPalVenderDataComponent::ItemShopRestockMinute' has a wrong offset!");
static_assert(offsetof(UPalVenderDataComponent, ItemShopLotteryType) == 0x0000D4, "Member 'UPalVenderDataComponent::ItemShopLotteryType' has a wrong offset!");
static_assert(offsetof(UPalVenderDataComponent, ItemShopSimpleLotteryTableName) == 0x0000D8, "Member 'UPalVenderDataComponent::ItemShopSimpleLotteryTableName' has a wrong offset!");
static_assert(offsetof(UPalVenderDataComponent, ItemShopBiomeLotteryTableMap) == 0x0000E0, "Member 'UPalVenderDataComponent::ItemShopBiomeLotteryTableMap' has a wrong offset!");
static_assert(offsetof(UPalVenderDataComponent, PalShopRestockMinute) == 0x000130, "Member 'UPalVenderDataComponent::PalShopRestockMinute' has a wrong offset!");
static_assert(offsetof(UPalVenderDataComponent, PalShopLotteryType) == 0x000134, "Member 'UPalVenderDataComponent::PalShopLotteryType' has a wrong offset!");
static_assert(offsetof(UPalVenderDataComponent, PalShopSimpleLotteryTableName) == 0x000138, "Member 'UPalVenderDataComponent::PalShopSimpleLotteryTableName' has a wrong offset!");
static_assert(offsetof(UPalVenderDataComponent, PalShopBiomeLotteryTableMap) == 0x000140, "Member 'UPalVenderDataComponent::PalShopBiomeLotteryTableMap' has a wrong offset!");
static_assert(offsetof(UPalVenderDataComponent, MyItemShop) == 0x000190, "Member 'UPalVenderDataComponent::MyItemShop' has a wrong offset!");
static_assert(offsetof(UPalVenderDataComponent, MyPalShop) == 0x000198, "Member 'UPalVenderDataComponent::MyPalShop' has a wrong offset!");

// Class Pal.PalTalkWidgetParameter
// 0x0028 (0x0060 - 0x0038)
class UPalTalkWidgetParameter final : public UPalHUDDispatchParameterBase
{
public:
	class UDataTable*                             TalkDataTable;                                     // 0x0038(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StartTalkSequence;                                 // 0x0040(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Talker;                                            // 0x0048(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPalIncidentBase*                       TalkIncident;                                      // 0x0050(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCancel;                                          // 0x0058(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F0F[0x7];                                     // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalTalkWidgetParameter">();
	}
	static class UPalTalkWidgetParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalTalkWidgetParameter>();
	}
};
static_assert(alignof(UPalTalkWidgetParameter) == 0x000008, "Wrong alignment on UPalTalkWidgetParameter");
static_assert(sizeof(UPalTalkWidgetParameter) == 0x000060, "Wrong size on UPalTalkWidgetParameter");
static_assert(offsetof(UPalTalkWidgetParameter, TalkDataTable) == 0x000038, "Member 'UPalTalkWidgetParameter::TalkDataTable' has a wrong offset!");
static_assert(offsetof(UPalTalkWidgetParameter, StartTalkSequence) == 0x000040, "Member 'UPalTalkWidgetParameter::StartTalkSequence' has a wrong offset!");
static_assert(offsetof(UPalTalkWidgetParameter, Talker) == 0x000048, "Member 'UPalTalkWidgetParameter::Talker' has a wrong offset!");
static_assert(offsetof(UPalTalkWidgetParameter, TalkIncident) == 0x000050, "Member 'UPalTalkWidgetParameter::TalkIncident' has a wrong offset!");
static_assert(offsetof(UPalTalkWidgetParameter, IsCancel) == 0x000058, "Member 'UPalTalkWidgetParameter::IsCancel' has a wrong offset!");

// Class Pal.PalTalkWindowWidgetBase
// 0x0018 (0x0448 - 0x0430)
class UPalTalkWindowWidgetBase final : public UPalUserWidgetOverlayUI
{
public:
	class UPalNPCTalkSystem*                      TalkSystem;                                        // 0x0430(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F10[0x10];                                    // 0x0438(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddArgument(const class FString& Key, const class FText& Text);
	void CreateTextAppliedArgments(const class FText& OrgText, class FText* OutText);
	EPalNPCTalkSelectedChoiceResult NotifyChoiceIndex(int32 Param_Index);
	void RequestClose();
	void SetMainTextList(const TArray<class FName>& TextIDList);
	void SetTalkerName(const class FName& Text);
	void ShowChoice(const TArray<class FName>& ChoiceTextIDList);

	bool HasArguments() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalTalkWindowWidgetBase">();
	}
	static class UPalTalkWindowWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalTalkWindowWidgetBase>();
	}
};
static_assert(alignof(UPalTalkWindowWidgetBase) == 0x000008, "Wrong alignment on UPalTalkWindowWidgetBase");
static_assert(sizeof(UPalTalkWindowWidgetBase) == 0x000448, "Wrong size on UPalTalkWindowWidgetBase");
static_assert(offsetof(UPalTalkWindowWidgetBase, TalkSystem) == 0x000430, "Member 'UPalTalkWindowWidgetBase::TalkSystem' has a wrong offset!");

// Class Pal.PalTechnologyData
// 0x0140 (0x0168 - 0x0028)
class UPalTechnologyData final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnUpdateTechnologyPoint;                           // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateBossTechnologyPoint;                       // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUnlockedAnyTechnology;                           // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNewUnlockedUpdate;                               // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FPalTechnologyDataSet                  TechnologyDataSet;                                 // 0x0068(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FPalTechnologyDataTableRowBase         EmptyTechnologyData;                               // 0x0080(0x0040)(NativeAccessSpecifierPublic)
	struct FPalTechnologyRecipeUnlockDataTableRow EmptyRecipeTechnologyData;                         // 0x00C0(0x0060)(NativeAccessSpecifierPublic)
	TArray<class FName>                           UnlockedTechnologyNameArray;                       // 0x0120(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	struct FGuid                                  OwnerPlayerUId;                                    // 0x0130(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TechnologyPoint;                                   // 0x0140(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         bossTechnologyPoint;                               // 0x0144(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           DefaultLockRecipeNameArray;                        // 0x0148(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class FName>                           DefaultLockBuildObjectNameArray;                   // 0x0158(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void CheckNewUnlockedFlag_Radial(const class FName& BuildName);
	void FilteringUnlockedRecipe(const TArray<class FName>& OriginalResipeIdArray, TArray<class FName>* OutRecipeIdArray);
	bool IsExistNewUnlockedTechnology();
	bool IsNewUnlockedTechnology(const class FName& TechnologyName);
	void OnNewUnlockedUpdateDelegate__DelegateSignature();
	void OnRep_BossTechnologyPoint();
	void OnRep_TechnologyPoint();
	void OnRep_UnlockedTechnologyNameArray();
	void OnUnlockedAnyTechnology__DelegateSignature();
	void OnUpdateLocalPlayerLevel(int32 AddLevel, int32 NowLevel);
	void OnUpdateTechnologyPoint__DelegateSignature(int32 Param_TechnologyPoint);
	void RemoveNewUnlockedFlag(const class FName& TechnologyName);
	void RequestAddBossTechnologyPointByItem(const struct FPalItemSlotId& ConsumeSlotId);
	void RequestAddTechnologyPointByItem(const struct FPalItemSlotId& ConsumeSlotId);
	void RequestUnlockRecipeTechnology(const class FName& UnlockTechnologyName);

	int32 GetBossTechnologyPoints() const;
	const struct FPalTechnologyRecipeUnlockDataTableRow GetRecipeTechlonogy(const class FName& TechnologyName) const;
	const TArray<class FName> GetRecipeTechnologyRowNameArray() const;
	const struct FPalTechnologyDataTableRowBase GetTechlonogyBaseData(const class FName& TechnologyName) const;
	class FText GetTechnologyDesc(const class FName& TechnologyName) const;
	class FText GetTechnologyName(const class FName& TechnologyName) const;
	int32 GetTechnologyPoints() const;
	bool IsNewUnlockedBuild_Radial(const class FName& BuildName) const;
	bool IsUnlockableRecipeTechnology(const class FName& TechnologyName) const;
	bool IsUnlockBuildObject(const class FName& BuildObjectId) const;
	bool IsUnlockCraftRecipe(const class FName& CraftRecipeName) const;
	bool IsUnlockRecipeTechnology(const class FName& TechnologyName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalTechnologyData">();
	}
	static class UPalTechnologyData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalTechnologyData>();
	}
};
static_assert(alignof(UPalTechnologyData) == 0x000008, "Wrong alignment on UPalTechnologyData");
static_assert(sizeof(UPalTechnologyData) == 0x000168, "Wrong size on UPalTechnologyData");
static_assert(offsetof(UPalTechnologyData, OnUpdateTechnologyPoint) == 0x000028, "Member 'UPalTechnologyData::OnUpdateTechnologyPoint' has a wrong offset!");
static_assert(offsetof(UPalTechnologyData, OnUpdateBossTechnologyPoint) == 0x000038, "Member 'UPalTechnologyData::OnUpdateBossTechnologyPoint' has a wrong offset!");
static_assert(offsetof(UPalTechnologyData, OnUnlockedAnyTechnology) == 0x000048, "Member 'UPalTechnologyData::OnUnlockedAnyTechnology' has a wrong offset!");
static_assert(offsetof(UPalTechnologyData, OnNewUnlockedUpdate) == 0x000058, "Member 'UPalTechnologyData::OnNewUnlockedUpdate' has a wrong offset!");
static_assert(offsetof(UPalTechnologyData, TechnologyDataSet) == 0x000068, "Member 'UPalTechnologyData::TechnologyDataSet' has a wrong offset!");
static_assert(offsetof(UPalTechnologyData, EmptyTechnologyData) == 0x000080, "Member 'UPalTechnologyData::EmptyTechnologyData' has a wrong offset!");
static_assert(offsetof(UPalTechnologyData, EmptyRecipeTechnologyData) == 0x0000C0, "Member 'UPalTechnologyData::EmptyRecipeTechnologyData' has a wrong offset!");
static_assert(offsetof(UPalTechnologyData, UnlockedTechnologyNameArray) == 0x000120, "Member 'UPalTechnologyData::UnlockedTechnologyNameArray' has a wrong offset!");
static_assert(offsetof(UPalTechnologyData, OwnerPlayerUId) == 0x000130, "Member 'UPalTechnologyData::OwnerPlayerUId' has a wrong offset!");
static_assert(offsetof(UPalTechnologyData, TechnologyPoint) == 0x000140, "Member 'UPalTechnologyData::TechnologyPoint' has a wrong offset!");
static_assert(offsetof(UPalTechnologyData, bossTechnologyPoint) == 0x000144, "Member 'UPalTechnologyData::bossTechnologyPoint' has a wrong offset!");
static_assert(offsetof(UPalTechnologyData, DefaultLockRecipeNameArray) == 0x000148, "Member 'UPalTechnologyData::DefaultLockRecipeNameArray' has a wrong offset!");
static_assert(offsetof(UPalTechnologyData, DefaultLockBuildObjectNameArray) == 0x000158, "Member 'UPalTechnologyData::DefaultLockBuildObjectNameArray' has a wrong offset!");

// Class Pal.PalTestMapObjectRegistrationToManager
// 0x0008 (0x0298 - 0x0290)
class APalTestMapObjectRegistrationToManager final : public AActor
{
public:
	bool                                          bReadyVirtualBaseCamp;                             // 0x0290(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F18[0x7];                                     // 0x0291(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ForceBuildComplete();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalTestMapObjectRegistrationToManager">();
	}
	static class APalTestMapObjectRegistrationToManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalTestMapObjectRegistrationToManager>();
	}
};
static_assert(alignof(APalTestMapObjectRegistrationToManager) == 0x000008, "Wrong alignment on APalTestMapObjectRegistrationToManager");
static_assert(sizeof(APalTestMapObjectRegistrationToManager) == 0x000298, "Wrong size on APalTestMapObjectRegistrationToManager");
static_assert(offsetof(APalTestMapObjectRegistrationToManager, bReadyVirtualBaseCamp) == 0x000290, "Member 'APalTestMapObjectRegistrationToManager::bReadyVirtualBaseCamp' has a wrong offset!");

// Class Pal.PalUIManagerSubsystem
// 0x0010 (0x0078 - 0x0068)
class UPalUIManagerSubsystem final : public UGameUIManagerSubsystem
{
public:
	uint8                                         Pad_2F19[0x10];                                    // 0x0068(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIManagerSubsystem">();
	}
	static class UPalUIManagerSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIManagerSubsystem>();
	}
};
static_assert(alignof(UPalUIManagerSubsystem) == 0x000008, "Wrong alignment on UPalUIManagerSubsystem");
static_assert(sizeof(UPalUIManagerSubsystem) == 0x000078, "Wrong size on UPalUIManagerSubsystem");

// Class Pal.PalTestNetArchiveTransmition
// 0x0000 (0x0290 - 0x0290)
class APalTestNetArchiveTransmition final : public AActor
{
public:
	void OnRecieveTest(const struct FPalNetArchive& Ar);
	void SendTest();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalTestNetArchiveTransmition">();
	}
	static class APalTestNetArchiveTransmition* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalTestNetArchiveTransmition>();
	}
};
static_assert(alignof(APalTestNetArchiveTransmition) == 0x000008, "Wrong alignment on APalTestNetArchiveTransmition");
static_assert(sizeof(APalTestNetArchiveTransmition) == 0x000290, "Wrong size on APalTestNetArchiveTransmition");

// Class Pal.PalTextBlockBase
// 0x0010 (0x0380 - 0x0370)
class UPalTextBlockBase : public UCommonTextBlock
{
public:
	struct FDataTableRowHandle                    BindTextDatatableHandle;                           // 0x0368(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          IsAutoTextSetWhenWidgetRebuilt;                    // 0x0378(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAutoAdjustScale;                                 // 0x0379(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F1A[0x2];                                     // 0x037A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxWidth;                                          // 0x037C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool BP_ReflectText();
	void SetText_GDKInternal(bool IsSuccess, const class FString& OutString);
	void UpdateRowName(const class FName RowName);

	class FText GetBindedOriginalText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalTextBlockBase">();
	}
	static class UPalTextBlockBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalTextBlockBase>();
	}
};
static_assert(alignof(UPalTextBlockBase) == 0x000010, "Wrong alignment on UPalTextBlockBase");
static_assert(sizeof(UPalTextBlockBase) == 0x000380, "Wrong size on UPalTextBlockBase");
static_assert(offsetof(UPalTextBlockBase, BindTextDatatableHandle) == 0x000368, "Member 'UPalTextBlockBase::BindTextDatatableHandle' has a wrong offset!");
static_assert(offsetof(UPalTextBlockBase, IsAutoTextSetWhenWidgetRebuilt) == 0x000378, "Member 'UPalTextBlockBase::IsAutoTextSetWhenWidgetRebuilt' has a wrong offset!");
static_assert(offsetof(UPalTextBlockBase, IsAutoAdjustScale) == 0x000379, "Member 'UPalTextBlockBase::IsAutoAdjustScale' has a wrong offset!");
static_assert(offsetof(UPalTextBlockBase, MaxWidth) == 0x00037C, "Member 'UPalTextBlockBase::MaxWidth' has a wrong offset!");

// Class Pal.PalTimerPointLightComponent
// 0x00B0 (0x04D0 - 0x0420)
class UPalTimerPointLightComponent : public UPointLightComponent
{
public:
	class UCurveFloat*                            LightCurve;                                        // 0x0418(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLocalOnly;                                      // 0x0420(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F1C[0x3];                                     // 0x0421(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultIntensity;                                  // 0x0424(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFlagContainer                         DisableFlag;                                       // 0x0428(0x0050)(Transient, NativeAccessSpecifierPrivate)
	struct FFlagContainer                         EnableWhenDayTimeFlag;                             // 0x0478(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F1D[0x8];                                     // 0x04C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckOtomoPal_AndSetRange(class APalCharacter* SelfCharacter);
	void SetEnableWhenDayTime(class FName Key, bool Enable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalTimerPointLightComponent">();
	}
	static class UPalTimerPointLightComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalTimerPointLightComponent>();
	}
};
static_assert(alignof(UPalTimerPointLightComponent) == 0x000010, "Wrong alignment on UPalTimerPointLightComponent");
static_assert(sizeof(UPalTimerPointLightComponent) == 0x0004D0, "Wrong size on UPalTimerPointLightComponent");
static_assert(offsetof(UPalTimerPointLightComponent, LightCurve) == 0x000418, "Member 'UPalTimerPointLightComponent::LightCurve' has a wrong offset!");
static_assert(offsetof(UPalTimerPointLightComponent, bIsLocalOnly) == 0x000420, "Member 'UPalTimerPointLightComponent::bIsLocalOnly' has a wrong offset!");
static_assert(offsetof(UPalTimerPointLightComponent, DefaultIntensity) == 0x000424, "Member 'UPalTimerPointLightComponent::DefaultIntensity' has a wrong offset!");
static_assert(offsetof(UPalTimerPointLightComponent, DisableFlag) == 0x000428, "Member 'UPalTimerPointLightComponent::DisableFlag' has a wrong offset!");
static_assert(offsetof(UPalTimerPointLightComponent, EnableWhenDayTimeFlag) == 0x000478, "Member 'UPalTimerPointLightComponent::EnableWhenDayTimeFlag' has a wrong offset!");

// Class Pal.PalToolUtility
// 0x0000 (0x0028 - 0x0028)
class UPalToolUtility final : public UBlueprintFunctionLibrary
{
public:
	static void CopyFileOverride(const class FString& SourceFileName, const class FString& DestFileName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalToolUtility">();
	}
	static class UPalToolUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalToolUtility>();
	}
};
static_assert(alignof(UPalToolUtility) == 0x000008, "Wrong alignment on UPalToolUtility");
static_assert(sizeof(UPalToolUtility) == 0x000028, "Wrong size on UPalToolUtility");

// Class Pal.PalTreasureBoxVisualBase
// 0x0008 (0x0298 - 0x0290)
class APalTreasureBoxVisualBase final : public AActor
{
public:
	class UPalSkeletalMeshComponent*              SkeletalMeshComponent;                             // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnPlayMontageNotifyBegin(class FName NotifyName, const struct FBranchingPointNotifyPayload& BranchingPointPayload);
	void OnPlayMontageNotifyBegin_BP(class FName NotifyName);
	void SetTickEnabled(bool bEnabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalTreasureBoxVisualBase">();
	}
	static class APalTreasureBoxVisualBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalTreasureBoxVisualBase>();
	}
};
static_assert(alignof(APalTreasureBoxVisualBase) == 0x000008, "Wrong alignment on APalTreasureBoxVisualBase");
static_assert(sizeof(APalTreasureBoxVisualBase) == 0x000298, "Wrong size on APalTreasureBoxVisualBase");
static_assert(offsetof(APalTreasureBoxVisualBase, SkeletalMeshComponent) == 0x000290, "Member 'APalTreasureBoxVisualBase::SkeletalMeshComponent' has a wrong offset!");

// Class Pal.PalTutorialManager
// 0x0088 (0x00F8 - 0x0070)
class UPalTutorialManager : public UPalWorldSubsystem
{
public:
	uint8                                         Pad_2F1F[0x8];                                     // 0x0070(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnTutorialTriggered;                               // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TArray<class UPalTutorialTriggerBase*>        TutorialTriggers;                                  // 0x0088(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UDataTable*                             MsgDataTable;                                      // 0x0098(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             TutorialTriggersDataTable;                         // 0x00A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F20[0x50];                                    // 0x00A8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void TutorialTrigger_Capture(const struct FPalUIPalCaptureInfo& CaptureInfo, bool CaptureSuccess);
	void TutorialTrigger_Common(EPalTutorialTriggerConditionType TriggerType);
	void TutorialTriggerDelegate__DelegateSignature(const struct FDataTableRowHandle& TutorialMsg);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalTutorialManager">();
	}
	static class UPalTutorialManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalTutorialManager>();
	}
};
static_assert(alignof(UPalTutorialManager) == 0x000008, "Wrong alignment on UPalTutorialManager");
static_assert(sizeof(UPalTutorialManager) == 0x0000F8, "Wrong size on UPalTutorialManager");
static_assert(offsetof(UPalTutorialManager, OnTutorialTriggered) == 0x000078, "Member 'UPalTutorialManager::OnTutorialTriggered' has a wrong offset!");
static_assert(offsetof(UPalTutorialManager, TutorialTriggers) == 0x000088, "Member 'UPalTutorialManager::TutorialTriggers' has a wrong offset!");
static_assert(offsetof(UPalTutorialManager, MsgDataTable) == 0x000098, "Member 'UPalTutorialManager::MsgDataTable' has a wrong offset!");
static_assert(offsetof(UPalTutorialManager, TutorialTriggersDataTable) == 0x0000A0, "Member 'UPalTutorialManager::TutorialTriggersDataTable' has a wrong offset!");

// Class Pal.PalUIPalBoxBase
// 0x0018 (0x0448 - 0x0430)
class UPalUIPalBoxBase final : public UPalUserWidgetOverlayUI
{
public:
	uint8                                         Pad_2F22[0x18];                                    // 0x0430(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelLift();
	void ChangeNextPagePalBoxList();
	void ChangePrevPagePalBoxList();
	int32 GetBoxMaxPageNum();
	void OnUpdatePagePalBoxList(int32 NowPage, const TArray<class UPalIndividualCharacterSlot*>& SlotList);
	void OnUpdatePageWorkerList(const TArray<class UPalIndividualCharacterSlot*>& SlotList);
	void OnUpdateWorkerCapacity(class UPalIndividualCharacterContainer* Container);
	void RequestSortBox(EPalCharacterContainerSortType SortType);
	void SelectCharacterSlot(class UPalIndividualCharacterSlot* TargetSlot, const EPalItemSlotPressType PressType);
	void SetBaseCampId(const struct FGuid& BaseCampId);
	void SetPagePalBoxList(int32 NewPage);
	void TryLoosePal(class UPalIndividualCharacterSlot* TargetSlot);
	void TryMoveToBaseCamp(class UPalIndividualCharacterSlot* MoveSlot);
	void TryMoveToBox(class UPalIndividualCharacterSlot* MoveSlot);
	void TryMoveToOtomo(class UPalIndividualCharacterSlot* MoveSlot);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIPalBoxBase">();
	}
	static class UPalUIPalBoxBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIPalBoxBase>();
	}
};
static_assert(alignof(UPalUIPalBoxBase) == 0x000008, "Wrong alignment on UPalUIPalBoxBase");
static_assert(sizeof(UPalUIPalBoxBase) == 0x000448, "Wrong size on UPalUIPalBoxBase");

// Class Pal.PalTutorialQuestManager
// 0x0010 (0x00C8 - 0x00B8)
class UPalTutorialQuestManager : public UPalQuestManager
{
public:
	TArray<struct FPalOrderedQuestSaveData>       CachedOrderedQuestSaveData;                        // 0x00B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalTutorialQuestManager">();
	}
	static class UPalTutorialQuestManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalTutorialQuestManager>();
	}
};
static_assert(alignof(UPalTutorialQuestManager) == 0x000008, "Wrong alignment on UPalTutorialQuestManager");
static_assert(sizeof(UPalTutorialQuestManager) == 0x0000C8, "Wrong size on UPalTutorialQuestManager");
static_assert(offsetof(UPalTutorialQuestManager, CachedOrderedQuestSaveData) == 0x0000B8, "Member 'UPalTutorialQuestManager::CachedOrderedQuestSaveData' has a wrong offset!");

// Class Pal.PalTutorialTrigger_AddItem
// 0x0020 (0x0060 - 0x0040)
class UPalTutorialTrigger_AddItem final : public UPalTutorialTriggerBase
{
public:
	TArray<class FName>                           StaticItemIds;                                     // 0x0040(0x0010)(BlueprintVisible, ZeroConstructor, ExposeOnSpawn, NativeAccessSpecifierPublic)
	EPalItemTypeB                                 ItemCategory;                                      // 0x0050(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F25[0x3];                                     // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BuildObjectId;                                     // 0x0054(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F26[0x4];                                     // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalTutorialTrigger_AddItem">();
	}
	static class UPalTutorialTrigger_AddItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalTutorialTrigger_AddItem>();
	}
};
static_assert(alignof(UPalTutorialTrigger_AddItem) == 0x000008, "Wrong alignment on UPalTutorialTrigger_AddItem");
static_assert(sizeof(UPalTutorialTrigger_AddItem) == 0x000060, "Wrong size on UPalTutorialTrigger_AddItem");
static_assert(offsetof(UPalTutorialTrigger_AddItem, StaticItemIds) == 0x000040, "Member 'UPalTutorialTrigger_AddItem::StaticItemIds' has a wrong offset!");
static_assert(offsetof(UPalTutorialTrigger_AddItem, ItemCategory) == 0x000050, "Member 'UPalTutorialTrigger_AddItem::ItemCategory' has a wrong offset!");
static_assert(offsetof(UPalTutorialTrigger_AddItem, BuildObjectId) == 0x000054, "Member 'UPalTutorialTrigger_AddItem::BuildObjectId' has a wrong offset!");

// Class Pal.PalTutorialTrigger_Individual
// 0x0008 (0x0048 - 0x0040)
class UPalTutorialTrigger_Individual final : public UPalTutorialTriggerBase
{
public:
	EPalTutorialTriggerConditionType              TriggerType;                                       // 0x0040(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F27[0x7];                                     // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalTutorialTrigger_Individual">();
	}
	static class UPalTutorialTrigger_Individual* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalTutorialTrigger_Individual>();
	}
};
static_assert(alignof(UPalTutorialTrigger_Individual) == 0x000008, "Wrong alignment on UPalTutorialTrigger_Individual");
static_assert(sizeof(UPalTutorialTrigger_Individual) == 0x000048, "Wrong size on UPalTutorialTrigger_Individual");
static_assert(offsetof(UPalTutorialTrigger_Individual, TriggerType) == 0x000040, "Member 'UPalTutorialTrigger_Individual::TriggerType' has a wrong offset!");

// Class Pal.PalTutorialTrigger_Respawn
// 0x0010 (0x0050 - 0x0040)
class UPalTutorialTrigger_Respawn final : public UPalTutorialTriggerBase
{
public:
	TArray<EPalLocationType>                      LocationTypes;                                     // 0x0040(0x0010)(BlueprintVisible, ZeroConstructor, ExposeOnSpawn, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalTutorialTrigger_Respawn">();
	}
	static class UPalTutorialTrigger_Respawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalTutorialTrigger_Respawn>();
	}
};
static_assert(alignof(UPalTutorialTrigger_Respawn) == 0x000008, "Wrong alignment on UPalTutorialTrigger_Respawn");
static_assert(sizeof(UPalTutorialTrigger_Respawn) == 0x000050, "Wrong size on UPalTutorialTrigger_Respawn");
static_assert(offsetof(UPalTutorialTrigger_Respawn, LocationTypes) == 0x000040, "Member 'UPalTutorialTrigger_Respawn::LocationTypes' has a wrong offset!");

// Class Pal.PalMapBaseCampWorkerOrderTypeUtility
// 0x0000 (0x0028 - 0x0028)
class UPalMapBaseCampWorkerOrderTypeUtility final : public UBlueprintFunctionLibrary
{
public:
	static bool IsBattleOrderType(const EPalMapBaseCampWorkerOrderType OrderType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalMapBaseCampWorkerOrderTypeUtility">();
	}
	static class UPalMapBaseCampWorkerOrderTypeUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalMapBaseCampWorkerOrderTypeUtility>();
	}
};
static_assert(alignof(UPalMapBaseCampWorkerOrderTypeUtility) == 0x000008, "Wrong alignment on UPalMapBaseCampWorkerOrderTypeUtility");
static_assert(sizeof(UPalMapBaseCampWorkerOrderTypeUtility) == 0x000028, "Wrong size on UPalMapBaseCampWorkerOrderTypeUtility");

// Class Pal.PalWorkAssign
// 0x0068 (0x0090 - 0x0028)
class UPalWorkAssign : public UObject
{
public:
	struct FPalWorkAssignHandleId                 HandleId;                                          // 0x0028(0x0018)(Edit, Net, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPalInstanceID                         AssignedIndividualId;                              // 0x0040(0x0030)(Edit, Net, DisableEditOnTemplate, Transient, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPalWorkWorkerState                           State;                                             // 0x0070(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bFixed;                                            // 0x0071(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPalWorkWorkerWorkingState                    WorkingState;                                      // 0x0072(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F28[0x5];                                     // 0x0073(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LocalRandomWorkLocation;                           // 0x0078(0x0018)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UPalIndividualCharacterHandle* GetAssignedIndividualHandle() const;
	const struct FPalInstanceID GetAssignedIndividualId() const;
	class UPalIndividualCharacterParameter* GetAssignedIndividualParameter() const;
	const struct FPalWorkAssignHandleId GetId() const;
	int32 GetLocationIndex() const;
	EPalWorkWorkerState GetState() const;
	class UPalWorkBase* GetWork() const;
	const struct FGuid GetWorkId() const;
	EPalWorkWorkerWorkingState GetWorkingState() const;
	bool IsAssigned() const;
	bool IsAssignedIndividualId(const struct FPalInstanceID& IndividualId) const;
	bool IsFixed() const;
	bool IsWorkable() const;
	bool IsWorking() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorkAssign">();
	}
	static class UPalWorkAssign* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWorkAssign>();
	}
};
static_assert(alignof(UPalWorkAssign) == 0x000008, "Wrong alignment on UPalWorkAssign");
static_assert(sizeof(UPalWorkAssign) == 0x000090, "Wrong size on UPalWorkAssign");
static_assert(offsetof(UPalWorkAssign, HandleId) == 0x000028, "Member 'UPalWorkAssign::HandleId' has a wrong offset!");
static_assert(offsetof(UPalWorkAssign, AssignedIndividualId) == 0x000040, "Member 'UPalWorkAssign::AssignedIndividualId' has a wrong offset!");
static_assert(offsetof(UPalWorkAssign, State) == 0x000070, "Member 'UPalWorkAssign::State' has a wrong offset!");
static_assert(offsetof(UPalWorkAssign, bFixed) == 0x000071, "Member 'UPalWorkAssign::bFixed' has a wrong offset!");
static_assert(offsetof(UPalWorkAssign, WorkingState) == 0x000072, "Member 'UPalWorkAssign::WorkingState' has a wrong offset!");
static_assert(offsetof(UPalWorkAssign, LocalRandomWorkLocation) == 0x000078, "Member 'UPalWorkAssign::LocalRandomWorkLocation' has a wrong offset!");

// Class Pal.PalWorkAssign_LevelObject
// 0x0010 (0x00A0 - 0x0090)
class UPalWorkAssign_LevelObject final : public UPalWorkAssign
{
public:
	struct FGuid                                  TargetMapObjectModelId;                            // 0x0090(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorkAssign_LevelObject">();
	}
	static class UPalWorkAssign_LevelObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWorkAssign_LevelObject>();
	}
};
static_assert(alignof(UPalWorkAssign_LevelObject) == 0x000008, "Wrong alignment on UPalWorkAssign_LevelObject");
static_assert(sizeof(UPalWorkAssign_LevelObject) == 0x0000A0, "Wrong size on UPalWorkAssign_LevelObject");
static_assert(offsetof(UPalWorkAssign_LevelObject, TargetMapObjectModelId) == 0x000090, "Member 'UPalWorkAssign_LevelObject::TargetMapObjectModelId' has a wrong offset!");

// Class Pal.PalEnergyTypeUtility
// 0x0000 (0x0028 - 0x0028)
class UPalEnergyTypeUtility final : public UBlueprintFunctionLibrary
{
public:
	static void CollectWorkableElementTypes(const EPalEnergyType EnergyType, TArray<EPalElementType>* ElementTypes);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalEnergyTypeUtility">();
	}
	static class UPalEnergyTypeUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalEnergyTypeUtility>();
	}
};
static_assert(alignof(UPalEnergyTypeUtility) == 0x000008, "Wrong alignment on UPalEnergyTypeUtility");
static_assert(sizeof(UPalEnergyTypeUtility) == 0x000028, "Wrong size on UPalEnergyTypeUtility");

// Class Pal.PalLandingTypeUtility
// 0x0000 (0x0028 - 0x0028)
class UPalLandingTypeUtility final : public UBlueprintFunctionLibrary
{
public:
	static bool IsFootStep(EPalLandingType T);
	static bool IsJumpLanding(EPalLandingType T);
	static bool IsRollStep(EPalLandingType T);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalLandingTypeUtility">();
	}
	static class UPalLandingTypeUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalLandingTypeUtility>();
	}
};
static_assert(alignof(UPalLandingTypeUtility) == 0x000008, "Wrong alignment on UPalLandingTypeUtility");
static_assert(sizeof(UPalLandingTypeUtility) == 0x000028, "Wrong size on UPalLandingTypeUtility");

// Class Pal.PalUIActionWidgetBase
// 0x0000 (0x0450 - 0x0450)
class UPalUIActionWidgetBase final : public UCommonActionWidget
{
public:
	void OverrideImage(const struct FSlateBrush& OverrideBrush);
	void OverrideInputType(ECommonInputType InputType);

	class FText GetLocalizedDisplayText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIActionWidgetBase">();
	}
	static class UPalUIActionWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIActionWidgetBase>();
	}
};
static_assert(alignof(UPalUIActionWidgetBase) == 0x000010, "Wrong alignment on UPalUIActionWidgetBase");
static_assert(sizeof(UPalUIActionWidgetBase) == 0x000450, "Wrong size on UPalUIActionWidgetBase");

// Class Pal.PalUIActionWidgetForPlayerInput
// 0x0020 (0x0428 - 0x0408)
class UPalUIActionWidgetForPlayerInput : public UPalUserWidget
{
public:
	class FName                                   BindInputActionName;                               // 0x0408(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   OverrideMouseInputActionName;                      // 0x0410(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   OverridePadInputActionName;                        // 0x0418(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         OverrideInputType;                                 // 0x0420(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F2B[0x4];                                     // 0x0424(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindInputMethodChangeEvent();
	void ChangeBindActionName(const class FName& NewActionName);
	void ChangeOverrideMouseBindActionName(const class FName& NewActionName);
	void ChangeOverridePadBindActionName(const class FName& NewActionName);
	void ChangeOverrideType(int32 Type);
	void OnKeyConfigChanged();
	void UnbindInputMethodChangeEvent();
	void UpdateImage(const struct FSlateBrush& NewBrush);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIActionWidgetForPlayerInput">();
	}
	static class UPalUIActionWidgetForPlayerInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIActionWidgetForPlayerInput>();
	}
};
static_assert(alignof(UPalUIActionWidgetForPlayerInput) == 0x000008, "Wrong alignment on UPalUIActionWidgetForPlayerInput");
static_assert(sizeof(UPalUIActionWidgetForPlayerInput) == 0x000428, "Wrong size on UPalUIActionWidgetForPlayerInput");
static_assert(offsetof(UPalUIActionWidgetForPlayerInput, BindInputActionName) == 0x000408, "Member 'UPalUIActionWidgetForPlayerInput::BindInputActionName' has a wrong offset!");
static_assert(offsetof(UPalUIActionWidgetForPlayerInput, OverrideMouseInputActionName) == 0x000410, "Member 'UPalUIActionWidgetForPlayerInput::OverrideMouseInputActionName' has a wrong offset!");
static_assert(offsetof(UPalUIActionWidgetForPlayerInput, OverridePadInputActionName) == 0x000418, "Member 'UPalUIActionWidgetForPlayerInput::OverridePadInputActionName' has a wrong offset!");
static_assert(offsetof(UPalUIActionWidgetForPlayerInput, OverrideInputType) == 0x000420, "Member 'UPalUIActionWidgetForPlayerInput::OverrideInputType' has a wrong offset!");

// Class Pal.PalUIAimReticleBase
// 0x0008 (0x0410 - 0x0408)
class UPalUIAimReticleBase final : public UPalUserWidget
{
public:
	uint8                                         Pad_2F2C[0x8];                                     // 0x0408(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void IsAssignableToHitResult(const struct FHitResult& HitResult, class UPalCharacterParameterComponent* CheckCharacterParam, struct FPalUIAimReticleMapObjectAssignableData* OutAssignableData);
	void IsThrowableToHitResult(const struct FHitResult& HitResult, class UPalCharacterParameterComponent* CheckCharacterParam, struct FPalUIAimReticleMapObjectThrowableData* OutThrowableData);
	void TickDisplayOutline(const struct FHitResult& HitResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIAimReticleBase">();
	}
	static class UPalUIAimReticleBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIAimReticleBase>();
	}
};
static_assert(alignof(UPalUIAimReticleBase) == 0x000008, "Wrong alignment on UPalUIAimReticleBase");
static_assert(sizeof(UPalUIAimReticleBase) == 0x000410, "Wrong size on UPalUIAimReticleBase");

// Class Pal.PalUIBaseCampPartyModel
// 0x0000 (0x0028 - 0x0028)
class UPalUIBaseCampPartyModel final : public UObject
{
public:
	void SelectHandleSlot(const int32 DisplayIndex, const EPalItemSlotPressType PressType);

	const TArray<class UPalIndividualCharacterSlot*> GetCurrentPageSlots() const;
	const int32 GetSlotCountInPage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIBaseCampPartyModel">();
	}
	static class UPalUIBaseCampPartyModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIBaseCampPartyModel>();
	}
};
static_assert(alignof(UPalUIBaseCampPartyModel) == 0x000008, "Wrong alignment on UPalUIBaseCampPartyModel");
static_assert(sizeof(UPalUIBaseCampPartyModel) == 0x000028, "Wrong size on UPalUIBaseCampPartyModel");

// Class Pal.PalHUDDispatchParameter_BaseCampTask
// 0x0010 (0x0048 - 0x0038)
class UPalHUDDispatchParameter_BaseCampTask final : public UPalHUDDispatchParameterBase
{
public:
	struct FGuid                                  TargetBaseCampID;                                  // 0x0038(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalHUDDispatchParameter_BaseCampTask">();
	}
	static class UPalHUDDispatchParameter_BaseCampTask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalHUDDispatchParameter_BaseCampTask>();
	}
};
static_assert(alignof(UPalHUDDispatchParameter_BaseCampTask) == 0x000008, "Wrong alignment on UPalHUDDispatchParameter_BaseCampTask");
static_assert(sizeof(UPalHUDDispatchParameter_BaseCampTask) == 0x000048, "Wrong size on UPalHUDDispatchParameter_BaseCampTask");
static_assert(offsetof(UPalHUDDispatchParameter_BaseCampTask, TargetBaseCampID) == 0x000038, "Member 'UPalHUDDispatchParameter_BaseCampTask::TargetBaseCampID' has a wrong offset!");

// Class Pal.PalUIBaseCampTaskBase
// 0x0028 (0x0458 - 0x0430)
class UPalUIBaseCampTaskBase final : public UPalUserWidgetOverlayUI
{
public:
	TSubclassOf<class UPalBaseCampTaskChecker>    baseCampTaskCheckerClass;                          // 0x0430(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  BaseCampId;                                        // 0x0438(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         LastCheckedBaseCampLevel;                          // 0x0448(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F2F[0x4];                                     // 0x044C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalBaseCampTaskChecker*                TaskChecker;                                       // 0x0450(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool CheckTask(struct FPalBaseCampTaskCheckedData* OutChedckedData);
	const struct FGuid GetBaseCampId();
	class UPalBaseCampModel* GetBaseCampModel();
	bool GetNowLevelTaskData(struct FPalBaseCampTaskDataSet* OutTaskData);
	bool IsCampLevelMax();
	void SetTargetBaseCampID(const struct FGuid& TargetBaseCampID);
	bool TryBaseCampLevelUp();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIBaseCampTaskBase">();
	}
	static class UPalUIBaseCampTaskBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIBaseCampTaskBase>();
	}
};
static_assert(alignof(UPalUIBaseCampTaskBase) == 0x000008, "Wrong alignment on UPalUIBaseCampTaskBase");
static_assert(sizeof(UPalUIBaseCampTaskBase) == 0x000458, "Wrong size on UPalUIBaseCampTaskBase");
static_assert(offsetof(UPalUIBaseCampTaskBase, baseCampTaskCheckerClass) == 0x000430, "Member 'UPalUIBaseCampTaskBase::baseCampTaskCheckerClass' has a wrong offset!");
static_assert(offsetof(UPalUIBaseCampTaskBase, BaseCampId) == 0x000438, "Member 'UPalUIBaseCampTaskBase::BaseCampId' has a wrong offset!");
static_assert(offsetof(UPalUIBaseCampTaskBase, LastCheckedBaseCampLevel) == 0x000448, "Member 'UPalUIBaseCampTaskBase::LastCheckedBaseCampLevel' has a wrong offset!");
static_assert(offsetof(UPalUIBaseCampTaskBase, TaskChecker) == 0x000450, "Member 'UPalUIBaseCampTaskBase::TaskChecker' has a wrong offset!");

// Class Pal.PalUIBaseCampWorkerListModel
// 0x0030 (0x0058 - 0x0028)
class UPalUIBaseCampWorkerListModel final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnUpdatePageDelegate;                              // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGuid                                  BaseCampId;                                        // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  CurrentDisplayBaseCampId;                          // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SelectFirstEmptyHandleSlot();
	void SelectHandleSlot(const int32 DisplayIndex, const EPalItemSlotPressType PressType);
	void UpdatePageDelegate__DelegateSignature(class UPalUIBaseCampWorkerListModel* Model);

	const struct FGuid GetBaseCampId() const;
	class FString GetBaseCampName() const;
	const struct FGuid GetCurrentDisplayBaseCampId() const;
	void GetCurrentPageSlots(TArray<class UPalIndividualCharacterSlot*>* OutSlots) const;
	int32 GetSlotCountInPage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIBaseCampWorkerListModel">();
	}
	static class UPalUIBaseCampWorkerListModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIBaseCampWorkerListModel>();
	}
};
static_assert(alignof(UPalUIBaseCampWorkerListModel) == 0x000008, "Wrong alignment on UPalUIBaseCampWorkerListModel");
static_assert(sizeof(UPalUIBaseCampWorkerListModel) == 0x000058, "Wrong size on UPalUIBaseCampWorkerListModel");
static_assert(offsetof(UPalUIBaseCampWorkerListModel, OnUpdatePageDelegate) == 0x000028, "Member 'UPalUIBaseCampWorkerListModel::OnUpdatePageDelegate' has a wrong offset!");
static_assert(offsetof(UPalUIBaseCampWorkerListModel, BaseCampId) == 0x000038, "Member 'UPalUIBaseCampWorkerListModel::BaseCampId' has a wrong offset!");
static_assert(offsetof(UPalUIBaseCampWorkerListModel, CurrentDisplayBaseCampId) == 0x000048, "Member 'UPalUIBaseCampWorkerListModel::CurrentDisplayBaseCampId' has a wrong offset!");

// Class Pal.PalUIBaseCampWorkersModel
// 0x0028 (0x0050 - 0x0028)
class UPalUIBaseCampWorkersModel final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnUpdatePageDelegate;                              // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F33[0x10];                                    // 0x0038(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentPageIndex;                                  // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F34[0x4];                                     // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SelectFirstEmptyHandleSlot();
	void SelectHandleSlot(const int32 DisplayIndex, const EPalItemSlotPressType PressType);
	void ToPage(const int32 PageIndex);
	void UpdatePageDelegate__DelegateSignature(class UPalUIBaseCampWorkersModel* Model);

	const struct FGuid GetBaseCampId() const;
	class UPalBaseCampModel* GetBaseCampModel(const int32 PageIndex) const;
	const TArray<class UPalIndividualCharacterSlot*> GetCurrentPageSlots() const;
	const int32 GetSlotCountInPage() const;
	const int32 GetWholePageCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIBaseCampWorkersModel">();
	}
	static class UPalUIBaseCampWorkersModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIBaseCampWorkersModel>();
	}
};
static_assert(alignof(UPalUIBaseCampWorkersModel) == 0x000008, "Wrong alignment on UPalUIBaseCampWorkersModel");
static_assert(sizeof(UPalUIBaseCampWorkersModel) == 0x000050, "Wrong size on UPalUIBaseCampWorkersModel");
static_assert(offsetof(UPalUIBaseCampWorkersModel, OnUpdatePageDelegate) == 0x000028, "Member 'UPalUIBaseCampWorkersModel::OnUpdatePageDelegate' has a wrong offset!");
static_assert(offsetof(UPalUIBaseCampWorkersModel, CurrentPageIndex) == 0x000048, "Member 'UPalUIBaseCampWorkersModel::CurrentPageIndex' has a wrong offset!");

// Class Pal.PalUIBuilding
// 0x0000 (0x0420 - 0x0420)
class UPalUIBuilding final : public UPalUserWidgetStackableUI
{
public:
	void BuildObjectFailed(const int32 ResultIntValue);
	void BuildObjectSuccessed();
	bool IsExistBaseCamp();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIBuilding">();
	}
	static class UPalUIBuilding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIBuilding>();
	}
};
static_assert(alignof(UPalUIBuilding) == 0x000008, "Wrong alignment on UPalUIBuilding");
static_assert(sizeof(UPalUIBuilding) == 0x000420, "Wrong size on UPalUIBuilding");

// Class Pal.PalUIBuildingParameter
// 0x0008 (0x0040 - 0x0038)
class UPalUIBuildingParameter final : public UPalHUDDispatchParameterBase
{
public:
	int32                                         BuildObjectId;                                     // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F37[0x4];                                     // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIBuildingParameter">();
	}
	static class UPalUIBuildingParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIBuildingParameter>();
	}
};
static_assert(alignof(UPalUIBuildingParameter) == 0x000008, "Wrong alignment on UPalUIBuildingParameter");
static_assert(sizeof(UPalUIBuildingParameter) == 0x000040, "Wrong size on UPalUIBuildingParameter");
static_assert(offsetof(UPalUIBuildingParameter, BuildObjectId) == 0x000038, "Member 'UPalUIBuildingParameter::BuildObjectId' has a wrong offset!");

// Class Pal.PalUIBuildModel
// 0x0008 (0x0030 - 0x0028)
class UPalUIBuildModel final : public UObject
{
public:
	class FName                                   ForceBuildPalBoxTextId;                            // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnConfimAlert_ForceBuildPalBox(const bool bDialogBool);
	void OnOpenMenu();

	void FinishDismantleMode() const;
	void GetBuildObjectDataArrayForTypeAByTypeB(const EPalBuildObjectTypeA TypeA, TArray<struct FPalBuildObjectDataSetTypeB>* OutArray) const;
	void StartBuildObject(const class FName BuildObjectId, bool bFromRadialMenu) const;
	void StartDismantleMode(const int32 LastSelectedIndex, bool bFromRadialMenu) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIBuildModel">();
	}
	static class UPalUIBuildModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIBuildModel>();
	}
};
static_assert(alignof(UPalUIBuildModel) == 0x000008, "Wrong alignment on UPalUIBuildModel");
static_assert(sizeof(UPalUIBuildModel) == 0x000030, "Wrong size on UPalUIBuildModel");
static_assert(offsetof(UPalUIBuildModel, ForceBuildPalBoxTextId) == 0x000028, "Member 'UPalUIBuildModel::ForceBuildPalBoxTextId' has a wrong offset!");

// Class Pal.PalBuildProgressWorldHUDParameter
// 0x0010 (0x0048 - 0x0038)
class UPalBuildProgressWorldHUDParameter final : public UPalHUDDispatchParameterBase
{
public:
	class UPalBuildProcess*                       BuildProcess;                                      // 0x0038(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APalBuildObject*                        BuildObject;                                       // 0x0040(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalBuildProgressWorldHUDParameter">();
	}
	static class UPalBuildProgressWorldHUDParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalBuildProgressWorldHUDParameter>();
	}
};
static_assert(alignof(UPalBuildProgressWorldHUDParameter) == 0x000008, "Wrong alignment on UPalBuildProgressWorldHUDParameter");
static_assert(sizeof(UPalBuildProgressWorldHUDParameter) == 0x000048, "Wrong size on UPalBuildProgressWorldHUDParameter");
static_assert(offsetof(UPalBuildProgressWorldHUDParameter, BuildProcess) == 0x000038, "Member 'UPalBuildProgressWorldHUDParameter::BuildProcess' has a wrong offset!");
static_assert(offsetof(UPalBuildProgressWorldHUDParameter, BuildObject) == 0x000040, "Member 'UPalBuildProgressWorldHUDParameter::BuildObject' has a wrong offset!");

// Class Pal.PalUICharacterDisplayOptionInterface
// 0x0000 (0x0028 - 0x0028)
class IPalUICharacterDisplayOptionInterface final : public IInterface
{
public:
	bool IsSelectableSlot(const class UPalIndividualCharacterSlot* Slot) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUICharacterDisplayOptionInterface">();
	}
	static class IPalUICharacterDisplayOptionInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPalUICharacterDisplayOptionInterface>();
	}
};
static_assert(alignof(IPalUICharacterDisplayOptionInterface) == 0x000008, "Wrong alignment on IPalUICharacterDisplayOptionInterface");
static_assert(sizeof(IPalUICharacterDisplayOptionInterface) == 0x000028, "Wrong size on IPalUICharacterDisplayOptionInterface");

// Class Pal.PalUICharacterDisplayModel
// 0x0040 (0x0068 - 0x0028)
class UPalUICharacterDisplayModel final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnUpdateDelegate;                                  // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UPalIndividualCharacterSlot*>    DisplaySlots;                                      // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<struct FPalInstanceID>                 NotSelectableIndividualIds;                        // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F3C[0x10];                                    // 0x0058(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsSelectable(const int32 DisplayIndex);
	void UpdateDelegate__DelegateSignature(class UPalUICharacterDisplayModel* Model);

	void GetDisplaySlots(TArray<class UPalIndividualCharacterSlot*>* OutSlots) const;
	int32 GetSlotCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUICharacterDisplayModel">();
	}
	static class UPalUICharacterDisplayModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUICharacterDisplayModel>();
	}
};
static_assert(alignof(UPalUICharacterDisplayModel) == 0x000008, "Wrong alignment on UPalUICharacterDisplayModel");
static_assert(sizeof(UPalUICharacterDisplayModel) == 0x000068, "Wrong size on UPalUICharacterDisplayModel");
static_assert(offsetof(UPalUICharacterDisplayModel, OnUpdateDelegate) == 0x000028, "Member 'UPalUICharacterDisplayModel::OnUpdateDelegate' has a wrong offset!");
static_assert(offsetof(UPalUICharacterDisplayModel, DisplaySlots) == 0x000038, "Member 'UPalUICharacterDisplayModel::DisplaySlots' has a wrong offset!");
static_assert(offsetof(UPalUICharacterDisplayModel, NotSelectableIndividualIds) == 0x000048, "Member 'UPalUICharacterDisplayModel::NotSelectableIndividualIds' has a wrong offset!");

// Class Pal.PalUICharacterHPGaugeBase
// 0x0000 (0x0408 - 0x0408)
class UPalUICharacterHPGaugeBase final : public UPalUserWidget
{
public:
	void OnRequestClose();
	void SetHPPercent(float Percent);
	void SetTargetCharacter(class APalCharacter* TargetCharacter);
	void SetupEvents();
	void SetupGaugeColor();
	void UpdatePosition();
	void UpdateText();
	void UpdateVisibility();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUICharacterHPGaugeBase">();
	}
	static class UPalUICharacterHPGaugeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUICharacterHPGaugeBase>();
	}
};
static_assert(alignof(UPalUICharacterHPGaugeBase) == 0x000008, "Wrong alignment on UPalUICharacterHPGaugeBase");
static_assert(sizeof(UPalUICharacterHPGaugeBase) == 0x000408, "Wrong size on UPalUICharacterHPGaugeBase");

// Class Pal.PalHUDDispatchParameter_CharacterMake
// 0x0008 (0x0040 - 0x0038)
class UPalHUDDispatchParameter_CharacterMake final : public UPalHUDDispatchParameterBase
{
public:
	bool                                          bIsNewGame;                                        // 0x0038(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRemake;                                         // 0x0039(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F3E[0x6];                                     // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalHUDDispatchParameter_CharacterMake">();
	}
	static class UPalHUDDispatchParameter_CharacterMake* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalHUDDispatchParameter_CharacterMake>();
	}
};
static_assert(alignof(UPalHUDDispatchParameter_CharacterMake) == 0x000008, "Wrong alignment on UPalHUDDispatchParameter_CharacterMake");
static_assert(sizeof(UPalHUDDispatchParameter_CharacterMake) == 0x000040, "Wrong size on UPalHUDDispatchParameter_CharacterMake");
static_assert(offsetof(UPalHUDDispatchParameter_CharacterMake, bIsNewGame) == 0x000038, "Member 'UPalHUDDispatchParameter_CharacterMake::bIsNewGame' has a wrong offset!");
static_assert(offsetof(UPalHUDDispatchParameter_CharacterMake, bIsRemake) == 0x000039, "Member 'UPalHUDDispatchParameter_CharacterMake::bIsRemake' has a wrong offset!");

// Class Pal.PalUICharacterStatus
// 0x0000 (0x0430 - 0x0430)
class UPalUICharacterStatus final : public UPalUserWidgetOverlayUI
{
public:
	void AddActiveSkill(class UPalIndividualCharacterHandle* TargetHandle, EPalWazaID NewWazaID);
	void ChangeActiveSkill(class UPalIndividualCharacterHandle* TargetHandle, EPalWazaID ChangeWazaID, EPalWazaID NewWazaID);
	void ChangeNickname(class UPalIndividualCharacterHandle* TargetHandle, const class FText& NewNickName);
	void DropCharacter(class UPalIndividualCharacterHandle* TargetHandle);
	void RemoveActiveSkill(class UPalIndividualCharacterHandle* TargetHandle, EPalWazaID TargetWazaID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUICharacterStatus">();
	}
	static class UPalUICharacterStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUICharacterStatus>();
	}
};
static_assert(alignof(UPalUICharacterStatus) == 0x000008, "Wrong alignment on UPalUICharacterStatus");
static_assert(sizeof(UPalUICharacterStatus) == 0x000430, "Wrong size on UPalUICharacterStatus");

// Class Pal.PalChatFilteringWaiter
// 0x0058 (0x0080 - 0x0028)
class UPalChatFilteringWaiter final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnFilteredChatMessageDelegate;                     // 0x0028(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	struct FPalChatMessage                        ChatData;                                          // 0x0038(0x0048)(NativeAccessSpecifierPrivate)

public:
	void OnFilteredChatMessageDelegate__DelegateSignature(class UPalChatFilteringWaiter* Waiter, const struct FPalChatMessage& Message);
	void OnReceivedWordFilteringResult(const class FString& ResponseBody, bool bResponseOK, int32 ResponseCode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalChatFilteringWaiter">();
	}
	static class UPalChatFilteringWaiter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalChatFilteringWaiter>();
	}
};
static_assert(alignof(UPalChatFilteringWaiter) == 0x000008, "Wrong alignment on UPalChatFilteringWaiter");
static_assert(sizeof(UPalChatFilteringWaiter) == 0x000080, "Wrong size on UPalChatFilteringWaiter");
static_assert(offsetof(UPalChatFilteringWaiter, OnFilteredChatMessageDelegate) == 0x000028, "Member 'UPalChatFilteringWaiter::OnFilteredChatMessageDelegate' has a wrong offset!");
static_assert(offsetof(UPalChatFilteringWaiter, ChatData) == 0x000038, "Member 'UPalChatFilteringWaiter::ChatData' has a wrong offset!");

// Class Pal.PalUICompassIconBase
// 0x0000 (0x0408 - 0x0408)
class UPalUICompassIconBase final : public UPalUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUICompassIconBase">();
	}
	static class UPalUICompassIconBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUICompassIconBase>();
	}
};
static_assert(alignof(UPalUICompassIconBase) == 0x000008, "Wrong alignment on UPalUICompassIconBase");
static_assert(sizeof(UPalUICompassIconBase) == 0x000408, "Wrong size on UPalUICompassIconBase");

// Class Pal.PalUIConvertItemModel
// 0x0028 (0x0050 - 0x0028)
class UPalUIConvertItemModel final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnUpdateCanTransportOut;                           // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UPalUIProductSettingModel*              ProductSettingModel;                               // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UPalMapObjectConvertItemModel> WeakConvertItemModel;                              // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanTransportOut;                                  // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F43[0x7];                                     // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelProduct();
	void Initialize(class UPalMapObjectConvertItemModel* InModel);
	void ReturnBoolDelegate__DelegateSignature(bool bOn);
	void StartProduction();
	bool TryGetConcreteModel(class UPalMapObjectConvertItemModel** Model);
	void UpdateProductSetting_TransportToStorage(const bool bOn);

	EPalUIConvertItemRequestStartResponse CanStartProduction() const;
	class FText GetBuildObjectName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIConvertItemModel">();
	}
	static class UPalUIConvertItemModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIConvertItemModel>();
	}
};
static_assert(alignof(UPalUIConvertItemModel) == 0x000008, "Wrong alignment on UPalUIConvertItemModel");
static_assert(sizeof(UPalUIConvertItemModel) == 0x000050, "Wrong size on UPalUIConvertItemModel");
static_assert(offsetof(UPalUIConvertItemModel, OnUpdateCanTransportOut) == 0x000028, "Member 'UPalUIConvertItemModel::OnUpdateCanTransportOut' has a wrong offset!");
static_assert(offsetof(UPalUIConvertItemModel, ProductSettingModel) == 0x000038, "Member 'UPalUIConvertItemModel::ProductSettingModel' has a wrong offset!");
static_assert(offsetof(UPalUIConvertItemModel, WeakConvertItemModel) == 0x000040, "Member 'UPalUIConvertItemModel::WeakConvertItemModel' has a wrong offset!");
static_assert(offsetof(UPalUIConvertItemModel, bCanTransportOut) == 0x000048, "Member 'UPalUIConvertItemModel::bCanTransportOut' has a wrong offset!");

// Class Pal.PalUIDamageTextBase
// 0x0038 (0x0440 - 0x0408)
class UPalUIDamageTextBase : public UPalUserWidget
{
public:
	FMulticastInlineDelegateProperty_             OnRequestCloseDelegate;                            // 0x0408(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         DisplayTime;                                       // 0x0418(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DisplayTimer;                                      // 0x041C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPalDamageTextSeq                             NowSeq;                                            // 0x0420(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F45[0x7];                                     // 0x0421(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TargetLocation;                                    // 0x0428(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRequestClose();
	void RequestClose();
	void RequestCloseDelegate__DelegateSignature(class UPalUIDamageTextBase* SelfWidget);
	void ResetTimer();
	void SetDamageColor(const struct FSlateColor& InColor);
	void SetDamageValue(int32 InValue);
	void SetTargetWorldLocation(const struct FVector& NewLocation);
	void StartDisplay(float InDisplayTime);
	void UpdatePosition(const struct FVector& TargetWorldLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIDamageTextBase">();
	}
	static class UPalUIDamageTextBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIDamageTextBase>();
	}
};
static_assert(alignof(UPalUIDamageTextBase) == 0x000008, "Wrong alignment on UPalUIDamageTextBase");
static_assert(sizeof(UPalUIDamageTextBase) == 0x000440, "Wrong size on UPalUIDamageTextBase");
static_assert(offsetof(UPalUIDamageTextBase, OnRequestCloseDelegate) == 0x000408, "Member 'UPalUIDamageTextBase::OnRequestCloseDelegate' has a wrong offset!");
static_assert(offsetof(UPalUIDamageTextBase, DisplayTime) == 0x000418, "Member 'UPalUIDamageTextBase::DisplayTime' has a wrong offset!");
static_assert(offsetof(UPalUIDamageTextBase, DisplayTimer) == 0x00041C, "Member 'UPalUIDamageTextBase::DisplayTimer' has a wrong offset!");
static_assert(offsetof(UPalUIDamageTextBase, NowSeq) == 0x000420, "Member 'UPalUIDamageTextBase::NowSeq' has a wrong offset!");
static_assert(offsetof(UPalUIDamageTextBase, TargetLocation) == 0x000428, "Member 'UPalUIDamageTextBase::TargetLocation' has a wrong offset!");

// Class Pal.PalWorldSecurityLawBase
// 0x0018 (0x0040 - 0x0028)
class UPalWorldSecurityLawBase : public UObject
{
public:
	struct FPalDataTableRowName_CrimeMasterData   CrimeId;                                           // 0x0028(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInvalid;                                          // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F46[0x3];                                     // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CrimeStateMaintainDurationBase;                    // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bNotUseReleaseTimer;                               // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F47[0x7];                                     // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorldSecurityLawBase">();
	}
	static class UPalWorldSecurityLawBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWorldSecurityLawBase>();
	}
};
static_assert(alignof(UPalWorldSecurityLawBase) == 0x000008, "Wrong alignment on UPalWorldSecurityLawBase");
static_assert(sizeof(UPalWorldSecurityLawBase) == 0x000040, "Wrong size on UPalWorldSecurityLawBase");
static_assert(offsetof(UPalWorldSecurityLawBase, CrimeId) == 0x000028, "Member 'UPalWorldSecurityLawBase::CrimeId' has a wrong offset!");
static_assert(offsetof(UPalWorldSecurityLawBase, bInvalid) == 0x000030, "Member 'UPalWorldSecurityLawBase::bInvalid' has a wrong offset!");
static_assert(offsetof(UPalWorldSecurityLawBase, CrimeStateMaintainDurationBase) == 0x000034, "Member 'UPalWorldSecurityLawBase::CrimeStateMaintainDurationBase' has a wrong offset!");
static_assert(offsetof(UPalWorldSecurityLawBase, bNotUseReleaseTimer) == 0x000038, "Member 'UPalWorldSecurityLawBase::bNotUseReleaseTimer' has a wrong offset!");

// Class Pal.PalWorldSecurityLawTrigger
// 0x0000 (0x0040 - 0x0040)
class UPalWorldSecurityLawTrigger : public UPalWorldSecurityLawBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorldSecurityLawTrigger">();
	}
	static class UPalWorldSecurityLawTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWorldSecurityLawTrigger>();
	}
};
static_assert(alignof(UPalWorldSecurityLawTrigger) == 0x000008, "Wrong alignment on UPalWorldSecurityLawTrigger");
static_assert(sizeof(UPalWorldSecurityLawTrigger) == 0x000040, "Wrong size on UPalWorldSecurityLawTrigger");

// Class Pal.PalWorldSecurityLawTrigger_AreaInvasion
// 0x0000 (0x0040 - 0x0040)
class UPalWorldSecurityLawTrigger_AreaInvasion : public UPalWorldSecurityLawTrigger
{
public:
	bool Condition(class AActor* InvasionActor, class UPalIndividualCharacterHandle** CriminalHandle);
	void OnNotifiedEvent(class AActor* InvasionActor, const struct FGuid& AreaInstanceId);
	void OnNotifiedEventEnd(class AActor* InvasionActor, const struct FGuid& AreaInstanceId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorldSecurityLawTrigger_AreaInvasion">();
	}
	static class UPalWorldSecurityLawTrigger_AreaInvasion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWorldSecurityLawTrigger_AreaInvasion>();
	}
};
static_assert(alignof(UPalWorldSecurityLawTrigger_AreaInvasion) == 0x000008, "Wrong alignment on UPalWorldSecurityLawTrigger_AreaInvasion");
static_assert(sizeof(UPalWorldSecurityLawTrigger_AreaInvasion) == 0x000040, "Wrong size on UPalWorldSecurityLawTrigger_AreaInvasion");

// Class Pal.PalDialogParameter_RequestJoinGuild
// 0x0040 (0x00C8 - 0x0088)
class UPalDialogParameter_RequestJoinGuild final : public UPalDialogParameterDialog
{
public:
	struct FGuid                                  TargetPlayerUId;                                   // 0x0088(0x0010)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPalInstanceID                         TargetPlayerInstanceId;                            // 0x0098(0x0030)(BlueprintVisible, Transient, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalDialogParameter_RequestJoinGuild">();
	}
	static class UPalDialogParameter_RequestJoinGuild* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalDialogParameter_RequestJoinGuild>();
	}
};
static_assert(alignof(UPalDialogParameter_RequestJoinGuild) == 0x000008, "Wrong alignment on UPalDialogParameter_RequestJoinGuild");
static_assert(sizeof(UPalDialogParameter_RequestJoinGuild) == 0x0000C8, "Wrong size on UPalDialogParameter_RequestJoinGuild");
static_assert(offsetof(UPalDialogParameter_RequestJoinGuild, TargetPlayerUId) == 0x000088, "Member 'UPalDialogParameter_RequestJoinGuild::TargetPlayerUId' has a wrong offset!");
static_assert(offsetof(UPalDialogParameter_RequestJoinGuild, TargetPlayerInstanceId) == 0x000098, "Member 'UPalDialogParameter_RequestJoinGuild::TargetPlayerInstanceId' has a wrong offset!");

// Class Pal.PalUIDialogBase
// 0x0000 (0x0430 - 0x0430)
class UPalUIDialogBase : public UPalUserWidgetOverlayUI
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIDialogBase">();
	}
	static class UPalUIDialogBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIDialogBase>();
	}
};
static_assert(alignof(UPalUIDialogBase) == 0x000008, "Wrong alignment on UPalUIDialogBase");
static_assert(sizeof(UPalUIDialogBase) == 0x000430, "Wrong size on UPalUIDialogBase");

// Class Pal.PalUIDismantling
// 0x0000 (0x0420 - 0x0420)
class UPalUIDismantling final : public UPalUserWidgetStackableUI
{
public:
	void DismantleObjectFailed();
	void DismantleObjectSuccessed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIDismantling">();
	}
	static class UPalUIDismantling* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIDismantling>();
	}
};
static_assert(alignof(UPalUIDismantling) == 0x000008, "Wrong alignment on UPalUIDismantling");
static_assert(sizeof(UPalUIDismantling) == 0x000420, "Wrong size on UPalUIDismantling");

// Class Pal.PalUIDismantlingModel
// 0x0008 (0x0030 - 0x0028)
class UPalUIDismantlingModel final : public UObject
{
public:
	class FName                                   BuildObjectId;                                     // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void DismantleObject(const bool bContinuously);
	void Dispose();
	void FinishDismantling();
	void OnUpdateInventory(class UPalItemContainer* Container);
	void Setup();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIDismantlingModel">();
	}
	static class UPalUIDismantlingModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIDismantlingModel>();
	}
};
static_assert(alignof(UPalUIDismantlingModel) == 0x000008, "Wrong alignment on UPalUIDismantlingModel");
static_assert(sizeof(UPalUIDismantlingModel) == 0x000030, "Wrong size on UPalUIDismantlingModel");
static_assert(offsetof(UPalUIDismantlingModel, BuildObjectId) == 0x000028, "Member 'UPalUIDismantlingModel::BuildObjectId' has a wrong offset!");

// Class Pal.PalUIGameOver
// 0x0000 (0x0430 - 0x0430)
class UPalUIGameOver final : public UPalUserWidgetOverlayUI
{
public:
	bool IsExistRespawnLocation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIGameOver">();
	}
	static class UPalUIGameOver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIGameOver>();
	}
};
static_assert(alignof(UPalUIGameOver) == 0x000008, "Wrong alignment on UPalUIGameOver");
static_assert(sizeof(UPalUIGameOver) == 0x000430, "Wrong size on UPalUIGameOver");

// Class Pal.ReactivePropertyFloatUtility
// 0x0000 (0x0028 - 0x0028)
class UReactivePropertyFloatUtility final : public UObject
{
public:
	static void BindProperty(struct FReactivePropertyFloat& Property, TDelegate<void(float NewValue)> Delegate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReactivePropertyFloatUtility">();
	}
	static class UReactivePropertyFloatUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReactivePropertyFloatUtility>();
	}
};
static_assert(alignof(UReactivePropertyFloatUtility) == 0x000008, "Wrong alignment on UReactivePropertyFloatUtility");
static_assert(sizeof(UReactivePropertyFloatUtility) == 0x000028, "Wrong size on UReactivePropertyFloatUtility");

// Class Pal.PalUIGuildMenu
// 0x0000 (0x0430 - 0x0430)
class UPalUIGuildMenu final : public UPalUserWidgetOverlayUI
{
public:
	bool CanExitGuild();
	void GetAdminPlayerUId(struct FGuid* OutAdminPlayerUId);
	bool IsAdminLocalPlayer();
	bool IsExistPlayer(const struct FGuid& PlayerUId);
	void OnRemovedMemberInfo(const struct FGuid& PlayerUId);
	void OnUpdatedGuildName(const class FString& NewGuildName);
	void OnUpdatedGuildName_Binded(const class FString& NewGuildName);
	void OnUpdatedMemberInfo(const struct FGuid& PlayerUId, const struct FPalUIGuildMemberDisplayInfo& PlayerInfo);
	void OnUpdatedMemberInfo_Binded(const class UPalGroupGuildBase* Guild, const struct FGuid& PlayerUId, const struct FPalGuildPlayerInfo& PlayerInfo);
	void RequestBanPlayer(const struct FGuid& TargetPlayerUId);
	void RequestChangeAdmin(const struct FGuid& TargetPlayerUId);
	void RequestChangeGuildName(const class FString& NewGuildName);
	void RequestExitGuild();

	void GetGuildMemberInfo(TMap<struct FGuid, struct FPalUIGuildMemberDisplayInfo>* OutDisplayInfoMap) const;
	void GetGuildName(class FString* OutGuildName) const;
	class UPalGroupGuildBase* GetMyGuild() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIGuildMenu">();
	}
	static class UPalUIGuildMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIGuildMenu>();
	}
};
static_assert(alignof(UPalUIGuildMenu) == 0x000008, "Wrong alignment on UPalUIGuildMenu");
static_assert(sizeof(UPalUIGuildMenu) == 0x000430, "Wrong size on UPalUIGuildMenu");

// Class Pal.PalUIHUDLayoutBase
// 0x0000 (0x03C8 - 0x03C8)
class UPalUIHUDLayoutBase final : public UCommonActivatableWidget
{
public:
	void AddHUD(class UPalUserWidget* Widget, const int32 ZOrder);
	void AddWorldHUD(class UPalUserWidgetWorldHUD* Widget);
	void RemoveHUD(class UPalUserWidget* Widget);
	void RemoveWorldHUD(class UPalUserWidgetWorldHUD* Widget);
	void VisibilityOverride(ESlateVisibility ChangedVisibility);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIHUDLayoutBase">();
	}
	static class UPalUIHUDLayoutBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIHUDLayoutBase>();
	}
};
static_assert(alignof(UPalUIHUDLayoutBase) == 0x000008, "Wrong alignment on UPalUIHUDLayoutBase");
static_assert(sizeof(UPalUIHUDLayoutBase) == 0x0003C8, "Wrong size on UPalUIHUDLayoutBase");

// Class Pal.PalUIInGameGeneralDispatchEventReciever
// 0x0000 (0x0408 - 0x0408)
class UPalUIInGameGeneralDispatchEventReciever final : public UPalUserWidget
{
public:
	void CloseBuildingUI();
	void CloseDismantlingUI();
	void OpenBuildingUI(const class FName BuildObjectId);
	void OpenBuildingUIFromRadialMenu(const class FName BuildObjectId);
	void OpenDismantlingUI();
	void OpenDismantlingUIFromRadialMenu(const int32 LastSelectedIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIInGameGeneralDispatchEventReciever">();
	}
	static class UPalUIInGameGeneralDispatchEventReciever* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIInGameGeneralDispatchEventReciever>();
	}
};
static_assert(alignof(UPalUIInGameGeneralDispatchEventReciever) == 0x000008, "Wrong alignment on UPalUIInGameGeneralDispatchEventReciever");
static_assert(sizeof(UPalUIInGameGeneralDispatchEventReciever) == 0x000408, "Wrong size on UPalUIInGameGeneralDispatchEventReciever");

// Class Pal.PalUIInGameInputListener
// 0x0000 (0x0420 - 0x0420)
class UPalUIInGameInputListener final : public UPalUserWidgetStackableUI
{
public:
	void OpenBuildMenu(const int32 BuildObjectTypeA);
	void OpenBuildRadialMenu(const class FName BuildObjectId);
	void OpenBuildRadialMenuWithSelectedIndex(const int32 SelectedIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIInGameInputListener">();
	}
	static class UPalUIInGameInputListener* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIInGameInputListener>();
	}
};
static_assert(alignof(UPalUIInGameInputListener) == 0x000008, "Wrong alignment on UPalUIInGameInputListener");
static_assert(sizeof(UPalUIInGameInputListener) == 0x000420, "Wrong size on UPalUIInGameInputListener");

// Class Pal.PalUIInGameMainMenuBuildModel
// 0x0000 (0x0028 - 0x0028)
class UPalUIInGameMainMenuBuildModel final : public UObject
{
public:
	void Dispose();
	void OnUpdateInventory(class UPalItemContainer* Container);
	void Setup();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIInGameMainMenuBuildModel">();
	}
	static class UPalUIInGameMainMenuBuildModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIInGameMainMenuBuildModel>();
	}
};
static_assert(alignof(UPalUIInGameMainMenuBuildModel) == 0x000008, "Wrong alignment on UPalUIInGameMainMenuBuildModel");
static_assert(sizeof(UPalUIInGameMainMenuBuildModel) == 0x000028, "Wrong size on UPalUIInGameMainMenuBuildModel");

// Class Pal.PalUIInGameMainMenuModel
// 0x0000 (0x0028 - 0x0028)
class UPalUIInGameMainMenuModel final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIInGameMainMenuModel">();
	}
	static class UPalUIInGameMainMenuModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIInGameMainMenuModel>();
	}
};
static_assert(alignof(UPalUIInGameMainMenuModel) == 0x000008, "Wrong alignment on UPalUIInGameMainMenuModel");
static_assert(sizeof(UPalUIInGameMainMenuModel) == 0x000028, "Wrong size on UPalUIInGameMainMenuModel");

// Class Pal.PalWildPalDrinkWaterSpotProvider
// 0x0050 (0x0078 - 0x0028)
class UPalWildPalDrinkWaterSpotProvider final : public UObject
{
public:
	TMap<struct FGuid, class UPalWildDrinkWaterSpot*> DrinkWaterSpotList;                                // 0x0028(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	void AddDrinkWaterSpot(const struct FVector& ActorLocation, const TArray<struct FVector>& GoalLocations);
	void CancelReservation(const struct FGuid& SpotID);
	class UPalWildDrinkWaterSpot* FindSpot(const struct FGuid& SpotID);
	bool RequestReservation(class AActor* LeaderPal, const struct FVector& WildPalSpawnerCenter, int32 MemberNum, struct FGuid* OutSpotID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWildPalDrinkWaterSpotProvider">();
	}
	static class UPalWildPalDrinkWaterSpotProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWildPalDrinkWaterSpotProvider>();
	}
};
static_assert(alignof(UPalWildPalDrinkWaterSpotProvider) == 0x000008, "Wrong alignment on UPalWildPalDrinkWaterSpotProvider");
static_assert(sizeof(UPalWildPalDrinkWaterSpotProvider) == 0x000078, "Wrong size on UPalWildPalDrinkWaterSpotProvider");
static_assert(offsetof(UPalWildPalDrinkWaterSpotProvider, DrinkWaterSpotList) == 0x000028, "Member 'UPalWildPalDrinkWaterSpotProvider::DrinkWaterSpotList' has a wrong offset!");

// Class Pal.PalUIInputGuard
// 0x0000 (0x0408 - 0x0408)
class UPalUIInputGuard final : public UPalUserWidget
{
public:
	void OnTriggerReleaseGuardInput();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIInputGuard">();
	}
	static class UPalUIInputGuard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIInputGuard>();
	}
};
static_assert(alignof(UPalUIInputGuard) == 0x000008, "Wrong alignment on UPalUIInputGuard");
static_assert(sizeof(UPalUIInputGuard) == 0x000408, "Wrong size on UPalUIInputGuard");

// Class Pal.PalUIInsideBaseCampCanvas
// 0x0148 (0x0550 - 0x0408)
class UPalUIInsideBaseCampCanvas final : public UPalUserWidget
{
public:
	FMulticastInlineDelegateProperty_             OnEnterPalBoxAreaDelegate;                         // 0x0408(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnLeavePalBoxAreaDelegate;                         // 0x0418(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnUpdateInsideBaseCampWokerBattleType;             // 0x0428(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class UPalBaseCampTaskChecker*                TaskChecker;                                       // 0x0438(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PalboxAreaRange;                                   // 0x0440(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F4C[0x4];                                     // 0x0444(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UPalLogWidgetBase>          AllTaskCompletedLogClass;                          // 0x0448(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  LastInsideBaseCampID;                              // 0x0450(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FPalDataTableRowName_ItemData, struct FPalInsideBaseCampUI_DisplayItemInfo> DisplayItemInfoMap;                                // 0x0460(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FPalBaseCampTaskCheckedData            CachedTaskCheckData;                               // 0x04B0(0x0060)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F4D[0x8];                                     // 0x0510(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class UPalMapObjectBaseCampWorkerDirectorModel>> WeakBaseCampWorkerDirectorModelArray;              // 0x0518(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class UPalMapObjectBaseCampPassiveWorkHardModel>> WeakBaseCampWorkHardModelArray;                    // 0x0528(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F4E[0x18];                                    // 0x0538(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckInsidePalBox();
	void CheckItemNum(TMap<class FName, int64>* OutItemNumMap, int64* OutFoodNum);
	bool CheckTask(struct FPalBaseCampTaskCheckedData* OutCheckedData);
	void CollectBaseCampWorkerInfo();
	int32 GetBaseCampPalBedCount();
	void GetBaseCampPalSlots(TArray<class UPalIndividualCharacterSlot*>* OutSlots);
	bool GetTaskData(struct FPalBaseCampTaskDataSet* OutTaskData);
	void OnAvailableInsideBaseCampMapObjectConcreteModel(class UPalMapObjectConcreteModelBase* ConcreteModel);
	void OnEnterPalBoxAreaDelegate__DelegateSignature();
	void OnLeavePalBoxAreaDelegate__DelegateSignature();
	void OnNotAvailableInsideBaseCampMapObjectConcreteModel(class UPalMapObjectConcreteModelBase* ConcreteModel);
	void OnUpdateBaseCampWorkerDirectorBattleType(class UPalMapObjectBaseCampWorkerDirectorModel* Model);
	void OnUpdateInsideBaseCampWokerBattleType__DelegateSignature(EPalBaseCampWorkerDirectionBattleType BattleType);
	void RegisterTaskProgressEvent();
	void RemoveAllTaskCompletedLog();
	void ResetCachedTaskCheckData();
	void ResetCollectedBaseCampWorkerInfo();
	void UnregisterTaskProgressEvent(const class UPalBaseCampModel* Model);

	class UPalBaseCampModel* GetInsideBaseCampModel() const;
	struct FGuid GetLocalPlayerGroupID() const;
	EPalBaseCampPassiveEffectWorkHardType GetWorkHardType() const;
	bool IsExistWorkerDirectorModel() const;
	bool IsExistWorkHardModel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIInsideBaseCampCanvas">();
	}
	static class UPalUIInsideBaseCampCanvas* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIInsideBaseCampCanvas>();
	}
};
static_assert(alignof(UPalUIInsideBaseCampCanvas) == 0x000008, "Wrong alignment on UPalUIInsideBaseCampCanvas");
static_assert(sizeof(UPalUIInsideBaseCampCanvas) == 0x000550, "Wrong size on UPalUIInsideBaseCampCanvas");
static_assert(offsetof(UPalUIInsideBaseCampCanvas, OnEnterPalBoxAreaDelegate) == 0x000408, "Member 'UPalUIInsideBaseCampCanvas::OnEnterPalBoxAreaDelegate' has a wrong offset!");
static_assert(offsetof(UPalUIInsideBaseCampCanvas, OnLeavePalBoxAreaDelegate) == 0x000418, "Member 'UPalUIInsideBaseCampCanvas::OnLeavePalBoxAreaDelegate' has a wrong offset!");
static_assert(offsetof(UPalUIInsideBaseCampCanvas, OnUpdateInsideBaseCampWokerBattleType) == 0x000428, "Member 'UPalUIInsideBaseCampCanvas::OnUpdateInsideBaseCampWokerBattleType' has a wrong offset!");
static_assert(offsetof(UPalUIInsideBaseCampCanvas, TaskChecker) == 0x000438, "Member 'UPalUIInsideBaseCampCanvas::TaskChecker' has a wrong offset!");
static_assert(offsetof(UPalUIInsideBaseCampCanvas, PalboxAreaRange) == 0x000440, "Member 'UPalUIInsideBaseCampCanvas::PalboxAreaRange' has a wrong offset!");
static_assert(offsetof(UPalUIInsideBaseCampCanvas, AllTaskCompletedLogClass) == 0x000448, "Member 'UPalUIInsideBaseCampCanvas::AllTaskCompletedLogClass' has a wrong offset!");
static_assert(offsetof(UPalUIInsideBaseCampCanvas, LastInsideBaseCampID) == 0x000450, "Member 'UPalUIInsideBaseCampCanvas::LastInsideBaseCampID' has a wrong offset!");
static_assert(offsetof(UPalUIInsideBaseCampCanvas, DisplayItemInfoMap) == 0x000460, "Member 'UPalUIInsideBaseCampCanvas::DisplayItemInfoMap' has a wrong offset!");
static_assert(offsetof(UPalUIInsideBaseCampCanvas, CachedTaskCheckData) == 0x0004B0, "Member 'UPalUIInsideBaseCampCanvas::CachedTaskCheckData' has a wrong offset!");
static_assert(offsetof(UPalUIInsideBaseCampCanvas, WeakBaseCampWorkerDirectorModelArray) == 0x000518, "Member 'UPalUIInsideBaseCampCanvas::WeakBaseCampWorkerDirectorModelArray' has a wrong offset!");
static_assert(offsetof(UPalUIInsideBaseCampCanvas, WeakBaseCampWorkHardModelArray) == 0x000528, "Member 'UPalUIInsideBaseCampCanvas::WeakBaseCampWorkHardModelArray' has a wrong offset!");

// Class Pal.PalUIItemBoxModel
// 0x0000 (0x0028 - 0x0028)
class UPalUIItemBoxModel final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIItemBoxModel">();
	}
	static class UPalUIItemBoxModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIItemBoxModel>();
	}
};
static_assert(alignof(UPalUIItemBoxModel) == 0x000008, "Wrong alignment on UPalUIItemBoxModel");
static_assert(sizeof(UPalUIItemBoxModel) == 0x000028, "Wrong size on UPalUIItemBoxModel");

// Class Pal.PalUIItemChestFilterModel
// 0x0018 (0x0040 - 0x0028)
class UPalUIItemChestFilterModel final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnUpdateFilterPreferenceDelegate;                  // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UPalMapObjectConcreteModelBase> WeakTargetModel;                                   // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Dispose();
	void OnUpdateFilterPreference(class UPalMapObjectItemContainerModule* Module);
	void RequestAllCheck();
	void RequestAllUncheck();
	void RequestChangeFilter(const class FName InFilterName, const bool bOn);
	void Setup(class UPalMapObjectConcreteModelBase* InConcreteModel);

	TMap<class FName, class FName> GetFilterIdAndDisplayTextId() const;
	class UPalMapObjectItemContainerModule* GetItemContainerModule() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIItemChestFilterModel">();
	}
	static class UPalUIItemChestFilterModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIItemChestFilterModel>();
	}
};
static_assert(alignof(UPalUIItemChestFilterModel) == 0x000008, "Wrong alignment on UPalUIItemChestFilterModel");
static_assert(sizeof(UPalUIItemChestFilterModel) == 0x000040, "Wrong size on UPalUIItemChestFilterModel");
static_assert(offsetof(UPalUIItemChestFilterModel, OnUpdateFilterPreferenceDelegate) == 0x000028, "Member 'UPalUIItemChestFilterModel::OnUpdateFilterPreferenceDelegate' has a wrong offset!");
static_assert(offsetof(UPalUIItemChestFilterModel, WeakTargetModel) == 0x000038, "Member 'UPalUIItemChestFilterModel::WeakTargetModel' has a wrong offset!");

// Class Pal.PalUIItemPossessStatusIndicatorParameter
// 0x0008 (0x0040 - 0x0038)
class UPalUIItemPossessStatusIndicatorParameter final : public UPalHUDDispatchParameterBase
{
public:
	class UPalIndividualCharacterHandle*          TargetCharacter;                                   // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIItemPossessStatusIndicatorParameter">();
	}
	static class UPalUIItemPossessStatusIndicatorParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIItemPossessStatusIndicatorParameter>();
	}
};
static_assert(alignof(UPalUIItemPossessStatusIndicatorParameter) == 0x000008, "Wrong alignment on UPalUIItemPossessStatusIndicatorParameter");
static_assert(sizeof(UPalUIItemPossessStatusIndicatorParameter) == 0x000040, "Wrong size on UPalUIItemPossessStatusIndicatorParameter");
static_assert(offsetof(UPalUIItemPossessStatusIndicatorParameter, TargetCharacter) == 0x000038, "Member 'UPalUIItemPossessStatusIndicatorParameter::TargetCharacter' has a wrong offset!");

// Class Pal.PalWorkTypeUtility
// 0x0000 (0x0028 - 0x0028)
class UPalWorkTypeUtility final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorkTypeUtility">();
	}
	static class UPalWorkTypeUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWorkTypeUtility>();
	}
};
static_assert(alignof(UPalWorkTypeUtility) == 0x000008, "Wrong alignment on UPalWorkTypeUtility");
static_assert(sizeof(UPalWorkTypeUtility) == 0x000028, "Wrong size on UPalWorkTypeUtility");

// Class Pal.PalHUDDispatchParameter_ItemShop
// 0x0008 (0x0040 - 0x0038)
class UPalHUDDispatchParameter_ItemShop : public UPalHUDDispatchParameterBase
{
public:
	class UPalShopBase*                           Shop;                                              // 0x0038(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalHUDDispatchParameter_ItemShop">();
	}
	static class UPalHUDDispatchParameter_ItemShop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalHUDDispatchParameter_ItemShop>();
	}
};
static_assert(alignof(UPalHUDDispatchParameter_ItemShop) == 0x000008, "Wrong alignment on UPalHUDDispatchParameter_ItemShop");
static_assert(sizeof(UPalHUDDispatchParameter_ItemShop) == 0x000040, "Wrong size on UPalHUDDispatchParameter_ItemShop");
static_assert(offsetof(UPalHUDDispatchParameter_ItemShop, Shop) == 0x000038, "Member 'UPalHUDDispatchParameter_ItemShop::Shop' has a wrong offset!");

// Class Pal.PalUIItemShopBase
// 0x0030 (0x0460 - 0x0430)
class UPalUIItemShopBase final : public UPalUserWidgetOverlayUI
{
public:
	uint8                                         Pad_2F52[0x30];                                    // 0x0430(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool TryBuy(const struct FGuid& buyProductID, const int32 BuyNum);
	bool TrySell(const TArray<class UPalItemSlot*>& SellItemSlots);
	bool TrySteal(const struct FGuid& buyProductID, const int32 StealNum);

	bool GetMyShop(class UPalShopBase** OutShop) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIItemShopBase">();
	}
	static class UPalUIItemShopBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIItemShopBase>();
	}
};
static_assert(alignof(UPalUIItemShopBase) == 0x000008, "Wrong alignment on UPalUIItemShopBase");
static_assert(sizeof(UPalUIItemShopBase) == 0x000460, "Wrong size on UPalUIItemShopBase");

// Class Pal.PalHUDDispatchParame_JoinGameInputCode
// 0x01A8 (0x01E0 - 0x0038)
class UPalHUDDispatchParame_JoinGameInputCode final : public UPalHUDDispatchParameterBase
{
public:
	EPalUIJoinGameInputCodeType                   InputCodeType;                                     // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F57[0x7];                                     // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPalUIServerDisplayData                TargetServerDisplayInfo;                           // 0x0040(0x01A0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalHUDDispatchParame_JoinGameInputCode">();
	}
	static class UPalHUDDispatchParame_JoinGameInputCode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalHUDDispatchParame_JoinGameInputCode>();
	}
};
static_assert(alignof(UPalHUDDispatchParame_JoinGameInputCode) == 0x000008, "Wrong alignment on UPalHUDDispatchParame_JoinGameInputCode");
static_assert(sizeof(UPalHUDDispatchParame_JoinGameInputCode) == 0x0001E0, "Wrong size on UPalHUDDispatchParame_JoinGameInputCode");
static_assert(offsetof(UPalHUDDispatchParame_JoinGameInputCode, InputCodeType) == 0x000038, "Member 'UPalHUDDispatchParame_JoinGameInputCode::InputCodeType' has a wrong offset!");
static_assert(offsetof(UPalHUDDispatchParame_JoinGameInputCode, TargetServerDisplayInfo) == 0x000040, "Member 'UPalHUDDispatchParame_JoinGameInputCode::TargetServerDisplayInfo' has a wrong offset!");

// Class Pal.PalUIJoinGameInputCodeBase
// 0x0010 (0x0440 - 0x0430)
class UPalUIJoinGameInputCodeBase : public UPalUserWidgetOverlayUI
{
public:
	class FString                                 CahcedInputInviteCode;                             // 0x0430(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnCompletedFindSessions(bool IsSuccess, const TArray<struct FBlueprintSessionResult>& Results, const class FString& ErrorStr);
	void OnCompletedJoinSession(bool IsSuccess, EJoinSessionResultType Type);
	void OnNotifyVerifyInviteCode(bool IsValidCode, bool IsRequirePassword);
	void OnNotifyVerifyPassword(bool IsMatchPassword);
	void VerifyInviteCode(const class FString& InputCode);
	void VerifyPassword(const class FString& InputPassword);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIJoinGameInputCodeBase">();
	}
	static class UPalUIJoinGameInputCodeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIJoinGameInputCodeBase>();
	}
};
static_assert(alignof(UPalUIJoinGameInputCodeBase) == 0x000008, "Wrong alignment on UPalUIJoinGameInputCodeBase");
static_assert(sizeof(UPalUIJoinGameInputCodeBase) == 0x000440, "Wrong size on UPalUIJoinGameInputCodeBase");
static_assert(offsetof(UPalUIJoinGameInputCodeBase, CahcedInputInviteCode) == 0x000430, "Member 'UPalUIJoinGameInputCodeBase::CahcedInputInviteCode' has a wrong offset!");

// Class Pal.PalUILiftSlotModel
// 0x00C8 (0x00F0 - 0x0028)
class UPalUILiftSlotModel final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnUpdateDelegate;                                  // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateHandleSlotDelegate;                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateIconDelegate;                              // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateCountDelegate;                             // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFailedItemOperationDelegate;                     // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FPalItemSlotId                         SourceItemSlotId;                                  // 0x0078(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPalItemAndNum                         SourceLiftItemInfo;                                // 0x008C(0x002C)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F59[0x18];                                    // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalIndividualCharacterSlot*            CharacterSlot;                                     // 0x00D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F5A[0x18];                                    // 0x00D8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFailedItemOperationDelegate__DelegateSignature();
	void OnUpdateCountDelegate__DelegateSignature(int32 Count);
	void OnUpdateDelegate__DelegateSignature();
	void OnUpdateHandleSlotDelegate__DelegateSignature(class UPalIndividualCharacterSlot* TargetHandleSlot);
	void OnUpdateIconDelegate__DelegateSignature(TSoftObjectPtr<class UTexture2D> IconTexture);
	void OnUpdateLiftHandleSlot(class UPalIndividualCharacterSlot* Slot, class UPalIndividualCharacterHandle* LastHandle);
	void OnUpdateLiftItemSourceSlot(class UPalItemSlot* Slot);
	void ResetLiftItem();
	void SelectCharacterSlot(const struct FPalCharacterSlotId& SlotID, const EPalItemSlotPressType Type);
	void SelectItemSlot(const struct FPalItemSlotId& SlotID, const EPalItemSlotPressType Type);

	bool IsLift() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUILiftSlotModel">();
	}
	static class UPalUILiftSlotModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUILiftSlotModel>();
	}
};
static_assert(alignof(UPalUILiftSlotModel) == 0x000008, "Wrong alignment on UPalUILiftSlotModel");
static_assert(sizeof(UPalUILiftSlotModel) == 0x0000F0, "Wrong size on UPalUILiftSlotModel");
static_assert(offsetof(UPalUILiftSlotModel, OnUpdateDelegate) == 0x000028, "Member 'UPalUILiftSlotModel::OnUpdateDelegate' has a wrong offset!");
static_assert(offsetof(UPalUILiftSlotModel, OnUpdateHandleSlotDelegate) == 0x000038, "Member 'UPalUILiftSlotModel::OnUpdateHandleSlotDelegate' has a wrong offset!");
static_assert(offsetof(UPalUILiftSlotModel, OnUpdateIconDelegate) == 0x000048, "Member 'UPalUILiftSlotModel::OnUpdateIconDelegate' has a wrong offset!");
static_assert(offsetof(UPalUILiftSlotModel, OnUpdateCountDelegate) == 0x000058, "Member 'UPalUILiftSlotModel::OnUpdateCountDelegate' has a wrong offset!");
static_assert(offsetof(UPalUILiftSlotModel, OnFailedItemOperationDelegate) == 0x000068, "Member 'UPalUILiftSlotModel::OnFailedItemOperationDelegate' has a wrong offset!");
static_assert(offsetof(UPalUILiftSlotModel, SourceItemSlotId) == 0x000078, "Member 'UPalUILiftSlotModel::SourceItemSlotId' has a wrong offset!");
static_assert(offsetof(UPalUILiftSlotModel, SourceLiftItemInfo) == 0x00008C, "Member 'UPalUILiftSlotModel::SourceLiftItemInfo' has a wrong offset!");
static_assert(offsetof(UPalUILiftSlotModel, CharacterSlot) == 0x0000D0, "Member 'UPalUILiftSlotModel::CharacterSlot' has a wrong offset!");

// Class Pal.PalUILoadOutModel
// 0x0008 (0x0030 - 0x0028)
class UPalUILoadOutModel final : public UObject
{
public:
	EPalPlayerInventoryType                       DraggedTargetContainerType;                        // 0x0028(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F5D[0x7];                                     // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanSetItem(const struct FPalItemData& ItemData) const;
	void SelectItemSlot(const struct FPalItemSlotId& SlotID, const EPalItemSlotPressType PressType) const;
	const bool TryGetContainer(EPalPlayerInventoryType TargetType, class UPalItemContainer** Container) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUILoadOutModel">();
	}
	static class UPalUILoadOutModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUILoadOutModel>();
	}
};
static_assert(alignof(UPalUILoadOutModel) == 0x000008, "Wrong alignment on UPalUILoadOutModel");
static_assert(sizeof(UPalUILoadOutModel) == 0x000030, "Wrong size on UPalUILoadOutModel");
static_assert(offsetof(UPalUILoadOutModel, DraggedTargetContainerType) == 0x000028, "Member 'UPalUILoadOutModel::DraggedTargetContainerType' has a wrong offset!");

// Class Pal.PalUILocalWorldSelectBase
// 0x0050 (0x0480 - 0x0430)
class UPalUILocalWorldSelectBase : public UPalUserWidgetOverlayUI
{
public:
	TMap<class FString, struct FPalWorldBaseInfoData> LoadedBaseInfoMap;                                 // 0x0430(0x0050)(NativeAccessSpecifierPrivate)

public:
	bool DeleteWorld(const class FString& WorldSaveDirectoryName);
	TArray<struct FPalUILocalWorldDisplayData> GetSortedWorldDisplayInfoArray(const TMap<class FString, struct FPalUILocalWorldDisplayData>& DisplayInfoMap);
	void GetWorldDisplayInfo(TMap<class FString, struct FPalUILocalWorldDisplayData>* OutDisplayInfo);
	bool SelectWorld(const class FString& WorldSaveDirectoryName, const class FString& WorldName, struct FPalOptionWorldSaveData* OptionWorldData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUILocalWorldSelectBase">();
	}
	static class UPalUILocalWorldSelectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUILocalWorldSelectBase>();
	}
};
static_assert(alignof(UPalUILocalWorldSelectBase) == 0x000008, "Wrong alignment on UPalUILocalWorldSelectBase");
static_assert(sizeof(UPalUILocalWorldSelectBase) == 0x000480, "Wrong size on UPalUILocalWorldSelectBase");
static_assert(offsetof(UPalUILocalWorldSelectBase, LoadedBaseInfoMap) == 0x000430, "Member 'UPalUILocalWorldSelectBase::LoadedBaseInfoMap' has a wrong offset!");

// Class Pal.PalUIManager
// 0x0000 (0x0028 - 0x0028)
class UPalUIManager final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIManager">();
	}
	static class UPalUIManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIManager>();
	}
};
static_assert(alignof(UPalUIManager) == 0x000008, "Wrong alignment on UPalUIManager");
static_assert(sizeof(UPalUIManager) == 0x000028, "Wrong size on UPalUIManager");

// Class Pal.PalUIMapObjectHPWorldHUD
// 0x0000 (0x0408 - 0x0408)
class UPalUIMapObjectHPWorldHUD final : public UPalUserWidgetWorldHUD
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIMapObjectHPWorldHUD">();
	}
	static class UPalUIMapObjectHPWorldHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIMapObjectHPWorldHUD>();
	}
};
static_assert(alignof(UPalUIMapObjectHPWorldHUD) == 0x000008, "Wrong alignment on UPalUIMapObjectHPWorldHUD");
static_assert(sizeof(UPalUIMapObjectHPWorldHUD) == 0x000408, "Wrong size on UPalUIMapObjectHPWorldHUD");

// Class Pal.PalUINPCHPGaugeCanvasBase
// 0x0000 (0x0408 - 0x0408)
class UPalUINPCHPGaugeCanvasBase final : public UPalUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUINPCHPGaugeCanvasBase">();
	}
	static class UPalUINPCHPGaugeCanvasBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUINPCHPGaugeCanvasBase>();
	}
};
static_assert(alignof(UPalUINPCHPGaugeCanvasBase) == 0x000008, "Wrong alignment on UPalUINPCHPGaugeCanvasBase");
static_assert(sizeof(UPalUINPCHPGaugeCanvasBase) == 0x000408, "Wrong size on UPalUINPCHPGaugeCanvasBase");

// Class Pal.PalUIOffScreenLoupeBase
// 0x0050 (0x0458 - 0x0408)
class UPalUIOffScreenLoupeBase : public UPalUserWidget
{
public:
	float                                         DisplayDotBorder;                                  // 0x0408(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsWaitedClose;                                     // 0x040C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsOverrideVisibility;                              // 0x040D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsRequestedDisplay;                                // 0x040E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ESlateVisibility                              OverrideVisibility;                                // 0x040F(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                TargetWorldLocation;                               // 0x0410(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              ProjectedScreenPosition;                           // 0x0428(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              CalcedScreenPosition;                              // 0x0438(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              WidgetSize;                                        // 0x0448(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void CalcScreenPosition();
	void CloseSelf();
	void GetTargetWidgetSize(struct FVector2D* OutVector);
	void GetTargetWorldLocation(struct FVector* OutVector);
	bool IsEnableLoupe();
	void OnRequestedClose();
	void RequestClose();
	void RequestDisplay();
	void RequestHide();
	void ResetOverrideVisibility();
	void SetOverrideVisibility(ESlateVisibility NewVisibility);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIOffScreenLoupeBase">();
	}
	static class UPalUIOffScreenLoupeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIOffScreenLoupeBase>();
	}
};
static_assert(alignof(UPalUIOffScreenLoupeBase) == 0x000008, "Wrong alignment on UPalUIOffScreenLoupeBase");
static_assert(sizeof(UPalUIOffScreenLoupeBase) == 0x000458, "Wrong size on UPalUIOffScreenLoupeBase");
static_assert(offsetof(UPalUIOffScreenLoupeBase, DisplayDotBorder) == 0x000408, "Member 'UPalUIOffScreenLoupeBase::DisplayDotBorder' has a wrong offset!");
static_assert(offsetof(UPalUIOffScreenLoupeBase, IsWaitedClose) == 0x00040C, "Member 'UPalUIOffScreenLoupeBase::IsWaitedClose' has a wrong offset!");
static_assert(offsetof(UPalUIOffScreenLoupeBase, IsOverrideVisibility) == 0x00040D, "Member 'UPalUIOffScreenLoupeBase::IsOverrideVisibility' has a wrong offset!");
static_assert(offsetof(UPalUIOffScreenLoupeBase, IsRequestedDisplay) == 0x00040E, "Member 'UPalUIOffScreenLoupeBase::IsRequestedDisplay' has a wrong offset!");
static_assert(offsetof(UPalUIOffScreenLoupeBase, OverrideVisibility) == 0x00040F, "Member 'UPalUIOffScreenLoupeBase::OverrideVisibility' has a wrong offset!");
static_assert(offsetof(UPalUIOffScreenLoupeBase, TargetWorldLocation) == 0x000410, "Member 'UPalUIOffScreenLoupeBase::TargetWorldLocation' has a wrong offset!");
static_assert(offsetof(UPalUIOffScreenLoupeBase, ProjectedScreenPosition) == 0x000428, "Member 'UPalUIOffScreenLoupeBase::ProjectedScreenPosition' has a wrong offset!");
static_assert(offsetof(UPalUIOffScreenLoupeBase, CalcedScreenPosition) == 0x000438, "Member 'UPalUIOffScreenLoupeBase::CalcedScreenPosition' has a wrong offset!");
static_assert(offsetof(UPalUIOffScreenLoupeBase, WidgetSize) == 0x000448, "Member 'UPalUIOffScreenLoupeBase::WidgetSize' has a wrong offset!");

// Class Pal.PalUIOtomoListModel
// 0x0020 (0x0048 - 0x0028)
class UPalUIOtomoListModel final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnSelectSlotDelegate;                              // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateSlotDelegate;                              // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void SelectHandleSlot(const int32 DisplayIndex, const EPalItemSlotPressType PressType);
	void SelectSlotDelegate__DelegateSignature(class UPalUIOtomoListModel* Model, const int32 SlotIndex, const EPalItemSlotPressType PressType);
	void UpdateSlotDelegate__DelegateSignature(class UPalUIOtomoListModel* Model);

	struct FPalContainerId GetContainerId() const;
	void GetCurrentPageSlots(TArray<class UPalIndividualCharacterSlot*>* OutSlots) const;
	int32 GetSlotCountInPage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIOtomoListModel">();
	}
	static class UPalUIOtomoListModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIOtomoListModel>();
	}
};
static_assert(alignof(UPalUIOtomoListModel) == 0x000008, "Wrong alignment on UPalUIOtomoListModel");
static_assert(sizeof(UPalUIOtomoListModel) == 0x000048, "Wrong size on UPalUIOtomoListModel");
static_assert(offsetof(UPalUIOtomoListModel, OnSelectSlotDelegate) == 0x000028, "Member 'UPalUIOtomoListModel::OnSelectSlotDelegate' has a wrong offset!");
static_assert(offsetof(UPalUIOtomoListModel, OnUpdateSlotDelegate) == 0x000038, "Member 'UPalUIOtomoListModel::OnUpdateSlotDelegate' has a wrong offset!");

// Class Pal.PalUIPalBoxTerminalManageModel
// 0x0030 (0x0058 - 0x0028)
class UPalUIPalBoxTerminalManageModel final : public UObject
{
public:
	TSubclassOf<class UPalUIPalBoxModel>          PalBoxClass;                                       // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalUIPalBoxModel*                      PalBox;                                            // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UPalUIBaseCampWorkersModel> BaseCampWorkersClass;                              // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalUIBaseCampWorkersModel*             BaseCampWorkers;                                   // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UPalUIBaseCampPartyModel>   BaseCampPartyClass;                                // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalUIBaseCampPartyModel*               BaseCampParty;                                     // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Initialize(const struct FGuid& BaseCampId);
	void MoveSlotToLost(class UPalIndividualCharacterSlot* Slot);
	void MoveSlotToParty(class UPalIndividualCharacterSlot* Slot);
	void MoveSlotToPosses(class UPalIndividualCharacterSlot* Slot);
	void MoveSlotToWorker(class UPalIndividualCharacterSlot* Slot);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIPalBoxTerminalManageModel">();
	}
	static class UPalUIPalBoxTerminalManageModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIPalBoxTerminalManageModel>();
	}
};
static_assert(alignof(UPalUIPalBoxTerminalManageModel) == 0x000008, "Wrong alignment on UPalUIPalBoxTerminalManageModel");
static_assert(sizeof(UPalUIPalBoxTerminalManageModel) == 0x000058, "Wrong size on UPalUIPalBoxTerminalManageModel");
static_assert(offsetof(UPalUIPalBoxTerminalManageModel, PalBoxClass) == 0x000028, "Member 'UPalUIPalBoxTerminalManageModel::PalBoxClass' has a wrong offset!");
static_assert(offsetof(UPalUIPalBoxTerminalManageModel, PalBox) == 0x000030, "Member 'UPalUIPalBoxTerminalManageModel::PalBox' has a wrong offset!");
static_assert(offsetof(UPalUIPalBoxTerminalManageModel, BaseCampWorkersClass) == 0x000038, "Member 'UPalUIPalBoxTerminalManageModel::BaseCampWorkersClass' has a wrong offset!");
static_assert(offsetof(UPalUIPalBoxTerminalManageModel, BaseCampWorkers) == 0x000040, "Member 'UPalUIPalBoxTerminalManageModel::BaseCampWorkers' has a wrong offset!");
static_assert(offsetof(UPalUIPalBoxTerminalManageModel, BaseCampPartyClass) == 0x000048, "Member 'UPalUIPalBoxTerminalManageModel::BaseCampPartyClass' has a wrong offset!");
static_assert(offsetof(UPalUIPalBoxTerminalManageModel, BaseCampParty) == 0x000050, "Member 'UPalUIPalBoxTerminalManageModel::BaseCampParty' has a wrong offset!");

// Class Pal.PalHUDDispatchParameter_CharacterRankUp
// 0x0008 (0x0040 - 0x0038)
class UPalHUDDispatchParameter_CharacterRankUp final : public UPalHUDDispatchParameterBase
{
public:
	class UPalMapObjectRankUpCharacterModel*      ConcreteModel;                                     // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalHUDDispatchParameter_CharacterRankUp">();
	}
	static class UPalHUDDispatchParameter_CharacterRankUp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalHUDDispatchParameter_CharacterRankUp>();
	}
};
static_assert(alignof(UPalHUDDispatchParameter_CharacterRankUp) == 0x000008, "Wrong alignment on UPalHUDDispatchParameter_CharacterRankUp");
static_assert(sizeof(UPalHUDDispatchParameter_CharacterRankUp) == 0x000040, "Wrong size on UPalHUDDispatchParameter_CharacterRankUp");
static_assert(offsetof(UPalHUDDispatchParameter_CharacterRankUp, ConcreteModel) == 0x000038, "Member 'UPalHUDDispatchParameter_CharacterRankUp::ConcreteModel' has a wrong offset!");

// Class Pal.PalUIPaldex
// 0x0060 (0x0490 - 0x0430)
class UPalUIPaldex final : public UPalUserWidgetOverlayUI
{
public:
	TMap<class FName, struct FPalUIPaldex_DisplayInfo> DisplayInfoMap;                                    // 0x0430(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TArray<struct FPalUIPaldex_DisplayInfo>       DisplayInfoArray;                                  // 0x0480(0x0010)(BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void CreateDisplayInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIPaldex">();
	}
	static class UPalUIPaldex* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIPaldex>();
	}
};
static_assert(alignof(UPalUIPaldex) == 0x000008, "Wrong alignment on UPalUIPaldex");
static_assert(sizeof(UPalUIPaldex) == 0x000490, "Wrong size on UPalUIPaldex");
static_assert(offsetof(UPalUIPaldex, DisplayInfoMap) == 0x000430, "Member 'UPalUIPaldex::DisplayInfoMap' has a wrong offset!");
static_assert(offsetof(UPalUIPaldex, DisplayInfoArray) == 0x000480, "Member 'UPalUIPaldex::DisplayInfoArray' has a wrong offset!");

// Class Pal.PalUIPalFarmSelectCropModel
// 0x0000 (0x0028 - 0x0028)
class UPalUIPalFarmSelectCropModel final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIPalFarmSelectCropModel">();
	}
	static class UPalUIPalFarmSelectCropModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIPalFarmSelectCropModel>();
	}
};
static_assert(alignof(UPalUIPalFarmSelectCropModel) == 0x000008, "Wrong alignment on UPalUIPalFarmSelectCropModel");
static_assert(sizeof(UPalUIPalFarmSelectCropModel) == 0x000028, "Wrong size on UPalUIPalFarmSelectCropModel");

// Class Pal.PalUIPalFoodBoxModel
// 0x0000 (0x0028 - 0x0028)
class UPalUIPalFoodBoxModel final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIPalFoodBoxModel">();
	}
	static class UPalUIPalFoodBoxModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIPalFoodBoxModel>();
	}
};
static_assert(alignof(UPalUIPalFoodBoxModel) == 0x000008, "Wrong alignment on UPalUIPalFoodBoxModel");
static_assert(sizeof(UPalUIPalFoodBoxModel) == 0x000028, "Wrong size on UPalUIPalFoodBoxModel");

// Class Pal.PalUIPalStorageManageModel
// 0x0030 (0x0058 - 0x0028)
class UPalUIPalStorageManageModel final : public UObject
{
public:
	struct FGuid                                  OwnerBaseCampId;                                   // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UPalUIPalStorageModel>      PalStorageClass;                                   // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalUIPalStorageModel*                  PalStorage;                                        // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UPalUIPalStorageManageRightModel> PalStorageManageRightClass;                        // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPalUIPalStorageManageRightModel*       PalStorageManageRight;                             // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Initialize(const struct FGuid& InOwnerBaseCampId);
	void MoveSlotToLost(class UPalIndividualCharacterSlot* Slot);
	void MoveSlotToParty(class UPalIndividualCharacterSlot* Slot);
	void MoveSlotToPosses(class UPalIndividualCharacterSlot* Slot);
	void MoveSlotToWorker(class UPalIndividualCharacterSlot* Slot);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIPalStorageManageModel">();
	}
	static class UPalUIPalStorageManageModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIPalStorageManageModel>();
	}
};
static_assert(alignof(UPalUIPalStorageManageModel) == 0x000008, "Wrong alignment on UPalUIPalStorageManageModel");
static_assert(sizeof(UPalUIPalStorageManageModel) == 0x000058, "Wrong size on UPalUIPalStorageManageModel");
static_assert(offsetof(UPalUIPalStorageManageModel, OwnerBaseCampId) == 0x000028, "Member 'UPalUIPalStorageManageModel::OwnerBaseCampId' has a wrong offset!");
static_assert(offsetof(UPalUIPalStorageManageModel, PalStorageClass) == 0x000038, "Member 'UPalUIPalStorageManageModel::PalStorageClass' has a wrong offset!");
static_assert(offsetof(UPalUIPalStorageManageModel, PalStorage) == 0x000040, "Member 'UPalUIPalStorageManageModel::PalStorage' has a wrong offset!");
static_assert(offsetof(UPalUIPalStorageManageModel, PalStorageManageRightClass) == 0x000048, "Member 'UPalUIPalStorageManageModel::PalStorageManageRightClass' has a wrong offset!");
static_assert(offsetof(UPalUIPalStorageManageModel, PalStorageManageRight) == 0x000050, "Member 'UPalUIPalStorageManageModel::PalStorageManageRight' has a wrong offset!");

// Class Pal.PalUIPalStorageModel
// 0x0020 (0x0048 - 0x0028)
class UPalUIPalStorageModel final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnUpdatePageDelegate;                              // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         CurrentPageIndex;                                  // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F66[0x4];                                     // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPalUICharacterDisplayModel*            DisplayModel;                                      // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnOperatedByOuter();
	void SelectHandleSlot(const int32 DisplayIndex, const EPalItemSlotPressType PressType);
	void ToNextPage();
	void ToPage(const int32 PageIndex, const bool bForce);
	void ToPrevPage();
	void UpdatePageDelegate__DelegateSignature(class UPalUIPalStorageModel* Model);

	bool CanMoveToNext() const;
	bool CanMoveToPrev() const;
	struct FPalContainerId GetTargetContainerId() const;
	int32 GetWholePageCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIPalStorageModel">();
	}
	static class UPalUIPalStorageModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIPalStorageModel>();
	}
};
static_assert(alignof(UPalUIPalStorageModel) == 0x000008, "Wrong alignment on UPalUIPalStorageModel");
static_assert(sizeof(UPalUIPalStorageModel) == 0x000048, "Wrong size on UPalUIPalStorageModel");
static_assert(offsetof(UPalUIPalStorageModel, OnUpdatePageDelegate) == 0x000028, "Member 'UPalUIPalStorageModel::OnUpdatePageDelegate' has a wrong offset!");
static_assert(offsetof(UPalUIPalStorageModel, CurrentPageIndex) == 0x000038, "Member 'UPalUIPalStorageModel::CurrentPageIndex' has a wrong offset!");
static_assert(offsetof(UPalUIPalStorageModel, DisplayModel) == 0x000040, "Member 'UPalUIPalStorageModel::DisplayModel' has a wrong offset!");

// Class Pal.PalUIPlayerEquipment
// 0x0000 (0x0430 - 0x0430)
class UPalUIPlayerEquipment final : public UPalUserWidgetOverlayUI
{
public:
	void RemoveEquipment(EPalPlayerEquipItemSlotType SlotType, class UPalItemSlot* ToSlot);
	void RemoveItemSlot(class UPalItemSlot* TargetSlot, class UPalItemSlot* ToSlot);
	void SetDisableEquipmentHeadMeshFlag(bool IsDisable);
	void SwapEquipment(EPalPlayerEquipItemSlotType SlotType, class UPalItemSlot* FromSlot);
	void SwapItemSlot(class UPalItemSlot* SlotA, class UPalItemSlot* SlotB);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIPlayerEquipment">();
	}
	static class UPalUIPlayerEquipment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIPlayerEquipment>();
	}
};
static_assert(alignof(UPalUIPlayerEquipment) == 0x000008, "Wrong alignment on UPalUIPlayerEquipment");
static_assert(sizeof(UPalUIPlayerEquipment) == 0x000430, "Wrong size on UPalUIPlayerEquipment");

// Class Pal.PalUIPlayerRadialMenuBase
// 0x0000 (0x0408 - 0x0408)
class UPalUIPlayerRadialMenuBase final : public UPalUserWidget
{
public:
	void OpenOtomoFeedInventory();
	void SelectedFeed(const struct FPalItemSlotId& ItemSlotId, const int32 ItemNum);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIPlayerRadialMenuBase">();
	}
	static class UPalUIPlayerRadialMenuBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIPlayerRadialMenuBase>();
	}
};
static_assert(alignof(UPalUIPlayerRadialMenuBase) == 0x000008, "Wrong alignment on UPalUIPlayerRadialMenuBase");
static_assert(sizeof(UPalUIPlayerRadialMenuBase) == 0x000408, "Wrong size on UPalUIPlayerRadialMenuBase");

// Class Pal.PalUIProductSettingModel
// 0x0068 (0x0090 - 0x0028)
class UPalUIProductSettingModel final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnUpdateRecipeDelegate;                            // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateProductNumDelegate;                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateDelegate;                                  // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FText                                   TargetMapObjectName;                               // 0x0058(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	class FName                                   SelectedRecipeId;                                  // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   FocusedRecipeId;                                   // 0x0078(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ProductNum;                                        // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UPalMapObjectEnergyModule> WeakEnergyModule;                                  // 0x0084(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F6B[0x4];                                     // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 CalcMaxProductableNum();
	void DecreaseProductNum();
	void GetRequiredMaterialInfos(TArray<struct FPalStaticItemIdAndNum>* RequiredMaterialInfos);
	void IncreaseProductNum();
	void NotifyUpdateForce();
	void OnUpdateInventory(class UPalItemContainerMultiHelper* IInventoryContainers);
	void ResetProductNum();
	void SelectRecipe(const class FName RecipeID);
	void SetFocusedRecipe(const class FName RecipeID);
	void SetInfiniteProduction();
	void SetMaxProduction();
	void SetProductNumByInput(int32 InputNum);
	bool TryGetEnergyModule(class UPalMapObjectEnergyModule** Module);
	void UpdateSettingDelegate__DelegateSignature(class UPalUIProductSettingModel* Model);

	int32 CalcConsumeEnergy() const;
	float CalcWorkAmount() const;
	int32 GetProductNum() const;
	struct FPalItemRecipe GetRecipe() const;
	class FName GetRecipeId() const;
	bool IsProductNumInfinite() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIProductSettingModel">();
	}
	static class UPalUIProductSettingModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIProductSettingModel>();
	}
};
static_assert(alignof(UPalUIProductSettingModel) == 0x000008, "Wrong alignment on UPalUIProductSettingModel");
static_assert(sizeof(UPalUIProductSettingModel) == 0x000090, "Wrong size on UPalUIProductSettingModel");
static_assert(offsetof(UPalUIProductSettingModel, OnUpdateRecipeDelegate) == 0x000028, "Member 'UPalUIProductSettingModel::OnUpdateRecipeDelegate' has a wrong offset!");
static_assert(offsetof(UPalUIProductSettingModel, OnUpdateProductNumDelegate) == 0x000038, "Member 'UPalUIProductSettingModel::OnUpdateProductNumDelegate' has a wrong offset!");
static_assert(offsetof(UPalUIProductSettingModel, OnUpdateDelegate) == 0x000048, "Member 'UPalUIProductSettingModel::OnUpdateDelegate' has a wrong offset!");
static_assert(offsetof(UPalUIProductSettingModel, TargetMapObjectName) == 0x000058, "Member 'UPalUIProductSettingModel::TargetMapObjectName' has a wrong offset!");
static_assert(offsetof(UPalUIProductSettingModel, SelectedRecipeId) == 0x000070, "Member 'UPalUIProductSettingModel::SelectedRecipeId' has a wrong offset!");
static_assert(offsetof(UPalUIProductSettingModel, FocusedRecipeId) == 0x000078, "Member 'UPalUIProductSettingModel::FocusedRecipeId' has a wrong offset!");
static_assert(offsetof(UPalUIProductSettingModel, ProductNum) == 0x000080, "Member 'UPalUIProductSettingModel::ProductNum' has a wrong offset!");
static_assert(offsetof(UPalUIProductSettingModel, WeakEnergyModule) == 0x000084, "Member 'UPalUIProductSettingModel::WeakEnergyModule' has a wrong offset!");

// Class Pal.PalUIRecoverPalStatusIndicator
// 0x0000 (0x0408 - 0x0408)
class UPalUIRecoverPalStatusIndicator final : public UPalUIMapObjectStatusIndicatorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIRecoverPalStatusIndicator">();
	}
	static class UPalUIRecoverPalStatusIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIRecoverPalStatusIndicator>();
	}
};
static_assert(alignof(UPalUIRecoverPalStatusIndicator) == 0x000008, "Wrong alignment on UPalUIRecoverPalStatusIndicator");
static_assert(sizeof(UPalUIRecoverPalStatusIndicator) == 0x000408, "Wrong size on UPalUIRecoverPalStatusIndicator");

// Class Pal.PalHUDDispatchParameter_RepairBench
// 0x0008 (0x0040 - 0x0038)
class UPalHUDDispatchParameter_RepairBench final : public UPalHUDDispatchParameterBase
{
public:
	class UPalMapObjectRepairItemModel*           Model;                                             // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalHUDDispatchParameter_RepairBench">();
	}
	static class UPalHUDDispatchParameter_RepairBench* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalHUDDispatchParameter_RepairBench>();
	}
};
static_assert(alignof(UPalHUDDispatchParameter_RepairBench) == 0x000008, "Wrong alignment on UPalHUDDispatchParameter_RepairBench");
static_assert(sizeof(UPalHUDDispatchParameter_RepairBench) == 0x000040, "Wrong size on UPalHUDDispatchParameter_RepairBench");
static_assert(offsetof(UPalHUDDispatchParameter_RepairBench, Model) == 0x000038, "Member 'UPalHUDDispatchParameter_RepairBench::Model' has a wrong offset!");

// Class Pal.PalUIRepairItemBase
// 0x0008 (0x0438 - 0x0430)
class UPalUIRepairItemBase final : public UPalUserWidgetOverlayUI
{
public:
	class UPalMapObjectRepairItemModel*           RepairItemModel;                                   // 0x0430(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void CollectRepairableSlot(TArray<class UPalItemSlot*>* OutRepairableSlots);
	void CollectRepairInfo(const TArray<class UPalItemSlot*>& TargetItemSlotArray, TArray<struct FPalStaticItemIdAndNum>* OutRequiredMaterials, bool* OutCanRepair);
	void OnRecievedRepairResult(bool IsSuccess);
	void RequestRepair(const TArray<class UPalItemSlot*>& TargetItemSlotArray);
	void SetMaxDurabilityForce(const TArray<class UPalItemSlot*>& TargetItemSlotArray);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIRepairItemBase">();
	}
	static class UPalUIRepairItemBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIRepairItemBase>();
	}
};
static_assert(alignof(UPalUIRepairItemBase) == 0x000008, "Wrong alignment on UPalUIRepairItemBase");
static_assert(sizeof(UPalUIRepairItemBase) == 0x000438, "Wrong size on UPalUIRepairItemBase");
static_assert(offsetof(UPalUIRepairItemBase, RepairItemModel) == 0x000430, "Member 'UPalUIRepairItemBase::RepairItemModel' has a wrong offset!");

// Class Pal.PalHUDDispatchParameter_SelectItemInventory
// 0x0060 (0x0098 - 0x0038)
class UPalHUDDispatchParameter_SelectItemInventory final : public UPalHUDDispatchParameterBase
{
public:
	class FText                                   TitleText;                                         // 0x0038(0x0018)(BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	TArray<EPalPlayerInventoryType>               ShowInventoryTypes;                                // 0x0050(0x0010)(BlueprintVisible, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<EPalItemTypeA>                         ShowItemTypesA;                                    // 0x0060(0x0010)(BlueprintVisible, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<EPalItemTypeB>                         ShowItemTypesB;                                    // 0x0070(0x0010)(BlueprintVisible, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	bool                                          ShouldSelectNum;                                   // 0x0080(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F6E[0x3];                                     // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(struct FPalItemSlotId& ItemSlotId, int32 ItemNum)> Callback;                                          // 0x0084(0x0010)(BlueprintVisible, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F6F[0x4];                                     // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InvokeCallback(const struct FPalItemSlotId& ItemSlotId, const int32 ItemNum);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalHUDDispatchParameter_SelectItemInventory">();
	}
	static class UPalHUDDispatchParameter_SelectItemInventory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalHUDDispatchParameter_SelectItemInventory>();
	}
};
static_assert(alignof(UPalHUDDispatchParameter_SelectItemInventory) == 0x000008, "Wrong alignment on UPalHUDDispatchParameter_SelectItemInventory");
static_assert(sizeof(UPalHUDDispatchParameter_SelectItemInventory) == 0x000098, "Wrong size on UPalHUDDispatchParameter_SelectItemInventory");
static_assert(offsetof(UPalHUDDispatchParameter_SelectItemInventory, TitleText) == 0x000038, "Member 'UPalHUDDispatchParameter_SelectItemInventory::TitleText' has a wrong offset!");
static_assert(offsetof(UPalHUDDispatchParameter_SelectItemInventory, ShowInventoryTypes) == 0x000050, "Member 'UPalHUDDispatchParameter_SelectItemInventory::ShowInventoryTypes' has a wrong offset!");
static_assert(offsetof(UPalHUDDispatchParameter_SelectItemInventory, ShowItemTypesA) == 0x000060, "Member 'UPalHUDDispatchParameter_SelectItemInventory::ShowItemTypesA' has a wrong offset!");
static_assert(offsetof(UPalHUDDispatchParameter_SelectItemInventory, ShowItemTypesB) == 0x000070, "Member 'UPalHUDDispatchParameter_SelectItemInventory::ShowItemTypesB' has a wrong offset!");
static_assert(offsetof(UPalHUDDispatchParameter_SelectItemInventory, ShouldSelectNum) == 0x000080, "Member 'UPalHUDDispatchParameter_SelectItemInventory::ShouldSelectNum' has a wrong offset!");
static_assert(offsetof(UPalHUDDispatchParameter_SelectItemInventory, Callback) == 0x000084, "Member 'UPalHUDDispatchParameter_SelectItemInventory::Callback' has a wrong offset!");

// Class Pal.PalUISelectItemInventoryBase
// 0x0000 (0x0430 - 0x0430)
class UPalUISelectItemInventoryBase final : public UPalUserWidgetOverlayUI
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUISelectItemInventoryBase">();
	}
	static class UPalUISelectItemInventoryBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUISelectItemInventoryBase>();
	}
};
static_assert(alignof(UPalUISelectItemInventoryBase) == 0x000008, "Wrong alignment on UPalUISelectItemInventoryBase");
static_assert(sizeof(UPalUISelectItemInventoryBase) == 0x000430, "Wrong size on UPalUISelectItemInventoryBase");

// Class Pal.PalUITechnologyDetailButton
// 0x0000 (0x0408 - 0x0408)
class UPalUITechnologyDetailButton : public UPalUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUITechnologyDetailButton">();
	}
	static class UPalUITechnologyDetailButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUITechnologyDetailButton>();
	}
};
static_assert(alignof(UPalUITechnologyDetailButton) == 0x000008, "Wrong alignment on UPalUITechnologyDetailButton");
static_assert(sizeof(UPalUITechnologyDetailButton) == 0x000408, "Wrong size on UPalUITechnologyDetailButton");

// Class Pal.PalUIRecipeTechnologyDetailButton
// 0x0000 (0x0408 - 0x0408)
class UPalUIRecipeTechnologyDetailButton final : public UPalUITechnologyDetailButton
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIRecipeTechnologyDetailButton">();
	}
	static class UPalUIRecipeTechnologyDetailButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIRecipeTechnologyDetailButton>();
	}
};
static_assert(alignof(UPalUIRecipeTechnologyDetailButton) == 0x000008, "Wrong alignment on UPalUIRecipeTechnologyDetailButton");
static_assert(sizeof(UPalUIRecipeTechnologyDetailButton) == 0x000408, "Wrong size on UPalUIRecipeTechnologyDetailButton");

// Class Pal.PalUITitleBase
// 0x0000 (0x0420 - 0x0420)
class UPalUITitleBase : public UPalUserWidgetStackableUI
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUITitleBase">();
	}
	static class UPalUITitleBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUITitleBase>();
	}
};
static_assert(alignof(UPalUITitleBase) == 0x000008, "Wrong alignment on UPalUITitleBase");
static_assert(sizeof(UPalUITitleBase) == 0x000420, "Wrong size on UPalUITitleBase");

// Class Pal.PalGaugeInterpolationCalculatorUtility
// 0x0000 (0x0028 - 0x0028)
class UPalGaugeInterpolationCalculatorUtility final : public UBlueprintFunctionLibrary
{
public:
	static void SetGaugeInterpolationTargetValue(struct FPalGaugeInterpolationCalculator& Target, const float TargetValue);
	static void TickGaugeInterpolation(const class UObject* WorldContextObject, struct FPalGaugeInterpolationCalculator& Target, const float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGaugeInterpolationCalculatorUtility">();
	}
	static class UPalGaugeInterpolationCalculatorUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalGaugeInterpolationCalculatorUtility>();
	}
};
static_assert(alignof(UPalGaugeInterpolationCalculatorUtility) == 0x000008, "Wrong alignment on UPalGaugeInterpolationCalculatorUtility");
static_assert(sizeof(UPalGaugeInterpolationCalculatorUtility) == 0x000028, "Wrong size on UPalGaugeInterpolationCalculatorUtility");

// Class Pal.PalUIUtility
// 0x0000 (0x0028 - 0x0028)
class UPalUIUtility final : public UBlueprintFunctionLibrary
{
public:
	static float ConvertReviveTimerToUIDisplayRemainReviveTime(const class UObject* WorldContextObject, float ReviveTimer);
	static class UPalUserWidget* FindOwningActivatableWidget(const class UObject* WorldContextObject, const class UWidget* Widget);
	static void GetAdditionalEffectName(const class UObject* WorldContextObject, EPalAdditionalEffectType EffectType, class FText* OutName);
	static void GetAllTagFromText(const class UObject* WorldContextObject, const class FText& TargetText, TArray<class FString>* OutTagArray);
	static void GetBaseCampEventName(const class UObject* WorldContextObject, const EPalBaseCampWorkerEventType EventType, class FText* OutName);
	static void GetBuildObjectCategoryAName(const class UObject* WorldContextObject, const EPalBuildObjectTypeA TypeA, class FText* OutName);
	static void GetBuildObjectCategoryBName(const class UObject* WorldContextObject, const EPalBuildObjectTypeB TypeB, class FText* OutName);
	static void GetBuildObjectDesc(const class UObject* WorldContextObject, const class FName& buildObjectName, class FText* OutDesc);
	static void GetFormatedFirstActivatedInfoText(const class UObject* WorldContextObject, class APalCharacter* Character, class FText* OutFormatedText);
	static void GetInventoryCategoryName(const class UObject* WorldContextObject, EPalPlayerInventoryType InventoryType, class FText* OutName);
	static void GetItemDescription(const class UObject* WorldContextObject, const class FName& StaticItemId, class FText* OutName);
	static void GetItemName(const class UObject* WorldContextObject, const class FName& StaticItemId, class FText* OutName);
	static void GetItemTypeAName(const class UObject* WorldContextObject, const EPalItemTypeA ItemTypeA, class FText* OutName);
	static struct FSlateBrush GetKeyIconByKey(const class UObject* WorldContextObject, const struct FKey& Key, ECommonInputType InputType);
	static void GetMapObjectName(const class UObject* WorldContextObject, const class FName& MapObjectName, class FText* OutName);
	static class FName GetMapObjectNameTextId(const class UObject* WorldContextObject, const class FName& MapObjectName);
	static void GetMapObjectOperationResultText(const class UObject* WorldContextObject, const EPalMapObjectOperationResult OperationType, class FText* OutName);
	static struct FSlateBrush GetMappedKeyIcon(const class UObject* WorldContextObject, const class FName InputActionName, ECommonInputType InputType, EPalKeyConfigAxisFilterType FilterType);
	static void GetPalConditionDesc(const class UObject* WorldContextObject, const EPalUIConditionType ConditionType, class FText* OutDesc);
	static void GetPalConditionName(const class UObject* WorldContextObject, const EPalUIConditionType ConditionType, class FText* OutName);
	static int32 GetPalConditionUrgency(const class UObject* WorldContextObject, EPalUIConditionType Condition);
	static void GetPalElementTypeName(const class UObject* WorldContextObject, EPalElementType ElementType, class FText* OutName);
	static void GetPalFirstActivatedInfo(const class UObject* WorldContextObject, const class FName& CharacterID, class FText* OutName);
	static void GetPalGenusCategoryName(const class UObject* WorldContextObject, EPalGenusCategoryType GenusCategory, class FText* OutName);
	static void GetPalLongDescription(const class UObject* WorldContextObject, const class FName& CharacterID, class FText* OutName);
	static bool GetPalRestrictItemID(const class UObject* WorldContextObject, const class FName& CharacterID, class FName* ItemId);
	static void GetPalShortDescription(const class UObject* WorldContextObject, const class FName& CharacterID, class FText* OutName);
	static void GetPartnerSkillName(const class UObject* WorldContextObject, const class FName& CharacterID, class FText* OutText);
	static void GetPassiveSkillName(const class UObject* WorldContextObject, const class FName& PassiveSkillId, class FText* OutName);
	static int32 GetPlayerInframeRenderTargetResolution();
	static void GetTechnologyDescription(const class UObject* WorldContextObject, const class FName& TechnologyName, class FText* OutDescription);
	static void GetUIDisplayPalCondition(const class UObject* WorldContextObject, TArray<EPalUIConditionType>* OutArray, class UPalIndividualCharacterHandle* TargetHandle);
	static bool GetUIInputActionRowHandle(const class UObject* WorldContextObject, const class FName& ActionName, struct FDataTableRowHandle* OutHandle);
	static void GetWaitForWorkableDetailName(const class UObject* WorldContextObject, const EPalWorkType WorkType, class FText* OutName);
	static void GetWazaDesc(const class UObject* WorldContextObject, EPalWazaID WazaID, class FText* OutDesc);
	static void GetWazaName(const class UObject* WorldContextObject, EPalWazaID WazaID, class FText* OutName);
	static void GetWorkerComment(const class UObject* WorldContextObject, class UPalIndividualCharacterHandle* TargetHandle, class FText* OutName);
	static void GetWorkingDetailName(const class UObject* WorldContextObject, const EPalWorkType WorkType, class FText* OutName);
	static bool GetWorkingDetailNameFromHandle(const class UObject* WorldContextObject, class UPalIndividualCharacterHandle* TargetHandle, class FText* OutName);
	static void GetWorkName(const class UObject* WorldContextObject, const EPalWorkType WorkType, class FText* OutName);
	static bool GetWorkNameFromHandle(const class UObject* WorldContextObject, class UPalIndividualCharacterHandle* TargetHandle, class FText* OutName);
	static void GetWorkSickName(const class UObject* WorldContextObject, const EPalBaseCampWorkerSickType SickType, class FText* OutName);
	static void GetWorkSuitabilityName(const class UObject* WorldContextObject, const EPalWorkSuitability WorkSuitability, class FText* OutName);
	static void GetWorkSuitabilityNameWithMaterialSubType(const class UObject* WorldContextObject, const EPalWorkSuitability WorkSuitability, const EPalMapObjectMaterialSubType MaterialSubType, class FText* OutName);
	static bool IsAltDown_ForUI();
	static bool IsControlDown_ForUI();
	static bool IsLeftAltDown_ForUI();
	static bool IsLeftControlDown_ForUI();
	static bool IsLeftShiftDown_ForUI();
	static bool IsRightAltDown_ForUI();
	static bool IsRightControlDown_ForUI();
	static bool IsRightShiftDown_ForUI();
	static bool IsShiftDown_ForUI();
	static bool IsToggleInteract(const class UObject* WorldContextObject);
	static void ResetSlateNavigation(const class UObject* WorldContextObject);
	static void SetCustomSlateNavigation(const class UObject* WorldContextObject, const struct FPalSlateNavigationSetting& NavigationSetting);
	static void SetEnableCommonUIInput(const class UObject* WorldContextObject, bool IsEnable);
	static void SetNumberToSeparatedTextBlock(const class UObject* WorldContextObject, const TArray<int32>& NumberArray, TArray<class UPalTextBlockBase*>& TextBlockArray, float TopZeroTextOpacity);
	static void SetVisibilityHUD(const class UObject* WorldContextObject, bool IsVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIUtility">();
	}
	static class UPalUIUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIUtility>();
	}
};
static_assert(alignof(UPalUIUtility) == 0x000008, "Wrong alignment on UPalUIUtility");
static_assert(sizeof(UPalUIUtility) == 0x000028, "Wrong size on UPalUIUtility");

// Class Pal.PalHUDDispatchParameter_SaveDataBackupSelect
// 0x0010 (0x0048 - 0x0038)
class UPalHUDDispatchParameter_SaveDataBackupSelect final : public UPalHUDDispatchParameterBase
{
public:
	class FString                                 WorldDirectoryName;                                // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalHUDDispatchParameter_SaveDataBackupSelect">();
	}
	static class UPalHUDDispatchParameter_SaveDataBackupSelect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalHUDDispatchParameter_SaveDataBackupSelect>();
	}
};
static_assert(alignof(UPalHUDDispatchParameter_SaveDataBackupSelect) == 0x000008, "Wrong alignment on UPalHUDDispatchParameter_SaveDataBackupSelect");
static_assert(sizeof(UPalHUDDispatchParameter_SaveDataBackupSelect) == 0x000048, "Wrong size on UPalHUDDispatchParameter_SaveDataBackupSelect");
static_assert(offsetof(UPalHUDDispatchParameter_SaveDataBackupSelect, WorldDirectoryName) == 0x000038, "Member 'UPalHUDDispatchParameter_SaveDataBackupSelect::WorldDirectoryName' has a wrong offset!");

// Class Pal.PalUIWorldBackupSelect
// 0x0000 (0x0430 - 0x0430)
class UPalUIWorldBackupSelect : public UPalUserWidgetOverlayUI
{
public:
	void GetBackupDisplayData(TArray<struct FPalUIBackupSaveDisplayData>* OutDisplayData);
	EPalSaveDataRestoreResultType RestoreSaveData(const class FString& SelectedBackupDirectoryName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIWorldBackupSelect">();
	}
	static class UPalUIWorldBackupSelect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIWorldBackupSelect>();
	}
};
static_assert(alignof(UPalUIWorldBackupSelect) == 0x000008, "Wrong alignment on UPalUIWorldBackupSelect");
static_assert(sizeof(UPalUIWorldBackupSelect) == 0x000430, "Wrong size on UPalUIWorldBackupSelect");

// Class Pal.PalUIWorldHUDWidgetCanvas
// 0x0000 (0x0408 - 0x0408)
class UPalUIWorldHUDWidgetCanvas final : public UPalUserWidget
{
public:
	void AddWidget(class UPalUserWidgetWorldHUD* Widget);
	void RemoveWidget(class UPalUserWidgetWorldHUD* Widget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUIWorldHUDWidgetCanvas">();
	}
	static class UPalUIWorldHUDWidgetCanvas* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUIWorldHUDWidgetCanvas>();
	}
};
static_assert(alignof(UPalUIWorldHUDWidgetCanvas) == 0x000008, "Wrong alignment on UPalUIWorldHUDWidgetCanvas");
static_assert(sizeof(UPalUIWorldHUDWidgetCanvas) == 0x000408, "Wrong size on UPalUIWorldHUDWidgetCanvas");

// Class Pal.PalHUDDispatchParameter_WorldMap
// 0x0008 (0x0040 - 0x0038)
class UPalHUDDispatchParameter_WorldMap final : public UPalHUDDispatchParameterBase
{
public:
	bool                                          CanFastTravel;                                     // 0x0038(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ForRespawn;                                        // 0x0039(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInitSelect;                                      // 0x003A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F90[0x5];                                     // 0x003B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalHUDDispatchParameter_WorldMap">();
	}
	static class UPalHUDDispatchParameter_WorldMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalHUDDispatchParameter_WorldMap>();
	}
};
static_assert(alignof(UPalHUDDispatchParameter_WorldMap) == 0x000008, "Wrong alignment on UPalHUDDispatchParameter_WorldMap");
static_assert(sizeof(UPalHUDDispatchParameter_WorldMap) == 0x000040, "Wrong size on UPalHUDDispatchParameter_WorldMap");
static_assert(offsetof(UPalHUDDispatchParameter_WorldMap, CanFastTravel) == 0x000038, "Member 'UPalHUDDispatchParameter_WorldMap::CanFastTravel' has a wrong offset!");
static_assert(offsetof(UPalHUDDispatchParameter_WorldMap, ForRespawn) == 0x000039, "Member 'UPalHUDDispatchParameter_WorldMap::ForRespawn' has a wrong offset!");
static_assert(offsetof(UPalHUDDispatchParameter_WorldMap, IsInitSelect) == 0x00003A, "Member 'UPalHUDDispatchParameter_WorldMap::IsInitSelect' has a wrong offset!");

// Class Pal.PalUniqueSkillModule
// 0x0010 (0x0038 - 0x0028)
class UPalUniqueSkillModule final : public UObject
{
public:
	class APalCharacter*                          ActionCharacter;                                   // 0x0028(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 ActionTarget;                                      // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnBeginModule();
	void OnEndModule();
	void SetActionCharacter(class APalCharacter* Character);
	void SetActionTarget(class AActor* Target);
	void TickModule(float DeltaTime);

	class APalCharacter* GetActionCharacter() const;
	class AActor* GetActionTarget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUniqueSkillModule">();
	}
	static class UPalUniqueSkillModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUniqueSkillModule>();
	}
};
static_assert(alignof(UPalUniqueSkillModule) == 0x000008, "Wrong alignment on UPalUniqueSkillModule");
static_assert(sizeof(UPalUniqueSkillModule) == 0x000038, "Wrong size on UPalUniqueSkillModule");
static_assert(offsetof(UPalUniqueSkillModule, ActionCharacter) == 0x000028, "Member 'UPalUniqueSkillModule::ActionCharacter' has a wrong offset!");
static_assert(offsetof(UPalUniqueSkillModule, ActionTarget) == 0x000030, "Member 'UPalUniqueSkillModule::ActionTarget' has a wrong offset!");

// Class Pal.PalWidgetTimerGaugeParameter
// 0x0018 (0x0050 - 0x0038)
class UPalWidgetTimerGaugeParameter final : public UPalHUDDispatchParameterBase
{
public:
	struct FTimerHandle                           TimerHandle;                                       // 0x0038(0x0008)(BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0040(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   bindActionName;                                    // 0x0044(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsHide;                                            // 0x004C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F91[0x3];                                     // 0x004D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWidgetTimerGaugeParameter">();
	}
	static class UPalWidgetTimerGaugeParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWidgetTimerGaugeParameter>();
	}
};
static_assert(alignof(UPalWidgetTimerGaugeParameter) == 0x000008, "Wrong alignment on UPalWidgetTimerGaugeParameter");
static_assert(sizeof(UPalWidgetTimerGaugeParameter) == 0x000050, "Wrong size on UPalWidgetTimerGaugeParameter");
static_assert(offsetof(UPalWidgetTimerGaugeParameter, TimerHandle) == 0x000038, "Member 'UPalWidgetTimerGaugeParameter::TimerHandle' has a wrong offset!");
static_assert(offsetof(UPalWidgetTimerGaugeParameter, Time) == 0x000040, "Member 'UPalWidgetTimerGaugeParameter::Time' has a wrong offset!");
static_assert(offsetof(UPalWidgetTimerGaugeParameter, bindActionName) == 0x000044, "Member 'UPalWidgetTimerGaugeParameter::bindActionName' has a wrong offset!");
static_assert(offsetof(UPalWidgetTimerGaugeParameter, IsHide) == 0x00004C, "Member 'UPalWidgetTimerGaugeParameter::IsHide' has a wrong offset!");

// Class Pal.PalUserWidgetTimerGaugeBase
// 0x0010 (0x0418 - 0x0408)
class UPalUserWidgetTimerGaugeBase final : public UPalUserWidgetWorldHUD
{
public:
	struct FTimerHandle                           TargetTimerHandle;                                 // 0x0408(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Time;                                              // 0x0410(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F92[0x4];                                     // 0x0414(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetGaugePercent(float Percent);
	void SetGaugeText(const class FText& Text);
	void VisibilityForceHidden(ESlateVisibility ChangedVisibility);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUserWidgetTimerGaugeBase">();
	}
	static class UPalUserWidgetTimerGaugeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUserWidgetTimerGaugeBase>();
	}
};
static_assert(alignof(UPalUserWidgetTimerGaugeBase) == 0x000008, "Wrong alignment on UPalUserWidgetTimerGaugeBase");
static_assert(sizeof(UPalUserWidgetTimerGaugeBase) == 0x000418, "Wrong size on UPalUserWidgetTimerGaugeBase");
static_assert(offsetof(UPalUserWidgetTimerGaugeBase, TargetTimerHandle) == 0x000408, "Member 'UPalUserWidgetTimerGaugeBase::TargetTimerHandle' has a wrong offset!");
static_assert(offsetof(UPalUserWidgetTimerGaugeBase, Time) == 0x000410, "Member 'UPalUserWidgetTimerGaugeBase::Time' has a wrong offset!");

// Class Pal.PalUtility
// 0x0000 (0x0028 - 0x0028)
class UPalUtility final : public UBlueprintFunctionLibrary
{
public:
	static void AddDownForceAllRigidBody(class APalCharacter* TargetCharacter, float Rate);
	static void AddForceWithMassScale(class APalCharacter* TargetCharacter, const struct FVector& Force, class FName BoneName, bool IsImplus);
	static class AActor* AdjustActorToFloor(class AActor* TargetActor, float UpOffset);
	static void Alert(const class UObject* WorldContextObject, const class FText& Message);
	static void AlertWithCallback(const class UObject* WorldContextObject, const class FText& Message, TDelegate<void(bool bResult)> Callback);
	static float Angle180from360Degree(float Degree);
	static float AngleBetweenVector(const struct FVector& A, const struct FVector& B, bool IsDegree);
	static void ApplyGuildColorForCharacter(const struct FLinearColor& Color, class APalCharacter* Character);
	static bool BoxOvelapLimitVolume(const class UObject* WorldContextObject, EPalLimitVolumeFlag LimitVolumeFlag, const struct FVector& BoxPos, const struct FVector& BoxExtent, const struct FQuat& Rot);
	static struct FVector CalcBlowVelocity(EPalBlowVelocityOwner VelocityType, const class AActor* Attacker, const class USceneComponent* HitComponent, const struct FVector& HitLocation, const class AActor* Defender, const struct FVector& NativeVelocity);
	static float CalcCaptureRateByStatus(const class AActor* TargetPal);
	static int32 CalcDamage(const struct FPalDamageInfo& DamageInfo, const class AActor* Defender);
	static int32 CalcDamageCharacter(const struct FPalDamageInfo& DamageInfo, const class AActor* Defender, const struct FPalCalcCharacterDamageInfo& CharacterDamageInfo);
	static int32 CalcNPCWeaponDamage(const class APalWeaponBase* Weapon);
	static int32 CalcRemainBattleTime(const struct FDateTime& TimeLimit);
	static struct FRotator CalcRotationGeneralTurnLinear(const struct FVector& InForwardDirection, const struct FVector& InRightDirection, const float CurrentYaw, const struct FVector& InGoalDirection, float AngleDegreeSpeed, float DeltaTime, const float YawRate);
	static void CalcSceneComponentBounds(const TArray<class USceneComponent*>& SceneComps, struct FBox* OutBounds);
	static bool CanAdjustActorToFloor(class AActor* TargetActor, float UpOffset, struct FVector* OutLocation);
	static bool CanNooseTrap(class AActor* Actor);
	static bool CanSpawnDashEffect(class AActor* DashActor);
	static bool CanUseTargetMedicine(const class UObject* WorldContextObject, class UPalIndividualCharacterParameter* IndividualParameter, const class UPalStaticItemDataBase* Item);
	static bool CanUseTargetPalExpItem(const class UObject* WorldContextObject, class UPalIndividualCharacterParameter* IndividualParameter, const class UPalStaticItemDataBase* Item);
	static bool CanUseTargetRankUp(const class UObject* WorldContextObject, class UPalIndividualCharacterParameter* IndividualParameter, const class UPalStaticItemDataBase* Item);
	static void ChangeDefaultLandMovementModeForWalking(class APalCharacter* Character);
	static void ClearCharacterRagdoll(class APalCharacter* Character);
	static bool ClipboardCopy(const class FString& String);
	static bool ContainsAny(const TArray<class UObject*>& SourceArray, const TArray<class UObject*>& FindElms);
	static bool ContainsOnlyIn(const TArray<class UObject*>& SourceArray, const TArray<class UObject*>& TargetElms, class UObject* Target);
	static class FString Convert_PalInstanceIDToString(const struct FPalInstanceID& ID);
	static EObjectTypeQuery ConvertToObjectTypeQuery(EPalObjectTypeQuery Type);
	static EPhysicalSurface ConvertToPhysicalSurface(EPalPhysicalSurface Type);
	static ETraceTypeQuery ConvertToTraceTypeQuery(EPalTraceTypeQuery Type);
	static void CreateUNKO(class APalCharacter* Character, int32 Count);
	static struct FVector CutVectorByAngle(const struct FVector& Target, const struct FVector& BaseAxis, float MaxAngleDegree);
	static struct FVector CutVectorByLength(const struct FVector& Vector, float Length);
	static void DestroyActorIncludingAttachedActors(class AActor* Actor);
	static struct FGuid Dialog(const class UObject* WorldContextObject, const class FText& Message, const EPalDialogType DialogType, TDelegate<void(bool bResult)> Callback, const bool bNegativeDefault);
	static struct FGuid DialogWithParameter(const class UObject* WorldContextObject, class UPalDialogParameterDialog* Parameter);
	static void DropCharacter_ServerInternal(const class UObject* WorldContextObject, const struct FPalInstanceID& IndividualId, const struct FVector& DropLocation, const struct FGuid& RequestPlayerUId, bool CreateLocation);
	static void DropCharactersCircularly_ServerInternal(const class UObject* WorldContextObject, const TArray<class UPalIndividualCharacterHandle*>& IndividualHandles, const struct FVector& Location, const struct FPalDropCharacterExtraParameter& ExtraParameter);
	static void DropItem_FromEnemyDeath(const class AActor* EnemyActor, const class AActor* LastAttacker);
	static void Editor_AddCharacterToImportanceManager(class APalCharacter* Character);
	static void EmitSoundForAIListener(class FName SoundFName, class AActor* EmitterCharacter, const struct FVector& EmitLocation, float VolumeRate);
	static class FText EnumToLocalizedText(const class UObject* WorldContextObject, const class FString& EnumStr, const EPalLocalizeTextCategory TextCategory, const class FString& TextIdPrefix);
	static class AActor* FindHomingTarget_ForPlayer(class APalPlayerCharacter* Player, float MinRange, float MaxRange, float InFrontDegree);
	static class AActor* FindOwnerActor(const class UObject* StartObject);
	static class APalCharacter* FindOwnerPalCharacter(const class UObject* StartObject);
	static class APalCharacter* FindRiderByRidingActor(const class AActor* RidingActor);
	static void GeneralTurn(class AActor* TurnActor, const struct FVector& GoalDirection, float LerpSpeed, float DeltaTime);
	static void GeneralTurn_WithMovementRotationSpeed(class AActor* TurnActor, const struct FVector& GoalDirection, float DeltaTime);
	static void GeneralTurnLinear(class AActor* TurnActor, const struct FVector& GoalDirection, float AngleDegreeSpeed, float DeltaTime);
	static void GeneralTurnLinearToActor(class AActor* TurnActor, const class AActor* TargetActor, float LerpSpeed, float DeltaTime);
	static void GeneralTurnToActor(class AActor* TurnActor, const class AActor* TargetActor, float LerpSpeed, float DeltaTime);
	static void GeneralTurnToActor_WithMovementRotationSpeed(class AActor* TurnActor, const class AActor* GoalDirectionActor, float DeltaTime);
	static TArray<struct FPalKeyAction> GetActionsByKey(const class UObject* WorldContextObject, const struct FKey& Key);
	static void GetActorByGrid(class UObject* WorldContextObject, TSubclassOf<class AActor> ActorClass, const struct FVector2D& MinPoint, const struct FVector2D& MaxPoint, int32 GridXMax, int32 GridYMax, int32 GridXNum, int32 GridYNum, TArray<class AActor*>* OutActors);
	static struct FQuat GetActorQuat(const class AActor* SourceActor);
	static class FString GetAdminPasswordForCmdline(const class UObject* WorldContextObject);
	static class FName GetAkComponentAttachName(class AActor* Character);
	static void GetAllControlledCharacters(const class UObject* WorldContextObject, TArray<class APalCharacter*>* OutCharacters);
	static void GetAllPlayerCharacters(const class UObject* WorldContextObject, TArray<class APalCharacter*>* OutPlayers);
	static void GetAllPlayerStates(const class UObject* WorldContextObject, TArray<class APalPlayerState*>* OutPlayerStates);
	static class FString GetAPIBaseURL(const class UObject* WorldContextObject);
	static bool GetArrivableLocation(class UObject* WorldContextObject, const struct FVector& StartLocation, const struct FVector& TargetLocation, const float OffsetZUp, const float OffsetZUnder, EPalTraceTypeQuery TraceTypeQuery, const float Range, struct FVector* OutLocation, float* OutDistance, EDrawDebugTrace DrawDebugType);
	static class UPalAssetStreamableManager* GetAssetStreamableManager(const class UObject* WorldContextObject);
	static bool GetAttachInformationByBodyLocation(class AActor* Character, EPalBodyLocationType bodyLocationType, class USceneComponent** AttachComponent, class FName* AttachBoneName, struct FTransform* AttachRelativeTransform);
	static struct FVector GetAttackTargetLocation(const class AActor* Attacker, const class AActor* TargetActor);
	static class UPalAudioSettingSystem* GetAudioSettingSystem(const class UObject* WorldContextObject);
	static class UPalBaseCampManager* GetBaseCampManager(const class UObject* WorldContextObject);
	static class UPalBattleManager* GetBattleManager(const class UObject* WorldContextObject);
	static struct FTransform GetBodyLocation(class AActor* Character, EPalBodyLocationType bodyLocationType);
	static EPalBodyPartsType GetBodyPartsType(const class UActorComponent* Component);
	static class FName GetBoneNameFromEHumanBone(EHumanBone HumanBone);
	static class UPalBossBattleManager* GetBossBattleManager(const class UObject* WorldContextObject);
	static class UPalBulletCreator* GetBulletCreator(const class UObject* WorldContextObject);
	static class UProjectileMovementComponent* GetBulletProjectileComponent(const TSubclassOf<class APalBullet>& bulletClass);
	static void GetCalculatedCaptureRate(const class UObject* WorldContextObject, float baseRate, TArray<float>* OutCalculatedRateArray);
	static void GetCharacterApartFromPlayer(const class UObject* WorldContextObject, TArray<class APalCharacter*>* OutCharacters);
	static class UPalCharacterContainerManager* GetCharacterContainerManager(const class UObject* WorldContextObject);
	static class FName GetCharacterIDFromCharacter(const class APalCharacter* Character);
	static class FName GetCharacterIDFromTribeID(const EPalTribeID TribeID);
	static class FName GetCharacterIDReplacedName(class FName OriginalID);
	static class UPalCharacterImportanceManager* GetCharacterImportanceManager(const class UObject* WorldContextObject);
	static bool GetCharacterMakeInfoFromLocalPlayer(const class UObject* WorldContextObject, struct FPalPlayerDataCharacterMakeInfo* OutMakeInfo);
	static class UPalCharacterManager* GetCharacterManager(const class UObject* WorldContextObject);
	static class UPalCharacterParameterStorageSubsystem* GetCharacterParameterStorageSubsystem(const class UObject* WorldContextObject);
	static float GetCharacterRadius(const class AActor* Actor);
	static class UClass* GetClassFromBlueprintAsset(const struct FAssetData& Asset);
	static bool GetClipboard(class FString* String);
	static class AController* GetController(const class UObject* WorldContextObject, class AActor* Actor);
	static class UPalCoopSkillSearchSystem* GetCoopSkillSearchSystem(const class UObject* WorldContextObject);
	static EPalWorkSuitability GetCurrentWorkSuitability(class APalCharacter* Character);
	static class UPalDamagePopUpManager* GetDamagePopUpManager(const class UObject* WorldContextObject);
	static class UPalDatabaseCharacterParameter* GetDatabaseCharacterParameter(const class UObject* WorldContextObject);
	static class UPalDeadBodyManager* GetDeadBodyManager(const class UObject* WorldContextObject);
	static class UPalDeathPenaltyManager* GetDeathPenaltyManager(const class UObject* WorldContextObject);
	static class FName GetDebugBotBaseCampMode(const class UObject* WorldContextObject);
	static int32 GetDebugBotBaseCampWorkerCount(const class UObject* WorldContextObject);
	static int32 GetDebugEnemySpawnCountForBot(const class UObject* WorldContextObject);
	static class UObject* GetDefaultObject(TSubclassOf<class UObject> ObjectClass);
	static class UObject* GetDefaultObjectByBlueprint(class UObject* bp);
	static struct FVector GetDiffVelocity(class AActor* A, class AActor* B);
	static class FString GetDisplayVersion(const class UObject* WorldContextObject);
	static EHumanBone GetEHumanBoneFromBoneName(class FName BoneName);
	static float GetElementMultiplay(const class UObject* WorldContextObject, EPalElementType AttackElementType, EPalElementType DefenceTypeA, EPalElementType DefenceTypeB);
	static TArray<class APalCharacter*> GetEnemiesByLocation(const class UObject* WorldContextObject, const struct FVector& Location, class APalCharacter* MyCharacter, float MinDistance, float MaxDistance);
	static TArray<class APalCharacter*> GetEnemiesByLocation2D(const class UObject* WorldContextObject, const struct FVector& Location, class APalCharacter* MyCharacter, float MinDistance, float MaxDistance, float MinHeight, float MaxHeight);
	static ECollisionChannel GetEngineCollisionChannel(EPalObjectTypeQuery Channnel);
	static ECollisionChannel GetEngineCollisionChannelByPalObjectType(EPalObjectTypeQuery Type);
	static ECollisionChannel GetEngineCollisionChannelByPalTraceType(EPalTraceTypeQuery Type);
	static class UPalEventNotifySystem* GetEventNotifySystem(const class UObject* WorldContextObject);
	static struct FVector GetExclamationMarkLocation(const class APalCharacter* TargetCharacter);
	static class UPalExpDatabase* GetExpDatabase(const class UObject* WorldContextObject);
	static class FString GetFirstLine(const class FString& SourceString);
	static struct FVector GetFloorHitLocationByActor(class AActor* TargetActor);
	static struct FVector GetFloorLocationByActor(class AActor* TargetActor);
	static class UPalFunnelCharacterManager* GetFunnelCharacterManager(const class UObject* WorldContextObject);
	static TArray<class FName> GetGainStatusItemEffectStatus(const class UObject* WorldContextObject, const class FName ItemId);
	static class UPalGameSetting* GetGameSetting(const class UObject* WorldContextObject);
	static class UPalGroupManager* GetGroupManager(const class UObject* WorldContextObject);
	static class FName GetHairAttachAccessorySocketName(const class UObject* WorldContextObject, const class FName& HairEquipmentName, const class FName& BodyTypeName);
	static class UPalHUDService* GetHUDService(const class UObject* WorldContextObject);
	static void GetHumanNPCs(const class UObject* WorldContextObject, TArray<class APalCharacter*>* OutCharacters);
	static class UPalIncidentSystem* GetIncidentSystem(const class UObject* WorldContextObject);
	static class UPalIndividualCharacterHandle* GetIndividualCharacterHandleByActor(class AActor* Actor);
	static class UPalIndividualCharacterParameter* GetIndividualCharacterParameterByActor(class AActor* Actor);
	static struct FPalInstanceID GetIndividualID(const class UPalIndividualCharacterHandle* Handle);
	static struct FPalInstanceID GetIndividualIDByActor(const class AActor* Actor);
	static bool GetInitializedCharacterSaveParemter(const class UObject* WorldContextObject, const class FName CharacterID, const class FName UniqueNPCID, const int32 Level, const struct FGuid& OwnerPlayerUId, struct FPalIndividualCharacterSaveParameter* OutParameter, bool DisableRandomPassiveSkill, bool RarePalAble);
	static bool GetInitializedCharacterSaveParemter_DebugDefaultParamSetup(const class UObject* WorldContextObject, const class FName CharacterID, const class FName UniqueNPCID, const int32 Level, const struct FGuid& OwnerPlayerUId, struct FPalIndividualCharacterSaveParameter* OutParameter, bool DisableRandomPassiveSkilll, const TArray<EPalWazaID>& WazaList, const TArray<class FName>& PassiveSkillList, int32 Rank, const TArray<struct FPalDebugCharacterStatusRank>& StatusRank, bool RarePalAble);
	static bool GetInitializedPlayerSaveParemter(const class UObject* WorldContextObject, const int32 Level, struct FPalIndividualCharacterSaveParameter* OutParameter);
	static float GetInPacketLoss(const class UObject* WorldContextObject);
	static class UPalInvaderManager* GetInvaderManager(const class UObject* WorldContextObject);
	static class UPalPlayerInventoryData* GetInventoryDataByPlayerUID(const class UObject* WorldContextObject, const struct FGuid& PlayerUId);
	static class UPalItemContainerManager* GetItemContainerManager(const class UObject* WorldContextObject);
	static class UPalItemIDManager* GetItemIDManager(const class UObject* WorldContextObject);
	static class UPalPlayerInventoryData* GetLocalInventoryData(const class UObject* WorldContextObject);
	static class UPalMoneyData* GetLocalMoneyData(const class UObject* WorldContextObject);
	static class UPalPlayerInput* GetLocalPalPlayerInput(const class UObject* WorldContextObject);
	static class UPalPlayerDataPalStorage* GetLocalPalStorageData(const class UObject* WorldContextObject);
	static class APlayerController* GetLocalPlayerController(const class UObject* WorldContextObject);
	static int32 GetLocalPlayerID(const class UObject* WorldContextObject);
	static class APalPlayerState* GetLocalPlayerState(const class UObject* WorldContextObject);
	static struct FGuid GetLocalPlayerUID(const class UObject* WorldContextObject);
	static class UPalPlayerRecordData* GetLocalRecordData(const class UObject* WorldContextObject);
	static class UPalTechnologyData* GetLocalTechnologyData(const class UObject* WorldContextObject);
	static class UPalWorldMapUIData* GetLocalWorldMapData(const class UObject* WorldContextObject);
	static class UPalLocationManager* GetLocationManager(const class UObject* WorldContextObject);
	static class UPalLogManager* GetLogManager(const class UObject* WorldContextObject);
	static class USkeletalMeshComponent* GetMainMeshByActor(class AActor* Actor);
	static class UPalMapObjectManager* GetMapObjectManager(const class UObject* WorldContextObject);
	static class UPalMasterDataTables* GetMasterDataTables(const class UObject* WorldContextObject);
	static class UPalMoneyData* GetMoneyDataByPlayerUID(const class UObject* WorldContextObject, const struct FGuid& PlayerUId);
	static void GetMontageNotifyStates(class UAnimMontage* Montange, TArray<class UAnimNotifyState*>* OutStates, class FName SectionName);
	static float GetMontageSectionLength(class UAnimMontage* Montange, class FName SectionName);
	static float GetMontageSectionLengthDefault(class UAnimMontage* Montange);
	static class APalMapObject* GetNearestEnemyBuildObject(class AActor* Character);
	static class APalCharacter* GetNearestEnemyByLocation(const struct FVector& Location, class APalCharacter* MyCharacter, float* OutMinRange);
	static class APalCharacter* GetNearestEnemyByLocation_FrontPlayerCamera(const struct FVector& Location, class APalCharacter* MyCharacter, class APalPlayerCharacter* Player, float InDegree, float InDistance, float InHeight);
	static float GetNearstPlayerDistance2D(const class UObject* WorldContextObject, const struct FVector& Location);
	static class APalNetworkTransmitter* GetNetworkTransmitter(const class UObject* WorldContextObject);
	static class APalNetworkTransmitter* GetNetworkTransmitterByPlayerCharacter(class APalPlayerCharacter* Player);
	static class APalNetworkTransmitter* GetNetworkTransmitterByPlayerId(const class UObject* WorldContextObject, const int32 PlayerId);
	static class UPalNPCManager* GetNPCManager(const class UObject* WorldContextObject);
	static int32 GetNumPlayers(const class UObject* WorldContextObject);
	static bool GetOffFromPal(class AActor* RiderActor, bool bIsSkipAnimation, bool bNoAnimCancel);
	static class UPalOilrigManager* GetOilrigManager(const class UObject* WorldContextObject);
	static const struct FPalOptionGraphicsSettings GetOptionGraphicsSettings(const class UObject* WorldContextObject);
	static const struct FPalOptionKeyboardSettings GetOptionKeyboardSettings(const class UObject* WorldContextObject);
	static const struct FPalOptionPadSettings GetOptionPadSettings(const class UObject* WorldContextObject);
	static class UPalOptionSubsystem* GetOptionSubsystem(const class UObject* WorldContextObject);
	static const struct FPalOptionWorldSettings GetOptionWorldSettings(const class UObject* WorldContextObject);
	static class UPalOtomoHolderComponentBase* GetOtomoHolderByOtomoPal(class AActor* OtomoPal);
	static class UPalOtomoHolderComponentBase* GetOtomoHolderComponent(const class UObject* WorldContextObject);
	static float GetOutPacketLoss(const class UObject* WorldContextObject);
	static TArray<int32> GetOverlapFoliageIndexByComponent(class UPrimitiveComponent* AttackComponent, class UPrimitiveComponent* FolageComponent);
	static void GetOverrideLoginPlayerUId(const class UObject* WorldContextObject, struct FGuid* PlayerUId);
	static void GetPalCharacters(const class UObject* WorldContextObject, TArray<class APalCharacter*>* OutCharacters);
	static class UPalCheatManager* GetPalCheatManager(const class UObject* WorldContextObject);
	static class UPalDebugSetting* GetPalDebugSetting();
	static class UPalGameInstance* GetPalGameInstance(const class UObject* WorldContextObject);
	static class APalGameMode* GetPalGameMode(const class UObject* WorldContextObject);
	static class APalGameState* GetPalGameState(const class UObject* WorldContextObject);
	static class APalGameStateInGame* GetPalGameStateInGame(const class UObject* WorldContextObject);
	static class UPalGameWorldSettings* GetPalGameWorldSettings();
	static void GetPalIconInfoByCharacterID(class UObject* WorldContextObject, const struct FPalDataTableRowName_PalMonsterData& CharacterID, TSoftObjectPtr<class UTexture2D>* OutIcon, bool* OutIsRare, bool* OutIsBoss);
	static class APalPlayerCharacter* GetPalmi(const class UObject* WorldContextObject);
	static void GetPalMonsters(const class UObject* WorldContextObject, TArray<class APalCharacter*>* OutCharacters);
	static class UPalObjectCollector* GetPalObjectCollector(const class UObject* WorldContextObject);
	static class UPalPlayerDataPalStorage* GetPalStorageDataByPlayerUID(const class UObject* WorldContextObject, const struct FGuid& PlayerUId);
	static class UPalPassiveSkillManager* GetPassiveSkillManager(const class UObject* WorldContextObject);
	static class FString GetPassword(const class UObject* WorldContextObject);
	static EPhysicalSurface GetPhysicalSurfaceType(const class UObject* WorldContextObject, const struct FVector& RayStart, const struct FVector& RayEnd, bool* bHit);
	static EPhysicalSurface GetPhysicalSurfaceTypeByActor(class AActor* SelfActor, class FName SocketName, const struct FVector& OffsetSt, const struct FVector& OffsetEd, bool* bHit);
	static int32 GetPhysicsBoneIndex(class AActor* Character, EPalPhysicsBoneType boneType);
	static class FName GetPhysicsBoneName(class AActor* Character, EPalPhysicsBoneType boneType);
	static class FName GetPhysicsRootBoneName(class AActor* Character);
	static EPalSupportedPlatformType GetPlatformType(const class UObject* WorldContextObject);
	static class APalPlayerCharacter* GetPlayerCharacter(const class UObject* WorldContextObject);
	static class ACharacter* GetPlayerCharacterByPlayerId(const class UObject* WorldContextObject, const int32 PlayerId);
	static class APalPlayerCharacter* GetPlayerCharacterByPlayerIndex(const class UObject* WorldContextObject, const int32 PlayerIndex);
	static class APalPlayerCharacter* GetPlayerCharacterByPlayerUID(const class UObject* WorldContextObject, const struct FGuid& PlayerUId);
	static class APalCharacter* GetPlayerControlledCharacter(const class UObject* WorldContextObject);
	static class APawn* GetPlayerControlledPawn(const class UObject* WorldContextObject);
	static class APalPlayerController* GetPlayerControllerByPlayerId(const class UObject* WorldContextObject, const int32 PlayerId);
	static class APalPlayerController* GetPlayerControllerByPlayerUId(const class UObject* WorldContextObject, const struct FGuid& PlayerUId);
	static class UPalPlayerDataStorage* GetPlayerDataStorage(const class UObject* WorldContextObject);
	static int32 GetPlayerEquipmentDefense(const class UObject* WorldContextObject, const struct FGuid& PlayerUId);
	static int32 GetPlayerEquipmentHP(const class UObject* WorldContextObject, const struct FGuid& PlayerUId);
	static void GetPlayerEquipmentPassiveList(const class UObject* WorldContextObject, const struct FGuid& PlayerUId, TArray<class FName>* OutPassiveList);
	static int32 GetPlayerEquipmentShield(const class UObject* WorldContextObject, const struct FGuid& PlayerUId);
	static TArray<struct FPlayerListItem> GetPlayerList(const class UObject* WorldContextObject);
	static class FString GetPlayerListDisplayMessage(const class UObject* WorldContextObject);
	static TArray<class FString> GetPlayerListDisplayMessages(const class UObject* WorldContextObject);
	static class UPalPlayerManager* GetPlayerManager(const class UObject* WorldContextObject);
	static class APalPlayerState* GetPlayerState(const class AActor* Player);
	static class APalPlayerState* GetPlayerStateByPlayer(const class APalPlayerCharacter* Player);
	static class APalPlayerState* GetPlayerStateByPlayerUid(const class UObject* WorldContextObject, const struct FGuid& PlayerUId);
	static class APalPlayerState* GetPlayerStateByUserId(const class UObject* WorldContextObject, const class FString& UserId);
	static struct FGuid GetPlayerUIDByActor(const class AActor* PlayerActor);
	static struct FGuid GetPlayerUIdByString(const class UObject* WorldContextObject, const class FString& PlayerUIdOrSteamId);
	static class FString GetPlayerUniqueIdToString(const struct FUniqueNetIdRepl& UserId);
	static class UPalRaidBossManager* GetRaidBossManager(const class UObject* WorldContextObject);
	static void GetRandomPointList(int32 PointNum, int32 MaxLoopCount, float MinXPos, float MaxXPos, float MinYPos, float MaxYPos, float SizeX, float SizeY, const struct FRandomStream& RandomStream, TArray<struct FVector2D>* OutPointArray);
	static float GetRangeToGround(class AActor* Actor);
	static class UPalRCONSubsystem* GetRCONSubsystem(const class UObject* WorldContextObject);
	static class UPalPlayerRecordData* GetRecordDataByPlayerUID(const class UObject* WorldContextObject, const struct FGuid& PlayerUId);
	static struct FTransform GetRelativeTransformFromRoot(class USceneComponent* SceneComponent);
	static class UPalRESTAPISubsystem* GetRESTAPISubsystem(const class UObject* WorldContextObject);
	static float GetRTTJitter(const class UObject* WorldContextObject);
	static float GetSafeZero(float Value);
	static class UPalSaveGameManager* GetSaveGameManager(const class UObject* WorldContextObject);
	static EPalLogFormatType GetServerLogFormatType(const class UObject* WorldContextObject);
	static class FString GetServerWorldDisplayName(const class UObject* WorldContextObject);
	static class UPalShopManager* GetShopManager(const class UObject* WorldContextObject);
	static class USignificanceManager* GetSignificanceManager(const class UObject* WorldContextObject);
	static void GetStatUnitResult(const class UObject* WorldContextObject, float* FrameTime, float* GameThreadTime, float* RenderThreadTime, float* GPUTime);
	static int32 GetStatusPoint(class UPalIndividualCharacterHandle* Handle, class FName StatusName);
	static class UPalTechnologyData* GetTechnologyDataByPlayerUID(const class UObject* WorldContextObject, const struct FGuid& PlayerUId);
	static class UPalTimeManager* GetTimeManager(const class UObject* WorldContextObject);
	static class APalPlayerCharacter* GetTrainerPlayer(const class AActor* Monster);
	static class APalPlayerController* GetTrainerPlayerController_ForServer(class AActor* Monster);
	static struct FQuat GetTransformQuat(const struct FTransform& SourceTransform);
	static EPalTribeID GetTribeIDFromCharacterID(const class UObject* WorldContextObject, const class FName& CharacterID);
	static void GetTribeIDNameFromCharacterID(const class UObject* WorldContextObject, const class FName& CharacterID, class FName* OutTribeIDName);
	static void GetTribeIDNameFromParameter(const class UObject* WorldContextObject, class UPalIndividualCharacterParameter* IndividualParameter, class FName* OutTribeIDName);
	static class UPalTutorialManager* GetTutorialManager(const class UObject* WorldContextObject);
	static class UPalVisualEffectDataBase* GetVisualEffectDatabase(const class UObject* WorldContextObject);
	static class UPalWazaDatabase* GetWazaDatabase(const class UObject* WorldContextObject);
	static int32 GetWeakCount(EPalElementType AttackElementType, EPalElementType DefenceTypeA, EPalElementType DefenceTypeB);
	static int32 GetWeakCount_ForUI(EPalElementType AttackElementType, EPalElementType DefenceTypeA, EPalElementType DefenceTypeB, EPalAttackType AttackType, EPalBodyPartsType BodyPartsType);
	static void GetWeakElementType(EPalElementType Type1, EPalElementType Type2, TArray<EPalElementType>* OutArray);
	static class UPalWorkProgressManager* GetWorkProgressManager(const class UObject* WorldContextObject);
	static float GetWorkSpeed(class APalCharacter* Character);
	static class UPalWorldObjectRecordWorldSubsystem* GetWorldObjectRecorder(const class UObject* WorldContextObject);
	static class UPalWorldSecuritySystem* GetWorldSecuritySystem(const class UObject* WorldContextObject);
	static void GiftItem_FromOtomoCutMeat(const class AActor* Otomo, const class AActor* Trainer);
	static void GiveExpToAroundCharacter(const class UObject* WorldContextObject, const struct FVector& Center, float Radius, float Exp, TSubclassOf<class APalCharacter> CharacterClass, bool bCallDelegate);
	static void GiveExpToAroundPlayerCharacter(const class UObject* WorldContextObject, const struct FVector& Center, float Radius, float Exp, bool bCallDelegate);
	static bool HasAliveFriendPlayers(class APalCharacter* My);
	static bool HasResponseToChannelByPalObjectType(class APalCharacter* Character, EPalObjectTypeQuery Type, ECollisionResponse Response);
	static void HeadBillboardEffectSetTransform(class APalCharacter* Character, class USceneComponent* Effect, const struct FVector& AddOffset);
	static bool InConeShapAndDitance(const struct FVector& SelfLocation, const struct FRotator& SelfRotator, const struct FVector& TargetLocation, float Degree, float Distance);
	static bool InConeShapAndDitance_Actor(const class AActor* SelfActor, const class AActor* TargetActor, float Degree, float Distance);
	static bool InConeShapAndDitance_PreThreshold(const struct FVector& SelfLocation, const struct FRotator& SelfRotator, const struct FVector& TargetLocation, float Threshold, float Distance);
	static bool InConeShapAndDitance_PreThreshold_Actor(const class AActor* SelfActor, const class AActor* TargetActor, float Threshold, float Distance);
	static bool InFanShap(const class AActor* SelfActor, const class AActor* TargetActor, float Degree);
	static bool InFanShap_PlayerCamera(const class AActor* SelfActor, const class APalPlayerCharacter* Player, float Degree);
	static bool InFanShap_TargetLocation(const class AActor* SelfActor, const struct FVector& TargetLocation, float Degree);
	static bool InFanShapAimTarget(const class AActor* SelfActor, const class AActor* TargetActor, float Degree);
	static bool InFanShapAndDitance(const class AActor* SelfActor, const class AActor* TargetActor, float Degree, float Distance);
	static void InitializeHumanBoneInfo(class UPalAnimInstance* AnimInstance);
	static bool InWazaMaxRange(class APalCharacter* Attacker, EPalWazaID Waza, const struct FVector& TargetLocation, float TargetRadius);
	static bool IsAIAttackAbleByPlayerCamera(const class AActor* SelfActor, const class AActor* TargetActor);
	static bool IsAliveOrDyingFriendPlayers_ByUId(const class UObject* WorldContextObject, const struct FGuid& PlayerUId);
	static bool IsAllLevelLoaded(const class UObject* WorldContextObject);
	static bool IsApplicableDamage(class UObject* Causer, class AActor* Receiver, class UPrimitiveComponent* ReceivedComponent);
	static bool IsApplicablePowerOnlyToDamageValue(class AActor* Reciever);
	static bool IsBaseCampPal(const class AActor* Actor);
	static bool IsBotEnterDungeon(const class UObject* WorldContextObject);
	static bool IsBotMode(const class UObject* WorldContextObject);
	static bool IsBuildBotBaseCamp(const class UObject* WorldContextObject);
	static bool IsCanOpenExternalWebSite();
	static bool IsCanPlayDedicatedServer(const class UObject* WorldContextObject);
	static bool IsCanPlayInviteCode();
	static bool IsCanPlaySinglePlay();
	static bool IsClientDedicatedServer(const class UObject* WorldContextObject);
	static bool IsCrossplayBlock();
	static bool IsDead(class AActor* Actor);
	static bool IsDedicatedServer(const class UObject* WorldContextObject);
	static bool IsDestructionByCompleteBuilt(const class UObject* WorldContextObject);
	static bool IsDevelopmentBuild();
	static bool IsDyingPlayer(const class APalPlayerCharacter* PlayerCharacter);
	static bool IsEditorBuild();
	static bool IsEditorPreviewActor(class AActor* Actor);
	static bool IsElementStrong(EPalElementType AttackType, EPalElementType DefenceType);
	static bool IsElementWeak(EPalElementType AttackType, EPalElementType DefenceType);
	static bool IsEnableBotLocationFlag(const class UObject* WorldContextObject);
	static bool IsEnableRandomizeSpawner(const class UObject* WorldContextObject);
	static bool IsEnemy(const class AActor* ActorA, const class AActor* ActorB);
	static bool IsExistsInDoor(class AActor* TargetActor, const EDrawDebugTrace DrawDebugType, const float DrawDebugDuration);
	static bool IsForceQuitOnDisconnect(const class UObject* WorldContextObject);
	static bool IsFriend(const class AActor* ActorA, const class AActor* ActorB);
	static bool IsGDK(const class UObject* WorldContextObject);
	static bool IsHairAttachAccessory(const class UObject* WorldContextObject, const class FName& EquipmentArmorName);
	static bool IsIgnoreNetworkVersionCheck(const class UObject* WorldContextObject);
	static bool IsInClientConnection(const class UObject* WorldContextObject);
	static bool IsLive(class AActor* Actor);
	static bool IsLocalControlActor(const class AActor* CheckActor);
	static bool IsLocalControlActorOrPalmi(class AActor* CheckActor);
	static bool IsLocalPlayerCampPal(const class AActor* Actor);
	static bool IsMultiplayer(const class UObject* WorldContextObject);
	static bool IsMultiplayRestricted(const class UObject* WorldContextObject);
	static bool IsNearTwoActor(const class AActor* Actor1, const class AActor* Actor2, float Distance, bool IgnoreHeight);
	static bool IsNearTwoActorWithRadius(const class AActor* Actor1, const class AActor* Actor2, float Distance, bool IgnoreHeight);
	static bool IsNearTwoActorWithRootRadius(const class AActor* Actor1, const class AActor* Actor2, float Distance, bool IgnoreHeight);
	static bool IsNearTwoPoint(const struct FVector& Point1, const struct FVector& Point2, float Distance, bool IgnoreHeight);
	static bool IsOpenListenServer(const class UObject* WorldContextObject);
	static bool IsOtomo(const class AActor* Actor);
	static bool IsPalCharacter(class AActor* Actor);
	static bool IsPalMonster(const class AActor* Actor);
	static bool IsPIEUsingPlayerStart();
	static bool IsPlayerControlActor(class AActor* CheckActor);
	static bool IsPointInDoor(const class UObject* WorldContextObject, const struct FVector& Point, const TArray<class AActor*>& IgnoreActors, const EDrawDebugTrace DrawDebugType, const float DrawDebugDuration);
	static bool IsPointOnBase(const class UObject* WorldContextObject, const struct FVector& Point, const TArray<class AActor*>& IgnoreActors, const EDrawDebugTrace DrawDebugType, const float DrawDebugDuration);
	static bool IsServer(const class UObject* WorldContextObject);
	static bool IsServerPlayerUID(const class UObject* WorldContextObject, const struct FGuid& PlayerUId);
	static bool IsSleepTimeForWildLife(class APalAIController* Controller, float SleepStartHours, float SleepEndHours);
	static bool IsSneakAttackSuccessByLocation(const struct FVector& HitLocation, const class AActor* Defender);
	static bool IsSteamDeck(const class UObject* WorldContextObject);
	static bool IsUGCBlocked(const class UObject* WorldContextObject);
	static bool IsUGCFilter();
	static bool IsValid_ThreadSafe(class UObject* Object);
	static bool IsValidInstanceID(const struct FPalInstanceID& ID);
	static bool IsWildNPC(const class AActor* Actor);
	static bool IsWindows(const class UObject* WorldContextObject);
	static bool IsWinGDK(const class UObject* WorldContextObject);
	static bool IsWorldOwner(const class UObject* WorldContextObject);
	static bool IsXB1(const class UObject* WorldContextObject);
	static bool IsXSX(const class UObject* WorldContextObject);
	static bool JudgePalCapture(class AActor* Pal);
	static void JudgePalCapture_TryAllPhase(const class UPalIndividualCharacterHandle* TargetHandle, const class UPalIndividualCharacterHandle* ThrowCharacterHandle, int32 CaptureItemLevel, TArray<bool>* OutJudgeFlagArray, bool Robbery);
	static bool LineTraceToTarget_ForAIAttack(class AActor* SelfActor, class AActor* Target);
	static void LoadIconToImage(const class UObject* WorldContextObject, TSoftObjectPtr<class UTexture2D> TexturePath, class UImage* TargetImage, TDelegate<void(class UImage* ImageWidget, class UTexture2D* Texture)> Callback);
	static bool LotteryFloat(const float ProbabilityPercentage);
	static bool LotteryInt(const int32 ProbabilityPercentage);
	static struct FPalDamageInfo MakeDamageInfo(const struct FPalMakeDamageInfo& Param_MakeDamageInfo);
	static struct FPalDamageInfo MakeDamageInfoByWazaType(class AActor* Attacker, class AActor* Defencer, const class USceneComponent* AttackerHitComponent, const class USceneComponent* DefenderHitComponent, const struct FVector& HitLocation, const TArray<int32>& FoliageIndex, EPalWazaID WazaType, EPalBlowVelocityOwner BlowOwner, const struct FVector& NativeBlowVelocity, int32 ReferenceIndex, float DamageRatePerCollision);
	static struct FFixedPoint64 NextPointCalculate(const struct FFixedPoint64& CurrentPoint, const struct FFixedPoint64& CurrentMax, const struct FFixedPoint64& NextMax);
	static bool NotContainsAny(const TArray<class UObject*>& SourceArray, const TArray<class UObject*>& FindElms);
	static bool PalAIMoveToTargetActor(class APalAIController* Controller, class AActor* Target);
	static bool PalAIMoveToTargetLocation(class APalAIController* Controller, const struct FVector& Goal);
	static void PalCaptureSuccess(class APalPlayerCharacter* AttackerPlayer, class APalCharacter* Monster);
	static void Play2MontageByFixLength(class ACharacter* Character, class UAnimMontage* Montange, float FixLength, class UAnimMontage* LoopMontange);
	static bool PlayAction(class AActor* ActionActor, class AActor* TargetActor, EPalActionType ActionType);
	static bool PlayActionByWazaID(class AActor* ActionActor, class AActor* TargetActor, EPalWazaID WazaID);
	static void PlayMontageByFixLength(class ACharacter* Character, class UAnimMontage* Montange, float FixLength);
	static void PlayMontageByMinLength(class ACharacter* Character, class UAnimMontage* Montange, float MinLength);
	static void PlayWorldCameraShake(const class UObject* WorldContextObject, TSubclassOf<class UCameraShakeBase> Shake, const struct FVector& Epicenter, float InnerRadius, float OuterRadius, float Falloff, bool bOrientShakeTowardsEpicenter);
	static bool PointOvelapLimitVolume(const class UObject* WorldContextObject, EPalLimitVolumeFlag LimitVolumeFlag, const struct FVector& Location);
	static void ProcessDamageAndPlayEffects(class AActor* Attacker, class AActor* Defender, const struct FPalMakeDamageInfo& MakeDamageInfo);
	static void ProcessDamageAndPlayEffectsByDamageInfo(class AActor* Attacker, class AActor* Defender, const struct FPalDamageInfo& DamageInfo, bool bIsEnableHitEffect);
	static void ProcessDeadAction(class APalCharacter* Character);
	static bool ProjectWorldToScreenBehindCamera(class APlayerController* Player, const struct FVector& WorldPosition, struct FVector2D* ScreenPosition, bool* bTargetBehindCamera, bool bPlayerViewportRelative);
	static void RefreshParameterForCharacterAndHoldOtomo(class APalCharacter* Character);
	static void RefreshRagdollSkeletalMesh(class APalCharacter* Character);
	static void RemoveAroundInfoCollectorComponent(class APalCharacter* Target);
	static void ResetBodyPartsCollisionProfileToDefault(class APalCharacter* Character);
	static void ReturnOtomoPalToHolder(const class AController* TargetController);
	static bool RideTo(class AActor* RiderActor, class AActor* RidePal, bool bIsSkipAnimation);
	static float RSign(const float V);
	static class FText SelectText(const class FText& A, const class FText& B, bool bPickA);
	static void SendSystemAnnounce(const class UObject* WorldContextObject, const class FString& Message);
	static void SendSystemToPlayerChat(const class UObject* WorldContextObject, const class FString& Message, const struct FGuid& ReceiverPlayerUId);
	static void SetActorQuat(class AActor* TargetActor, const struct FQuat& NewQuat);
	static void SetBodyPartsCollisionEnable(class APalCharacter* Character, bool bEnable);
	static void SetBodyPartsCollisionProfile(class APalCharacter* Character, const class FName ProfileName);
	static void SetBodyPartsGenerateOverlapEvents(class APalCharacter* Character, bool IsEnable);
	static void SetCharacterLocationAtMainMeshFoot(class APalCharacter* Character, const struct FVector& Location);
	static void SetCharacterRagdoll(class APalCharacter* Character, bool IsKeepGravity, bool KeepRootCollision);
	static void SetCharacterRagdollForLiftup(class APalCharacter* Character);
	static void SetCharacterRagdollForNooseTrap(class APalCharacter* Character);
	static void SetCoopFlag(class APalCharacter* Trainer, class APalCharacter* Otomo, bool bIsEnable);
	static void SetEnableCameraFade(class AActor* Character, bool bIsEnable);
	static void SetEnableSkyCreator(const class UObject* WorldContextObject, bool bEnable);
	static void SetFolderPathForBP(class AActor* TargetActor, class FName FolderName);
	static void SetHPByRateToCharacter(class APalCharacter* Character, float Rate);
	static void SetHPByRateToHandle(class UPalIndividualCharacterHandle* Handle, float Rate);
	static void SetMoveDisableFlag(class AActor* Actor, bool IsDisable, class FName FlagName);
	static void SetOpacityForCharacter(class AActor* Character, float OpacityIntensity);
	static void SetOtomoCollisionProfile(class APalCharacter* Character);
	static void SetPassword(const class UObject* WorldContextObject, const class FString& Password);
	static void SetRidingCharacterCollision(class APalCharacter* Character);
	static void SetSpeedCollisionEnable(class AActor* Actor, bool bEnable);
	static void SetStatusPoint(class UPalIndividualCharacterHandle* Handle, class FName StatusName, int32 Point);
	static void SetTelemetry(const class UObject* WorldContextObject, const class FName& Key, const class FString& Value, class FName Namespace);
	static struct FTimerHandle SetTimerWithGaugeWidget(class UObject* Object, const struct FPalTimerGaugeWidgetCreateInfo& CreateInfo);
	static struct FTransform SetTransformQuat(const struct FTransform& TargetTransform, const struct FQuat& NewQuat);
	static void SetUnRidingCharacterCollision(class APalCharacter* Character);
	static void SetVisibleComponentInDataLayer(const class UObject* WorldContextObject, class UDataLayerInstance* TargetDataLayer, bool bEnable);
	static void SetVoiceID(class AActor* TargetActor, int32 VoiceID);
	static void SetYawApplyRate(class AActor* Actor, float Rate, class FName FlagName);
	static void ShowUI(const class UObject* WorldContextObject, const EPalWidgetBlueprintType WBPType, class UPalHUDDispatchParameterBase* Parameter);
	static void SortActorListByLabel(TArray<class AActor*>& ActorList);
	static bool SpawnActorBroadcast(const class UObject* WorldContextObject, class UClass* ActorClass, class AActor* NetworkOwner, class AActor* Owner, class FName Param_Name, const struct FTransform& SpawnTransform, TSubclassOf<class AController> Controller, struct FGuid* SpawnGUID, TDelegate<void(const struct FGuid& SpawnGUID, class AActor* SpawnActor)> SpawnDelegate);
	static class AController* SpawnControllerAndPossess(TSubclassOf<class AController> ControllerClass, class APawn* ControlActor);
	static void SpectatorOff(const class UObject* WorldContextObject);
	static void SpectatorOn(const class UObject* WorldContextObject);
	static bool SphereOverlapLimitVolume(const class UObject* WorldContextObject, EPalLimitVolumeFlag LimitVolumeFlag, const struct FVector& Center, const float Radius);
	static class FString SteamLanguageNameToCultureName(const class UObject* WorldContextObject, const class FString& SteamLanguageName);
	static bool SynchronizedGroup(const class UObject* WorldContextObject, class UPalIndividualCharacterHandle* FromHandle, class UPalIndividualCharacterHandle* ToHandle);
	static bool Teleport(class APalCharacter* Target, const struct FVector& Location, const struct FQuat& Rotation, const bool bNoCheck, const bool bAroundCheck);
	static bool TeleportAroundLoccation(class APalCharacter* Target, const struct FVector& Location, const struct FQuat& Rotation);
	static void TeleportInitLocation(class APalPlayerCharacter* Target);
	static void TeleportToPlayerByIndex(class APalPlayerController* Controller, int32 PlayerIndex);
	static class FString ToPointerAddress(const class UObject* Obj);
	static bool TryGetHeadWorldPosition(class APalCharacter* Character, struct FVector* OutLocation);
	static void UnlockAchievement(const class UObject* WorldContextObject, const class FString& AchievementId, const int32 Progress);
	static void UnlockBaseCampLevelAchievement(const class UObject* WorldContextObject, const int32 Level);
	static void UpdateLocalPlayerParameter(const class UObject* WorldContextObject);
	static void UpdatePlayerCharacterParameter(const class APalCharacter* Character);

	void LoadIconToImageDelegate__DelegateSignature(class UImage* ImageWidget, class UTexture2D* Texture);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalUtility">();
	}
	static class UPalUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalUtility>();
	}
};
static_assert(alignof(UPalUtility) == 0x000008, "Wrong alignment on UPalUtility");
static_assert(sizeof(UPalUtility) == 0x000028, "Wrong size on UPalUtility");

// Class Pal.PalWazaDatabase
// 0x0068 (0x0090 - 0x0028)
class UPalWazaDatabase : public UObject
{
public:
	class UDataTable*                             WazaDataTable;                                     // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EPalAdditionalEffectType, EPalStatusID>  AdditionalEffectToStatusID;                        // 0x0030(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UDataTable*                             WazaMasterLevel_DataTable;                         // 0x0080(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             WazaMasterTamago_DataTable;                        // 0x0088(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool FindWazaForBP(EPalWazaID Type, struct FPalWazaDatabaseRaw* OutData);
	void GetMasterrableWaza_BetweenLevel(class FName CharacterID, int32 StartLevel, int32 EndLevel, TMap<EPalWazaID, int32>* OutMap);
	bool IsExistMasterrableWaza_BetweenLevel(class FName CharacterID, int32 StartLevel, int32 EndLevel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWazaDatabase">();
	}
	static class UPalWazaDatabase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWazaDatabase>();
	}
};
static_assert(alignof(UPalWazaDatabase) == 0x000008, "Wrong alignment on UPalWazaDatabase");
static_assert(sizeof(UPalWazaDatabase) == 0x000090, "Wrong size on UPalWazaDatabase");
static_assert(offsetof(UPalWazaDatabase, WazaDataTable) == 0x000028, "Member 'UPalWazaDatabase::WazaDataTable' has a wrong offset!");
static_assert(offsetof(UPalWazaDatabase, AdditionalEffectToStatusID) == 0x000030, "Member 'UPalWazaDatabase::AdditionalEffectToStatusID' has a wrong offset!");
static_assert(offsetof(UPalWazaDatabase, WazaMasterLevel_DataTable) == 0x000080, "Member 'UPalWazaDatabase::WazaMasterLevel_DataTable' has a wrong offset!");
static_assert(offsetof(UPalWazaDatabase, WazaMasterTamago_DataTable) == 0x000088, "Member 'UPalWazaDatabase::WazaMasterTamago_DataTable' has a wrong offset!");

// Class Pal.PalWeaponFilter
// 0x0018 (0x0170 - 0x0158)
class UPalWeaponFilter final : public UPalHitFilter
{
public:
	float                                         BlowSpeed;                                         // 0x0158(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlowUpRate;                                        // 0x015C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageRate;                                        // 0x0160(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBlow;                                            // 0x0164(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3075[0x3];                                     // 0x0165(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Attacker;                                          // 0x0168(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWeaponFilter">();
	}
	static class UPalWeaponFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWeaponFilter>();
	}
};
static_assert(alignof(UPalWeaponFilter) == 0x000008, "Wrong alignment on UPalWeaponFilter");
static_assert(sizeof(UPalWeaponFilter) == 0x000170, "Wrong size on UPalWeaponFilter");
static_assert(offsetof(UPalWeaponFilter, BlowSpeed) == 0x000158, "Member 'UPalWeaponFilter::BlowSpeed' has a wrong offset!");
static_assert(offsetof(UPalWeaponFilter, BlowUpRate) == 0x00015C, "Member 'UPalWeaponFilter::BlowUpRate' has a wrong offset!");
static_assert(offsetof(UPalWeaponFilter, DamageRate) == 0x000160, "Member 'UPalWeaponFilter::DamageRate' has a wrong offset!");
static_assert(offsetof(UPalWeaponFilter, IsBlow) == 0x000164, "Member 'UPalWeaponFilter::IsBlow' has a wrong offset!");
static_assert(offsetof(UPalWeaponFilter, Attacker) == 0x000168, "Member 'UPalWeaponFilter::Attacker' has a wrong offset!");

// Class Pal.PalWidgetAnimationArray
// 0x0060 (0x0088 - 0x0028)
class UPalWidgetAnimationArray final : public UObject
{
public:
	class UUserWidget*                            TargetWidget;                                      // 0x0028(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FName, class UWidgetAnimation*>    AnimationMap;                                      // 0x0030(0x0050)(NativeAccessSpecifierPrivate)
	float                                         MultiplyTimeScale;                                 // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3076[0x4];                                     // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetAnimationNameArray(TArray<class FName>* OutArray);
	void Initialize(class UUserWidget* InTargetWidget);
	void PauseAnimation(const class FName& AnimationName);
	void PlayLoop(const class FName& AnimationName);
	void PlayLoopPingPong(const class FName& AnimationName);
	void PlayLoopReverse(const class FName& AnimationName);
	void PlayOneshot(const class FName& AnimationName);
	void PlayOneShotPingPong(const class FName& AnimationName);
	void PlayOneShotReverse(const class FName& AnimationName);
	void SetTimeScale(float TimeScale);
	void StopAllAnimation();
	void StopAnimation(const class FName& AnimationName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWidgetAnimationArray">();
	}
	static class UPalWidgetAnimationArray* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWidgetAnimationArray>();
	}
};
static_assert(alignof(UPalWidgetAnimationArray) == 0x000008, "Wrong alignment on UPalWidgetAnimationArray");
static_assert(sizeof(UPalWidgetAnimationArray) == 0x000088, "Wrong size on UPalWidgetAnimationArray");
static_assert(offsetof(UPalWidgetAnimationArray, TargetWidget) == 0x000028, "Member 'UPalWidgetAnimationArray::TargetWidget' has a wrong offset!");
static_assert(offsetof(UPalWidgetAnimationArray, AnimationMap) == 0x000030, "Member 'UPalWidgetAnimationArray::AnimationMap' has a wrong offset!");
static_assert(offsetof(UPalWidgetAnimationArray, MultiplyTimeScale) == 0x000080, "Member 'UPalWidgetAnimationArray::MultiplyTimeScale' has a wrong offset!");

// Class Pal.PalWildDrinkWaterSpot
// 0x0030 (0x0058 - 0x0028)
class UPalWildDrinkWaterSpot final : public UObject
{
public:
	bool                                          IsReserved;                                        // 0x0028(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3077[0x7];                                     // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SpotActorLocation;                                 // 0x0030(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FVector>                        PalGoalLocations;                                  // 0x0048(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	struct FVector GetActorLocation();
	bool SetAssignPointToMember(const TArray<class AActor*>& MemberList);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWildDrinkWaterSpot">();
	}
	static class UPalWildDrinkWaterSpot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWildDrinkWaterSpot>();
	}
};
static_assert(alignof(UPalWildDrinkWaterSpot) == 0x000008, "Wrong alignment on UPalWildDrinkWaterSpot");
static_assert(sizeof(UPalWildDrinkWaterSpot) == 0x000058, "Wrong size on UPalWildDrinkWaterSpot");
static_assert(offsetof(UPalWildDrinkWaterSpot, IsReserved) == 0x000028, "Member 'UPalWildDrinkWaterSpot::IsReserved' has a wrong offset!");
static_assert(offsetof(UPalWildDrinkWaterSpot, SpotActorLocation) == 0x000030, "Member 'UPalWildDrinkWaterSpot::SpotActorLocation' has a wrong offset!");
static_assert(offsetof(UPalWildDrinkWaterSpot, PalGoalLocations) == 0x000048, "Member 'UPalWildDrinkWaterSpot::PalGoalLocations' has a wrong offset!");

// Class Pal.PalWindController
// 0x08D0 (0x0B60 - 0x0290)
class APalWindController final : public AInfo
{
public:
	struct FFloatInterval                         WindDirectionChangeInterval;                       // 0x0290(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WindDirectionResponse;                             // 0x0298(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFloatInterval                         WindSpeedInterval;                                 // 0x029C(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFloatInterval                         WindSpeedChangeInterval;                           // 0x02A4(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3079[0x894];                                   // 0x02AC(0x0894)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastChangedDirectionTime;                          // 0x0B40(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LastChangedSpeedTime;                              // 0x0B44(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_307A[0x18];                                    // 0x0B48(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorSpawned(class AActor* InActor);
	void UpdateNiagaraParameterCollection(const struct FPalWindInfo& WindInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWindController">();
	}
	static class APalWindController* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalWindController>();
	}
};
static_assert(alignof(APalWindController) == 0x000008, "Wrong alignment on APalWindController");
static_assert(sizeof(APalWindController) == 0x000B60, "Wrong size on APalWindController");
static_assert(offsetof(APalWindController, WindDirectionChangeInterval) == 0x000290, "Member 'APalWindController::WindDirectionChangeInterval' has a wrong offset!");
static_assert(offsetof(APalWindController, WindDirectionResponse) == 0x000298, "Member 'APalWindController::WindDirectionResponse' has a wrong offset!");
static_assert(offsetof(APalWindController, WindSpeedInterval) == 0x00029C, "Member 'APalWindController::WindSpeedInterval' has a wrong offset!");
static_assert(offsetof(APalWindController, WindSpeedChangeInterval) == 0x0002A4, "Member 'APalWindController::WindSpeedChangeInterval' has a wrong offset!");
static_assert(offsetof(APalWindController, LastChangedDirectionTime) == 0x000B40, "Member 'APalWindController::LastChangedDirectionTime' has a wrong offset!");
static_assert(offsetof(APalWindController, LastChangedSpeedTime) == 0x000B44, "Member 'APalWindController::LastChangedSpeedTime' has a wrong offset!");

// Class Pal.PalWorkBootUp
// 0x0020 (0x0340 - 0x0320)
class UPalWorkBootUp final : public UPalWorkBase
{
public:
	FMulticastInlineDelegateProperty_             OnBootUpInServerDelegate;                          // 0x0318(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_307B[0x18];                                    // 0x0328(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorkBootUp">();
	}
	static class UPalWorkBootUp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWorkBootUp>();
	}
};
static_assert(alignof(UPalWorkBootUp) == 0x000010, "Wrong alignment on UPalWorkBootUp");
static_assert(sizeof(UPalWorkBootUp) == 0x000340, "Wrong size on UPalWorkBootUp");
static_assert(offsetof(UPalWorkBootUp, OnBootUpInServerDelegate) == 0x000318, "Member 'UPalWorkBootUp::OnBootUpInServerDelegate' has a wrong offset!");

// Class Pal.PalWorkDefense
// 0x0020 (0x0340 - 0x0320)
class UPalWorkDefense final : public UPalWorkBase
{
public:
	TSubclassOf<class UPalAIActionBaseCampDefenseBase> DefenseAIActionClass;                              // 0x0318(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UPalActionBase>             DefenseWaitActionClass;                            // 0x0320(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPalWorkDefenseCombatType                     DefenseCombatType;                                 // 0x0328(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_307C[0x3];                                     // 0x0329(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UPalMapObjectDefenseModelBase> WeakDefenseModel;                                  // 0x032C(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UPalMapObjectDefenseBulletLauncherModel> WeakDefenseBulletLauncherModel;                    // 0x0334(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_307D[0x4];                                     // 0x033C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorkDefense">();
	}
	static class UPalWorkDefense* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWorkDefense>();
	}
};
static_assert(alignof(UPalWorkDefense) == 0x000010, "Wrong alignment on UPalWorkDefense");
static_assert(sizeof(UPalWorkDefense) == 0x000340, "Wrong size on UPalWorkDefense");
static_assert(offsetof(UPalWorkDefense, DefenseAIActionClass) == 0x000318, "Member 'UPalWorkDefense::DefenseAIActionClass' has a wrong offset!");
static_assert(offsetof(UPalWorkDefense, DefenseWaitActionClass) == 0x000320, "Member 'UPalWorkDefense::DefenseWaitActionClass' has a wrong offset!");
static_assert(offsetof(UPalWorkDefense, DefenseCombatType) == 0x000328, "Member 'UPalWorkDefense::DefenseCombatType' has a wrong offset!");
static_assert(offsetof(UPalWorkDefense, WeakDefenseModel) == 0x00032C, "Member 'UPalWorkDefense::WeakDefenseModel' has a wrong offset!");
static_assert(offsetof(UPalWorkDefense, WeakDefenseBulletLauncherModel) == 0x000334, "Member 'UPalWorkDefense::WeakDefenseBulletLauncherModel' has a wrong offset!");

// Class Pal.PalWorkUtility
// 0x0000 (0x0028 - 0x0028)
class UPalWorkUtility final : public UBlueprintFunctionLibrary
{
public:
	static struct FVector BP_GetWorkLocation(const class UPalWorkBase* Target);
	static bool BP_TryGetWorkLocation(const class UPalWorkBase* Target, struct FVector* OutLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorkUtility">();
	}
	static class UPalWorkUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWorkUtility>();
	}
};
static_assert(alignof(UPalWorkUtility) == 0x000008, "Wrong alignment on UPalWorkUtility");
static_assert(sizeof(UPalWorkUtility) == 0x000028, "Wrong size on UPalWorkUtility");

// Class Pal.PalWorkDeforestFoliage
// 0x0030 (0x0350 - 0x0320)
class UPalWorkDeforestFoliage final : public UPalWorkBase
{
public:
	struct FPalFoliageIdentifiableInfo            IdentifiableInfo;                                  // 0x0318(0x0030)(Edit, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_307F[0x8];                                     // 0x0348(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorkDeforestFoliage">();
	}
	static class UPalWorkDeforestFoliage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWorkDeforestFoliage>();
	}
};
static_assert(alignof(UPalWorkDeforestFoliage) == 0x000010, "Wrong alignment on UPalWorkDeforestFoliage");
static_assert(sizeof(UPalWorkDeforestFoliage) == 0x000350, "Wrong size on UPalWorkDeforestFoliage");
static_assert(offsetof(UPalWorkDeforestFoliage, IdentifiableInfo) == 0x000318, "Member 'UPalWorkDeforestFoliage::IdentifiableInfo' has a wrong offset!");

// Class Pal.PalWorkAssign_MonsterFarm
// 0x0058 (0x00E8 - 0x0090)
class UPalWorkAssign_MonsterFarm final : public UPalWorkAssign
{
public:
	struct FFloatCounter                          ActionIntervalTimer;                               // 0x0090(0x0008)(Edit, DisableEditOnTemplate, Transient, EditConst, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector                                WalkTargetLocation;                                // 0x0098(0x0018)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3080[0x20];                                    // 0x00B0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPalStaticItemIdAndNum                 SpawnItemInfoPerAction;                            // 0x00D0(0x000C)(Edit, DisableEditOnTemplate, Transient, EditConst, NoDestructor, NativeAccessSpecifierPrivate)
	int32                                         SpawnActionWholeCount;                             // 0x00DC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SpawnActionCurrentCount;                           // 0x00E0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3081[0x4];                                     // 0x00E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorkAssign_MonsterFarm">();
	}
	static class UPalWorkAssign_MonsterFarm* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWorkAssign_MonsterFarm>();
	}
};
static_assert(alignof(UPalWorkAssign_MonsterFarm) == 0x000008, "Wrong alignment on UPalWorkAssign_MonsterFarm");
static_assert(sizeof(UPalWorkAssign_MonsterFarm) == 0x0000E8, "Wrong size on UPalWorkAssign_MonsterFarm");
static_assert(offsetof(UPalWorkAssign_MonsterFarm, ActionIntervalTimer) == 0x000090, "Member 'UPalWorkAssign_MonsterFarm::ActionIntervalTimer' has a wrong offset!");
static_assert(offsetof(UPalWorkAssign_MonsterFarm, WalkTargetLocation) == 0x000098, "Member 'UPalWorkAssign_MonsterFarm::WalkTargetLocation' has a wrong offset!");
static_assert(offsetof(UPalWorkAssign_MonsterFarm, SpawnItemInfoPerAction) == 0x0000D0, "Member 'UPalWorkAssign_MonsterFarm::SpawnItemInfoPerAction' has a wrong offset!");
static_assert(offsetof(UPalWorkAssign_MonsterFarm, SpawnActionWholeCount) == 0x0000DC, "Member 'UPalWorkAssign_MonsterFarm::SpawnActionWholeCount' has a wrong offset!");
static_assert(offsetof(UPalWorkAssign_MonsterFarm, SpawnActionCurrentCount) == 0x0000E0, "Member 'UPalWorkAssign_MonsterFarm::SpawnActionCurrentCount' has a wrong offset!");

// Class Pal.PalWorkAssign_OnlyJoinAndWalkAround
// 0x0038 (0x00C8 - 0x0090)
class UPalWorkAssign_OnlyJoinAndWalkAround final : public UPalWorkAssign
{
public:
	struct FVector                                TargetLocation;                                    // 0x0090(0x0018)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3082[0x20];                                    // 0x00A8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorkAssign_OnlyJoinAndWalkAround">();
	}
	static class UPalWorkAssign_OnlyJoinAndWalkAround* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWorkAssign_OnlyJoinAndWalkAround>();
	}
};
static_assert(alignof(UPalWorkAssign_OnlyJoinAndWalkAround) == 0x000008, "Wrong alignment on UPalWorkAssign_OnlyJoinAndWalkAround");
static_assert(sizeof(UPalWorkAssign_OnlyJoinAndWalkAround) == 0x0000C8, "Wrong size on UPalWorkAssign_OnlyJoinAndWalkAround");
static_assert(offsetof(UPalWorkAssign_OnlyJoinAndWalkAround, TargetLocation) == 0x000090, "Member 'UPalWorkAssign_OnlyJoinAndWalkAround::TargetLocation' has a wrong offset!");

// Class Pal.PalWorkProgressTransformMapObject
// 0x0080 (0x00B0 - 0x0030)
class UPalWorkProgressTransformMapObject final : public UPalWorkProgressTransformBase
{
public:
	struct FGuid                                  MapObjectInstanceId;                               // 0x0030(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             TransformCache;                                    // 0x0040(0x0060)(Edit, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCached;                                           // 0x00A0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3083[0xB];                                     // 0x00A1(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShouldSearchForFoliage;                           // 0x00AC(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3084[0x3];                                     // 0x00AD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorkProgressTransformMapObject">();
	}
	static class UPalWorkProgressTransformMapObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWorkProgressTransformMapObject>();
	}
};
static_assert(alignof(UPalWorkProgressTransformMapObject) == 0x000010, "Wrong alignment on UPalWorkProgressTransformMapObject");
static_assert(sizeof(UPalWorkProgressTransformMapObject) == 0x0000B0, "Wrong size on UPalWorkProgressTransformMapObject");
static_assert(offsetof(UPalWorkProgressTransformMapObject, MapObjectInstanceId) == 0x000030, "Member 'UPalWorkProgressTransformMapObject::MapObjectInstanceId' has a wrong offset!");
static_assert(offsetof(UPalWorkProgressTransformMapObject, TransformCache) == 0x000040, "Member 'UPalWorkProgressTransformMapObject::TransformCache' has a wrong offset!");
static_assert(offsetof(UPalWorkProgressTransformMapObject, bCached) == 0x0000A0, "Member 'UPalWorkProgressTransformMapObject::bCached' has a wrong offset!");
static_assert(offsetof(UPalWorkProgressTransformMapObject, bShouldSearchForFoliage) == 0x0000AC, "Member 'UPalWorkProgressTransformMapObject::bShouldSearchForFoliage' has a wrong offset!");

// Class Pal.PalWorkProgressUtility
// 0x0000 (0x0028 - 0x0028)
class UPalWorkProgressUtility final : public UBlueprintFunctionLibrary
{
public:
	static float WorkAmountToManMonth(const class UObject* WorldContextObject, const float WorkAmount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorkProgressUtility">();
	}
	static class UPalWorkProgressUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWorkProgressUtility>();
	}
};
static_assert(alignof(UPalWorkProgressUtility) == 0x000008, "Wrong alignment on UPalWorkProgressUtility");
static_assert(sizeof(UPalWorkProgressUtility) == 0x000028, "Wrong size on UPalWorkProgressUtility");

// Class Pal.PalWorkProgressWorkableCheckInterface
// 0x0000 (0x0028 - 0x0028)
class IPalWorkProgressWorkableCheckInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorkProgressWorkableCheckInterface">();
	}
	static class IPalWorkProgressWorkableCheckInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPalWorkProgressWorkableCheckInterface>();
	}
};
static_assert(alignof(IPalWorkProgressWorkableCheckInterface) == 0x000008, "Wrong alignment on IPalWorkProgressWorkableCheckInterface");
static_assert(sizeof(IPalWorkProgressWorkableCheckInterface) == 0x000028, "Wrong size on IPalWorkProgressWorkableCheckInterface");

// Class Pal.PalWorkRemoveMapObjectEffect
// 0x0000 (0x0320 - 0x0320)
class UPalWorkRemoveMapObjectEffect final : public UPalWorkBase
{
public:
	EPalStatusID                                  TargetEffectType;                                  // 0x0318(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3085[0x7];                                     // 0x0319(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorkRemoveMapObjectEffect">();
	}
	static class UPalWorkRemoveMapObjectEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWorkRemoveMapObjectEffect>();
	}
};
static_assert(alignof(UPalWorkRemoveMapObjectEffect) == 0x000010, "Wrong alignment on UPalWorkRemoveMapObjectEffect");
static_assert(sizeof(UPalWorkRemoveMapObjectEffect) == 0x000320, "Wrong size on UPalWorkRemoveMapObjectEffect");
static_assert(offsetof(UPalWorkRemoveMapObjectEffect, TargetEffectType) == 0x000318, "Member 'UPalWorkRemoveMapObjectEffect::TargetEffectType' has a wrong offset!");

// Class Pal.PalWorkRepair
// 0x0040 (0x0360 - 0x0320)
class UPalWorkRepair final : public UPalWorkBase
{
public:
	uint8                                         Pad_3086[0x14];                                    // 0x0318(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  ConnectToModelInstanceId;                          // 0x032C(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3087[0x4];                                     // 0x033C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UPalMapObjectModel*>             ConnectedModels;                                   // 0x0340(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3088[0x10];                                    // 0x0350(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorkRepair">();
	}
	static class UPalWorkRepair* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWorkRepair>();
	}
};
static_assert(alignof(UPalWorkRepair) == 0x000010, "Wrong alignment on UPalWorkRepair");
static_assert(sizeof(UPalWorkRepair) == 0x000360, "Wrong size on UPalWorkRepair");
static_assert(offsetof(UPalWorkRepair, ConnectToModelInstanceId) == 0x00032C, "Member 'UPalWorkRepair::ConnectToModelInstanceId' has a wrong offset!");
static_assert(offsetof(UPalWorkRepair, ConnectedModels) == 0x000340, "Member 'UPalWorkRepair::ConnectedModels' has a wrong offset!");

// Class Pal.PalWorkTransportItemInBaseCamp
// 0x0020 (0x0340 - 0x0320)
class UPalWorkTransportItemInBaseCamp final : public UPalWorkBase
{
public:
	EPalWorkTransportItemType                     TransportType;                                     // 0x0318(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3089[0x3];                                     // 0x0319(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ApproachFailedTimeout;                             // 0x031C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_308A[0x20];                                    // 0x0320(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorkTransportItemInBaseCamp">();
	}
	static class UPalWorkTransportItemInBaseCamp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWorkTransportItemInBaseCamp>();
	}
};
static_assert(alignof(UPalWorkTransportItemInBaseCamp) == 0x000010, "Wrong alignment on UPalWorkTransportItemInBaseCamp");
static_assert(sizeof(UPalWorkTransportItemInBaseCamp) == 0x000340, "Wrong size on UPalWorkTransportItemInBaseCamp");
static_assert(offsetof(UPalWorkTransportItemInBaseCamp, TransportType) == 0x000318, "Member 'UPalWorkTransportItemInBaseCamp::TransportType' has a wrong offset!");
static_assert(offsetof(UPalWorkTransportItemInBaseCamp, ApproachFailedTimeout) == 0x00031C, "Member 'UPalWorkTransportItemInBaseCamp::ApproachFailedTimeout' has a wrong offset!");

// Class Pal.PalWorldMapCapture
// 0x0020 (0x02B0 - 0x0290)
class APalWorldMapCapture final : public AActor
{
public:
	class USceneCaptureComponent2D*               SceneCaptureComponent;                             // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             WorldMapTexture;                                   // 0x0298(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextureRenderTarget2D*                 WorldMapDetailRenderTexture;                       // 0x02A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             WorldMapHeightTexture;                             // 0x02A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void CaptureWorldMapTexture_Ortho();
	void CaptureWorldMapTexture_Perspective();
	bool CreateWorldMapTexture();
	class UTextureRenderTarget2D* GetRenderedWorldMapTexture();
	class UTexture2D* GetWorldMapHeightMap();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorldMapCapture">();
	}
	static class APalWorldMapCapture* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalWorldMapCapture>();
	}
};
static_assert(alignof(APalWorldMapCapture) == 0x000008, "Wrong alignment on APalWorldMapCapture");
static_assert(sizeof(APalWorldMapCapture) == 0x0002B0, "Wrong size on APalWorldMapCapture");
static_assert(offsetof(APalWorldMapCapture, SceneCaptureComponent) == 0x000290, "Member 'APalWorldMapCapture::SceneCaptureComponent' has a wrong offset!");
static_assert(offsetof(APalWorldMapCapture, WorldMapTexture) == 0x000298, "Member 'APalWorldMapCapture::WorldMapTexture' has a wrong offset!");
static_assert(offsetof(APalWorldMapCapture, WorldMapDetailRenderTexture) == 0x0002A0, "Member 'APalWorldMapCapture::WorldMapDetailRenderTexture' has a wrong offset!");
static_assert(offsetof(APalWorldMapCapture, WorldMapHeightTexture) == 0x0002A8, "Member 'APalWorldMapCapture::WorldMapHeightTexture' has a wrong offset!");

// Class Pal.PalWorldMapUIData
// 0x00A8 (0x00D0 - 0x0028)
class UPalWorldMapUIData : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnUnlockedMap;                                     // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 MaskRenderTarget;                                  // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             MaskTexture;                                       // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_308B[0x18];                                    // 0x0048(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 CachedTextureRawData;                              // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, bool>                       UnlockedRegionMap;                                 // 0x0070(0x0050)(NativeAccessSpecifierPrivate)
	class UDataTable*                             WorldMapDataTable;                                 // 0x00C0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   CurrentPlayMapName;                                // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	const class FName GetCurrentPlayMapName();
	bool GetCurrentPlayMapUIData(struct FPalWorldMapUIDataTableRow* OutData);
	void GetUnlockedMapData(TMap<class FName, bool>* OutMapData);
	bool IsUnlockedMap(const class FName& RegionId);
	void UnlockedMapDelegate__DelegateSignature(const class FName& UnlockedRegionId, const int32 PlayerId);
	bool UnlockMap(const class FName& RegionId, const int32 PlayerId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorldMapUIData">();
	}
	static class UPalWorldMapUIData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWorldMapUIData>();
	}
};
static_assert(alignof(UPalWorldMapUIData) == 0x000008, "Wrong alignment on UPalWorldMapUIData");
static_assert(sizeof(UPalWorldMapUIData) == 0x0000D0, "Wrong size on UPalWorldMapUIData");
static_assert(offsetof(UPalWorldMapUIData, OnUnlockedMap) == 0x000028, "Member 'UPalWorldMapUIData::OnUnlockedMap' has a wrong offset!");
static_assert(offsetof(UPalWorldMapUIData, MaskRenderTarget) == 0x000038, "Member 'UPalWorldMapUIData::MaskRenderTarget' has a wrong offset!");
static_assert(offsetof(UPalWorldMapUIData, MaskTexture) == 0x000040, "Member 'UPalWorldMapUIData::MaskTexture' has a wrong offset!");
static_assert(offsetof(UPalWorldMapUIData, CachedTextureRawData) == 0x000060, "Member 'UPalWorldMapUIData::CachedTextureRawData' has a wrong offset!");
static_assert(offsetof(UPalWorldMapUIData, UnlockedRegionMap) == 0x000070, "Member 'UPalWorldMapUIData::UnlockedRegionMap' has a wrong offset!");
static_assert(offsetof(UPalWorldMapUIData, WorldMapDataTable) == 0x0000C0, "Member 'UPalWorldMapUIData::WorldMapDataTable' has a wrong offset!");
static_assert(offsetof(UPalWorldMapUIData, CurrentPlayMapName) == 0x0000C8, "Member 'UPalWorldMapUIData::CurrentPlayMapName' has a wrong offset!");

// Class Pal.PalWorldObjectRecordWorldSubsystem
// 0x0058 (0x00C8 - 0x0070)
class UPalWorldObjectRecordWorldSubsystem final : public UPalWorldSubsystem
{
public:
	uint8                                         Pad_308F[0x8];                                     // 0x0070(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UClass*, class UPalWorldObjectRecorderBase*> RecorderMap;                                       // 0x0078(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)

public:
	static class UPalWorldObjectRecorderBase* BP_GetRecorder(const class UObject* WorldContextObject, const TSubclassOf<class UPalWorldObjectRecorderBase> TargetClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorldObjectRecordWorldSubsystem">();
	}
	static class UPalWorldObjectRecordWorldSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWorldObjectRecordWorldSubsystem>();
	}
};
static_assert(alignof(UPalWorldObjectRecordWorldSubsystem) == 0x000008, "Wrong alignment on UPalWorldObjectRecordWorldSubsystem");
static_assert(sizeof(UPalWorldObjectRecordWorldSubsystem) == 0x0000C8, "Wrong size on UPalWorldObjectRecordWorldSubsystem");
static_assert(offsetof(UPalWorldObjectRecordWorldSubsystem, RecorderMap) == 0x000078, "Member 'UPalWorldObjectRecordWorldSubsystem::RecorderMap' has a wrong offset!");

// Class Pal.PalWorldSecurityCrimeInstance
// 0x0028 (0x0050 - 0x0028)
class UPalWorldSecurityCrimeInstance final : public UObject
{
public:
	struct FGuid                                  InstanceId;                                        // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CrimeId;                                           // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  TargetId;                                          // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorldSecurityCrimeInstance">();
	}
	static class UPalWorldSecurityCrimeInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWorldSecurityCrimeInstance>();
	}
};
static_assert(alignof(UPalWorldSecurityCrimeInstance) == 0x000008, "Wrong alignment on UPalWorldSecurityCrimeInstance");
static_assert(sizeof(UPalWorldSecurityCrimeInstance) == 0x000050, "Wrong size on UPalWorldSecurityCrimeInstance");
static_assert(offsetof(UPalWorldSecurityCrimeInstance, InstanceId) == 0x000028, "Member 'UPalWorldSecurityCrimeInstance::InstanceId' has a wrong offset!");
static_assert(offsetof(UPalWorldSecurityCrimeInstance, CrimeId) == 0x000038, "Member 'UPalWorldSecurityCrimeInstance::CrimeId' has a wrong offset!");
static_assert(offsetof(UPalWorldSecurityCrimeInstance, TargetId) == 0x000040, "Member 'UPalWorldSecurityCrimeInstance::TargetId' has a wrong offset!");

// Class Pal.PalWorldSecurityLawTrigger_ItemMove
// 0x0000 (0x0040 - 0x0040)
class UPalWorldSecurityLawTrigger_ItemMove : public UPalWorldSecurityLawTrigger
{
public:
	bool Condition(const struct FPalItemOperationInfo_Move& EventInfo);
	void OnNotifiedEvent(const struct FPalItemOperationInfo_Move& EventInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorldSecurityLawTrigger_ItemMove">();
	}
	static class UPalWorldSecurityLawTrigger_ItemMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWorldSecurityLawTrigger_ItemMove>();
	}
};
static_assert(alignof(UPalWorldSecurityLawTrigger_ItemMove) == 0x000008, "Wrong alignment on UPalWorldSecurityLawTrigger_ItemMove");
static_assert(sizeof(UPalWorldSecurityLawTrigger_ItemMove) == 0x000040, "Wrong size on UPalWorldSecurityLawTrigger_ItemMove");

// Class Pal.PalWorldSecurityLawTrigger_CharacterDamaged
// 0x0000 (0x0040 - 0x0040)
class UPalWorldSecurityLawTrigger_CharacterDamaged : public UPalWorldSecurityLawTrigger
{
public:
	bool Condition(const struct FPalDamageResult& DamageResult, class UPalIndividualCharacterHandle** CriminalHandle);
	void OnNotifiedEvent(const struct FPalDamageResult& DamageResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorldSecurityLawTrigger_CharacterDamaged">();
	}
	static class UPalWorldSecurityLawTrigger_CharacterDamaged* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWorldSecurityLawTrigger_CharacterDamaged>();
	}
};
static_assert(alignof(UPalWorldSecurityLawTrigger_CharacterDamaged) == 0x000008, "Wrong alignment on UPalWorldSecurityLawTrigger_CharacterDamaged");
static_assert(sizeof(UPalWorldSecurityLawTrigger_CharacterDamaged) == 0x000040, "Wrong size on UPalWorldSecurityLawTrigger_CharacterDamaged");

// Class Pal.PalWorldSecuritySystem
// 0x01E8 (0x0258 - 0x0070)
class UPalWorldSecuritySystem : public UPalWorldSubsystem
{
public:
	uint8                                         Pad_3092[0x28];                                    // 0x0070(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnReportCriminalDelegate;                          // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnReleaseWantedDelegate;                           // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRegisterdAreaTriggerDelegate;                    // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FName                                   LawClassDirectoryPath;                             // 0x00C8(0x0008)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UPalWorldSecurityLawBase*>       Laws;                                              // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	struct FGuid                                  GroupID;                                           // 0x00E0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<struct FPalInstanceID, struct FPalCrimeStateInfo> IndividualCrimeStateMap;                           // 0x00F0(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	TMap<struct FPalInstanceID, struct FPalWorldSecurityWantedStateInfo> IndividualWantedStateMap;                          // 0x0140(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	TMap<struct FGuid, class UPalWorldSecurityCrimeInstance*> CrimeInstanceMap;                                  // 0x0190(0x0050)(Edit, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class APalTriggerAreaBase>> WeakTriggerAreaList;                               // 0x01E0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<struct FGuid, class UPalIndividualCharacterHandle*> CriminalMap;                                       // 0x01F0(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3093[0x8];                                     // 0x0240(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UPalWorldSecurityLawBase>> LawArray;                                          // 0x0248(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	class FName GetCrimeIdByCrimeInstanceId(const struct FGuid& CrimeInstanceId);
	class APalTriggerAreaBase* GetNearestTriggerArea(const struct FVector& Location);
	void RegisterdAreaTriggerDelegate__DelegateSignature(class APalTriggerAreaBase* TriggerBase);
	void ReleaseCrime(class UPalIndividualCharacterHandle* CriminalHandle, const struct FGuid& CrimeInstanceId);
	void ReleaseWanted(class UPalIndividualCharacterHandle* CriminalHandle);
	void ReleaseWantedDelegate__DelegateSignature(class UPalIndividualCharacterHandle* CriminalHandle);
	void ReportCriminal(class UPalIndividualCharacterHandle* CriminalHandle, class UPalIndividualCharacterHandle* ReporterHandle);
	void ReportCriminalDelegate__DelegateSignature(class UPalIndividualCharacterHandle* CriminalHandle, const struct FPalWorldSecurityWantedStateInfo& WantedStateInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorldSecuritySystem">();
	}
	static class UPalWorldSecuritySystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalWorldSecuritySystem>();
	}
};
static_assert(alignof(UPalWorldSecuritySystem) == 0x000008, "Wrong alignment on UPalWorldSecuritySystem");
static_assert(sizeof(UPalWorldSecuritySystem) == 0x000258, "Wrong size on UPalWorldSecuritySystem");
static_assert(offsetof(UPalWorldSecuritySystem, OnReportCriminalDelegate) == 0x000098, "Member 'UPalWorldSecuritySystem::OnReportCriminalDelegate' has a wrong offset!");
static_assert(offsetof(UPalWorldSecuritySystem, OnReleaseWantedDelegate) == 0x0000A8, "Member 'UPalWorldSecuritySystem::OnReleaseWantedDelegate' has a wrong offset!");
static_assert(offsetof(UPalWorldSecuritySystem, OnRegisterdAreaTriggerDelegate) == 0x0000B8, "Member 'UPalWorldSecuritySystem::OnRegisterdAreaTriggerDelegate' has a wrong offset!");
static_assert(offsetof(UPalWorldSecuritySystem, LawClassDirectoryPath) == 0x0000C8, "Member 'UPalWorldSecuritySystem::LawClassDirectoryPath' has a wrong offset!");
static_assert(offsetof(UPalWorldSecuritySystem, Laws) == 0x0000D0, "Member 'UPalWorldSecuritySystem::Laws' has a wrong offset!");
static_assert(offsetof(UPalWorldSecuritySystem, GroupID) == 0x0000E0, "Member 'UPalWorldSecuritySystem::GroupID' has a wrong offset!");
static_assert(offsetof(UPalWorldSecuritySystem, IndividualCrimeStateMap) == 0x0000F0, "Member 'UPalWorldSecuritySystem::IndividualCrimeStateMap' has a wrong offset!");
static_assert(offsetof(UPalWorldSecuritySystem, IndividualWantedStateMap) == 0x000140, "Member 'UPalWorldSecuritySystem::IndividualWantedStateMap' has a wrong offset!");
static_assert(offsetof(UPalWorldSecuritySystem, CrimeInstanceMap) == 0x000190, "Member 'UPalWorldSecuritySystem::CrimeInstanceMap' has a wrong offset!");
static_assert(offsetof(UPalWorldSecuritySystem, WeakTriggerAreaList) == 0x0001E0, "Member 'UPalWorldSecuritySystem::WeakTriggerAreaList' has a wrong offset!");
static_assert(offsetof(UPalWorldSecuritySystem, CriminalMap) == 0x0001F0, "Member 'UPalWorldSecuritySystem::CriminalMap' has a wrong offset!");
static_assert(offsetof(UPalWorldSecuritySystem, LawArray) == 0x000248, "Member 'UPalWorldSecuritySystem::LawArray' has a wrong offset!");

// Class Pal.PalWorldSettings
// 0x0068 (0x0520 - 0x04B8)
class APalWorldSettings : public AWorldSettings
{
public:
	TSubclassOf<class UPalDungeonWorldSubsystem>  DungeonWorldSubsystemClass;                        // 0x04B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DungeonCreateInitialLocation;                      // 0x04C0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataLayerAsset*                        FieldEnvironmentDataLayerAsset;                    // 0x04D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalAudioWorldSubsystem>    AudioWorldSubsystemClass;                          // 0x04E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPalTimerEnabled;                                // 0x04E8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3094[0x7];                                     // 0x04E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UPalOptionSubsystem>        OptionWorldSubsystemClass;                         // 0x04F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalTimeManager>            TimeManagerClass;                                  // 0x04F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalInvaderManager>         InvaderManagerClass;                               // 0x0500(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalIncidentSystem>         IncidentSystemClass;                               // 0x0508(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPalFunnelCharacterManager> FunnelCharacterManagerClass;                       // 0x0510(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequestCharacterMake;                             // 0x0518(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3095[0x7];                                     // 0x0519(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalWorldSettings">();
	}
	static class APalWorldSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalWorldSettings>();
	}
};
static_assert(alignof(APalWorldSettings) == 0x000008, "Wrong alignment on APalWorldSettings");
static_assert(sizeof(APalWorldSettings) == 0x000520, "Wrong size on APalWorldSettings");
static_assert(offsetof(APalWorldSettings, DungeonWorldSubsystemClass) == 0x0004B8, "Member 'APalWorldSettings::DungeonWorldSubsystemClass' has a wrong offset!");
static_assert(offsetof(APalWorldSettings, DungeonCreateInitialLocation) == 0x0004C0, "Member 'APalWorldSettings::DungeonCreateInitialLocation' has a wrong offset!");
static_assert(offsetof(APalWorldSettings, FieldEnvironmentDataLayerAsset) == 0x0004D8, "Member 'APalWorldSettings::FieldEnvironmentDataLayerAsset' has a wrong offset!");
static_assert(offsetof(APalWorldSettings, AudioWorldSubsystemClass) == 0x0004E0, "Member 'APalWorldSettings::AudioWorldSubsystemClass' has a wrong offset!");
static_assert(offsetof(APalWorldSettings, bIsPalTimerEnabled) == 0x0004E8, "Member 'APalWorldSettings::bIsPalTimerEnabled' has a wrong offset!");
static_assert(offsetof(APalWorldSettings, OptionWorldSubsystemClass) == 0x0004F0, "Member 'APalWorldSettings::OptionWorldSubsystemClass' has a wrong offset!");
static_assert(offsetof(APalWorldSettings, TimeManagerClass) == 0x0004F8, "Member 'APalWorldSettings::TimeManagerClass' has a wrong offset!");
static_assert(offsetof(APalWorldSettings, InvaderManagerClass) == 0x000500, "Member 'APalWorldSettings::InvaderManagerClass' has a wrong offset!");
static_assert(offsetof(APalWorldSettings, IncidentSystemClass) == 0x000508, "Member 'APalWorldSettings::IncidentSystemClass' has a wrong offset!");
static_assert(offsetof(APalWorldSettings, FunnelCharacterManagerClass) == 0x000510, "Member 'APalWorldSettings::FunnelCharacterManagerClass' has a wrong offset!");
static_assert(offsetof(APalWorldSettings, bRequestCharacterMake) == 0x000518, "Member 'APalWorldSettings::bRequestCharacterMake' has a wrong offset!");

// Class Pal.PalGameSystemNeedWorldSync
// 0x0000 (0x0028 - 0x0028)
class IPalGameSystemNeedWorldSync final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalGameSystemNeedWorldSync">();
	}
	static class IPalGameSystemNeedWorldSync* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPalGameSystemNeedWorldSync>();
	}
};
static_assert(alignof(IPalGameSystemNeedWorldSync) == 0x000008, "Wrong alignment on IPalGameSystemNeedWorldSync");
static_assert(sizeof(IPalGameSystemNeedWorldSync) == 0x000028, "Wrong size on IPalGameSystemNeedWorldSync");

// Class Pal.PaRichTextDecorator_KeyGuideIcon
// 0x0000 (0x0028 - 0x0028)
class UPaRichTextDecorator_KeyGuideIcon : public URichTextBlockDecorator
{
public:
	class UWidget* CreateWidget(class FName KeyGuideActionName, float IconScale, int32 OverrideType);
	class FString GetTextStringInternal(const class UObject* WorldContextObject, class FName ID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PaRichTextDecorator_KeyGuideIcon">();
	}
	static class UPaRichTextDecorator_KeyGuideIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPaRichTextDecorator_KeyGuideIcon>();
	}
};
static_assert(alignof(UPaRichTextDecorator_KeyGuideIcon) == 0x000008, "Wrong alignment on UPaRichTextDecorator_KeyGuideIcon");
static_assert(sizeof(UPaRichTextDecorator_KeyGuideIcon) == 0x000028, "Wrong size on UPaRichTextDecorator_KeyGuideIcon");

}

